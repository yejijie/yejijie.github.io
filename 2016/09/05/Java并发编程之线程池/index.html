<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="奔跑吧菜鸟"><title>Java并发编程之线程池 | NoobSky</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java并发编程之线程池</h1><a id="logo" href="/.">NoobSky</a><p class="description">Talk is cheap. Show me the code. - http://noobsky.com</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java并发编程之线程池</h1><div class="post-meta">Sep 5, 2016<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/09/05/Java并发编程之线程池/" href="/2016/09/05/Java并发编程之线程池/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>多线程可以最大限度的发挥多核处理器的计算能力，提高生成系统的吞吐量和性能。但是，若不加控制和管理地随意使用线程，对系统的性能反而会产生不利的影响。在真实的生产环境中，当线程数量过大时，有可能耗尽CPU和内存资源。</p>
<p>首先，虽然与进程相比，线程是一种轻量级的工具，但其创建和关闭依然需要花费时间，如果为每一个小任务都创建一个线程，很有可能出现创建和销毁线程所占用的时间大于该线程真实工作所消耗时间的情况，反而会得不偿失。</p>
<p>其次，线程本身也是要占用内存空间的，大量的线程会抢占宝贵的内存资源，如果处理不当，可能会导致Out of Memory异常。即便没有，大量的线程回收也会给GC带来很大的压力，延长GC的停顿时间。</p>
<p>所以，对线程的使用要适度，在有限范围内，增加线程的数量可以明显提高系统吞吐量，但超出范围，大量线程只会拖垮应用系统。因此，在生产环境中使用线程，必须加以控制和管理。</p>
<p>为了避免系统频繁地创建和销毁线程，我们可以让创建的线程进行复用。就是线程执行完一个任务，并不被销毁，而是可以继续执行其他的任务。Java中可以通过线程池来达到这样的效果。</p>
<h2 id="JDK对线程池的支持">JDK对线程池的支持</h2><p>为了更好的控制多线程，JDK提供了一套Executor框架，帮助开发人员有效地进行线程控制，其本质就是一个线程池。核心成员的UML类图如下：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E5%9B%BE.jpg" alt=""></p>
<p>Executor是顶层接口，里面只有一个方法execute(Runnable command)，返回值为void，参数为Runnable类型，顾名思义，就是用来执行传进去的任务的。而ExecutorService接口继承了Executor接口，并声明了一些方法，包括shutdown、isShutdown、isTerminated、submit、invokeAll、invokeAny等方法。然后抽象类AbstractExecutorService实现了ExecutorService接口。ThreadPoolExecutor继承了抽象类AbstractExecutorService。ThreadPoolExecutor类中有几个非常重要的方法：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">submit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">shutdownNow</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>execute方法实际上是接口Executor中声明的方法，在ThreadPoolExecutor中进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，这个方法可以向线程池提交一个任务，交由线程池去执行。</p>
<p>submit方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，查看源码可以发现，会发现submit内部也是调用execute方法的，只不过它利用了Future来获取任务执行的结果。还有很多其他方法，这里就不一一介绍了。</p>
<p>Executors则扮演着线程池工厂的角色，通过Executors可以取得一个拥有特定功能的线程池。ThreadPoolExecutor类实现了Executor接口，因此通过这个接口，任何Runable的对象都可以被ThreadPoolExecutor线程池调度。</p>
<p>Executors主要提供了以下工厂方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure></p>
<p>以上工厂方法分别返回不同工作特性的线程池。这些线程池工厂方法具体说明如下：</p>
<ul>
<li><p>newFixedThreadPool()方法：该方法返回一个固定线程数量的线程池。该线程池的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>
</li>
<li><p>newSingleThreadExecutor()方法：该方法返回只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行任务中的队列。</p>
</li>
<li><p>newCachedThreadPool()方法：该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池复用。</p>
</li>
<li><p>newSingleThreadScheduledExecutor()方法：该方法返回一个ScheduleExecutorService对象，线程池大小为1。ScheduledExecutorService 接口在ExecutorService接口之上扩展了在给定时间执行某任务的功能，如在某个固定的延时之后执行，或者周期性执行某个任务。</p>
</li>
<li><p>newScheduledThreadPool()方法：该方法也返回一个ScheduleExecutorService对象，但该线程池可以指定线程数量。</p>
</li>
</ul>
<h2 id="深入理解线程池内部实现">深入理解线程池内部实现</h2><p>对于核心的几个线程池，无论是newFixedThreadPool()方法、newSingleThreadExecutor()还是newCachedThreadPool()方法，虽然看起来创建的线程有着完全不同的功能特点，但其内部实现均使用ThreadPoolExecutor来实现的。这三种线程池的实现方式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由以上源码可知，它们都是ThreadPoolExecutor类的封装。我们首先来看一下ThreadPoolExecutor的实现</p>
<h3 id="线程池状态">线程池状态</h3><h3 id="线程池状态-1">线程池状态</h3><p>定义了几个static final变量表示线程池的各个状态：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>先看看文档：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The runState provides the main lifecyle control, taking <span class="keyword">on</span> values:</span><br><span class="line"></span><br><span class="line">RUNNING:  Accept <span class="keyword">new</span> tasks <span class="keyword">and</span> <span class="keyword">process</span> queued tasks</span><br><span class="line">SHUTDOWN: Don<span class="attribute">'t</span> accept <span class="keyword">new</span> tasks, but <span class="keyword">process</span> queued tasks</span><br><span class="line">STOP:     Don<span class="attribute">'t</span> accept <span class="keyword">new</span> tasks, don<span class="attribute">'t</span> <span class="keyword">process</span> queued tasks,<span class="keyword">and</span> interrupt <span class="keyword">in</span>-progress tasks</span><br><span class="line">TIDYING:  <span class="keyword">All</span> tasks have terminated, workerCount <span class="keyword">is</span> zero,the thread transitioning <span class="keyword">to</span> state TIDYING will run the terminated() hook method</span><br><span class="line">TERMINATED: terminated() has completed</span><br></pre></td></tr></table></figure></p>
<p>ThreadPoolExecutor线程池有五个状态，分别为：</p>
<ul>
<li>RUNNING: 可以接受新的任务，也可以处理阻塞队列里的任务</li>
<li>SHUTDOWN: 不接受新的任务，但是可以处理阻塞队列里的任务</li>
<li>STOP: 不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务</li>
<li>TIDYING: 过渡状态，也就是说所有的任务都执行完了，当前线程池已经没有有效线程，此时线程池的状态将会为TIDYING，并且将要调用terminated方法</li>
<li>TERMINATED: 终止状态。terminated方法调用完成以后的方法</li>
</ul>
<p>各状态的相互转换如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RUNNING</span> -&gt; <span class="type">SHUTDOWN</span></span><br><span class="line">    <span class="type">On</span> invocation <span class="keyword">of</span> shutdown(), perhaps implicitly <span class="keyword">in</span> finalize()</span><br><span class="line">(<span class="type">RUNNING</span> <span class="keyword">or</span> <span class="type">SHUTDOWN</span>) -&gt; <span class="type">STOP</span></span><br><span class="line">    <span class="type">On</span> invocation <span class="keyword">of</span> shutdownNow()</span><br><span class="line"><span class="type">SHUTDOWN</span> -&gt; <span class="type">TIDYING</span></span><br><span class="line">    <span class="type">When</span> both queue <span class="keyword">and</span> pool are empty</span><br><span class="line"><span class="type">STOP</span> -&gt; <span class="type">TIDYING</span></span><br><span class="line">    <span class="type">When</span> pool <span class="keyword">is</span> empty</span><br><span class="line"><span class="type">TIDYING</span> -&gt; <span class="type">TERMINATED</span></span><br><span class="line">    <span class="type">When</span> the terminated() hook <span class="keyword">method</span> has completed</span><br></pre></td></tr></table></figure></p>
<p>ThreadPoolExecutor内部还保存着线程池的有效线程个数，状态和线程数在ThreadPoolExecutor内部使用一个原子整形变量保存。那么是如何做到的呢？</p>
<p>java中整型占四个字节，即32位，在ThreadPoolExecutor，整形32位的前三位用来表示线程池的状态，后29位用来表示线程池中有效的线程个数。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前3位表示状态，后29位用来表示线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.<span class="keyword">SIZE</span> - <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>线程池的容量为(1&lt;<29)-1= 00011111111111111111111111111111(二进制，约500="" million)，代码如下：="" <figure="" class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></29)-1=></p>
<p>表示RUNNING状态的代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<p>-1用二进制表示是：11111111111111111111111111111111(这是补码表示，不明白可以补补原码，反码，补码的知识)<br>则 -1 &lt;&lt; 29 = 11111111111111111111111111111111 &lt;&lt; 29 = 11100000000000000000000000000000(前3位为111)</p>
<p>表示SHUTDOWN状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即0 &lt;&lt; 29 = 00000000000000000000000000000000 &lt;&lt; 29 = 00000000000000000000000000000000(前3位为000)</p>
<p>表示STOP状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即 1 &lt;&lt; 29 = 00000000000000000000000000000001 &lt;&lt; 29 = 00100000000000000000000000000000(前3位为001)</p>
<p>表示TIDYING状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即 2 &lt;&lt; 29 = 00000000000000000000000000000010 &lt;&lt; 29 = 01000000000000000000000000000000(前3位为010)</p>
<p>表示TERMINATED状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即 3 &lt;&lt; 29 = 00000000000000000000000000000011 &lt;&lt; 29 = 01100000000000000000000000000000(前3位为011)</p>
<p>所以我们可以通过整数的二进制中后29位来获取线程数，前3位来获取线程的状态：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">//该方法获取状态，CAPACITY的非操作得到的二进制位11100000000000000000000000000000，然后做在一个与操作，相当于直接取前3位的的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//该方法获取线程数，取后29位。CAPACITY常量值为(1&lt;&lt;29)-1= 00011111111111111111111111111111。与CAPACITY相与的话，前三位相与为0，即可得后29位。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 或操作。更新代表线程数量和状态的整形变量。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadPoolExecutor还有一些重要的成员变量：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">private final BlockingQueue<span class="variable">&lt;Runnable&gt;</span> workQueue;//任务阻塞队列，用来存放等待执行的任务</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Lock held on access to workers set and related bookkeeping.</span><br><span class="line"> <span class="keyword">*</span> While we could use a concurrent set of some sort, it turns out</span><br><span class="line"> <span class="keyword">*</span> to be generally preferable to use a lock. Among the reasons is</span><br><span class="line"> <span class="keyword">*</span> that this serializes interruptIdleWorkers, which avoids</span><br><span class="line"> <span class="keyword">*</span> unnecessary interrupt storms, especially during shutdown.</span><br><span class="line"> <span class="keyword">*</span> Otherwise exiting threads would concurrently interrupt those</span><br><span class="line"> <span class="keyword">*</span> that have not yet interrupted. It also simplifies some of the</span><br><span class="line"> <span class="keyword">*</span> associated statistics bookkeeping of largestPoolSize etc. We</span><br><span class="line"> <span class="keyword">*</span> also hold mainLock on shutdown and shutdownNow, for the sake of</span><br><span class="line"> <span class="keyword">*</span> ensuring workers set is stable while separately checking</span><br><span class="line"> <span class="keyword">*</span> permission to interrupt and actually interrupting.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private final ReentrantLock mainLock = new ReentrantLock();//线程池的状态锁，对线程状态（如线程池大小、runState等）的改变都要使用这个锁</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Set containing all worker threads in pool. Accessed only when</span><br><span class="line"> <span class="keyword">*</span> holding mainLock.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private final HashSet<span class="variable">&lt;Worker&gt;</span> workers = new HashSet<span class="variable">&lt;Worker&gt;</span>();//用来存放工作集</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Wait condition to support awaitTermination</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private final Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Tracks largest attained pool size. Accessed only under</span><br><span class="line"> <span class="keyword">*</span> mainLock.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private int largestPoolSize;//用来记录线程池曾出现过的最大线程数</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Counter for completed tasks. Updated only on termination of</span><br><span class="line"> <span class="keyword">*</span> worker threads. Accessed only under mainLock.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private long completedTaskCount;//已完成任务计数器</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> All user control parameters are declared as volatiles so that</span><br><span class="line"> <span class="keyword">*</span> ongoing actions are based on freshest values, but without need</span><br><span class="line"> <span class="keyword">*</span> for locking, since no internal invariants depend on them</span><br><span class="line"> <span class="keyword">*</span> changing synchronously with respect to other actions.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Factory for new threads. All threads are created using this</span><br><span class="line"> <span class="keyword">*</span> factory (via method addWorker).  All callers must be prepared</span><br><span class="line"> <span class="keyword">*</span> for addWorker to fail, which may reflect a system or user's</span><br><span class="line"> <span class="keyword">*</span> policy limiting the number of threads.  Even though it is not</span><br><span class="line"> <span class="keyword">*</span> treated as an error, failure to create threads may result in</span><br><span class="line"> <span class="keyword">*</span> new tasks being rejected or existing ones remaining stuck in</span><br><span class="line"> <span class="keyword">*</span> the queue.</span><br><span class="line"> <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> We go further and preserve pool invariants even in the face of</span><br><span class="line"> <span class="keyword">*</span> errors such as OutOfMemoryError, that might be thrown while</span><br><span class="line"> <span class="keyword">*</span> trying to create threads.  Such errors are rather common due to</span><br><span class="line"> <span class="keyword">*</span> the need to allocate a native stack in Thread<span class="comment">#start, and users</span></span><br><span class="line"> <span class="keyword">*</span> will want to perform clean pool shutdown to clean up.  There</span><br><span class="line"> <span class="keyword">*</span> will likely be enough memory available for the cleanup code to</span><br><span class="line"> <span class="keyword">*</span> complete without encountering yet another OutOfMemoryError.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile ThreadFactory threadFactory;//线程工厂，用来创建线程</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Handler called when saturated or shutdown in execute.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile RejectedExecutionHandler handler;//任务拒绝策略</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Timeout in nanoseconds for idle threads waiting for work.</span><br><span class="line"> <span class="keyword">*</span> Threads use this timeout when there are more than corePoolSize</span><br><span class="line"> <span class="keyword">*</span> present or if allowCoreThreadTimeOut. Otherwise they wait</span><br><span class="line"> <span class="keyword">*</span> forever for new work.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile long keepAliveTime; //闲置线程的存活时间</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> If false (default), core threads stay alive even when idle.</span><br><span class="line"> <span class="keyword">*</span> If true, core threads use keepAliveTime to time out waiting</span><br><span class="line"> <span class="keyword">*</span> for work.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile boolean allowCoreThreadTimeOut;//是否允许为核心线程设置存活时间</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Core pool size is the minimum number of workers to keep alive</span><br><span class="line"> <span class="keyword">*</span> (and not allow to time out etc) unless allowCoreThreadTimeOut</span><br><span class="line"> <span class="keyword">*</span> is set, in which case the minimum is zero.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile int corePoolSize;//核心池的大小，当线程池中的线程数目大于这个参数时，提交的任务会被放进任务阻塞队列中</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Maximum pool size. Note that the actual maximum is internally</span><br><span class="line"> <span class="keyword">*</span> bounded by CAPACITY.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile int maximumPoolSize;//线程池最大能容忍的线程数</span><br></pre></td></tr></table></figure></p>
<h3 id="构造函数">构造函数</h3><p>ThreadPoolExecutor最重要的构造函数：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler <span class="keyword">handler</span>)</span><br></pre></td></tr></table></figure>
<p>函数的参数含义如下：</p>
<ul>
<li>corePoolSize: 指定线程池中的线程数量</li>
<li>maximumPoolSize: 指定了线程池中的最大线程数量</li>
<li>keepAliveTime: 当线程池线程数量超过corePoolSize时，多余的空闲线程的存活时间。即，超过corePoolSize的空闲线程，在多长时间内，会被销毁。</li>
<li>unit: keepAliveTime的单位</li>
<li>workQueue: 任务队列，被提交但尚未被执行的任务。</li>
<li>threadFactory: 线程工厂，用于创建线程，一般用默认的即可。</li>
<li>handler: 拒绝策略。当任务太多来不及处理，如何拒绝任务。</li>
</ul>
<h3 id="任务执行">任务执行</h3><p>在ThreadPoolExecutor类中，最核心的任务执行方法是execute和submit，submit方法也是通过调用execute方法来完成任务的执行。execute方法的源码如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">         * start a new thread with the given command as its first</span><br><span class="line">         * task.  The call to addWorker atomically checks runState and</span><br><span class="line">         * workerCount, and so prevents false alarms that would add</span><br><span class="line">         * threads when it shouldn't, by returning false.</span><br><span class="line">         *</span><br><span class="line">         * 2. If a task can be successfully queued, then we still need</span><br><span class="line">         * to double-check whether we should have added a thread</span><br><span class="line">         * (because existing ones died since last checking) or that</span><br><span class="line">         * the pool shut down since entry into this method. So we</span><br><span class="line">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">         * stopped, or start a new thread if there are none.</span><br><span class="line">         *</span><br><span class="line">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">         * and so reject the task.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<span class="comment">//第1步，线程池中的线程大小小于corePoolSize</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))<span class="comment">//true表示使用corePoolSize,false表示使用maximumPoolSize</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.<span class="keyword">get</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">//第2步，线程池的线程大小大于corePoolSize，而且线程池是RUNNING状态，阻塞队列也没满，加入到阻塞队列中</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.<span class="keyword">get</span>();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<span class="comment">//需要进行第二次判断，防止线程池被关闭了</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">workerCountOf(recheck</span>) </span>== <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">!addWorker(command, <span class="keyword">false</span></span>))<span class="comment">//第3步，使用线程池maximumPoolSize(最大大小)</span></span><br><span class="line">            <span class="title">reject</span>(<span class="params">command</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>由代码中的注释可知，execute方法分三步处理：</p>
<ol>
<li>如果当前正在执行的Worker数量比corePoolSize小，则直接通过addWorker方法创建一个新的Worker执行任务。</li>
<li>如果当前正在执行的Worker数量大于等于corePoolSize。将任务放到阻塞队列里，如果阻塞队列没满并且状态是RUNNING时，直接加入到阻塞队列中，否则跳到第三步。加入到阻塞队列后，还需要再验证一次（加入到聚在队列之后可能另外一个线程关闭了线程池或者刚加入到队列的线程死了）。如果此时线程池不是RUNNING状态，则把刚加入到阻塞队列中的任务remove掉，然后调用reject方法，否则查看Worker数量，如果Worker数量为0，起一个新的Worker去阻塞队列里拿任务执行。</li>
<li>加入阻塞队列失败时，会调用addWorker方法尝试起一个新的Worker去阻塞队列中拿任务并执行任务，如果addWorker调用失败，调用reject方法。</li>
</ol>
<h3 id="任务缓存队列">任务缓存队列</h3><ul>
<li><p>同步队列(SynchronousQueue)：该队列是直接提交的，是一个特殊的BlockingQueue。SynchronousQueue没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除操作都要等待对应的插入操作。如果使用SynchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程，则尝试创建新的线程，如果线程数已经达到最大值，则执行拒绝策略。因此，使用SynchronousQueue队列，通常需要设置很大的maximumPoolSize，否则很容易执行拒绝策略。</p>
</li>
<li><p>ArrayBlockingQueue</p>
</li>
<li><p>LinkedBlockingQueue：是无界任务队列，除非系统资源耗尽，否则无界的任务队列不存在入队失败的情况。当有新的任务到来，系统的线程数小于corePoolSize时，线程池会生成新的线程执行任务，但当系统的线程数达到corePoolSize后，就不会继续增加。若后续仍有新的任务加入，而又没有空闲的线程资源，则任务直接进入队列等待。若任务创建失败和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。</p>
</li>
<li><p>PriorityBlockingQueue：优先任务队列带有执行优先级，可以控制任务执行的先后顺序。ArrayBlockingQueue和LinkedBlockingQueue都是按照先进先出算法处理任务。而PriorityBlockingQueue则可以根据任务自身的优先级顺序先后执行。</p>
</li>
</ul>
<h3 id="任务拒绝策略">任务拒绝策略</h3><ul>
<li>AbortPolicy策略：丢弃任务并抛出RejectedExecutionException异常</li>
<li>CallerRunsPolicy策略：在调用者线程中运行当前被丢弃的任务</li>
<li>DiscardOldestPolicy策略：丢弃最老的任务，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li>
<li>DiscardPolicy策略：丢弃任务，但不抛出异常。</li>
</ul>
<h3 id="线程池的关闭">线程池的关闭</h3><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p>
<ul>
<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
<h3 id="线程工厂">线程工厂</h3><h3 id="扩展线程池">扩展线程池</h3><h3 id="线程池的大小">线程池的大小</h3><h2 id="参考文献">参考文献</h2><p><a href="http://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/" target="_blank" rel="external">Java线程池ThreadPoolExecutor源码分析</a><br><a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="external">Java并发编程：线程池的使用</a><br><a href="http://www.ticmy.com/?p=243" target="_blank" rel="external">hotspot1.7 ThreadPoolExecutor代码解析</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.noobsky.com/2016/09/05/Java并发编程之线程池/" data-id="cj730pqa600p9l8c1y0vf38lv" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Java线程池/">Java线程池</a></div><div class="post-nav"><a href="/2016/09/08/LeetCode-Reverse-Vowels-of-a-String/" class="pre">[LeetCode]Reverse Vowels of a String</a><a href="/2016/09/05/实战Java虚拟机之锁与并发/" class="next">实战Java虚拟机之锁与并发</a></div><div id="disqus_thread"><script>var disqus_shortname = 'noobsky';
var disqus_identifier = '2016/09/05/Java并发编程之线程池/';
var disqus_title = 'Java并发编程之线程池';
var disqus_url = 'http://blog.noobsky.com/2016/09/05/Java并发编程之线程池/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//noobsky.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.noobsky.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java8/">Java8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nodejs/">Nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shadowsocks/">Shadowsocks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Bit-Manipulation/" style="font-size: 15px;">Bit Manipulation</a> <a href="/tags/DFS/" style="font-size: 15px;">DFS</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/代理/" style="font-size: 15px;">代理</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/node-http-proxy/" style="font-size: 15px;">node-http-proxy</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/JVM基本结构/" style="font-size: 15px;">JVM基本结构</a> <a href="/tags/JVM参数/" style="font-size: 15px;">JVM参数</a> <a href="/tags/垃圾收集器/" style="font-size: 15px;">垃圾收集器</a> <a href="/tags/谷歌学术/" style="font-size: 15px;">谷歌学术</a> <a href="/tags/Shadowsocks/" style="font-size: 15px;">Shadowsocks</a> <a href="/tags/AWS/" style="font-size: 15px;">AWS</a> <a href="/tags/Stream-API/" style="font-size: 15px;">Stream API</a> <a href="/tags/lambda/" style="font-size: 15px;">lambda</a> <a href="/tags/线程安全/" style="font-size: 15px;">线程安全</a> <a href="/tags/Redis设计与实现/" style="font-size: 15px;">Redis设计与实现</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Hash-Table/" style="font-size: 15px;">Hash Table</a> <a href="/tags/Sort/" style="font-size: 15px;">Sort</a> <a href="/tags/Binary-Search/" style="font-size: 15px;">Binary Search</a> <a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/Two-Pointers/" style="font-size: 15px;">Two Pointers</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/Brainteaser/" style="font-size: 15px;">Brainteaser</a> <a href="/tags/BFS/" style="font-size: 15px;">BFS</a> <a href="/tags/Linked-List/" style="font-size: 15px;">Linked List</a> <a href="/tags/Heap/" style="font-size: 15px;">Heap</a> <a href="/tags/Dynamic-Programming/" style="font-size: 15px;">Dynamic Programming</a> <a href="/tags/静态代理/" style="font-size: 15px;">静态代理</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/Java线程池/" style="font-size: 15px;">Java线程池</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/Floyd判圈算法/" style="font-size: 15px;">Floyd判圈算法</a> <a href="/tags/HDFS/" style="font-size: 15px;">HDFS</a> <a href="/tags/DTW/" style="font-size: 15px;">DTW</a> <a href="/tags/语音识别/" style="font-size: 15px;">语音识别</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/31/Hadoop权威指南之Hadoop分布式文件系统/">Hadoop权威指南之Hadoop分布式文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/17/面试算法之Trie（前缀树）问题集锦/">面试算法之Trie（前缀树）问题集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/16/LeetCode-Minimum-Window-Substring/">[LeetCode]Minimum Window Substring</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/16/面试算法之Hard难度集锦/">面试算法之Hard难度集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/14/MySQL事务隔离级别/">MySQL事务隔离级别</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/面试算法之栈问题集锦/">面试算法之栈问题集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/面试算法之位运算集锦/">面试算法之位运算集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/12/面试算法之深度优先搜索算法集锦/">面试算法之深度优先搜索算法集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/09/Java单例模式/">Java单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/09/LeetCode-Implement-strStr/">[LeetCode]Implement strStr()</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//noobsky.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://coolshell.cn/" title="酷壳" target="_blank">酷壳</a><ul></ul><a href="http://www.importnew.com/" title="ImportNew" target="_blank">ImportNew</a><ul></ul><a href="http://toutiao.io/" title="开发者头条" target="_blank">开发者头条</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">NoobSky.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>