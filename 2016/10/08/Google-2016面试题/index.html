<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="奔跑吧菜鸟"><title>Google 2016面试题 | NoobSky</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Google 2016面试题</h1><a id="logo" href="/.">NoobSky</a><p class="description">Talk is cheap. Show me the code. - http://noobsky.com</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Google 2016面试题</h1><div class="post-meta">Oct 8, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/10/08/Google-2016面试题/" href="/2016/10/08/Google-2016面试题/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h2 id="轴对称">轴对称</h2><h3 id="题目描述">题目描述</h3><p>给定平面上的n个点，问是否存在一条平行于y轴的直线，使得这n个点相对于这条直线对称。</p>
<p><strong>Follow-up</strong><br>是否存在一条直线使得这n个点关于这条直线对称？</p>
<h3 id="算法分析">算法分析</h3><p>因为对称轴一定平行于y轴，这看起来缩小了穷举范围（可是我们真的要穷举可能的对称轴吗？有实无限个可能点对称轴…）</p>
<p>那么我们怎么找到那条对称轴？对称轴的特点就是每一个点都在另一边有一个对应的点。第一想法是：最左边的点一定对应某个最右边的点，因此最左边的点和最右边的点的中点应该在对称轴上。当然还有很多其他的找对称轴的方法，比如求所有x坐标的平均值。</p>
<p>找到了对称轴的位置，我们就可以通过HashMap判断是否每一个点都有对应的点，最后输出答案即可。</p>
<p>时间复杂度为O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReflected</span><span class="params">(Point[] points)</span></span>&#123;</span><br><span class="line">    <span class="comment">//最右边点的x坐标值</span></span><br><span class="line">    <span class="keyword">int</span> max = Math.MIN_VALUE;</span><br><span class="line">    <span class="comment">//最左边点的x坐标值</span></span><br><span class="line">    <span class="keyword">int</span> min = Math.MAX_VALUE;</span><br><span class="line">    <span class="comment">//key为y坐标值，value为y坐标值为key的所有点的x坐标值的集合</span></span><br><span class="line">    HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">      <span class="comment">//找出最左边和最右边对应点的x坐标值</span></span><br><span class="line">      max = Math.max(max, points[i].x);</span><br><span class="line">      min = Math.min(min, points[i].x);</span><br><span class="line">      <span class="keyword">if</span>(!map.containsKey(points[i].y))&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(points[i].x);</span><br><span class="line">        map.put(points[i].y, set);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.get(points[i].y).add(points[i].x);</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//max-y0 = y0-min; p-y0 = y0 - p' =&gt; p' = max+min-p</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++)&#123;</span><br><span class="line">      <span class="comment">//根据对称轴判断其他点是否都有对应的点</span></span><br><span class="line">      <span class="keyword">if</span>(!map.containsKey(points[i].y) || !map.get(points[i].y).contains(max+min-points[i].x))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">int</span> y;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">()</span></span>&#123;x = <span class="number">0</span>; y = <span class="number">0</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;x = a; y = b;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组补丁">数组补丁</h2><h3 id="题目描述-1">题目描述</h3><p>给出一个从小到大排好序的整数数组nums和一个整数n，在数组中添加若干个补丁（元素）使得[1,n]的区间内的所有数都可以表示成nums中若干个数的和。返回最少需要添加的补丁个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>], n = <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>返回1，表示至少需要添加1个数｛2｝，才可以表示1到6之间所有数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">2</span>:</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>], n = <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>返回2，表示至少需要添加两个数｛2，4｝，才可以表示1到20之间所有数。</p>
<p>我们不妨先思考一个简单的问题，如果nums数组为空，那么最少需要多少个数字才能表示1到n之间所有数？相信大家都可以想到一个贪心算法，即按照1、2、4、8…都顺序添加，每次加入都数都比之前所有数的总和大1，直到总和大于n。本题的难点是预先给出了一些数，但这不影响我们的贪心策略：假设nums当前至多可以表示1到m之间的所有数，加入m+1；直到m大于等于n。</p>
<p>变量miss表示[0,n]中我们缺少的最小的和，也就是说nums中元素求和我们已经能得到[0,miss)范围内的数<br>遍历nums数组，如果nums[i] &lt;= miss,那么我们可以将我们能得到的和的范围[0,miss)扩充到[0,miss+nums[i]);如果nums[i] &gt; miss,那么我们将不能连续扩充[0,miss),也就是说[0,miss+nums[i])的一些元素我们不能得到，则这时我们需要patch元素，那么应该patch什么数？我们采用贪心算法，我们patch的元素为miss，因为选择miss可以得到最大的连续区间[0, miss+miss)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化为缺少1</span></span><br><span class="line">    <span class="keyword">int</span> miss = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//统计patch的数量</span></span><br><span class="line">    <span class="keyword">int</span> patch = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">//如果溢出，miss小于0</span></span><br><span class="line">    <span class="keyword">while</span>(miss &gt; <span class="number">0</span> &amp;&amp; miss &lt;= n)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i &lt; nums.length &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">        miss = miss + nums[i];</span><br><span class="line">        i++;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//扩充miss</span></span><br><span class="line">        miss = miss + miss;</span><br><span class="line">        patch++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> patch;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="不构造树的情况下验证先序遍历">不构造树的情况下验证先序遍历</h2><h3 id="题目描述-2">题目描述</h3><p>给出一个字符序列，问该序列是否是一棵合法的二叉树的先序遍历？<br>找到一种不需要构造二叉树的方法。<br>For example：<br>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>是下面这颗二叉树的先序遍历。其中＃代表空节点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">9</span></span><br><span class="line">       /      \</span><br><span class="line">      <span class="number">3</span>       <span class="number">2</span></span><br><span class="line">    /   \   /    \</span><br><span class="line">   <span class="number">4</span>     <span class="number">1</span> <span class="preprocessor">#      <span class="number">6</span></span></span><br><span class="line"> /   \  / \      / \</span><br><span class="line"><span class="preprocessor">#    #  #  #    #   #</span></span><br></pre></td></tr></table></figure></p>
<h3 id="分析解答">分析解答</h3><p>通过观察上图中二叉树我们可以发现，一棵合法的二叉树去掉某个叶子节点后仍是合法的二叉树。在给出的字符序列中，叶子节点有很明显的特征，即叶子节点之后一定紧跟两个空节点＃。通过不断的把number,#,#的子串缩成空节点#(把number,#,#子串替换为#)，如果最后字符序列可以缩短到只有一个字符＃，那它就是我们要找的合法的先序遍历了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span></span>&#123;</span><br><span class="line">    String s = preorder;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.length() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> index = s.indexOf(<span class="string">",#,#"</span>);</span><br><span class="line">      <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> start = index;</span><br><span class="line">      <span class="comment">//找到,#,#前一个节点</span></span><br><span class="line">      <span class="comment">//有可能数字有多位</span></span><br><span class="line">      <span class="keyword">while</span>(start &gt; <span class="number">0</span> &amp;&amp; s.charAt(start-<span class="number">1</span>) != <span class="string">','</span>)&#123;</span><br><span class="line">        start--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(s.charAt(start) == <span class="string">'#'</span>)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      s = s.substring(<span class="number">0</span>,start)+s.substring(index+<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"#"</span>) &amp;&amp; flag) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摆动排序_II">摆动排序 II</h2><p>给出一个整数数组nums，重新排列nums使得nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…<br>Example:<br>nums = [1, 5, 1, 1, 6, 4], 一个可能的答案是[1, 4, 1, 5, 1, 6]<br>数据保证必定有解。</p>
<h2 id="分析解答-1">分析解答</h2><p>本题有一种简单的做法，先快速排序，然后把最小的一半依次放在奇数位上，最大的一半依次放在偶数位上。算法复杂度是快速排序的复杂度O(NlogN)。仔细思考后发现快速排序不是必要的，只需要找到中位数即可。利用快速排序的思想找中位数的期望时间复杂度是O(N)。为了防止相等的数放在一起，需要注意放置的顺序。笔者采用的方法是依nums长度分两种情况：若长度为奇数，把比中位数小的依次放在0,2,4,…位置，比中位数大的依次放在length-2,length-4,…位置；若长度为偶数，把比中位数小的依次放在length-2,length-4,…位置，比中位数大的依次放在1,3,5,…位置。其余位置填充中位数。这样可以保证中位数一定与较小与较大的数相邻（题目保证一定有解）。</p>
<p>排序解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先排序数组，然后将数组的前半部分和后半部分merge起来</span></span><br><span class="line">    <span class="comment">//把更大的一般放到奇数下标中，更小的一半放到偶数下标中</span></span><br><span class="line">    <span class="comment">//比如nums=[1,2,3,4,5,6,7]</span></span><br><span class="line">    <span class="comment">//4 3 2 1</span></span><br><span class="line">    <span class="comment">// 7 6 5 = &gt; 4 7 3 6 2 5 1</span></span><br><span class="line">    <span class="comment">//该种解法只要输入中存在valid answer就能正确找到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        <span class="comment">//排序，分成两部分</span></span><br><span class="line">        Arrays.sort(copy);</span><br><span class="line">        <span class="comment">//left初始时指向中间元素的后一元素</span></span><br><span class="line">        <span class="keyword">int</span> right = nums.length, left = (nums.length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? copy[--left] : copy[--right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="矩阵中的最长上升路径">矩阵中的最长上升路径</h2><h3 id="题目描述-3">题目描述</h3><p>给出一个数字矩阵，寻找一条最长上升路径，每个位置只能向上下左右四个位置移动。<br>Example：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>返回 4，最长上升路径是[1, 2, 6, 9].</p>
<h3 id="分析解答-2">分析解答</h3><p>最直观的做法是穷举每一个数字作为起点，dfs寻找最长上升路径，时间复杂度是指数级别的。仔细思考dfs有些盲目，此题中的最长上升路径很符合bfs的特点（每次向外扩展一层），bfs可以显著降低时间复杂度，朴素的bfs复杂度为O(n^4)，因为在bfs的过程中，每个位置最多会经过k次（k为到这个点对最长上升路径长度，最大可能为n^2）。如果使用动态规划的思路，把到每个位置的最长上升路径长度储存下来，那每个点只会计算一次，可以使复杂度变为O(n^2)。当前位置最长上升路径可以通过周围四个点的最长上升路径而得到。但是这里有个问题就是动态规划的穷举顺序，有两种方法解决，一是通过拓扑排序来确定穷举顺序，因为最长上升路径总是从小到大扩展的；二是通过记忆化搜索实现动态规划，记忆化搜索是搜索和动态规划的结合，在搜索过程中记录已经求解完毕的状态，使得每个状态只需进行一次搜索。在本题中，dp[i][j]记录在(i,j)位置可以得到的最长上升路径，其值通过搜索相邻四个位置的dp值确定；flag[i][j]表示(i,j)位置的解是否已经搜索完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//四个搜索方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> len = dfs(matrix, i, j, row, col, cache);</span><br><span class="line">                max = Math.max(max, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度搜索从[i][j]出发的最长递增路径的长度</span></span><br><span class="line">    <span class="comment">//cache缓存，即备忘录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] cache)</span></span>&#123;</span><br><span class="line">        <span class="comment">//已经搜索过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(cache[i][j] != <span class="number">0</span>) <span class="keyword">return</span> cache[i][j];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//四个方向搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//matrix[x][y] &lt;= matrix[i][j]可以避免使用visited[row][col]数组</span></span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= row || y &lt; <span class="number">0</span> || y &gt;= col || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span> + dfs(matrix, x, y, row, col, cache);</span><br><span class="line">            max = Math.max(len, max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache[i][j] = max;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="岛屿计数2">岛屿计数2</h2><h2 id="Count_of_Smaller_Numbers_After_Self(数组计数)">Count of Smaller Numbers After Self(数组计数)</h2><h3 id="题目描述-4">题目描述</h3><p>给定一个数组nums,返回一个计数数组count，count[i]表示nums中第i个右边有多少个数小于nums[i]<br>Example:<br>nums = [5, 2, 6, 1]<br>输出[2,1,1,0]</p>
<h3 id="分析解答-3">分析解答</h3><p>此题不难给出O(N^2)的算法，先穷举nums中每个位置i，再穷举右边的数计算有多少个小于nums[i]。难点在于利用数据结构进行优化从而降低时间复杂度。线段树（segment tree）和平衡树（Balanced Binary Tree）是两种可以使用的数据结构。</p>
<p>线段树的每个节点表示一段区间，记录这个区间的某些信息，其基本思想是把区间一分为二，二分为四。。。直到不可再分（因此叶子节点的区间只包含一个数），如此可以把任意区间表示成log（区间大小）个子区间的拼接，以降低查询时间复杂度。在本题中，假设nums中的数字范围在0到maxnum之间，那么建树的区间为[0,maxnum]（也就是根节点所表示的区间）。每个节点记录其表示区间内的数字个数。本题涉及两种线段树基本操作：插入和查询。插入操作把nums[i]插入到线段树相应位置，同时对所有经过的区间的sum值进行累加；查询操作需要查询区间[0,nums[i]-1]所包含的数字个数，利用已经建好的线段树把查询区间分割为若干个节点所表示的区间，统计并返回这些节点的sum值之和。</p>
<p>平衡树用途更广，代码复杂度也更高，是一种保持叶子节点深度平衡的二叉搜索树，有多种方法实现，因篇幅有限不再赘述，大家可以自行在网上搜索学习。</p>
<h2 id="翻转游戏（Flip_Game_II）">翻转游戏（Flip Game II）</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&amp;mid=401839317&amp;idx=1&amp;sn=0660926cc1e5edab1b92aa8160fa93e6&amp;scene=21#wechat_redirect" target="_blank" rel="external">详见</a></p>
<p>搜索+回溯：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWin</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] state = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span>)&#123;</span><br><span class="line">        state[i] = <span class="keyword">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        state[i] = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search(state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">boolean</span>[] state)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; state.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//连续加号</span></span><br><span class="line">      <span class="keyword">if</span>(state[i] &amp;&amp; state[i+<span class="number">1</span>])&#123;</span><br><span class="line">        state[i] = <span class="keyword">false</span>;</span><br><span class="line">        state[i+<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//不能继续翻转</span></span><br><span class="line">        <span class="keyword">if</span>(!search(state))&#123;</span><br><span class="line">          state[i] = <span class="keyword">true</span>;</span><br><span class="line">          state[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//能继续翻转，回溯</span></span><br><span class="line">          state[i] = <span class="keyword">true</span>;</span><br><span class="line">          state[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="吹气球">吹气球</h2><h3 id="题目描述-5">题目描述</h3><p>有n个气球，编号为0到n-1，每个气球都有一个分数，存在nums数组中。每次吹气球i可以得到的分数为 nums[left] <em> nums[i] </em> nums[right]，left和right分别表示i气球相邻的两个气球。当i气球被吹爆后，其左右两气球即为相邻。要求吹爆所有气球，得到最多的分数。<br>注释:<br>(1) 你可以假设nums[-1] = nums[n] = 1<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>Example:<br>给出[3, 1, 5, 8]<br>返回167</p>
<p>dp解法：<br>Definition:<br>     dp[i][j]表示吹爆i到j之间的气球所能得到的最大分数</p>
<p>Function:<br>     dp[i][j] = max(dp[i][k-1] + score(k) + dp[k+1][j]) 对于所有k属于{i,j}</p>
<p>Intialize:<br>     dp[i][i] = 0 for each i.</p>
<p>Answer:<br>     dp[1][n]</p>
<h2 id="题目链接">题目链接</h2><p><a href="http://posts.careerengine.us/p/579993895afff74f7f7f9e42" target="_blank" rel="external">题目</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.noobsky.com/2016/10/08/Google-2016面试题/" data-id="ciu1z8maw00pxtqc1u72e66p2" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2016/10/08/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/" class="pre">[LeetCode]Binary Tree Preorder/Inorder/Postorder Traversal</a><a href="/2016/10/07/LeetCode-Kth-Smallest-Element-in-a-Sorted-Matrix/" class="next">[LeetCode]Kth Smallest Element in a Sorted Matrix</a></div><div id="disqus_thread"><script>var disqus_shortname = 'noobsky';
var disqus_identifier = '2016/10/08/Google-2016面试题/';
var disqus_title = 'Google 2016面试题';
var disqus_url = 'http://blog.noobsky.com/2016/10/08/Google-2016面试题/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//noobsky.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.noobsky.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java8/">Java8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nodejs/">Nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shadowsocks/">Shadowsocks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/Binary-Search/" style="font-size: 15px;">Binary Search</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/代理/" style="font-size: 15px;">代理</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/node-http-proxy/" style="font-size: 15px;">node-http-proxy</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/JVM基本结构/" style="font-size: 15px;">JVM基本结构</a> <a href="/tags/JVM参数/" style="font-size: 15px;">JVM参数</a> <a href="/tags/垃圾收集器/" style="font-size: 15px;">垃圾收集器</a> <a href="/tags/谷歌学术/" style="font-size: 15px;">谷歌学术</a> <a href="/tags/Shadowsocks/" style="font-size: 15px;">Shadowsocks</a> <a href="/tags/AWS/" style="font-size: 15px;">AWS</a> <a href="/tags/Stream-API/" style="font-size: 15px;">Stream API</a> <a href="/tags/lambda/" style="font-size: 15px;">lambda</a> <a href="/tags/线程安全/" style="font-size: 15px;">线程安全</a> <a href="/tags/Redis设计与实现/" style="font-size: 15px;">Redis设计与实现</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Hash-Table/" style="font-size: 15px;">Hash Table</a> <a href="/tags/Sort/" style="font-size: 15px;">Sort</a> <a href="/tags/Bit-Manipulation/" style="font-size: 15px;">Bit Manipulation</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/DFS/" style="font-size: 15px;">DFS</a> <a href="/tags/Two-Pointers/" style="font-size: 15px;">Two Pointers</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/Brainteaser/" style="font-size: 15px;">Brainteaser</a> <a href="/tags/BFS/" style="font-size: 15px;">BFS</a> <a href="/tags/Linked-List/" style="font-size: 15px;">Linked List</a> <a href="/tags/Heap/" style="font-size: 15px;">Heap</a> <a href="/tags/Dynamic-Programming/" style="font-size: 15px;">Dynamic Programming</a> <a href="/tags/静态代理/" style="font-size: 15px;">静态代理</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/Java线程池/" style="font-size: 15px;">Java线程池</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/Floyd判圈算法/" style="font-size: 15px;">Floyd判圈算法</a> <a href="/tags/DTW/" style="font-size: 15px;">DTW</a> <a href="/tags/语音识别/" style="font-size: 15px;">语音识别</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/09/Java单例模式/">Java单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/09/LeetCode-Implement-strStr/">[LeetCode]Implement strStr()</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/09/面试算法之二叉树问题集锦/">面试算法之二叉树问题集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/LeetCode-Sort-List/">[LeetCode]Sort List</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/LeetCode-Max-Points-on-a-Line/">[LeetCode]Max Points on a Line</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/面试算法之Two-Pointers问题集锦/">面试算法之Two Pointers问题集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/面试算法之二分搜索问题集锦/">面试算法之二分搜索问题集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/LeetCode-Find-K-Pairs-with-Smallest-Sums/">[LeetCode]Find K Pairs with Smallest Sums</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/LeetCode-Permutations-I-II/">[LeetCode]Permutations I II</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/">[LeetCode]Binary Tree Preorder/Inorder/Postorder Traversal</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//noobsky.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://coolshell.cn/" title="酷壳" target="_blank">酷壳</a><ul></ul><a href="http://www.importnew.com/" title="ImportNew" target="_blank">ImportNew</a><ul></ul><a href="http://toutiao.io/" title="开发者头条" target="_blank">开发者头条</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">NoobSky.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>