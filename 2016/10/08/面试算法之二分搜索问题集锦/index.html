<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="奔跑吧菜鸟"><title>面试算法之二分搜索问题集锦 | NoobSky</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">面试算法之二分搜索问题集锦</h1><a id="logo" href="/.">NoobSky</a><p class="description">Talk is cheap. Show me the code. - http://noobsky.com</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">面试算法之二分搜索问题集锦</h1><div class="post-meta">Oct 8, 2016<span> | </span><span class="category"><a href="/categories/算法/">算法</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/10/08/面试算法之二分搜索问题集锦/" href="/2016/10/08/面试算法之二分搜索问题集锦/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h2 id="First_Bad_Version">First Bad Version</h2><p>给定一个判断版本是否是坏版本的函数，查找[1…n]中第一个坏的版本<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span><br><span class="line">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//int mid = left + (right - left)/2;</span></span><br><span class="line">            <span class="keyword">if</span>(!isBadVersion(mid)) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     public int firstBadVersion(int n) &#123;</span></span><br><span class="line"><span class="comment">//     int start = 1, end = n;</span></span><br><span class="line"><span class="comment">//     while (start &lt; end) &#123;</span></span><br><span class="line"><span class="comment">//         int mid = start + (end-start) / 2;</span></span><br><span class="line"><span class="comment">//         if (!isBadVersion(mid)) start = mid + 1;</span></span><br><span class="line"><span class="comment">//         else end = mid;            </span></span><br><span class="line"><span class="comment">//     &#125;        </span></span><br><span class="line"><span class="comment">//     return start;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Guess_Number_Higher_or_Lower">Guess Number Higher or Lower</h2><p>给定辅助guess(int num)函数，返回3种结果<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> lower</span><br><span class="line"> <span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> higher</span><br><span class="line"> <span class="number">0</span> : Congrats! You got <span class="keyword">it</span>!</span><br></pre></td></tr></table></figure></p>
<p>代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The guess API is defined in the parent class GuessGame.</span><br><span class="line">   @param num, your guess</span><br><span class="line">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span><br><span class="line">      int guess(int num); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(guess(mid) == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(guess(mid) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 1 : My number is higher,这里的My number是指要你猜的那个数</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Sqrt(x)">Sqrt(x)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid == x / mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; x / mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_a_2D_Matrix">Search a 2D Matrix</h2><p>矩阵每一行升序，每一行的第一个元素大于前一行的最后一个元素<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Given target = 3, return true.</p>
<p>每一行从左到右组成有序数组，数组下标范围为[0,row*col-1]，可以使用二分搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//row*col矩阵转换为数组=&gt;matrix[i][j] =&gt; array[i * col + j]</span></span><br><span class="line"><span class="comment">//数组转换为矩阵array[i] =&gt; matrix[i / col][i % col]</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">      <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">          <span class="keyword">int</span> mid = left+(right - left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Find_Peak_Element">Find Peak Element</h2><p>给定数组，num[i] ≠ num[i+1]，查找peek元素，并返回其下标</p>
<p>You may imagine that num[-1] = num[n] = -∞.</p>
<p>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//local maximum就是一个peek</span></span><br><span class="line">    <span class="comment">//mid = (left + right)/2,mid1 = mid + 1</span></span><br><span class="line">    <span class="comment">//如果nums[mid] &lt; nums[mid1]，那么nums[mid1...right]一定有peek，为什么？</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid1右边的数只能增加或者减少，如果mid1右边的数一直增加，则nums[right]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid1右边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="comment">//同理nums[mid] &gt; nums[mid1]，那么nums[left, mid]一定有peek，道理是一样的</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid左边的数只能增加或者减少，如果mid左边的数一直增加，则nums[left]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid左边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> mid1 = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右边一定有peek</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid1])&#123;</span><br><span class="line">                left = mid1;</span><br><span class="line">            <span class="comment">//左边一定有peek</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="comment">//如果出现相等就不符合题目中相邻元素不相等，可以抛异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历的方法不符合时间复杂度，但是实现非常tricky</span></span><br><span class="line">    <span class="comment">// public int findPeakElement(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     //右边有减小的话则peek出现</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] &lt; nums[i-1]) return i-1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //否则元素一直增大到最右边元素就是peek</span></span><br><span class="line">    <span class="comment">//     return nums.length - 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kth_Smallest_Element_in_a_BST">Kth Smallest Element in a BST</h2><p>寻找BST中第k小的元素<br>利用BST的性质，递归搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计左子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> count = countNodes(root.left);</span><br><span class="line">        <span class="comment">//左子树的节点个数大于等于k，说明第k小的元素在左子树中，递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.left, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第k个元素在右子树中，相当于在右子树中寻找第k-count-1小的元素</span></span><br><span class="line">        <span class="keyword">if</span>(count &lt; k-<span class="number">1</span>) <span class="keyword">return</span> kthSmallest(root.right, k - count -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//count = k-1,说明左子树有k-1个节点，跟该节点即为第k小的元素</span></span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以利用中序遍历，边遍历边查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用中序遍历法，因为中序遍历二叉树是有序的</span></span><br><span class="line"><span class="comment">//使用递归中序遍历</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    count = k;</span><br><span class="line">    dfsHelper(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) dfsHelper(root.left);</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">        number = root.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) dfsHelper(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_for_a_Range">Search for a Range</h2><p>给定有序数组，查找目标数在数组的开始和结束位置<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找左边界：mid = (left+right)/2，下取整，往左偏</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找左边界，所以right = mid</span></span><br><span class="line">    <span class="comment">// 2和3可以合并，合并后：if(nums[mid] &lt; target) left = mid+1; else right = mid;</span></span><br><span class="line">    <span class="comment">// 找右边界：mid = (left+right)/2+1，上取整，往右篇</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找右边界，所以left = mid</span></span><br><span class="line">    <span class="comment">// 1和3可以合并，合并后：if(nums[mid] &gt; target) right = mid-1; else left = mid;</span></span><br><span class="line">    <span class="comment">// 就是两种二分搜索的写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[left] != target) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> res[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line">        right = nums.length - <span class="number">1</span>;<span class="comment">//第二次时，left可以不重新设置为0，设置了也没错，多余而已</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//上取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有左边界，就一定能执行到这里，而且不用判断，right最起码等于前面判断左边界</span></span><br><span class="line">        res[<span class="number">1</span>] = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_a_2D_Matrix_II">Search a 2D Matrix II</h2><p>m*n的矩阵，每一行从左往右升序，每一列从上往下升序，在矩阵查找目标元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始比较位置为右上角即matrix[0][col-1],如果target大于该值，那么target不可能在该row，因为每一row都是升序，可以排除该row</span></span><br><span class="line">    <span class="comment">//如果target小于该值，那么target不可能在该col，因为每一col都是升序的，可以排除该col，</span></span><br><span class="line">    <span class="comment">//如果相等，返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[row][col])&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[row][col])&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Search_in_Rotated_Sorted_Array_II">Search in Rotated Sorted Array II</h2><p>[4 5 6 7 0 1 2]，考虑有重复元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//左半部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右半部分有序</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, rigth = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//左半部分有序</span></span><br><span class="line">      <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[] &lt; nums[right])&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Find_Minimum_in_Rotated_Sorted_Array">Find Minimum in Rotated Sorted Array</h2><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;<span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有重复元素呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="comment">//nums[mid] &gt; nums[right],nums[left:mid]有序，搜索右边</span></span><br><span class="line">    <span class="comment">//nums[mid] &lt; nums[right],nums[mid:right]有序，搜索左边</span></span><br><span class="line">    <span class="comment">//nums[mid] = nums[right],有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">    <span class="comment">//但可以肯定排除nums[right],即使min = A[right],排除A[right]并没有使min丢失</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Valid_Perfect_Square">Valid Perfect Square</h2><p>判断是否为完全平方数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里可以直接用数学规律</span></span><br><span class="line">    <span class="comment">//1 = 1</span></span><br><span class="line">    <span class="comment">//4 = 1 + 3</span></span><br><span class="line">    <span class="comment">//9 = 1 + 3 + 5</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//但是这里我们需要注意的是我们不能用加法来做</span></span><br><span class="line">    <span class="comment">//因为加法存在溢出的问题，我们可以逆向考虑，</span></span><br><span class="line">    <span class="comment">//用减法，减1、3...，看看最后num是否会为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            num -= i;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们不知道这个规律，之前实现过sqrt，同理这里也可以使用二分搜索</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//除法是下取整的，mid取值偏小</span></span><br><span class="line">            <span class="comment">//取值偏小的mid的平方都大于num，那么平方根肯定小于mid，所以right = mid - 1</span></span><br><span class="line">            <span class="comment">//除法防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(mid &gt; num / mid)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//小于等于</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &lt; num / mid)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果这样写会造成死循环，比如5</span></span><br><span class="line">                <span class="comment">//if(num % mid == 0) return true;</span></span><br><span class="line">                <span class="keyword">return</span> num % mid == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Find_the_Duplicate_Number">Find the Duplicate Number</h2><p>数组nums包含n+1个元素，每个元素的值在[1,n]区间<br>类似找到链表环的起点，快慢指针<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="LIS最长递增子序列">LIS最长递增子序列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.排序后的序列和原序列求LCS最长公共子序列</span></span><br><span class="line">    <span class="comment">//2.dp (O(n*n))</span></span><br><span class="line">    <span class="comment">//3.dp (O(nlgn))</span></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int[] ends = new int[nums.length];</span></span><br><span class="line">    <span class="comment">//     int len = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //二分搜索可以利用Arrays.binarySearch(int[] a, int fromIndex, int toIndex, int key),</span></span><br><span class="line">    <span class="comment">//     //该函数的返回值是这样的：如果a中存在key，则返回key在a中的index，不存在key返回-insertionpoint-1，所以</span></span><br><span class="line">    <span class="comment">//     //此时insertionpoint =  -(返回值+1)</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         int ret = Arrays.binarySearch(ends, 0, len, nums[i]);</span></span><br><span class="line">    <span class="comment">//         //小于0，不存在key，计算插入位置</span></span><br><span class="line">    <span class="comment">//         if(ret &lt; 0) ret = -(ret+1);</span></span><br><span class="line">    <span class="comment">//         //或者使用自己二分搜索函数</span></span><br><span class="line">    <span class="comment">//         //int ret = binarySearch(ends, 0, len, nums[i]);</span></span><br><span class="line">    <span class="comment">//         ends[ret] = nums[i];</span></span><br><span class="line">    <span class="comment">//         //在ends尾部增加了一个元素</span></span><br><span class="line">    <span class="comment">//         if(ret == len) len++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return len;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不记得Arrays.binarySearch返回值的含义，可以自己写一个二分搜索函数，</span></span><br><span class="line">    <span class="comment">//如果存在key返回index，不存在时返回插入位置的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = fromIndex, right = toIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == key) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; key) right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[j] = max(dp[i]) + 1 i&lt;j&amp;&amp;nums[i] &lt; nums[j]</span></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums)&#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int res = 0;</span></span><br><span class="line">    <span class="comment">//     int[] dp = new int[nums.length];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     for(int j = 0; j &lt; nums.length; j++)&#123;</span></span><br><span class="line">    <span class="comment">//         //也可以在前面用Arrays.fill(dp, 1)</span></span><br><span class="line">    <span class="comment">//         dp[j] = 1;</span></span><br><span class="line">    <span class="comment">//         for(int i = 0; i &lt; j; i++)&#123;</span></span><br><span class="line">    <span class="comment">//             if(nums[i] &lt; nums[j]) dp[j] = Math.max(dp[j], dp[i]+1);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         res = Math.max(res, dp[j]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums)&#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int[] numsCopy = new int[nums.length];</span></span><br><span class="line">    <span class="comment">//     numsCopy = Arrays.copyOfRange(nums, 0, nums.length);</span></span><br><span class="line">    <span class="comment">//     Arrays.sort(numsCopy);</span></span><br><span class="line">    <span class="comment">//     //System.arraycopy(nums, 0, numsCopy, 0, nums.length);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int dp[][] = new int[nums.length+1][nums.length+1];</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt;= nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 0; j &lt;= nums.length; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             if(i == 0 || j == 0) dp[i][j] = 0;</span></span><br><span class="line">    <span class="comment">//             else&#123;</span></span><br><span class="line">    <span class="comment">//                 if(nums[i-1] == numsCopy[j-1])&#123;</span></span><br><span class="line">    <span class="comment">//                     dp[i][j] = dp[i-1][j-1]+1;</span></span><br><span class="line">    <span class="comment">//                 &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                     dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);</span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return dp[nums.length][nums.length];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Russian_Doll_Envelopes">Russian Doll Envelopes</h2><p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>
<p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<p>Example:<br>Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分两步</span></span><br><span class="line">    <span class="comment">//1. 信封按宽升序高降序排序</span></span><br><span class="line">    <span class="comment">//2. 对信封的高找最长递增子序列</span></span><br><span class="line">    <span class="comment">//因为信封的宽已经是升序，我们只要考虑信封的高就可以了</span></span><br><span class="line">    <span class="comment">//[3, 4]是装不下[3, 3]，所以我们需要将[3, 4]排在[3, 3]的前面，如果排序排成了[3,3] [3,4]会被当成递增序列，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span> || envelopes[<span class="number">0</span>].length != <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[<span class="number">0</span>] == arr2[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="comment">//高度降序</span></span><br><span class="line">                    <span class="keyword">return</span> arr2[<span class="number">1</span>] - arr1[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] envelope : envelopes)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(dp, <span class="number">0</span>, len, envelope[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                index = -(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[index] = envelope[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(index == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.noobsky.com/2016/10/08/面试算法之二分搜索问题集锦/" data-id="ciu1z8lqz0005tqc1ya928u4y" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Binary-Search/">Binary Search</a></div><div class="post-nav"><a href="/2016/10/08/面试算法之Two-Pointers问题集锦/" class="pre">面试算法之Two Pointers问题集锦</a><a href="/2016/10/08/LeetCode-Find-K-Pairs-with-Smallest-Sums/" class="next">[LeetCode]Find K Pairs with Smallest Sums</a></div><div id="disqus_thread"><script>var disqus_shortname = 'noobsky';
var disqus_identifier = '2016/10/08/面试算法之二分搜索问题集锦/';
var disqus_title = '面试算法之二分搜索问题集锦';
var disqus_url = 'http://blog.noobsky.com/2016/10/08/面试算法之二分搜索问题集锦/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//noobsky.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.noobsky.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java8/">Java8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nodejs/">Nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shadowsocks/">Shadowsocks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/Binary-Search/" style="font-size: 15px;">Binary Search</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/代理/" style="font-size: 15px;">代理</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/node-http-proxy/" style="font-size: 15px;">node-http-proxy</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/JVM基本结构/" style="font-size: 15px;">JVM基本结构</a> <a href="/tags/JVM参数/" style="font-size: 15px;">JVM参数</a> <a href="/tags/垃圾收集器/" style="font-size: 15px;">垃圾收集器</a> <a href="/tags/谷歌学术/" style="font-size: 15px;">谷歌学术</a> <a href="/tags/Shadowsocks/" style="font-size: 15px;">Shadowsocks</a> <a href="/tags/AWS/" style="font-size: 15px;">AWS</a> <a href="/tags/Stream-API/" style="font-size: 15px;">Stream API</a> <a href="/tags/lambda/" style="font-size: 15px;">lambda</a> <a href="/tags/线程安全/" style="font-size: 15px;">线程安全</a> <a href="/tags/Redis设计与实现/" style="font-size: 15px;">Redis设计与实现</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Hash-Table/" style="font-size: 15px;">Hash Table</a> <a href="/tags/Sort/" style="font-size: 15px;">Sort</a> <a href="/tags/Bit-Manipulation/" style="font-size: 15px;">Bit Manipulation</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/DFS/" style="font-size: 15px;">DFS</a> <a href="/tags/Two-Pointers/" style="font-size: 15px;">Two Pointers</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/Math/" style="font-size: 15px;">Math</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/Brainteaser/" style="font-size: 15px;">Brainteaser</a> <a href="/tags/BFS/" style="font-size: 15px;">BFS</a> <a href="/tags/Linked-List/" style="font-size: 15px;">Linked List</a> <a href="/tags/Heap/" style="font-size: 15px;">Heap</a> <a href="/tags/Dynamic-Programming/" style="font-size: 15px;">Dynamic Programming</a> <a href="/tags/静态代理/" style="font-size: 15px;">静态代理</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/Java线程池/" style="font-size: 15px;">Java线程池</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/Floyd判圈算法/" style="font-size: 15px;">Floyd判圈算法</a> <a href="/tags/DTW/" style="font-size: 15px;">DTW</a> <a href="/tags/语音识别/" style="font-size: 15px;">语音识别</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/09/Java单例模式/">Java单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/09/LeetCode-Implement-strStr/">[LeetCode]Implement strStr()</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/09/面试算法之二叉树问题集锦/">面试算法之二叉树问题集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/LeetCode-Sort-List/">[LeetCode]Sort List</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/LeetCode-Max-Points-on-a-Line/">[LeetCode]Max Points on a Line</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/面试算法之Two-Pointers问题集锦/">面试算法之Two Pointers问题集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/面试算法之二分搜索问题集锦/">面试算法之二分搜索问题集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/LeetCode-Find-K-Pairs-with-Smallest-Sums/">[LeetCode]Find K Pairs with Smallest Sums</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/LeetCode-Permutations-I-II/">[LeetCode]Permutations I II</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/">[LeetCode]Binary Tree Preorder/Inorder/Postorder Traversal</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//noobsky.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://coolshell.cn/" title="酷壳" target="_blank">酷壳</a><ul></ul><a href="http://www.importnew.com/" title="ImportNew" target="_blank">ImportNew</a><ul></ul><a href="http://toutiao.io/" title="开发者头条" target="_blank">开发者头条</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">NoobSky.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>