<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="奔跑吧菜鸟"><title>[LeetCode]Best Time to Buy and Sell Stock系列 | NoobSky</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">[LeetCode]Best Time to Buy and Sell Stock系列</h1><a id="logo" href="/.">NoobSky</a><p class="description">Talk is cheap. Show me the code. - http://noobsky.com</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">[LeetCode]Best Time to Buy and Sell Stock系列</h1><div class="post-meta">Apr 30, 2016<span> | </span><span class="category"><a href="/categories/Leetcode/">Leetcode</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/04/30/Best-Time-to-Buy-and-Sell-Stock/" href="/2016/04/30/Best-Time-to-Buy-and-Sell-Stock/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h2 id="Best_Time_to_Buy_and_Sell_Stock">Best Time to Buy and Sell Stock</h2><h3 id="题目描述">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>开始我对这个题目不是很理解，存在一些误区，然后看了一个歪果仁的更清楚的说明：<br>If you were only permitted to complete at most one buy and at most one sell during the whole period of days, design an algorithm such that your profit, i.e., sell price minus buy price, is maximized. Note that you can only not sell a stock before you buy one.</p>
<p>For example:</p>
<p>[1,2,3,4] ==&gt; returns 3 (buy at 1 and sell at 4)</p>
<p>[4,3,2,1] ==&gt; returns 0 (don’t buy)</p>
<p>[4,10,25,2,10] ==&gt; returns 21 (buy at 4 and sell at 25)</p>
<p>题目大意是说整个期间你最多只能买一次股票然后只能卖出一次，当然也可以不买股票。设计一个算法计算最大收益。<br>该问题可以使用动态规划解决，设dp[i]是[0,1,2…i]区间的最大利润，则该问题的一维动态规划方程如下：<br>dp[i+1] = max{dp[i], prices[i+1] - minPrices},minPrices是区间[0,1,2…,i]内的最低价格,我们要求解的最大利润 = max{dp[0], dp[1], dp[2], …, dp[n-1]} 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> maxProfit=<span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           <span class="comment">//最大收益</span></span><br><span class="line">           maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">           <span class="comment">//保存最小的price</span></span><br><span class="line">           minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果我们不再从每日的股票价格的角度去看待输入数据，而是考察每日股票价格的变化，第i天的股票价格变化定义为第i天和第i-1的价格差。并将这些价格差看做一个新数组A{prices[1]-prices[0], prices[2]-prices[1], prices[3]-prices[2], …, prices[n-1]-prices[n-2]}，那么问题就转化为寻找新数组A的最大子数组和。最大子数组和也是一个DP问题，详见维基百科<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank" rel="external">Maximum subarray problem</a>和本博客的博文最大子数组和。最大子数组和的Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_subarray</span><span class="params">(A)</span>:</span></span><br><span class="line">    max_ending_here = max_so_far = A[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> A[<span class="number">1</span>:]:</span><br><span class="line">        max_ending_here = max(x, max_ending_here + x)</span><br><span class="line">        max_so_far = max(max_so_far, max_ending_here)</span><br><span class="line">    <span class="keyword">return</span> max_so_far</span><br></pre></td></tr></table></figure>
<p>根据最大子数组和的程序，利用最大子数组和算法解决本股票问题的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxEndingHere = prices[<span class="number">1</span>] - prices[<span class="number">0</span>], maxSoFar = prices[<span class="number">1</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            maxEndingHere = Math.max(prices[i] - prices[i-<span class="number">1</span>], maxEndingHere+prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最大收益为负数，则不买股票，返回0</span></span><br><span class="line">        <span class="keyword">return</span> maxSoFar &gt; <span class="number">0</span> ? maxSoFar : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码可能不够直观，可以使用额外的O(n)的内存空间来存股票价格变化数组，更为直观的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span>[] diffPrices = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length-<span class="number">1</span>];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           diffPrices[i-<span class="number">1</span>] = prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> res = maxSubarray(diffPrices);</span><br><span class="line">       <span class="keyword">return</span> res &gt; <span class="number">0</span> ? res : <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> maxEndingHere = arr[<span class="number">0</span>],maxSoFar = arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">           maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);</span><br><span class="line">           maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxSoFar;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_II">Best Time to Buy and Sell Stock II</h2><h3 id="题目描述-1">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>在上一题的基础上，可以买卖多次股票，但是再买股票时必须把之前的股票卖出去，也就是说手上最多只能有一只股票。可以找到所有价格的递增区间，把这些递增区间的收益全部加起来就是最后的最大收益。代码有以下两种写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码一：</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> length = prices.length;</span><br><span class="line">       <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//注意循环结束条件是i &lt; length-1,如果是i &lt; length在&#123;1，2&#125;会陷入死循环</span></span><br><span class="line">       <span class="keyword">while</span>(i &lt; length - <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">while</span>(i+<span class="number">1</span> &lt; length &amp;&amp; prices[i+<span class="number">1</span>] &gt;= prices[i])&#123;</span><br><span class="line">               profit += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">               i++;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">while</span>(i+<span class="number">1</span> &lt; length &amp;&amp; prices[i+<span class="number">1</span>] &lt; prices[i]) i++;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> profit;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//代码二：</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(prices[i+<span class="number">1</span>] &gt; prices[i]) profit += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> profit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_III">Best Time to Buy and Sell Stock III</h2><h3 id="题目描述-2">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>这一题是最多只能买卖两次股票，求最大收益，同理手上最多只能有一只股票。因为不能连续买入两次股票，所以买卖两次肯定分布在两个不同区间。容易想到的解决办法是，把prices[] 分成两部分prices[0…m] 和 prices[m…length]  ，分别计算在这两部分内做交易的做大收益。在每个区间的问题又回到了I的情况。由于做n次划分，每次划分后求解的时间复杂度为O(n),所以总的时间复杂度为O(n<sup>2</sup>)，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n*n) time limit exceeded</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           maxProfit = Math.max(maxProfit,maxProfitOnce(prices, <span class="number">0</span>, i) + maxProfitOnce(prices, i, prices.length -<span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfitOnce</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> minPrice = prices[start];</span><br><span class="line">       <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">           maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">           minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是由于时间复杂度为O(n<sup>2</sup>)，效率低，运行超时。可以利用动态规划的思想进行改进，保持计算的中间结果，减少重复的计算。那就是第一步扫描，先计算出子序列[0,…,i]中的最大利润，用一个数组保存下来，那么时间是O(n)。计算方法也是利用第一个问题的计算方法。第二步是逆向扫描，计算子序列[i,…,n-1]上的最大利润，这一步同时就能结合上一步的结果计算最终的最大利润了，这一步也是O(n)。 所以最后算法的复杂度就是O(n)的。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] maxProfitFromHead = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        maxProfitFromHead[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">            maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">            maxProfitFromHead[i] = maxProfit;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxPrice = prices[prices.length -<span class="number">1</span>];</span><br><span class="line">        maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> finalMaxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.length -<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            maxPrice = Math.max(prices[i], maxPrice);</span><br><span class="line">            maxProfit = Math.max(maxProfit, maxPrice - prices[i]);</span><br><span class="line">            finalMaxProfit = Math.max(finalMaxProfit, maxProfit + maxProfitFromHead[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> finalMaxProfit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_IV">Best Time to Buy and Sell Stock IV</h2><h2 id="Best_Time_to_Buy_and_Sell_Stock_with_Cooldown">Best Time to Buy and Sell Stock with Cooldown</h2><h3 id="题目描述-3">题目描述</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<p>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).<br>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)<br>Example:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prices = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">maxProfit = <span class="number">3</span></span><br><span class="line">transactions = [buy, sell, cooldown, buy, sell]</span><br></pre></td></tr></table></figure></p>
<p>而这道题与前面的股票题的不同之处在于加入了一个冷冻期Cooldown之说，就是如果某天卖了股票，那么第二天不能买股票，有一天的冷冻期。<br>涉及三种交易：buy，sell，rest。rest意味着那一天没有交易，也就是cooldown。我们需要维护三个一维数组buy、sell、rest。其中：</p>
<ul>
<li>buy[i]表示在第i天之前最后一个操作是买的最大收益</li>
<li>sell[i]表示在第i天之前最后一个操作是卖的最大收益</li>
<li>rest[i]表示在第i天之前最后一个操作是rest的最大收益<br>根据定义，我们有如下递推式<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buy<span class="string">[i]</span> = max(rest<span class="string">[i-1]</span> - price, buy<span class="string">[i-1]</span>)</span><br><span class="line">sell<span class="string">[i]</span> = max(buy<span class="string">[i-1]</span>+price, sell<span class="string">[i-1]</span>)</span><br><span class="line">rest<span class="string">[i]</span> = max(sell<span class="string">[i-1]</span>, buy<span class="string">[i-1]</span>, rest<span class="string">[i-1]</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>price是第i天的股票价格，上面的递推式表示：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(1)</span> buy之前有rest<span class="comment">(冷冻期)</span></span><br><span class="line"><span class="comment">(2)</span> sell之前有buy</span><br></pre></td></tr></table></figure></p>
<p>一个小技巧就是保证sell之前有buy，从上面的等式似乎会出现[buy, rest, buy]。由于buy[i]&lt;=rest[i],rest[i]=max(sell[i-1], rest[i-1]),这就确保了[buy,rest,buy]不会发生。另外rest[i] &lt;= sell[i],所以rest[i] = sell[i-1]，所以我们可以把上面的三个递推式精简到两个：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buy<span class="string">[i]</span> = max(sell<span class="string">[i-2]</span>-price, buy<span class="string">[i-1]</span>)</span><br><span class="line">sell<span class="string">[i]</span> = max(buy<span class="string">[i-1]</span>+price, sell<span class="string">[i-1]</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们还可以做进一步优化，由于i只依赖于i-1和i-2，所以我们可以在O(1)的空间复杂度完成算法，参见代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//buy[i] = max(rest[i-1]-price, buy[i-1]) = max(sell[i-2]-price, buy[i-1]);</span></span><br><span class="line">    <span class="comment">//sell[i] = max(buy[i-1]+price, sell[i-1])</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == null || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>, prevSell = <span class="number">0</span>, buy = Integer.MIN_VALUE, prevBuy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="comment">//保存前一个buy用于求sell</span></span><br><span class="line">            prevBuy = buy;</span><br><span class="line">            buy = Math.max(prevSell-prices[i], prevBuy);</span><br><span class="line">            prevSell = sell; </span><br><span class="line">            sell = Math.max(prevBuy+prices[i], prevSell);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.noobsky.com/2016/04/30/Best-Time-to-Buy-and-Sell-Stock/" data-id="cipc23ps7007xzmc1dweplu2t" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/算法/">算法</a></div><div class="post-nav"><a href="/2016/05/02/LeetCode-Swap-Nodes-in-Pairs/" class="pre">[LeetCode]Swap Nodes in Pairs</a><a href="/2016/04/30/Happy-Number与Floyd判圈算法/" class="next">Happy Number与Floyd判圈算法</a></div><div id="disqus_thread"><script>var disqus_shortname = 'noobsky';
var disqus_identifier = '2016/04/30/Best-Time-to-Buy-and-Sell-Stock/';
var disqus_title = '[LeetCode]Best Time to Buy and Sell Stock系列';
var disqus_url = 'http://blog.noobsky.com/2016/04/30/Best-Time-to-Buy-and-Sell-Stock/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//noobsky.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.noobsky.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nodejs/">Nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shadowsocks/">Shadowsocks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Dynamic-Programming/" style="font-size: 15px;">Dynamic Programming</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/代理/" style="font-size: 15px;">代理</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/node-http-proxy/" style="font-size: 15px;">node-http-proxy</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/谷歌学术/" style="font-size: 15px;">谷歌学术</a> <a href="/tags/Shadowsocks/" style="font-size: 15px;">Shadowsocks</a> <a href="/tags/AWS/" style="font-size: 15px;">AWS</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/静态代理/" style="font-size: 15px;">静态代理</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/Floyd判圈算法/" style="font-size: 15px;">Floyd判圈算法</a> <a href="/tags/DTW/" style="font-size: 15px;">DTW</a> <a href="/tags/语音识别/" style="font-size: 15px;">语音识别</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/LeetCode-Patching-Array/">[LeetCode]Patching Array</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/LeetCode-Insertion-Sort-List/">[LeetCode]Insertion Sort List</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/LeetCode-Partition-List/">[LeetCode]Partition List</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/11/LeetCode-Triangle/">[LeetCode]Triangle</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/11/LeetCode-Bitwise-AND-of-Numbers-Range/">[LeetCode]Bitwise AND of Numbers Range</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/11/LeetCode-Subsets-I-II/">[LeetCode]Subsets I II</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/11/LeetCode-Verify-Preorder-Serialization-of-a-Binary-Tree/">[LeetCode]Verify Preorder Serialization of a Binary Tree</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/10/LeetCode-Search-in-Rotated-Sorted-Array-I-II/">[LeetCode]Search in Rotated Sorted Array I II</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/10/LeetCode-Perfect-Squares/">[LeetCode]Perfect Squares</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/10/LeetCode-Remove-Duplicates-from-Sorted-Array-I-II/">[LeetCode]Remove Duplicates from Sorted Array I II</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//noobsky.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://coolshell.cn/" title="酷壳" target="_blank">酷壳</a><ul></ul><a href="http://www.importnew.com/" title="ImportNew" target="_blank">ImportNew</a><ul></ul><a href="http://toutiao.io/" title="开发者头条" target="_blank">开发者头条</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">NoobSky.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>