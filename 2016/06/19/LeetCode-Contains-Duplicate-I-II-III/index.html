<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="奔跑吧菜鸟"><title>[LeetCode]Contains Duplicate I II III | NoobSky</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">[LeetCode]Contains Duplicate I II III</h1><a id="logo" href="/.">NoobSky</a><p class="description">Talk is cheap. Show me the code. - http://noobsky.com</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">[LeetCode]Contains Duplicate I II III</h1><div class="post-meta">Jun 19, 2016<span> | </span><span class="category"><a href="/categories/Leetcode/">Leetcode</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/06/19/LeetCode-Contains-Duplicate-I-II-III/" href="/2016/06/19/LeetCode-Contains-Duplicate-I-II-III/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h2 id="Contains_Duplicate_I">Contains Duplicate I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<h3 id="代码">代码</h3><ul>
<li>解法一</li>
</ul>
<p>直接遍历搜索，没遍历到某个元素nums[i]，逐一判断该元素跟前面的元素是否相等，时间复杂度为O(n<sup>2</sup>)， 超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == nums[i]) <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Time Limit Exceeded</span></span><br></pre></td></tr></table></figure>
<ul>
<li>解法二 </li>
</ul>
<p>排序后再遍历搜索，只有比较相邻元素就可，时间复杂度为O(nlgn)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>解法三（推荐）</li>
</ul>
<p>使用HashMap或HashSet，使用HashMap也可以但是value用不上，直接用HashSet（HashSet就是用HashMap实现的），HashSet的查找和插入都是O(1)的，所以总的时间复杂度为O(n)，不过需要O(n)的空间复杂度：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> containsDuplicate(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">    Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> x: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>.contains(x)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="built_in">set</span>.<span class="built_in">add</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果内存没什么限制的话，推荐使用这种方法。</p>
<h2 id="Contains_Duplicate_II">Contains Duplicate II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.</p>
<h3 id="代码-1">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - j; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]  == nums[i+j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力法，时间复杂度O(nk)，超时</p>
<ul>
<li>解法二 </li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> containsNearbyDuplicate(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Integer,Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(nums[i]))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-<span class="built_in">map</span>.<span class="built_in">get</span>(nums[i]) &lt;= k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果之前存在该key，但索引差不小于等于k，则覆盖掉之前的元素，如果不覆盖，后面有相等元素</span></span><br><span class="line">            <span class="comment">//跟之前的比会出现大于k的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>.put(nums[i],i);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用HashMap，key为数组元素，value为对应的index</p>
<ul>
<li>解法三（推荐）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tricky，利用HashSet维护一个窗口为k的滑动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">//窗口大小应该是k+1</span></span><br><span class="line">        <span class="comment">//[0...k]是符合的</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; k) <span class="built_in">set</span>.remove(nums[i-k-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">set</span>.add(nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//后面remove也可以</span></span><br><span class="line">        <span class="comment">//if(i &gt;= k) set.remove(nums[i-k]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Contains_Duplicate_III">Contains Duplicate III</h2><h3 id="题目描述-2">题目描述</h3><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.</p>
<h3 id="代码-2">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//在窗口k中找到[nums[i] - t, nums[i] + t]那么就返回true</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(nlgk)</span></span><br><span class="line">    <span class="comment">//利用TreeSet维护一个大小为K的滑动窗口，TreeSet寻找[nums[i] - t, nums[i] + t]的时间复杂度为O(lgk)</span></span><br><span class="line">    <span class="comment">//所以该程序的时间复杂度为O(nlgk)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">       TreeSet&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//寻找set中小于等于nums[i]+t的最大的数</span></span><br><span class="line">            <span class="comment">//虽然有nums[i]+t会发生溢出，但是遍历到后面某个数nums[j] - t还是能找到nums[i]的</span></span><br><span class="line">            Integer <span class="built_in">floor</span> = <span class="built_in">set</span>.<span class="built_in">floor</span>(nums[i] + t);<span class="comment">//lg(k)</span></span><br><span class="line">            <span class="comment">//寻找set中大于等于num[i]-t的最小的数</span></span><br><span class="line">            Integer <span class="built_in">ceil</span> = <span class="built_in">set</span>.ceiling(nums[i] - t);<span class="comment">//lg(k)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">floor</span> != null &amp;&amp; <span class="built_in">floor</span> &gt;= nums[i]) ||(<span class="built_in">ceil</span> != null &amp;&amp; <span class="built_in">ceil</span> &lt;= nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>.add(nums[i]);</span><br><span class="line">            <span class="comment">//[0...k]移除nums[0],为下一次循环做准备,下一次i=i+1=k+1，k+1 - 0 &gt; k了要移除一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) <span class="built_in">set</span>.remove(nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了引出下一种解法，我们先进行一些简单的推导：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果： | nums<span class="string">[i]</span> - nums<span class="string">[j]</span> | &lt;= t   式a</span><br><span class="line"></span><br><span class="line">等价： | nums<span class="string">[i]</span> / t - nums<span class="string">[j]</span> / t | &lt;= <span class="number">1</span>   式b</span><br><span class="line"></span><br><span class="line">推出： | floor(nums<span class="string">[i]</span> / t) - floor(nums<span class="string">[j]</span> / t) | &lt;= <span class="number">1</span>   式c</span><br><span class="line"></span><br><span class="line">​等价： floor(nums<span class="string">[j]</span> / t) ∈ &#123;floor(nums<span class="string">[i]</span> / t) - <span class="number">1</span>, floor(nums<span class="string">[i]</span> / t), floor(nums<span class="string">[i]</span> / t) + <span class="number">1</span>&#125; 式d</span><br></pre></td></tr></table></figure>
<p>其中式b是式c的充分非必要条件，因为逆否命题与原命题等价，所以：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果： floor(nums<span class="string">[j]</span> / t) ∉ &#123;floor(nums<span class="string">[i]</span> / t) - <span class="number">1</span>, floor(nums<span class="string">[i]</span> / t), floor(nums<span class="string">[i]</span> / t) + <span class="number">1</span>&#125; 非d</span><br><span class="line"></span><br><span class="line">推出： | nums<span class="string">[i]</span> - nums<span class="string">[j]</span> | &gt; t   非a</span><br></pre></td></tr></table></figure>
<p>因此只需要维护一个大小为k的窗口（字典）numDict，其中键为nums[i] / t，值为nums[i]。</p>
<p>遍历数组nums时，检查nums[i]与键集{floor(nums[i] / t) - 1, floor(nums[i] / t), floor(nums[i] / t) + 1}对应的值的差值即可。</p>
<p>根据以上分析，可得如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	 <span class="comment">//滑动窗口+桶</span></span><br><span class="line">    <span class="comment">//维护一个大小为t的桶，相差如果|nums[i] - num[j]| &lt;= t那么这两个数会被分配到同一个桶或者相邻的桶</span></span><br><span class="line">    <span class="comment">//分配都同一个桶的元素之差&lt;=t(元素是正数才满足)，但是分配到相邻桶的元素之差不一定是&lt;=</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//key为桶的编号，value为nums[i]</span></span><br><span class="line">        Map&lt;Long, Long&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//重新映射数组中元素全部转化为正数</span></span><br><span class="line">            <span class="keyword">long</span> remappedNum = (<span class="keyword">long</span>)nums[i] - Integer.MIN_VALUE;</span><br><span class="line">            <span class="comment">//将的桶的大小取为t+1是避免t为0时需要另外的代码,前面t为负数时已经直接返回了t+1不会为0</span></span><br><span class="line">            <span class="keyword">long</span> bucket = remappedNum / ((<span class="keyword">long</span>)t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//[-3, 3] k = 1, t = 4</span></span><br><span class="line">            <span class="comment">//如果不转换为正数的，对于以上测试用例会失败</span></span><br><span class="line">            <span class="comment">//-3和3都映射到同一个桶中，但是值之差并不小于等于t</span></span><br><span class="line">            <span class="comment">//下面的判断中分配到同一桶中的元素直接就默认小于等于t(对于正数来说是成立的)，所以前面全部转换为正数</span></span><br><span class="line">            <span class="comment">//那么-3和3分配到不同的桶中。其实不重新映射数组中的元素也是可以的，此时分配到同一个桶的元素也需要判断是否&lt;=t</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(bucket) || (<span class="built_in">map</span>.containsKey(bucket - <span class="number">1</span>) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket - <span class="number">1</span>) &lt;= t) || (<span class="built_in">map</span>.containsKey(bucket + <span class="number">1</span>) &amp;&amp; <span class="built_in">map</span>.get(bucket + <span class="number">1</span>) - remappedNum &lt;= t))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">map</span>.put(bucket, remappedNum);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)&#123;</span><br><span class="line">                <span class="keyword">long</span> lastBucket = ((<span class="keyword">long</span>) nums[i - k] - Integer.MIN_VALUE) / ((<span class="keyword">long</span>) t + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">map</span>.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码成功AC，我尝试了一下不对数组中的元素重新映射，当元素分配到同一个桶中时仍然检查它们的之差是否小于等于t，但是我没有把数组中的元素转化为long类型，导致两数相减时溢出导致判断错误，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> remappedNum = nums[i];<span class="comment">// - Integer.MIN_VALUE;</span></span><br><span class="line">            <span class="keyword">int</span> bucket = remappedNum / ( t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//不需要重新映射但还是应该要long类型，因为remappedNum - map.get(bucket)等会发生溢出</span></span><br><span class="line">            <span class="comment">//nums = [-1,2147483647] k = 1  t = 2147483647就因为发生溢出而判断为true，正确的应该为false</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">map</span>.containsKey(bucket) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket) &lt;= t)</span><br><span class="line">                    || (<span class="built_in">map</span>.containsKey(bucket - <span class="number">1</span>) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket - <span class="number">1</span>) &lt;= t)</span><br><span class="line">                    || (<span class="built_in">map</span>.containsKey(bucket + <span class="number">1</span>) &amp;&amp; <span class="built_in">map</span>.get(bucket + <span class="number">1</span>) - remappedNum &lt;= t))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.entrySet().size() &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">int</span> lastBucket = nums[i - k] / (t + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">map</span>.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>.put(bucket, remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将数组中的元素强制转行为long类型时成功AC，推荐下面完善后AC的代码：</p>
<ul>
<li>解法二(推荐)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//不重新映射，nums转换为long类型，但是相同的桶也需要比较值之差是否小于等于t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Long, Long&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//不映射</span></span><br><span class="line">            <span class="keyword">long</span> remappedNum = (<span class="keyword">long</span>) nums[i];<span class="comment">// - Integer.MIN_VALUE;</span></span><br><span class="line">            <span class="keyword">long</span> bucket = remappedNum / ((<span class="keyword">long</span>) t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//要转换为long类型，是因为这里相减会发生溢出</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">map</span>.containsKey(bucket) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket) &lt;= t)</span><br><span class="line">                    || (<span class="built_in">map</span>.containsKey(bucket - <span class="number">1</span>) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket - <span class="number">1</span>) &lt;= t)</span><br><span class="line">                        || (<span class="built_in">map</span>.containsKey(bucket + <span class="number">1</span>) &amp;&amp; <span class="built_in">map</span>.get(bucket + <span class="number">1</span>) - remappedNum &lt;= t))</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.entrySet().size() &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastBucket = ((<span class="keyword">long</span>) nums[i - k]) / ((<span class="keyword">long</span>) t + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">map</span>.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>.put(bucket, remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="https://leetcode.com/discuss/38206/ac-o-n-solution-in-java-using-buckets-with-explanation" target="_blank" rel="external">AC O(N) solution in Java using buckets with explanation</a><br><a href="http://bookshadow.com/weblog/2015/06/03/leetcode-contains-duplicate-iii/" target="_blank" rel="external">[LeetCode]Contains Duplicate III</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.noobsky.com/2016/06/19/LeetCode-Contains-Duplicate-I-II-III/" data-id="ciqb1ytcm00cu26c1j42mfgh8" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/算法/">算法</a></div><div class="post-nav"><a href="/2016/06/20/LeetCode-Largest-Number/" class="pre">[LeetCode]Largest Number</a><a href="/2016/06/19/LeetCode-Range-Sum-Query-1D-2D-Immutable-Mutable/" class="next">[LeetCode]Range Sum Query 1D/2D - Immutable/Mutable</a></div><div id="disqus_thread"><script>var disqus_shortname = 'noobsky';
var disqus_identifier = '2016/06/19/LeetCode-Contains-Duplicate-I-II-III/';
var disqus_title = '[LeetCode]Contains Duplicate I II III';
var disqus_url = 'http://blog.noobsky.com/2016/06/19/LeetCode-Contains-Duplicate-I-II-III/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//noobsky.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.noobsky.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nodejs/">Nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shadowsocks/">Shadowsocks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Dynamic-Programming/" style="font-size: 15px;">Dynamic Programming</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/代理/" style="font-size: 15px;">代理</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/node-http-proxy/" style="font-size: 15px;">node-http-proxy</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/谷歌学术/" style="font-size: 15px;">谷歌学术</a> <a href="/tags/Shadowsocks/" style="font-size: 15px;">Shadowsocks</a> <a href="/tags/AWS/" style="font-size: 15px;">AWS</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/静态代理/" style="font-size: 15px;">静态代理</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/Floyd判圈算法/" style="font-size: 15px;">Floyd判圈算法</a> <a href="/tags/DTW/" style="font-size: 15px;">DTW</a> <a href="/tags/语音识别/" style="font-size: 15px;">语音识别</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/06/LeetCode-Minimum-Height-Trees/">[LeetCode]Minimum Height Trees</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/06/LeetCode-Course-Schedule-I-II/">[LeetCode]Course Schedule I II</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/06/LeetCode-Binary-Tree-Zigzag-Level-Level-Order-Traversal-I-II/">[LeetCode]Binary Tree Zigzag Level/Level Order Traversal I II</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/06/LeetCode-Largest-Divisible-Subset/">[LeetCode]Largest Divisible Subset</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/06/LeetCode-Game-of-Life/">[LeetCode]Game of Life</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/LeetCode-Container-With-Most-Water/">[LeetCode]Container With Most Water</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/LeetCode-Valid-Perfect-Square/">[LeetCode]Valid Perfect Square</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/LeetCode-Different-Ways-to-Add-Parentheses/">[LeetCode]Different Ways to Add Parentheses</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/LeetCode-Count-Numbers-with-Unique-Digits/">[LeetCode]Count Numbers with Unique Digits</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/LeetCode-ZigZag-Conversion/">[LeetCode]ZigZag Conversion</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//noobsky.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://coolshell.cn/" title="酷壳" target="_blank">酷壳</a><ul></ul><a href="http://www.importnew.com/" title="ImportNew" target="_blank">ImportNew</a><ul></ul><a href="http://toutiao.io/" title="开发者头条" target="_blank">开发者头条</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">NoobSky.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>