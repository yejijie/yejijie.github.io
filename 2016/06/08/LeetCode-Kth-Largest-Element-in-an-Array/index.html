<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="奔跑吧菜鸟"><title>[LeetCode]Kth Largest Element in an Array | NoobSky</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">[LeetCode]Kth Largest Element in an Array</h1><a id="logo" href="/.">NoobSky</a><p class="description">Talk is cheap. Show me the code. - http://noobsky.com</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">[LeetCode]Kth Largest Element in an Array</h1><div class="post-meta">Jun 8, 2016<span> | </span><span class="category"><a href="/categories/Leetcode/">Leetcode</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/06/08/LeetCode-Kth-Largest-Element-in-an-Array/" href="/2016/06/08/LeetCode-Kth-Largest-Element-in-an-Array/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h2 id="题目描述">题目描述</h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given <font color="red">[3,2,1,5,6,4]</font> and k = 2, return 5.</p>
<p><strong> Note: </strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<h2 id="解题思路与代码">解题思路与代码</h2><h3 id="排序法">排序法</h3><p>将数组排序，然后返回第K大的数组元素<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span>(<span class="params"><span class="keyword">int</span>[] nums, <span class="keyword">int</span> k</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//if(nums == null || nums.length == 0) return -1;</span></span><br><span class="line">        <span class="comment">//check if 1&lt;= k &lt;= nums.length</span></span><br><span class="line">        <span class="comment">//排序，O(nlgn)</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的<font color="red">时间复杂度为O(nlgn)，空间复杂度为O(1)</font>。</p>
<h3 id="堆">堆</h3><p>维护k个元素的最小堆，遍历数组，将每个元素加入堆中，当堆的大小大于k时，删除堆顶元素，最后堆中为top k元素，堆顶最小，则为第k大元素</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	    <span class="comment">//维护k个元素的最小堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用优先级队列模拟堆，构造函数不提供Comparator函数，则优先级队列中元素以自然顺序排列</span></span><br><span class="line">        <span class="comment">//相当于最小堆，堆顶是堆中最小的元素</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">        <span class="comment">// for(int num: nums)&#123;</span></span><br><span class="line">        <span class="comment">//     if(pq.size() &lt; k)&#123;</span></span><br><span class="line">        <span class="comment">//         pq.offer(num);</span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//         if(num &gt; pq.peek())&#123;</span></span><br><span class="line">        <span class="comment">//             pq.offer(num);</span></span><br><span class="line">        <span class="comment">//             pq.poll();</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            pq.offer(num);</span><br><span class="line">            <span class="comment">//如果优先级队列中元素个数大于k，则删除堆顶元素（堆中最小）</span></span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k) pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时，堆中为top k元素，堆顶最小，则为第k大元素</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> pq.<span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆方法的<font color="red">时间复杂度为O(nlgk)，空间复杂度为O(k)</font>。</p>
<h3 id="快速选择算法(Quickselect)">快速选择算法(Quickselect)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="comment">//two pointers</span></span><br><span class="line">        <span class="comment">//小于等于枢纽（主元）的元素都往前放，从left下标开始</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//i左边的数即[left, i)都比pivot小，i&lt;=位置&lt;j的数即[i, j)都比pivot大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i位置为pivot最后的位置</span></span><br><span class="line">        swap(nums,i, right);</span><br><span class="line">        <span class="comment">//返回主元的位置,i左边的元素都比nums[i]小，右边都比nums[i]大</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//另一种partition的实现,特别容易写错，比如写成nums&lt;pivot和nums[j]&gt;pivot时，在nums[i] = nums[j]= pivot</span></span><br><span class="line">    <span class="comment">//会造成死循环，看看就好，以后不写这个版本的了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;right &amp;&amp; nums[i] &lt;= pivot) i++;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;left &amp;&amp; nums[j] &gt;= pivot) j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) swap(nums, i, j);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, right);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分函数的随机化版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomizedPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//nextInt(i)产生[0, i)中的随机数</span></span><br><span class="line">        <span class="comment">//nextInt(right - left)为[0, right - left+1) + left =&gt; [left, right]</span></span><br><span class="line">        <span class="keyword">int</span> randomIndex = random.nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        <span class="comment">//随机选择[left, right]中的元素有nums[right]交换，会nums[right]作为pivot，相当于随机选择一个元素作为pivot</span></span><br><span class="line">        swap(nums, randomIndex, right);</span><br><span class="line">        <span class="keyword">return</span> partition(nums, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回第k小的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//处理k的非法值</span></span><br><span class="line">        <span class="comment">//if(k &lt; 1 || k &gt; (right - left + 1)) return -1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivotIndex = randomizedPartition(nums, left, right);</span><br><span class="line">        <span class="keyword">int</span> s = pivotIndex - left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对三种情况进行处理：s = pivotIndex - left + 1</span></span><br><span class="line">        <span class="comment">//s == k: 即返回的主元就是我们要找的第k小的元素</span></span><br><span class="line">        <span class="comment">//s &lt; k : 那么接下来要到高区间nums[pivotIndex+1, right]寻找, 丢掉低区间</span></span><br><span class="line">        <span class="comment">//s &gt; k : 那么接下来要到低区间nums[left, pivotIndex - 1]寻找，丢掉高区间</span></span><br><span class="line">        <span class="keyword">if</span>(s == k) <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; k) <span class="keyword">return</span> quickSelect(nums, pivotIndex + <span class="number">1</span>, right, k - s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第k大，就是第nums.length - k + 1小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法叫快速选择，类似快速排序，但是快速选择只需处理一个子问题，而快排需要处理两个子问题。详见维基百科<a href="https://en.wikipedia.org/wiki/Quickselect" target="_blank" rel="external">Quickselect</a>。该算法<font color="red">最好情况的时间复杂度为O(n)，最坏情况下时间复杂度为O(n<sup>2</sup>)，平均时间复杂度为O(n)</font>。我们可以利用随机化版本的Partition函数大大降低最坏情况发生的概率,如上代码，应该也可以利用洗牌算法对数组进行洗牌（随机化)降低最坏情况发生的概率。如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//洗牌算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//每次让nums[i]和nums[0.....i]中随机一元素交换</span></span><br><span class="line">        <span class="comment">//i=0自己跟自己交换没必要循环了，jdk也类似这样写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            swap(nums, i, random.nextInt(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="comment">//two pointers</span></span><br><span class="line">        <span class="comment">//小于等于枢纽（主元）的元素都往前放，从left下标开始</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//i左边的数即[left, i)都比pivot小，i&lt;=位置&lt;j的数即[i, j)都比pivot大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i位置为pivot最后的位置</span></span><br><span class="line">        swap(nums,i, right);</span><br><span class="line">        <span class="comment">//返回主元的位置,i左边的元素都比nums[i]小，右边都比nums[i]大</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//返回第k小的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//处理k的非法值</span></span><br><span class="line">        <span class="comment">//if(k &lt; 1 || k &gt; (right - left + 1)) return -1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">int</span> s = pivotIndex - left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对三种情况进行处理：s = pivotIndex - left + 1</span></span><br><span class="line">        <span class="comment">//s == k: 即返回的主元就是我们要找的第k小的元素</span></span><br><span class="line">        <span class="comment">//s &lt; k : 那么接下来要到高区间nums[pivotIndex+1, right]寻找, 丢掉低区间</span></span><br><span class="line">        <span class="comment">//s &gt; k : 那么接下来要到低区间nums[left, pivotIndex - 1]寻找，丢掉高区间</span></span><br><span class="line">        <span class="keyword">if</span>(s == k) <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; k) <span class="keyword">return</span> quickSelect(nums, pivotIndex + <span class="number">1</span>, right, k - s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//第k大，就是第nums.length - k + 1小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以使用Median of medians算法，也叫BRPRT算法，详见维基百科<a href="https://en.wikipedia.org/wiki/Median_of_medians" target="_blank" rel="external">Median of medians</a>。该算法使用五分化中项的中项的方法来选择枢纽元素，该算法能保证快速选择算法最坏情况下时间复杂度也为O(n)。虽然该算法理论上是O(n)的，但是这个算法n的系数实际上比较大，所以还是随机化快速选择更有实际意义，也更简单。另外，这个思路也可以应用到优化快速排序最坏情况的时间复杂度问题上去。我们还可以使用Introselect算法，详见维基百科<a href="https://en.wikipedia.org/wiki/Introselect" target="_blank" rel="external">Introselect</a>。使用BFBRT实现本题代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第k大，就是第nums.length - k + 1小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BFPRT(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//nums[left,...right]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">BFPRT</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> groupSize = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//nums中的元素个数小于等于5排序后直接返回第k个数</span></span><br><span class="line">        <span class="keyword">if</span>(size &lt;= <span class="number">5</span>)&#123;</span><br><span class="line">            Arrays.sort(nums, left, right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> nums[left + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算五分后有几组 或者groupNum = (size + groupSize - 1) / groupSize;</span></span><br><span class="line">        <span class="keyword">int</span> groupNum = size % groupSize &gt; <span class="number">0</span> ? size / groupSize + <span class="number">1</span> : size / groupSize;</span><br><span class="line">        <span class="comment">//对每组数进行排序找出中位数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; groupNum; i++)&#123;</span><br><span class="line">            <span class="comment">//每组数开始下标</span></span><br><span class="line">            <span class="keyword">int</span> subLeft = left + i * groupSize;</span><br><span class="line">            <span class="comment">//结束下标</span></span><br><span class="line">            <span class="keyword">int</span> subRight = subLeft + groupSize - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//最后一组有可能大于right</span></span><br><span class="line">            <span class="keyword">if</span>(subRight &gt; right)&#123;</span><br><span class="line">                subRight = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对每组数排序来求出该组的中位数，Arrays.sort函数</span></span><br><span class="line">            Arrays.sort(nums, subLeft, subRight + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//每组数中位数的下标(left + right) / 2 </span></span><br><span class="line">            <span class="keyword">int</span> median = subLeft + (subRight - subLeft) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//中位数移到数组的前面，对这些中位数递归调用BFPRT算法求得他们的中位数。</span></span><br><span class="line">            <span class="comment">//也可以另外用一个存中位数的数组</span></span><br><span class="line">            swap(nums, left+i, median);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算中位数们的中位数的下标这里的right = left + groupNum - 1，则left + (right - left) / 2可得如下</span></span><br><span class="line">        <span class="keyword">int</span> pivotIndex = left + (groupNum - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">////不关心中位数的值，保证中位数在正确的位置,因为k从1开始算，groupNum/2是从0开始算的</span></span><br><span class="line">        <span class="comment">// IMPORTANT !!</span></span><br><span class="line">       <span class="comment">// Recurse to call and place the median on the pivot_index, without care about the median value</span></span><br><span class="line">       <span class="comment">// Because the value of pivot_index must be the median after select function recursive call.</span></span><br><span class="line">        BFPRT(nums, left, left + groupNum - <span class="number">1</span>, (groupNum+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> midIndex = partition(nums, left, right, pivotIndex);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s = midIndex - left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对三种情况进行处理：s = midIndex - left + 1</span></span><br><span class="line">        <span class="comment">//s == k: 即返回的主元就是我们要找的第k小的元素</span></span><br><span class="line">        <span class="comment">//s &lt; k : 那么接下来要到高区间nums[midIndex+1, right]寻找, 丢掉低区间</span></span><br><span class="line">        <span class="comment">//s &gt; k : 那么接下来要到低区间nums[left, midIndex - 1]寻找，丢掉高区间</span></span><br><span class="line">        <span class="keyword">if</span>(s == k) <span class="keyword">return</span> nums[midIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; k) <span class="keyword">return</span> BFPRT(nums, midIndex + <span class="number">1</span>, right, k - s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> BFPRT(nums, left, midIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> pivotIndex)</span></span>&#123;</span><br><span class="line">        swap(nums, pivotIndex, right);</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="comment">//two pointers</span></span><br><span class="line">        <span class="comment">//小于等于枢纽（主元）的元素都往前放，从left下标开始</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//i左边的数即[left, i)都比pivot小，i&lt;=位置&lt;j的数即[i, j)都比pivot大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i位置为pivot最后的位置</span></span><br><span class="line">        swap(nums,i, right);</span><br><span class="line">        <span class="comment">//返回主元的位置,i左边的元素都比nums[i]小，右边都比nums[i]大</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献">参考文献</h2><p><a href="https://en.wikipedia.org/wiki/Selection_algorithm" target="_blank" rel="external">Selection algorithm</a><br><a href="https://en.wikipedia.org/wiki/Quickselect" target="_blank" rel="external">Quickselect</a><br><a href="https://en.wikipedia.org/wiki/Median_of_medians" target="_blank" rel="external">Median of medians</a><br><a href="https://en.wikipedia.org/wiki/Introselect" target="_blank" rel="external">Introselect</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6370650" target="_blank" rel="external">程序员编程艺术：第三章、寻找最小的k个数</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6403777" target="_blank" rel="external">程序员编程艺术：第三章续、Top K算法问题的实现</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6431001" target="_blank" rel="external">十四、第三章再续：快速选择SELECT算法的深入分析与实现</a><br><a href="http://noalgo.info/466.html" target="_blank" rel="external">BFPRT算法</a><br><a href="http://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array-set-3-worst-case-linear-time/" target="_blank" rel="external">K’th Smallest/Largest Element in Unsorted Array | Set 3 (Worst Case Linear Time)
</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.noobsky.com/2016/06/08/LeetCode-Kth-Largest-Element-in-an-Array/" data-id="cip8ize9u003nvuc16xwtjadu" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/算法/">算法</a></div><div class="post-nav"><a href="/2016/06/07/LeetCode-Increasing-Triplet-Subsequence/" class="next">[LeetCode]Increasing Triplet Subsequence</a></div><div id="disqus_thread"><script>var disqus_shortname = 'noobsky';
var disqus_identifier = '2016/06/08/LeetCode-Kth-Largest-Element-in-an-Array/';
var disqus_title = '[LeetCode]Kth Largest Element in an Array';
var disqus_url = 'http://blog.noobsky.com/2016/06/08/LeetCode-Kth-Largest-Element-in-an-Array/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//noobsky.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.noobsky.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nodejs/">Nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shadowsocks/">Shadowsocks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Dynamic-Programming/" style="font-size: 15px;">Dynamic Programming</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/代理/" style="font-size: 15px;">代理</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/node-http-proxy/" style="font-size: 15px;">node-http-proxy</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/谷歌学术/" style="font-size: 15px;">谷歌学术</a> <a href="/tags/Shadowsocks/" style="font-size: 15px;">Shadowsocks</a> <a href="/tags/AWS/" style="font-size: 15px;">AWS</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Tree/" style="font-size: 15px;">Tree</a> <a href="/tags/静态代理/" style="font-size: 15px;">静态代理</a> <a href="/tags/动态代理/" style="font-size: 15px;">动态代理</a> <a href="/tags/注解/" style="font-size: 15px;">注解</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/Floyd判圈算法/" style="font-size: 15px;">Floyd判圈算法</a> <a href="/tags/DTW/" style="font-size: 15px;">DTW</a> <a href="/tags/语音识别/" style="font-size: 15px;">语音识别</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/06/08/LeetCode-Kth-Largest-Element-in-an-Array/">[LeetCode]Kth Largest Element in an Array</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/07/LeetCode-Increasing-Triplet-Subsequence/">[LeetCode]Increasing Triplet Subsequence</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/07/LeetCode-Longest-Increasing-Subsequence/">[LeetCode]Longest Increasing Subsequence</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/LeetCode-Combinations/">[LeetCode]Combinations</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/LeetCode-Search-a-2D-Matrix-I-II/">[LeetCode]Search a 2D Matrix I II</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/LeetCode-Sort-Colors/">[LeetCode]Sort Colors</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/LeetCode-Ugly-Number-I-II/">[LeetCode]Ugly Number I II</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/LeetCode-Rotate-Image/">[LeetCode]Rotate Image</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/LeetCode-Binary-Search-Tree-Iterator/">[LeetCode]Binary Search Tree Iterator</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/LeetCode-Binary-Tree-Right-Side-View/">[LeetCode]Binary Tree Right Side View</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//noobsky.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://coolshell.cn/" title="酷壳" target="_blank">酷壳</a><ul></ul><a href="http://www.importnew.com/" title="ImportNew" target="_blank">ImportNew</a><ul></ul><a href="http://toutiao.io/" title="开发者头条" target="_blank">开发者头条</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">NoobSky.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>