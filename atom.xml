<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-06-06T07:27:51.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Ugly Number I,II]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Ugly-Number-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Ugly-Number-I-II/</id>
    <published>2016-06-06T07:22:02.000Z</published>
    <updated>2016-06-06T07:27:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Ugly_Number_I">Ugly Number I</h2><h3 id="题目描述">题目描述</h3><p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>) num = num / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>) num = num / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>) num = num / <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ugly_Number_II">Ugly Number II</h2><h3 id="题目描述-1">题目描述</h3><p>Write a program to find the n-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<p>Hint:</p>
<pre><code><span class="number">1.</span>The naive approach is <span class="built_in">to</span> call isUgly <span class="keyword">for</span> every <span class="built_in">number</span> <span class="keyword">until</span> you reach <span class="operator">the</span> nth <span class="constant">one</span>. Most numbers are <span class="operator">not</span> ugly. Try <span class="built_in">to</span> focus your effort <span class="command"><span class="keyword">on</span> <span class="title">generating</span> <span class="title">only</span> <span class="title">the</span> <span class="title">ugly</span> <span class="title">ones</span>.</span>
<span class="number">2.</span>An ugly <span class="built_in">number</span> must be multiplied <span class="keyword">by</span> either <span class="number">2</span>, <span class="number">3</span>, <span class="operator">or</span> <span class="number">5</span> <span class="built_in">from</span> <span class="operator">a</span> smaller ugly <span class="built_in">number</span>.
<span class="number">3.</span>The key is how <span class="built_in">to</span> maintain <span class="operator">the</span> order <span class="operator">of</span> <span class="operator">the</span> ugly numbers. Try <span class="operator">a</span> similar approach <span class="operator">of</span> merging <span class="built_in">from</span> <span class="constant">three</span> sorted lists: L1, L2, <span class="operator">and</span> L3.
<span class="number">4.</span>Assume you have Uk, <span class="operator">the</span> kth ugly <span class="built_in">number</span>. Then Uk+<span class="number">1</span> must be Min(L1 * <span class="number">2</span>, L2 * <span class="number">3</span>, L3 * <span class="number">5</span>).
</code></pre><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//ugly[0] = 1</span></span><br><span class="line">    <span class="comment">//ugly[1] = min(2*ugly[0], 3*ugly[0], 5*ugly[0])</span></span><br><span class="line">    <span class="comment">//ugly[2] = min(2*ugly[1], 3*ugly[0], 5*ugly[0])</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] ugly = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>, index3 = <span class="number">0</span>, index5 = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;i++)&#123;</span><br><span class="line">            ugly[i] = Math.min(Math.min(<span class="number">2</span> * ugly[index2], <span class="number">3</span> * ugly[index3]), <span class="number">5</span> * ugly[index5]);</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">2</span> * ugly[index2]) index2++;</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">3</span> * ugly[index3]) index3++;</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">5</span> * ugly[index5]) index5++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ugly[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Ugly_Number_I">Ugly Number I</h2><h3 id="题目描述">题目描述</h3><p>Write a program to check whether a given number is an ugly number.</p>
<p]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Rotate Image]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Rotate-Image/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Rotate-Image/</id>
    <published>2016-06-06T05:18:34.000Z</published>
    <updated>2016-06-06T05:19:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Follow up:<br>Could you do this in-place?</p>
<h2 id="代码">代码</h2><figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    <span class="comment">//顺时针旋转90度，先转置然后左右翻转(y轴反转)</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    1 2 3    1 4 7    7 4 1</span><br><span class="line">    4 5 6 =&gt; 2 5 8 =&gt; 8 5 2</span><br><span class="line">    7 8 9    3 6 9    9 6 3</span><br><span class="line">    */</span></span><br><span class="line">    public void rotate(int[][] <span class="keyword">matrix</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">matrix</span> == null || <span class="keyword">matrix</span>.<span class="built_in">length</span> == <span class="number">0</span> || <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="built_in">length</span> == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        int <span class="built_in">length</span> = <span class="keyword">matrix</span>.<span class="built_in">length</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i+<span class="number">1</span>; j &lt; <span class="built_in">length</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[j][i];</span><br><span class="line">                <span class="keyword">matrix</span>[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="built_in">length</span>/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[i][<span class="built_in">length</span>-j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">matrix</span>[i][<span class="built_in">length</span>-j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逆时针旋转90度，先转置然后上下翻转(x轴对称)</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    1 2 3    1 4 7    3 6 9</span><br><span class="line">    4 5 6 =&gt; 2 5 8 =&gt; 2 5 8</span><br><span class="line">    7 8 9    3 6 9    1 4 7</span><br><span class="line">    */</span></span><br><span class="line">    public void rotate2(int[][] <span class="keyword">matrix</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">matrix</span> == null || <span class="keyword">matrix</span>.<span class="built_in">length</span> == <span class="number">0</span> || <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="built_in">length</span> == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        int <span class="built_in">length</span> = <span class="keyword">matrix</span>.<span class="built_in">length</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i+<span class="number">1</span>; j &lt; <span class="built_in">length</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[j][i];</span><br><span class="line">                <span class="keyword">matrix</span>[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="built_in">length</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[<span class="built_in">length</span>-i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">matrix</span>[<span class="built_in">length</span>-i-<span class="number">1</span>][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Search Tree Iterator]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Search-Tree-Iterator/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Search-Tree-Iterator/</id>
    <published>2016-06-06T02:38:37.000Z</published>
    <updated>2016-06-06T02:40:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//很自然的思路就是将所有的树节点放入array中，然后利用索引指针进行next和hashNext</span></span><br><span class="line"><span class="comment">//满足O(1)time但是不满足O(h)memory</span></span><br><span class="line"><span class="comment">//我们可以利用栈，首先将树的left branch压栈，此时栈顶元素为最小的元素，当调用next弹出栈顶元素</span></span><br><span class="line"><span class="comment">//后，最小元素并不在栈中，我们需要寻找到最小元素然后入栈。此时树中元素最小元素在弹出元素的右子树的left branch</span></span><br><span class="line"><span class="comment">//这一点是由BST的性质决定的，所以我们next之后需要将弹出元素的右子树的left branch入栈。</span></span><br><span class="line"><span class="comment">//此种解法满足O(h)memory,next O(1), hashNext的平均时间能达到O(1)</span></span><br><span class="line"><span class="comment">//我们用next遍历整颗树，则next函数会遍历每个节点，run time为O(n),所以对于整棵树来说，平均运行时间为O(n)/n=O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> BSTIterator &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">stack</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode temp = <span class="built_in">stack</span>.pop();</span><br><span class="line">        pushLeftBranch(temp.right);</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLeftBranch</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node != null)&#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your BSTIterator will be called like this:</span><br><span class="line"> * BSTIterator i = new BSTIterator(root);</span><br><span class="line"> * while (i.hasNext()) v[f()] = i.next();</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a B]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Right Side View]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Tree-Right-Side-View/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Tree-Right-Side-View/</id>
    <published>2016-06-06T01:21:29.000Z</published>
    <updated>2016-06-06T01:23:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>For example:<br>Given the following binary tree,</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span>            &lt;-<span class="comment">--</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;-<span class="comment">--</span></span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;-<span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>You should return [1, 3, 4].</p>
<h2 id="代码">代码</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; res = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rightView(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一层就取一个，而且是最右边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> rightView(TreeNode root, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; res, int currHeight)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//tricky，因为一层就取一个（最右边的），当res.size()==currHeight时，说明该元素就是该层最右边的元素</span></span><br><span class="line">        <span class="keyword">if</span>(res<span class="built_in">.</span>size() == currHeight) res<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//右边优先</span></span><br><span class="line">        rightView(root<span class="built_in">.</span>right, res, currHeight+<span class="number">1</span>);</span><br><span class="line">        rightView(root<span class="built_in">.</span>left, res, currHeight+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Spiral Matrix I,II]]></title>
    <link href="http://blog.noobsky.com/2016/06/05/LeetCode-Spiral-Matrix-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/05/LeetCode-Spiral-Matrix-I-II/</id>
    <published>2016-06-05T08:52:49.000Z</published>
    <updated>2016-06-05T09:47:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Spiral_Matrix_I">Spiral Matrix I</h2><h3 id="题目描述">题目描述</h3><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>Given the following matrix:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>You should return [1,2,3,6,9,8,7,4,5].</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//matrix[0][0]、matrix[0][1]</span></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置为-1比较好</span></span><br><span class="line">        <span class="keyword">int</span> col = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当m或者n等于0时终止循环</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//col初始值为-1，for循环结束后col刚好为下一次循环的起始值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                res.add(matrix[row][++col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已经少了一行(row),所以m--</span></span><br><span class="line">            m--;</span><br><span class="line">            <span class="comment">//如果m==0终止循环</span></span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//等价于if(--m == 0) break;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                res.add(matrix[++row][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上面的for循环后，会减少一列，所以n--</span></span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                res.add(matrix[row][--col]);</span><br><span class="line">            &#125;</span><br><span class="line">            m--;</span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                res.add(matrix[--row][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spiral_Matrix_II">Spiral Matrix II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p>For example,<br>Given n = 3,</p>
<p>You should return the following matrix:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//if(n &lt;= 0) return new int[0][0];</span></span><br><span class="line">        <span class="keyword">int</span> rowLen = n;</span><br><span class="line">        <span class="keyword">int</span> colLen = n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colLen; i++)&#123;</span><br><span class="line">                matrix[row][++col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加上小于是防止n=0的情况，或者直接在前面判断特殊情况</span></span><br><span class="line">            <span class="keyword">if</span>(--rowLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowLen; i++)&#123;</span><br><span class="line">                matrix[++row][col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(--colLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colLen; i++)&#123;</span><br><span class="line">                matrix[row][--col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(--rowLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowLen; i++)&#123;</span><br><span class="line">                matrix[--row][col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(--colLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Spiral_Matrix_I">Spiral Matrix I</h2><h3 id="题目描述">题目描述</h3><p>Given a matrix of m x n elements (m rows, n columns), return all elem]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Permutations I,II]]></title>
    <link href="http://blog.noobsky.com/2016/06/05/LeetCode-Permutations-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/05/LeetCode-Permutations-I-II/</id>
    <published>2016-06-05T06:22:34.000Z</published>
    <updated>2016-06-05T07:38:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Permutations_I">Permutations I</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of distinct numbers, return all possible permutations.</p>
<p>For example,<br>[1,2,3] have the following permutations:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><ul>
<li><p>一般思路</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(nums, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> void permute(<span class="keyword">int</span>[]nums, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">int</span> start)&#123;</span><br><span class="line">        <span class="comment">//产生了一个permutation</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= nums.length)&#123;</span><br><span class="line">            <span class="comment">//如果Arrays.asList(arr)的参数arr是原生数组的话并不能得到你想要的结果，</span></span><br><span class="line">            <span class="comment">//Arrays.asList(T...a)形参为可变长参数，如果传入int[] nums的话，会将int[]看做一个类型</span></span><br><span class="line">            <span class="comment">//List list = Arrays.asList(nums)则list.size() == 1;</span></span><br><span class="line">            <span class="comment">//res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums)));</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//还是乖乖遍历吧，或者加多一个参数</span></span><br><span class="line">            <span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">list</span>.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">list</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">            <span class="comment">//注意第三个参数是start+1不是i+1</span></span><br><span class="line">            permute(nums, res, start+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//相当于还原回来</span></span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> void swap(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码比较简洁易懂</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute(nums, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> void permute(<span class="keyword">int</span>[] nums, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">List</span>&lt;Integer&gt; curr)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//curr中已经包含nums[i],跳过本次循环</span></span><br><span class="line">            <span class="keyword">if</span>(curr.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            permute(nums, res, curr);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Permutations_II">Permutations II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br>[1,1,2] have the following unique permutations:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码-1">代码</h3><ul>
<li><p>比较tricky的写法</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//注意排序，让重复的数相邻</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        helper(nums, used, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> void helper(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, <span class="keyword">List</span>&lt;Integer&gt; curr, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//only insert duplicate element when the previous duplicate element has been inserted</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            helper(nums, used, curr, res);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常规思路加排重</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; permuteUnique(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute(nums, res, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">void</span> permute(<span class="built_in">int</span>[] nums, <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res, <span class="built_in">int</span> start)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">            <span class="built_in">List</span>&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> <span class="built_in">num</span>: nums) &#123;temp.add(<span class="built_in">num</span>);&#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//set在for循环外面定义，在里面定义错误</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; <span class="literal">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">set</span>.add(nums[i]))&#123;</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">                permute(nums, res, start+<span class="number">1</span>);</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private <span class="keyword">void</span> swap(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> x, <span class="built_in">int</span> y)&#123;</span><br><span class="line">        <span class="built_in">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Permutations_I">Permutations I</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of distinct numbers, return all possible permutation]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Combination Sum I II III]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Combination-Sum-I-II-III/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Combination-Sum-I-II-III/</id>
    <published>2016-06-04T12:23:07.000Z</published>
    <updated>2016-06-05T01:43:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Combination_Sum_I">Combination Sum I</h2><h3 id="题目描述">题目描述</h3><p>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>The same repeated number may be chosen from C unlimited number of times.</p>
<p>Note:</p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</li>
<li>The solution set must not contain duplicate combinations.</li>
<li>For example, given candidate set 2,3,6,7 and target 7,<br>A solution set is:<br>[7]<br>[2, 2, 3]</li>
</ul>
<h3 id="代码">代码</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(candidates, <span class="keyword">target</span>, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">target</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; <span class="keyword">target</span> &gt;= candidates[i]; i++)&#123;</span><br><span class="line">                curr.add(candidates[i]);</span><br><span class="line">                <span class="comment">//元素可以重复利用，所以start为i</span></span><br><span class="line">                helper(candidates, <span class="keyword">target</span> - candidates[i], res, curr, i);</span><br><span class="line">                <span class="comment">//回溯，删除curr中最后一个元素</span></span><br><span class="line">                curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(<span class="keyword">target</span> == <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">            <span class="comment">//找到一个序列</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Combination_Sum_II">Combination Sum II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>Each number in C may only be used once in the combination.</p>
<p>Note:</p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>For example, given candidate set 10,1,2,7,6,1,5 and target 8,<br>A solution set is:<br>[1, 7]<br>[1, 2, 5]<br>[2, 6]<br>[1, 1, 6] </p>
<h3 id="代码-1">代码</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(candidates, <span class="keyword">target</span>, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">target</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">target</span> &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; <span class="keyword">target</span> &gt;= candidates[i]; i++)&#123;</span><br><span class="line">            <span class="comment">//i==start || candidates[i]!=candidates[i-1]避免重复结果</span></span><br><span class="line">            <span class="comment">//等价于（i&gt;start&amp;&amp;candidates[i]==candidates[i-1] continue</span></span><br><span class="line">            <span class="comment">//i大于start意味着candidates[i-1]已经从curr被remove，所以如果candidates[i]==candidates[i-1]</span></span><br><span class="line">            <span class="comment">//则我们不应该将candidates[i]加入curr中</span></span><br><span class="line">            <span class="keyword">if</span>(i==start || candidates[i]!=candidates[i-<span class="number">1</span>])&#123;</span><br><span class="line">                curr.add(candidates[i]);</span><br><span class="line">                <span class="comment">//candidates的每个元素智能使用一次,所以下一次递归时为i+1</span></span><br><span class="line">                helper(candidates, <span class="keyword">target</span>-candidates[i], res, curr, i+<span class="number">1</span>);</span><br><span class="line">                curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Combination_Sum_III">Combination Sum III</h2><h3 id="题目描述-2">题目描述</h3><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Ensure that numbers within the set are sorted in ascending order.</p>
<p>Example 1:</p>
<p>Input: k = 3, n = 7</p>
<p>Output:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<p>Input: k = 3, n = 9</p>
<p>Output:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>], [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(k, n, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> need, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(need == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//需要寻找从i开始的need个数，所以需要满足target &gt;= i+(i+1)+...+(i+need-1) = i*need+need*(need-1)/2</span></span><br><span class="line">        <span class="comment">//即i开始的need个数最小和为i+(i+1)+...+(i+need-1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i != <span class="number">10</span> &amp;&amp; target &gt;= i * need + need * (need - <span class="number">1</span>) / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            curr.add(i);</span><br><span class="line">            helper(need-<span class="number">1</span>, target-i, res, curr, i+<span class="number">1</span>);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Combination_Sum_I">Combination Sum I</h2><h3 id="题目描述">题目描述</h3><p>Given a set of candidate numbers (C) and a target number (T), fin]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Find Minimum in Rotated Sorted Array I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Find-Minimum-in-Rotated-Sorted-Array-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Find-Minimum-in-Rotated-Sorted-Array-I-II/</id>
    <published>2016-06-04T07:07:07.000Z</published>
    <updated>2016-06-04T08:49:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Find_Minimum_in_Rotated_Sorted_Array_I">Find Minimum in Rotated Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<h3 id="代码如下">代码如下</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="keyword">public</span> int findMin(int[] nums) &#123;</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>])&#123;<span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">                <span class="keyword">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="keyword">right</span>])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                <span class="keyword">right</span> = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="keyword">left</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Find_Minimum_in_Rotated_Sorted_Array_II">Find Minimum in Rotated Sorted Array II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for “Find Minimum in Rotated Sorted Array”:<br>What if duplicates are allowed?</p>
<p>Would this affect the run-time complexity? How and why?<br>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<h3 id="代码">代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="comment">//nums[mid] &gt; nums[right],nums[left:mid]有序，搜索右边</span></span><br><span class="line">    <span class="comment">//nums[mid] &lt; nums[right],nums[mid:right]有序，搜索左边</span></span><br><span class="line">    <span class="comment">//nums[mid] = nums[right],有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">    <span class="comment">//但可以肯定排除nums[right],即使min = A[right],排除A[right]并没有使min丢失</span></span><br><span class="line">    <span class="keyword">public</span> int findMin(int[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span>+(<span class="keyword">right</span> - <span class="keyword">left</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="keyword">right</span>])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                <span class="keyword">right</span> = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">                <span class="keyword">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="keyword">left</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Find_Minimum_in_Rotated_Sorted_Array_I">Find Minimum in Rotated Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Suppose a sorted array ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Populating Next Right Pointers in Each Node I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Populating-Next-Right-Pointers-in-Each-Node/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Populating-Next-Right-Pointers-in-Each-Node/</id>
    <published>2016-06-04T05:28:55.000Z</published>
    <updated>2016-06-04T06:38:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Populating_Next_Right_Pointers_in_Each_Node_I">Populating Next Right Pointers in Each Node I</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">struct</span> TreeLinkNode &#123;</span><br><span class="line">      <span class="title">TreeLinkNode</span> *left;</span><br><span class="line">      <span class="title">TreeLinkNode</span> *right;</span><br><span class="line">      <span class="title">TreeLinkNode</span> *next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<ul>
<li>You may only use constant extra space.</li>
<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
<p>For example,<br>Given the following perfect binary tree,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>After calling your function, the tree should look like:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span> -&gt; <span class="literal">NULL</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">NULL</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span> -&gt; <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p>
<h3 id="代码如下">代码如下</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree with next pointer.</span><br><span class="line"> * public class TreeLinkNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeLinkNode left, right, next;</span><br><span class="line"> *     TreeLinkNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//思路比较直接，直接迭代法遍历,分层处理</span></span><br><span class="line">    <span class="comment">//注意，所有节点的next都初始化为null</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> connect(TreeLinkNode root)&#123;</span><br><span class="line"></span><br><span class="line">		TreeLinkNode levelStart = root;</span><br><span class="line">		TreeLinkNode curr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(levelStart != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//从每一层的第一个节点开始处理</span></span><br><span class="line">			curr = levelStart;</span><br><span class="line">			<span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(curr.left != <span class="keyword">null</span>) curr.left.<span class="keyword">next</span> = curr.right;</span><br><span class="line">				<span class="keyword">if</span>(curr.right != <span class="keyword">null</span> &amp;&amp; curr.<span class="keyword">next</span> != <span class="keyword">null</span>) curr.right.<span class="keyword">next</span> = curr.<span class="keyword">next</span>.left;</span><br><span class="line">				curr = curr.<span class="keyword">next</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//换到下一层第一个节点</span></span><br><span class="line">			levelStart = levelStart.left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Populating_Next_Right_Pointers_in_Each_Node_II">Populating Next Right Pointers in Each Node II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for problem “Populating Next Right Pointers in Each Node”.</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note:</p>
<ul>
<li>You may only use constant extra space.<br>For example,<br>Given the following binary tree,<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"> / \    \</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>    <span class="number">7</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>After calling your function, the tree should look like:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span> -&gt; <span class="literal">NULL</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">NULL</span></span><br><span class="line"> / \    \</span><br><span class="line"><span class="number">4</span>-&gt; <span class="number">5</span> -&gt; <span class="number">7</span> -&gt; <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p>
<h3 id="代码">代码</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree with <span class="built_in">next</span> pointer.</span><br><span class="line"> * public class TreeLinkNode &#123;</span><br><span class="line"> *     <span class="typename">int</span> val;</span><br><span class="line"> *     TreeLinkNode left, right, <span class="built_in">next</span>;</span><br><span class="line"> *     TreeLinkNode(<span class="typename">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void connect(TreeLinkNode root)&#123;</span><br><span class="line">        TreeLinkNode levelStart = root;<span class="comment">//下一层的最左边节点</span></span><br><span class="line">        TreeLinkNode <span class="built_in">prev</span> = <span class="built_in">null</span>; <span class="comment">//下一层的前一节点</span></span><br><span class="line">        TreeLinkNode curr = <span class="built_in">null</span>;<span class="comment">//当前节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(levelStart != <span class="built_in">null</span>)&#123;</span><br><span class="line">            curr = levelStart;</span><br><span class="line">            <span class="built_in">prev</span> = <span class="built_in">null</span>;</span><br><span class="line">            <span class="comment">//不能缺少，少了会超时（只有根节点的情况），&#123;0&#125;死循环</span></span><br><span class="line">            levelStart = <span class="built_in">null</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(curr != <span class="built_in">null</span>)&#123;</span><br><span class="line">                <span class="comment">//不为空，进行处理</span></span><br><span class="line">                if(curr.left != <span class="built_in">null</span>)&#123;</span><br><span class="line">                    if(<span class="built_in">prev</span> != <span class="built_in">null</span>)</span><br><span class="line">                        <span class="built_in">prev</span>.<span class="built_in">next</span> = curr.left;</span><br><span class="line">                    else</span><br><span class="line">                        levelStart = curr.left;<span class="comment">//没有prev节点的话，则新的levelStart为curr.left</span></span><br><span class="line">                    <span class="comment">//处理完之后，curr.left成为prev节点</span></span><br><span class="line">                    <span class="built_in">prev</span> = curr.left;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if(curr.right != <span class="built_in">null</span>)&#123;</span><br><span class="line">                    if(<span class="built_in">prev</span> != <span class="built_in">null</span>)</span><br><span class="line">                        <span class="built_in">prev</span>.<span class="built_in">next</span> = curr.right;</span><br><span class="line">                    else</span><br><span class="line">                        levelStart = curr.right;</span><br><span class="line">                    <span class="comment">//处理完之后，curr.left成为prev节点</span></span><br><span class="line">                    <span class="built_in">prev</span> = curr.right;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr.<span class="built_in">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Populating_Next_Right_Pointers_in_Each_Node_I">Populating Next Right Pointers in Each Node I</h2><h3 id="题目描述">题目描述</h3><p>Given a b]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Unique Paths I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Unique-Paths-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Unique-Paths-I-II/</id>
    <published>2016-06-04T02:38:02.000Z</published>
    <updated>2016-06-04T04:03:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Unique_Paths">Unique Paths</h2><h3 id="题目描述">题目描述</h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="http://7xonwi.com1.z0.glb.clouddn.com/robot_maze.png" alt=""><br>Above is a 3 x 7 grid. How many possible unique paths are there?</p>
<p>Note: m and n will be at most 100.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//a[m][n] = a[m-1][n]+a[m][n-1]</span></span><br><span class="line">    <span class="comment">// public int uniquePaths(int m, int n) &#123;</span></span><br><span class="line">    <span class="comment">//     if(m &lt;= 0 || n &lt;= 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int[][] grid = new int[m][n];</span></span><br><span class="line">    <span class="comment">//     //第一排和第一列都为1</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; m; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         grid[i][0] = 1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     for(int j = 0; j &lt; n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//         grid[0][j] = 1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt; m; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 1; j &lt; n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             grid[i][j] = grid[i-1][j]+grid[i][j-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return grid[m-1][n-1];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a[m][n] = a[m-1][n]+a[m][n-1]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                grid[i][j] = (i == <span class="number">0</span> || j == <span class="number">0</span>) ? <span class="number">1</span> : grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Unique_Paths_II">Unique Paths II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p>For example,<br>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> grid[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) grid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">0</span> : grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) grid[<span class="number">0</span>][j] = (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) ? <span class="number">0</span> : grid[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                grid[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也可以但是不够好理解</span></span><br><span class="line">    <span class="comment">// public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span></span><br><span class="line">    <span class="comment">//     int m = obstacleGrid.length;</span></span><br><span class="line">    <span class="comment">//     if(m == 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int n = obstacleGrid[0].length;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int grid[][] = new int[m+1][n+1];</span></span><br><span class="line">    <span class="comment">//     grid[0][1] = 1;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt;= m; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 1; j &lt;= n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             grid[i][j] = obstacleGrid[i-1][j-1] == 1 ? 0 : grid[i-1][j]+grid[i][j-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return grid[m][n];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Unique_Paths">Unique Paths</h2><h3 id="题目描述">题目描述</h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ i]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Gray Code]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Gray-Code/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Gray-Code/</id>
    <published>2016-06-04T00:59:16.000Z</published>
    <updated>2016-06-04T01:55:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> - <span class="number">0</span></span><br><span class="line"><span class="number">01</span> - <span class="number">1</span></span><br><span class="line"><span class="number">11</span> - <span class="number">3</span></span><br><span class="line"><span class="number">10</span> - <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Note:<br>For a given n, a gray code sequence is not uniquely defined.</p>
<p>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Int    Grey Code    Binary</span><br><span class="line"> <span class="number">0</span>  　　  <span class="number">000</span>        <span class="number">000</span></span><br><span class="line"> <span class="number">1</span>  　　  <span class="number">001</span>        <span class="number">001</span></span><br><span class="line"> <span class="number">2</span>   　 　<span class="number">011</span>        <span class="number">010</span></span><br><span class="line"> <span class="number">3</span>   　 　<span class="number">010</span>        <span class="number">011</span></span><br><span class="line"> <span class="number">4</span>   　 　<span class="number">110</span>        <span class="number">100</span></span><br><span class="line"> <span class="number">5</span>   　 　<span class="number">111</span>        <span class="number">101</span></span><br><span class="line"> <span class="number">6</span>   　 　<span class="number">101</span>        <span class="number">110</span></span><br><span class="line"> <span class="number">7</span>   　　 <span class="number">100</span>        <span class="number">111</span></span><br></pre></td></tr></table></figure>
<h2 id="解法一">解法一</h2><p>利用格雷码和二进制数的相互转换，G(i)=(i/2)^i<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//G(i)=(i/2)^i</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; grayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            res.add(i ^ (i&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二">解法二</h2><p>格雷码有镜射排列的性质，即n位元的格雷码可以从n-1位元的格雷码以上下镜射后加上新位元的方式快速得到，如下图所示<br><img src="https://upload.wikimedia.org/wikipedia/commons/c/c1/Binary-reflected_Gray_code_construction.svg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//镜面排列</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; grayCode(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        res.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> highBit = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                res.add(res.get(j)+highBit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-ne]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Generate Parentheses]]></title>
    <link href="http://blog.noobsky.com/2016/06/03/LeetCode-Generate-Parentheses/"/>
    <id>http://blog.noobsky.com/2016/06/03/LeetCode-Generate-Parentheses/</id>
    <published>2016-06-03T12:00:58.000Z</published>
    <updated>2016-06-03T12:24:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:</p>
<p>“((()))”, “(()())”, “(())()”, “()(())”, “()()()”</p>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(n,n,<span class="string">""</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="comment">//在每次递归函数中记录左括号和右括号剩余的数量，然后有两种选择，一种是放一个左括号，一种放一个右括号</span></span><br><span class="line">    <span class="comment">//有一些否定条件，比如右括号的数量不能比左括号少，左右括号的数量要大于0</span></span><br><span class="line">    <span class="comment">//正常的递归终止条件是左右括号的数量都为0</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// public void helper(int left, int right, String item, List&lt;String&gt; res)&#123;</span></span><br><span class="line">    <span class="comment">//     //右括号的数量比左括号少，递归终止</span></span><br><span class="line">    <span class="comment">//     if(right &lt; left) return;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(right == 0 &amp;&amp; left == 0) res.add(item);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(left &gt; 0) helper(left-1, right, item+"(", res);</span></span><br><span class="line">    <span class="comment">//     if(right &gt; 0) helper(left, right-1, item+")", res);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//right不能比左括号少，且right &gt; 0,即条件为right &gt; left</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String item, List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//右括号的数量比左括号少，递归终止</span></span><br><span class="line">        <span class="comment">//if(right &lt; left) return;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">0</span> &amp;&amp; left == <span class="number">0</span>) res.add(item);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>) helper(left-<span class="number">1</span>, right, item+<span class="string">"("</span>, res);</span><br><span class="line">        <span class="comment">//右括号比左括号多时才能往下递归，比如n=3，当递归到helper(1,1,"()()",res),"()()"+")"显然是不可行的</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; left) helper(left, right-<span class="number">1</span>, item+<span class="string">")"</span>, res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]House Robber I II III]]></title>
    <link href="http://blog.noobsky.com/2016/06/03/LeetCode-House-Robber-I-II-III/"/>
    <id>http://blog.noobsky.com/2016/06/03/LeetCode-House-Robber-I-II-III/</id>
    <published>2016-06-03T06:25:53.000Z</published>
    <updated>2016-06-03T08:51:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="House_Robber_I">House Robber I</h2><h3 id="题目描述">题目描述</h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<h3 id="解题思路及代码">解题思路及代码</h3><p>dp解法，第i家要么不抢要么抢，dp[i] = max(dp[i-1],dp[i-2]+nums[i])，dp数组可以省略</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//dp[i] = max(dp[i-1],dp[i-2]+nums[i])</span></span><br><span class="line">    <span class="comment">//自己想的，O(n),但是需要O(n)的内存空间</span></span><br><span class="line">    <span class="comment">// public int rob(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(nums.length == 1) return nums[0];</span></span><br><span class="line">    <span class="comment">//     int[] dp = new int[nums.length];</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     dp[0] = nums[0];</span></span><br><span class="line">    <span class="comment">//     dp[1] = Math.max(nums[0], nums[1]);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     for(int i = 2; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return dp[nums.length - 1];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ifRobedPrevious = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ifDontRobedPrevious = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前house要么抢要么不抢</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//当前house抢能获得的money，则前一house不能抢，</span></span><br><span class="line">            <span class="keyword">int</span> currentRobed = ifDontRobedPrevious + nums[i];</span><br><span class="line">            <span class="comment">//当前house不抢能获得的money，则为前一house抢或者不抢，取最大值</span></span><br><span class="line">            <span class="keyword">int</span> currentNotRobed = Math.max(ifRobedPrevious, ifDontRobedPrevious);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对于下一次循环来说相当于前一house抢</span></span><br><span class="line">            ifRobedPrevious = currentRobed;</span><br><span class="line">            <span class="comment">//对于下一次循环来说相当于前一house不抢</span></span><br><span class="line">            ifDontRobedPrevious = currentNotRobed;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(ifRobedPrevious, ifDontRobedPrevious);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="House_Robber_II">House Robber II</h2><h3 id="题目描述-1">题目描述</h3><p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<h3 id="解题思路及代码-1">解题思路及代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//房子首尾相连形成了一个圈，所以i间房子和i+1间房子只能有一间抢，或者两者都不抢</span></span><br><span class="line">    <span class="comment">//如果假设第i间不抢，则我们可以打断该圈，比如1-&gt;2-&gt;3-&gt;1则变成了2-&gt;3如果1不抢，</span></span><br><span class="line">    <span class="comment">//我们假设第i间房子不抢，剩下的房子组成的连续序列用House Robber的方法求解出最大值max1</span></span><br><span class="line">    <span class="comment">//然后假设第i+1间房子不抢，剩下的房子组成的连续序列用House Robber的方法求解出最大值max2，max1和max2的较大者即为所求</span></span><br><span class="line">    <span class="comment">//为了编程简单，我们选择i=n，i+1=0，也就是说我们把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后比较两个值取</span></span><br><span class="line">    <span class="comment">//取其中的最大值即为所求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(robHelper(nums, <span class="number">0</span>, nums.length-<span class="number">2</span>), robHelper(nums, <span class="number">1</span>, nums.length-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robHelper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> robedPrevious = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dontRobedPrevious = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> currentRobed = dontRobedPrevious + nums[i];</span><br><span class="line">            <span class="keyword">int</span> currentDontRobed = Math.max(robedPrevious, dontRobedPrevious);</span><br><span class="line">            </span><br><span class="line">            robedPrevious = currentRobed;</span><br><span class="line">            dontRobedPrevious = currentDontRobed;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(robedPrevious, dontRobedPrevious);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="House_Robber_III">House Robber III</h2><h3 id="题目描述-2">题目描述</h3><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>
<p><em>Example 1:</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> \   \ </span><br><span class="line">  <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.<br><em>Example 2:</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"> / \   \ </span><br><span class="line"><span class="number">1</span>   <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>
<h3 id="解题思路及代码-2">解题思路及代码</h3><ul>
<li>方法一</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//最优子结构：如果从想从当前二叉树中抢到最大的money，那么从子二叉树也是应该抢到最多的money</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    <span class="comment">//递归解法，会有很多重复子问题，效率低</span></span><br><span class="line">    <span class="comment">//max(抢root，不抢root) 即max(rob(root),rob(root.left)+rob(root.right))</span></span><br><span class="line">    <span class="keyword">public</span> int rob(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">      <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">      int val = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span>(root.<span class="keyword">left</span> != null)&#123;</span><br><span class="line">          val += rob(root.<span class="keyword">left</span>.<span class="keyword">left</span>)+rob(root.<span class="keyword">left</span>.<span class="keyword">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span>(root.<span class="keyword">right</span> != null)&#123;</span><br><span class="line">          val += rob(root.<span class="keyword">right</span>.<span class="keyword">left</span>)+rob(root.<span class="keyword">right</span>.<span class="keyword">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">return</span> <span class="type">Math</span>.<span class="built_in">max</span>(val+root.val, rob(root.<span class="keyword">left</span>)+rob(root.<span class="keyword">right</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//最优子结构：如果从想从当前二叉树中抢到最大的money，那么从子二叉树也是应该抢到最多的money</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="comment">//直接递归有很多重复子问题，可以利用带备忘的递归，使用HashMap记录访问过的子树的结果</span></span><br><span class="line">    <span class="keyword">public</span> int rob(<span class="type">TreeNode</span> root)&#123;</span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">TreeNode</span>, <span class="type">Integer</span>&gt; <span class="built_in">map</span> = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> robHelper(root, <span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> int robHelper(<span class="type">TreeNode</span> root, <span class="type">Map</span>&lt;<span class="type">TreeNode</span>, <span class="type">Integer</span>&gt; <span class="built_in">map</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果map中存在root对应的值，则不需要递归，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(root)) <span class="keyword">return</span> <span class="built_in">map</span>.<span class="keyword">get</span>(root);</span><br><span class="line">        </span><br><span class="line">        int val = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.<span class="keyword">left</span> != null)&#123;</span><br><span class="line">            val += robHelper(root.<span class="keyword">left</span>.<span class="keyword">left</span>, <span class="built_in">map</span>)+robHelper(root.<span class="keyword">left</span>.<span class="keyword">right</span>, <span class="built_in">map</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.<span class="keyword">right</span> != null)&#123;</span><br><span class="line">            val += robHelper(root.<span class="keyword">right</span>.<span class="keyword">left</span>, <span class="built_in">map</span>)+robHelper(root.<span class="keyword">right</span>.<span class="keyword">right</span>,<span class="built_in">map</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        val = <span class="type">Math</span>.<span class="built_in">max</span>(val+root.val, robHelper(root.<span class="keyword">left</span>, <span class="built_in">map</span>)+robHelper(root.<span class="keyword">right</span>,<span class="built_in">map</span>));</span><br><span class="line">        <span class="comment">//将root对应的max money存入map中</span></span><br><span class="line">        <span class="built_in">map</span>.put(root, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法三</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//最优子结构：如果从想从当前二叉树中抢到最大的money，那么从子二叉树也是应该抢到最多的money</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//方法三</span></span><br><span class="line">    <span class="comment">//重新定义rob(root)函数，返回值为含有两个元素的数组，第一个元素代表不抢root获得的最大money，</span></span><br><span class="line">    <span class="comment">//第二个元素代表抢root获得的最大money</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = robHelper(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] robHelper(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] left = robHelper(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = robHelper(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//不抢root，则left可抢其子root也可不抢其子root,right同理</span></span><br><span class="line">        res[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//抢root,则left和right不能抢其子root</span></span><br><span class="line">        res[<span class="number">1</span>] = root.val +  left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="House_Robber_I">House Robber I</h2><h3 id="题目描述">题目描述</h3><p>You are a professional robber planning to rob houses along a street. Ea]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://blog.noobsky.com/tags/Dynamic-Programming/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Convert Sorted Array/List to Binary Search Tree]]></title>
    <link href="http://blog.noobsky.com/2016/06/02/LeetCode-Convert-Sorted-Array-List-to-Binary-Search-Tree/"/>
    <id>http://blog.noobsky.com/2016/06/02/LeetCode-Convert-Sorted-Array-List-to-Binary-Search-Tree/</id>
    <published>2016-06-02T07:01:58.000Z</published>
    <updated>2016-06-02T15:16:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Convert_Sorted_Array_to_Binary_Search_Tree">Convert Sorted Array to Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="解题思路与代码">解题思路与代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意判断是否为start&gt;end,不然会发生数组越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="comment">//取中间节点作为树的root，可以保证是height balanced的BST</span></span><br><span class="line">        <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, start, mid-<span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Convert_Sorted_List_to_Binary_Search_Tree">Convert Sorted List to Binary Search Tree</h2><h3 id="题目描述-1">题目描述</h3><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="解题思路与代码-1">解题思路与代码</h3><p>方法一：O(nlogn) runtime, O(logn) stack space<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//类似Convert Sorted Array to BST，找出中间节点</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(nlgn),找中间节点为O(n),需要找lgn次</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="comment">//pre指向slow前一节点，记录slow前面是否有节点</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//找出单链表的中间节点,循环结束后slow指向单链表的中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pre != null意味着slow前面有节点，pre.next = null,head则为单链表的前半部分</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//pre == null 意味着slow前面没有节点</span></span><br><span class="line">        <span class="keyword">else</span> head = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        <span class="comment">//head指向单链表前半部分的头结点</span></span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        <span class="comment">//slow.next指向单链表后半部分的头结点</span></span><br><span class="line">        root.right = sortedListToBST(slow.<span class="keyword">next</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二：O(n) runtime, O(logn) stack space, Bottom-up recursion<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="keyword">list</span>;</span><br><span class="line">    <span class="comment">//感觉不好理解</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode sortedListToBST(ListNode head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">list</span> = head;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,size-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode helper(<span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        TreeNode left = helper(start, mid-<span class="number">1</span>);</span><br><span class="line">        TreeNode <span class="keyword">parent</span> = <span class="keyword">new</span> TreeNode(<span class="keyword">list</span>.val);</span><br><span class="line">        <span class="keyword">parent</span>.left = left;</span><br><span class="line">        <span class="keyword">list</span> = <span class="keyword">list</span>.next;</span><br><span class="line">        <span class="keyword">parent</span>.right = helper(mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Convert_Sorted_Array_to_Binary_Search_Tree">Convert Sorted Array to Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given an array ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="Tree" scheme="http://blog.noobsky.com/tags/Tree/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Unique Binary Search Trees I II]]></title>
    <link href="http://blog.noobsky.com/2016/05/31/LeetCode-Unique-Binary-Search-Trees/"/>
    <id>http://blog.noobsky.com/2016/05/31/LeetCode-Unique-Binary-Search-Trees/</id>
    <published>2016-05-31T07:18:22.000Z</published>
    <updated>2016-06-03T09:57:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Unique_Binary_Search_Trees_I">Unique Binary Search Trees I</h2><h3 id="题目描述">题目描述</h3><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>      <span class="number">2</span></span><br><span class="line"> /     /       \                 \</span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                 <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路">解题思路</h3><p>G(n): 序列长度为n的不同BST的数量<br>F(i, n): 1&lt;= i &lt;= n为根节点，序列为1到n的不同BST的数量<br>则G(n) = F(1,n) + F(2,n) + F(3,n) + …… + F(n,n)<br>F(i, n) = G(i-1)*G(n-i)<br>G(n) = G(0)(n-1) + G(1)G(n-2) + G(2)G(n-3)+……+G(n-1)G(0)</p>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] G = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">				G[i] += G[j-<span class="number">1</span>]*G[i-j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> G[n];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique_Binary_Search_Trees_II">Unique Binary Search Trees II</h2><h3 id="题目描述-1">题目描述</h3><p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For example,<br>Given n = 3, your program should return all 5 unique BST’s shown below.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>      <span class="number">2</span></span><br><span class="line"> /     /       \                 \</span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                 <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>代码如下：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode <span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode <span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; generateTrees(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) return <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        return genTreeList(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; genTreeList(<span class="built_in">int</span> start, <span class="built_in">int</span> <span class="keyword">end</span>)&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start &gt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            res.add(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = start; i &lt;= <span class="keyword">end</span>; i++)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftList = genTreeList(start, i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightList = genTreeList(i+<span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(TreeNode <span class="built_in">left</span> : leftList)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode <span class="built_in">right</span>: rightList)&#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.<span class="built_in">left</span> = <span class="built_in">left</span>;</span><br><span class="line">                    root.<span class="built_in">right</span> = <span class="built_in">right</span>;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Unique_Binary_Search_Trees_I">Unique Binary Search Trees I</h2><h3 id="题目描述">题目描述</h3><p>Given n, how many structurally unique BST’s]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Kth Smallest Element in a BST]]></title>
    <link href="http://blog.noobsky.com/2016/05/28/LeetCode-Kth-Smallest-Element-in-a-BST/"/>
    <id>http://blog.noobsky.com/2016/05/28/LeetCode-Kth-Smallest-Element-in-a-BST/</id>
    <published>2016-05-28T15:19:28.000Z</published>
    <updated>2016-05-31T07:19:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<p>Hint:</p>
<p>1.Try to utilize the property of a BST.<br>2.What if you could modify the BST node’s structure?<br>3.The optimal runtime complexity is O(height of BST).</p>
<p>代码如下：<br>方法一：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二叉搜索树，左儿子比根节点小，右儿子比根节点大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> kthSmallest(TreeNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//统计左子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = countNodes(root.left);</span><br><span class="line">        <span class="comment">//左子树的节点个数大于等于k，说明第k小的元素在左子树中，递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.left, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第k个元素在右子树中，相当于在右子树中寻找第k-count-1小的元素</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> &lt; k-<span class="number">1</span>) <span class="keyword">return</span> kthSmallest(root.right, k - <span class="keyword">count</span> -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//count = k-1,说明左子树有k-1个节点，跟该节点即为第k小的元素</span></span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计节点个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> countNodes(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">//使用中序遍历法，因为中序遍历二叉树是有序的</span></span><br><span class="line">    <span class="comment">//使用递归中序遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        count = k;</span><br><span class="line">        dfsHelper(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left != null) dfsHelper(root.left);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            number = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != null) dfsHelper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用迭代法中序遍历</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span>(curr != null || !<span class="built_in">stack</span>.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr != null)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = <span class="built_in">stack</span>.pop();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> curr.val;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>Note:<br>Y]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Odd Even Linked List]]></title>
    <link href="http://blog.noobsky.com/2016/05/28/LeetCode-Odd-Even-Linked-List/"/>
    <id>http://blog.noobsky.com/2016/05/28/LeetCode-Odd-Even-Linked-List/</id>
    <published>2016-05-28T09:37:55.000Z</published>
    <updated>2016-05-28T09:39:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>Example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,<br>return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.</p>
<p>Note:<br>The relative order inside both the even and odd groups should remain as it was in the input.<br>The first node is considered odd, the second node even and so on …</p>
<p>代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//最直观的做法就是将奇数节点放到一个链表，偶数节点放到另一个链接，然后将偶数节点的链表链接到奇数链表的尾部即可</span></span><br><span class="line">    <span class="keyword">public</span> ListNode oddEvenList(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//odd奇数,even偶数节点，evenHead</span></span><br><span class="line">        ListNode odd = head, even = head.<span class="keyword">next</span>, evenHead = even;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(even != <span class="keyword">null</span> &amp;&amp; even.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            odd.<span class="keyword">next</span> = even.<span class="keyword">next</span>;</span><br><span class="line">            odd = odd.<span class="keyword">next</span>;</span><br><span class="line">            </span><br><span class="line">            even.<span class="keyword">next</span> = odd.<span class="keyword">next</span>;</span><br><span class="line">            even = even.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        odd.<span class="keyword">next</span> = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talki]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximum Product of Word Lengths]]></title>
    <link href="http://blog.noobsky.com/2016/05/28/LeetCode-Maximum-Product-of-Word-Lengths/"/>
    <id>http://blog.noobsky.com/2016/05/28/LeetCode-Maximum-Product-of-Word-Lengths/</id>
    <published>2016-05-28T08:20:16.000Z</published>
    <updated>2016-05-28T09:38:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.</p>
<p>Example 1:<br>Given [“abcw”, “baz”, “foo”, “bar”, “xtfn”, “abcdef”]<br>Return 16<br>The two words can be “abcw”, “xtfn”.</p>
<p>Example 2:<br>Given [“a”, “ab”, “abc”, “d”, “cd”, “bcd”, “abcd”]<br>Return 4<br>The two words can be “ab”, “cd”.</p>
<p>Example 3:<br>Given [“a”, “aa”, “aaa”, “aaaa”]<br>Return 0<br>No such pair of words.</p>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//使用一个int来记录一个字符串中出现的字符，题目说只包含26个小写字母，一个int有32比特位，足够表示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words == null || words.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = words.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">//使用masks[i]记录words[i]含有的字符信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历words[i]的每个字符，masks[i]的最低比特位表示words[i]是否含有字符a(1表示含有</span></span><br><span class="line">            <span class="comment">//，0表示不含)，最高位表示是否含有字符z</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch: words[i].toCharArray())&#123;</span><br><span class="line">                masks[i] |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxProduct = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">                <span class="comment">//(masks[i] &amp; masks[j]) == 0表示两个word没有相同的字符</span></span><br><span class="line">                <span class="keyword">if</span>((masks[i] &amp; masks[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    maxProduct = Math.max(maxProduct, words[i].length()*words[j].length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者优化一下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个int来记录一个字符串中出现的字符，题目说只包含26个小写字母，一个int有32比特位，足够表示</span></span><br><span class="line"><span class="comment">//我们还可以先对words数组按字符串长度排序，后面就可以进行剪枝优化,排序为O(nlgn)，不影响O(n*n)的时间复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(words == null || words.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对words数组按字符串长度排序</span></span><br><span class="line">    Arrays.sort(words, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b.length() - a.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> length = words.length;</span><br><span class="line">    <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="comment">//使用masks[i]记录words[i]含有的字符信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="comment">//遍历words[i]的每个字符，masks[i]的最低比特位表示words[i]是否含有字符a(1表示含有</span></span><br><span class="line">        <span class="comment">//，0表示不含)，最高位表示是否含有字符z</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch: words[i].toCharArray())&#123;</span><br><span class="line">            masks[i] |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxProduct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="comment">//words[i].length() * words[i].length()是words[i]最大可能的maxProduct</span></span><br><span class="line">        <span class="keyword">if</span>(words[i].length() * words[i].length() &lt; maxProduct) <span class="keyword">break</span>; <span class="comment">//剪枝优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">            <span class="comment">//(masks[i] &amp; masks[j]) == 0表示两个word没有相同的字符</span></span><br><span class="line">            <span class="keyword">if</span>((masks[i] &amp; masks[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                maxProduct = Math.max(maxProduct, words[i].length()*words[j].length());</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//剪枝，越前面的字符串求到的maxProduct越大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxProduct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Integer Break]]></title>
    <link href="http://blog.noobsky.com/2016/05/28/LeetCode-Integer-Break/"/>
    <id>http://blog.noobsky.com/2016/05/28/LeetCode-Integer-Break/</id>
    <published>2016-05-28T04:36:50.000Z</published>
    <updated>2016-05-28T04:43:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.</p>
<p>For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p>
<p>Note: you may assume that n is not less than 2.</p>
<p>Hint:</p>
<p>There is a simple O(n) solution to this problem.<br>You may check the breaking results of n ranging from 7 to 10 to discover the regularities.</p>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//2 = 1+1,1</span></span><br><span class="line">    <span class="comment">//3 = 1+2,2</span></span><br><span class="line">    <span class="comment">//4 = 2+2,4</span></span><br><span class="line">    <span class="comment">//5 = 2+3,6</span></span><br><span class="line">    <span class="comment">//6 = 3+3,9</span></span><br><span class="line">    <span class="comment">//7 = 3+4,12</span></span><br><span class="line">    <span class="comment">//8 = 2+3+3,18</span></span><br><span class="line">    <span class="comment">//9 = 3+3+3,27</span></span><br><span class="line">    <span class="comment">//10 = 3+3+2+2,36</span></span><br><span class="line">    <span class="comment">//11 = 3*3*3*2</span></span><br><span class="line">    <span class="comment">//12 = 3*3*3*3</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            product *= <span class="number">3</span>;</span><br><span class="line">            n = n -<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        product *= n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[n] = max(max(i,dp[i])*max(n-i,dp[n-i])),i = <span class="number">1.</span>.n/<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j,dp[j])*Math.max(i-j,dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of th]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Missing Number]]></title>
    <link href="http://blog.noobsky.com/2016/05/28/LeetCode-Missing-Number/"/>
    <id>http://blog.noobsky.com/2016/05/28/LeetCode-Missing-Number/</id>
    <published>2016-05-28T03:34:43.000Z</published>
    <updated>2016-05-28T03:56:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>For example,<br>Given nums = [0, 1, 3] return 2.</p>
<p>Note:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<p>这道题给我们n个数字，是0到n之间的数但是有一个数字去掉了，让我们寻找这个数字，要求线性的时间复杂度和常数级的空间复杂度。</p>
<p>代码如下：<br>方法一：排序</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没说是按顺序来排的</span></span><br><span class="line">    <span class="comment">//最直观的方法：Arrays.sort时间复杂度为O(nlgn)</span></span><br><span class="line">    <span class="keyword">public</span> int missingNumber(int[] nums) &#123;</span><br><span class="line">        <span class="comment">//先排序就可以了</span></span><br><span class="line">        <span class="type">Arrays</span>.<span class="built_in">sort</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != nums[i]) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int missingNumber(int[] nums) &#123; <span class="comment">//binary search</span></span><br><span class="line">    	<span class="type">Arrays</span>.<span class="built_in">sort</span>(nums);</span><br><span class="line">    	int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length, mid= (<span class="keyword">left</span> + <span class="keyword">right</span>)/<span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="keyword">left</span>&lt;<span class="keyword">right</span>)&#123;</span><br><span class="line">        	mid = (<span class="keyword">left</span> + <span class="keyword">right</span>)/<span class="number">2</span>;</span><br><span class="line">        	<span class="keyword">if</span>(nums[mid]&gt;mid) <span class="keyword">right</span> = mid;</span><br><span class="line">        	<span class="keyword">else</span> <span class="keyword">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">left</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：异或</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//可以利用异或，异或有交换性质，除了一个missing number以外，每一个number都会存在一个下标跟这个number相等</span><br><span class="line">    //相等的数异或为<span class="number">0</span>，一个数跟<span class="number">0</span>异或为自己本身，所以我们只要遍历一遍数组，每次异或下标i和nums[i]</span><br><span class="line">    //[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]:<span class="number">0</span>^<span class="number">0</span>^<span class="number">1</span>^<span class="number">1</span>^<span class="number">2</span>^<span class="number">3</span></span><br><span class="line">    //<span class="number">2</span>^<span class="number">3</span> = <span class="number">10</span>^<span class="number">11</span> = <span class="number">1</span> 如何转换为最终结果<span class="number">2</span>，答案是再异或上nums.length,<span class="number">01</span>^<span class="number">11</span> = <span class="number">10</span> = <span class="number">2</span></span><br><span class="line">    //如果这种想法正确的话，我们很容易猜到最后要异或上数组的长度，比如特例[<span class="number">0</span>,<span class="number">1</span>],返回<span class="number">2</span>，就是<span class="number">0</span>异或nums.length</span><br><span class="line">    //如果不用这种特例来猜也是可以说明的</span><br><span class="line">    //分两种情况：第一种情况是数组所有的元素都有相应的下边对应，那么missing number为nums.length,而数组里的数异或为<span class="number">0</span>，则返回</span><br><span class="line">    //<span class="number">0</span> ^ nums.length = nums.length</span><br><span class="line">    //第二种情况是数组里不是所有的元素都有相应的下边对应，也就是missing number为nums中的某一个元素，这种情况下nums.length</span><br><span class="line">    //必为数组中的一个元素，比如[<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>]，假设下边i没有元素对应，则此时相当于i^nums.length^nums.length = i</span><br><span class="line">    public <span class="type">int</span> missingNumber(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="literal">result</span> = <span class="literal">result</span> ^ i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span> ^ nums.length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法三：求和</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> missingNumber(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">sum</span> = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">sum</span> += i - nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
