<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-07-13T10:27:03.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Largest Rectangle in Histogram]]></title>
    <link href="http://blog.noobsky.com/2016/07/13/LeetCode-Largest-Rectangle-in-Histogram/"/>
    <id>http://blog.noobsky.com/2016/07/13/LeetCode-Largest-Rectangle-in-Histogram/</id>
    <published>2016-07-13T10:24:06.000Z</published>
    <updated>2016-07-13T10:27:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br><img src="http://articles.leetcode.com/wp-content/uploads/2012/04/histogram.png" alt=""><br>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p>
<p><img src="http://www.leetcode.com/wp-content/uploads/2012/04/histogram_area.png" alt=""><br>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>For example,<br>Given heights = [2,1,5,6,2,3],<br>return 10.</p>
<h2 id="代码">代码</h2><p>思路参见<a href="http://www.geeksforgeeks.org/largest-rectangle-under-histogram/" target="_blank" rel="external">Largest Rectangular Area in a Histogram | Set 2</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//长方形的面积由组成的所以bar的最矮的bar决定</span></span><br><span class="line">    <span class="comment">//对于每一个bar我们计算该bar是矩形中最小的bar时矩形的面积</span></span><br><span class="line">    <span class="comment">//这些矩形面积中最大的即为所求</span></span><br><span class="line">    <span class="comment">//为了计算bar x为最小bar时矩形的面积，我们需要bar x左边更小的bar的下标和bar x右边更小的bar</span></span><br><span class="line">    <span class="comment">//我们用栈保存每个bar，当遇到一个更小的bar时，我们弹出栈顶的bar x，计算该bar为最小bar的矩形的面积</span></span><br><span class="line">    <span class="comment">//弹栈后栈顶的bar为bar x左边更小的bar，当前的bar的为bar x右边更小的bar</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="comment">//存bar对应的下标</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len;)&#123;</span><br><span class="line">            <span class="comment">//应该在heights的最后面加一个高度为0的bar</span></span><br><span class="line">            <span class="comment">//否则如果heights数组为递增时：1、2、3、4、5不会发生计算</span></span><br><span class="line">            <span class="keyword">int</span> h = (i == len) ? <span class="number">0</span> : heights[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当当前bar的高度大于栈顶bar的高度时，将当前bar压入栈中</span></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty() || h &gt;= heights[stack.peek()])&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tp = stack.pop();</span><br><span class="line">                <span class="comment">//计算以heights[tp]为最小bar的矩形的面积，并更新maxArea的值</span></span><br><span class="line">                maxArea = Math.max(maxArea, heights[tp] * (stack.isEmpty() ? i : i-<span class="number">1</span>-stack.peek()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]The Skyline Problem]]></title>
    <link href="http://blog.noobsky.com/2016/07/13/LeetCode-The-Skyline-Problem/"/>
    <id>http://blog.noobsky.com/2016/07/13/LeetCode-The-Skyline-Problem/</id>
    <published>2016-07-13T04:17:14.000Z</published>
    <updated>2016-07-13T06:53:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).</p>
<p><img src="https://leetcode.com/static/images/problemset/skyline1.jpg" alt=""><br><img src="https://leetcode.com/static/images/problemset/skyline2.jpg" alt=""></p>
<p>The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>
<p>For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .</p>
<p>The output is a list of “key points” (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], … ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>
<p>For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].</p>
<p>Notes:</p>
<ul>
<li>The number of buildings in any input list is guaranteed to be in the range [0, 10000].</li>
<li>The input list is already sorted in ascending order by the left x position Li.</li>
<li>The output list must be sorted by the x position.</li>
<li>There must be no consecutive horizontal lines of equal height in the output skyline. For instance, […[2 3], [4 5], [7 5], [11 5], [12 7]…] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: […[2 3], [4 5], [12 7], …]</li>
</ul>
<h2 id="代码">代码</h2><p>解题思路见以下博客<a href="https://briangordon.github.io/2014/08/the-skyline-problem.html" target="_blank" rel="external">The skyline problem</a>。最后作者的总结的方法为：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Our final solution, <span class="keyword">then</span>, <span class="operator">in</span> O(nlog⁡n) <span class="built_in">time</span>, is <span class="keyword">as</span> follows. First, <span class="built_in">sort</span> <span class="operator">the</span> critical</span><br><span class="line"></span><br><span class="line">points. Then scan across <span class="operator">the</span> critical points <span class="built_in">from</span> left <span class="built_in">to</span> <span class="constant">right</span>. When we encounter <span class="operator">the</span></span><br><span class="line"></span><br><span class="line">left edge <span class="operator">of</span> <span class="operator">a</span> rectangle, we <span class="built_in">add</span> that rectangle <span class="built_in">to</span> <span class="operator">the</span> heap <span class="operator">with</span> its height <span class="keyword">as</span> <span class="operator">the</span> key.</span><br><span class="line"></span><br><span class="line">When we encounter <span class="operator">the</span> <span class="constant">right</span> edge <span class="operator">of</span> <span class="operator">a</span> rectangle, we remove that rectangle <span class="built_in">from</span> <span class="operator">the</span> heap.</span><br><span class="line"></span><br><span class="line">(This requires keeping external pointers <span class="keyword">into</span> <span class="operator">the</span> heap.) Finally, <span class="keyword">any</span> <span class="built_in">time</span> we encounter <span class="operator">a</span></span><br><span class="line"></span><br><span class="line">critical point, <span class="keyword">after</span> updating <span class="operator">the</span> heap we <span class="built_in">set</span> <span class="operator">the</span> height <span class="operator">of</span> that critical point <span class="built_in">to</span> <span class="operator">the</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">value</span> peeked <span class="built_in">from</span> <span class="operator">the</span> top <span class="operator">of</span> <span class="operator">the</span> heap.</span><br></pre></td></tr></table></figure>
<p>关键点为矩形左边和右边顶点，即左上顶点和右上顶点。每个关键点的高度为涉及到的矩形的最大高度。我们使用最大堆保存这些关键点。当遇到矩形的左边界时，我们将该矩形加入到堆中（堆中元素为矩形的高度）；当遇到矩形的右边界时，我们将矩形从堆中移除。为了区分矩形的左边界和右边界，我们将左边界的左上顶点的高度取为矩形高度的相反数，将右边界上右上顶点的高度取为矩形高度。经过这样处理后，我们到达关键点后，涉及到的矩形即The skyline problem博客中说的active set of rectangle的高度都在堆中，关键点的高度为这些高度的最大值，即大顶堆的堆顶元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//矩形左上顶点表示为[Li, -Hi]，右上顶点表示为[Ri, Hi]</span></span><br><span class="line">        <span class="comment">//cp mean critical point</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; cps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] b : buildings)&#123;</span><br><span class="line">            cps.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;b[<span class="number">0</span>], -b[<span class="number">2</span>]&#125;);</span><br><span class="line">            cps.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;b[<span class="number">1</span>], b[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对critical point 排序</span></span><br><span class="line">        Collections.sort(cps, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">                <span class="comment">//纵坐标升序，左边界小于右边界，左边界在前面，正确</span></span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//横坐标升序</span></span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">                <span class="comment">//return b - a;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//防止pq为空时，int curr = pq.peek();发生空指针异常，</span></span><br><span class="line">        <span class="comment">//比如测试用例为只有一栋楼:[[0, 1, 3]]，该测试用例的结果应该为[[0,3],[1,0]]</span></span><br><span class="line">        <span class="comment">//本来优先级队列在为空时peek时返回null的，但是这里会有自动拆箱的过程将Integer转换为int，</span></span><br><span class="line">        <span class="comment">//如果Integer为null报空指针异常</span></span><br><span class="line">        pq.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//前一个最大高度</span></span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] cp : cps)&#123;</span><br><span class="line">            <span class="comment">//矩形的左边界，加入pq中</span></span><br><span class="line">            <span class="keyword">if</span>(cp[<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                pq.add(-cp[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//remove操作为O(lgn)</span></span><br><span class="line">                <span class="comment">//右边界，从pq中移除</span></span><br><span class="line">                pq.remove(cp[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前关键点涉及到的矩形的最大高度</span></span><br><span class="line">            <span class="keyword">int</span> curr = pq.peek();</span><br><span class="line">            <span class="comment">//参加注意事项最后一点</span></span><br><span class="line">            <span class="comment">//There must be no consecutive horizontal lines of equal height in the output skyline.</span></span><br><span class="line">            <span class="comment">//For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable;</span></span><br><span class="line">            <span class="comment">//the three lines of height 5 should be merged into one in the final output as such:</span></span><br><span class="line">            <span class="comment">//[...[2 3], [4 5], [12 7], ...]</span></span><br><span class="line">            <span class="keyword">if</span>(curr != prev)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cp[<span class="number">0</span>], curr&#125;);</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始还以为优先级队列remove(Object)的时间复杂度为O(lgn)，查了一下文档才发现是O(n)的，文档说明如下：</p>
<p>Implementation note: this implementation provides O(log(n)) time for the enqueing and dequeing methods (offer, poll, remove() and add); linear time for the remove(Object) and contains(Object) methods; and constant time for the retrieval methods (peek, element, and size).</p>
<p>详情见<a href="https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html" target="_blank" rel="external">PriorityQueue</a>。所以以上算法的时间复杂度为O(n^2)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Expression Add Operators]]></title>
    <link href="http://blog.noobsky.com/2016/07/13/LeetCode-Expression-Add-Operators/"/>
    <id>http://blog.noobsky.com/2016/07/13/LeetCode-Expression-Add-Operators/</id>
    <published>2016-07-13T02:41:12.000Z</published>
    <updated>2016-07-13T04:17:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.</p>
<p>Examples:<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"123"</span>, <span class="number">6</span> -&gt; [<span class="string">"1+2+3"</span>, <span class="string">"1*2*3"</span>]</span><br><span class="line"><span class="string">"232"</span>, <span class="number">8</span> -&gt; [<span class="string">"2*3+2"</span>, <span class="string">"2+3*2"</span>]</span><br><span class="line"><span class="string">"105"</span>, <span class="number">5</span> -&gt; [<span class="string">"1*0+5"</span>,<span class="string">"10-5"</span>]</span><br><span class="line"><span class="string">"00"</span>, <span class="number">0</span> -&gt; [<span class="string">"0+0"</span>, <span class="string">"0-0"</span>, <span class="string">"0*0"</span>]</span><br><span class="line"><span class="string">"3456237490"</span>, <span class="number">9191</span> -&gt; <span class="literal">[]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dfs</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addOperators</span><span class="params">(String num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用来保存dfs过程中形成的表达式</span></span><br><span class="line">        <span class="comment">//StringBuilder的append操作比字符串的"+"操作高效</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(res, sb, num, target, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//避免溢出，用long类型</span></span><br><span class="line">    <span class="comment">//0开头，长度不为1的数字无效，比如01</span></span><br><span class="line">    <span class="comment">//eval保存已经计算了的结果</span></span><br><span class="line">    <span class="comment">//还有一个很tricky的就是，需要保存当前新增的数，因为如果下一次递归是乘法，那么该数应该是与后面的数相乘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; res, StringBuilder sb, String num, <span class="keyword">int</span> target, <span class="keyword">int</span> pos, <span class="keyword">long</span> eval, <span class="keyword">long</span> multi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件，如果已经尝试到最后一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(pos == num.length())&#123;</span><br><span class="line">            <span class="comment">//如果表达式的计算结果跟target相等，加入结果集中</span></span><br><span class="line">            <span class="keyword">if</span>(eval == target) res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; num.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//以0开头的字符，只有0是有效的，其他长度大于1的都无效，直接break循环</span></span><br><span class="line">            <span class="keyword">if</span>(num.charAt(pos) == <span class="string">'0'</span> &amp;&amp; pos != i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">long</span> curr = Long.parseLong(num.substring(pos, i+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> len = sb.length();</span><br><span class="line">            <span class="comment">//第一个数字</span></span><br><span class="line">            <span class="keyword">if</span>(pos == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//递归调用</span></span><br><span class="line">                dfs(res, sb.append(curr), num, target, i+<span class="number">1</span>, curr, curr);</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                sb.setLength(len);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//尝试+、-、*</span></span><br><span class="line">                dfs(res, sb.append(<span class="string">"+"</span>).append(curr), num, target, i+<span class="number">1</span>, eval + curr, curr);</span><br><span class="line">                sb.setLength(len);</span><br><span class="line">                dfs(res, sb.append(<span class="string">"-"</span>).append(curr), num, target, i+<span class="number">1</span>, eval - curr, -curr);</span><br><span class="line">                sb.setLength(len);</span><br><span class="line">                <span class="comment">//乘法优先级比加减高，如果尝试乘法的化，eval中保存的上一个加入的数字(multi)应该跟这次的乘法相结合。</span></span><br><span class="line">                dfs(res, sb.append(<span class="string">"*"</span>).append(curr), num, target, i+<span class="number">1</span>, eval - multi + multi*curr, multi*curr);</span><br><span class="line">                sb.setLength(len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Russian Doll Envelopes]]></title>
    <link href="http://blog.noobsky.com/2016/07/13/LeetCode-Russian-Doll-Envelopes/"/>
    <id>http://blog.noobsky.com/2016/07/13/LeetCode-Russian-Doll-Envelopes/</id>
    <published>2016-07-12T16:09:46.000Z</published>
    <updated>2016-07-12T16:13:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>
<p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<p>Example:<br>Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</p>
<h2 id="代码">代码</h2><ol>
<li>Sort the array. Ascend on width and descend on height if width are same.</li>
<li>Find the <a href="http://noobsky.com/2016/06/07/LeetCode-Longest-Increasing-Subsequence/" target="_blank" rel="external">Longest Increasing Subsequence</a> based on height.</li>
</ol>
<ul>
<li>Since the width is increasing, we only need to consider height.</li>
<li>[3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] when sorting otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4]</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分两步</span></span><br><span class="line">    <span class="comment">//1. 信封按宽升序高降序排序</span></span><br><span class="line">    <span class="comment">//2. 对信封的高找最长递增子序列</span></span><br><span class="line">    <span class="comment">//因为信封的宽已经是升序，我们只要考虑信封的高就可以了</span></span><br><span class="line">    <span class="comment">//[3, 4]是装不下[3, 3]，所以我们需要将[3, 4]排在[3, 3]的前面，如果排序排成了[3,3] [3,4]会被当成递增序列，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span> || envelopes[<span class="number">0</span>].length != <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[<span class="number">0</span>] == arr2[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="comment">//高度降序</span></span><br><span class="line">                    <span class="keyword">return</span> arr2[<span class="number">1</span>] - arr1[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] envelope : envelopes)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(dp, <span class="number">0</span>, len, envelope[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                index = -(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[index] = envelope[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(index == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit in]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Recover Binary Search Tree]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Recover-Binary-Search-Tree/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Recover-Binary-Search-Tree/</id>
    <published>2016-07-12T15:08:56.000Z</published>
    <updated>2016-07-12T15:32:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Note:<br>A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">4</span></span><br><span class="line"> /    \</span><br><span class="line"><span class="number">2</span>      <span class="number">6</span></span><br><span class="line"> \    /  </span><br><span class="line">  <span class="number">3</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>错误交互后变成了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">4</span></span><br><span class="line"> /    \</span><br><span class="line"><span class="number">6</span>      <span class="number">2</span></span><br><span class="line"> \    /  </span><br><span class="line">  <span class="number">3</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>中序遍历会从2,3,4,5,6变成6,3,4,5,2，我们在中序遍历的过程中通过将当前节点的值跟下一个节点的值相比较，可以找出这两个发生了交换的节点。6 &gt; 3我们可以找到6是第一个发生交换的节点，2 &lt; 5我们可以找到第二个发生交换的节点。最后将这两个节点的值相互交互即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TreeNode firstNode = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode secondNode = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode prevNode = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="comment">//交换两个节点的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = firstNode.val;</span><br><span class="line">        firstNode.val = secondNode.val;</span><br><span class="line">        secondNode.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="comment">//找到了第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(firstNode == <span class="keyword">null</span> &amp;&amp; prevNode.val &gt;= root.val)&#123;</span><br><span class="line">            firstNode = prevNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了第二个节点</span></span><br><span class="line">        <span class="keyword">if</span>(firstNode != <span class="keyword">null</span> &amp;&amp; prevNode.val &gt;= root.val)&#123;</span><br><span class="line">            secondNode = root;</span><br><span class="line">        &#125;</span><br><span class="line">        prevNode = root;</span><br><span class="line"></span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n)，但空间复杂度因为有递归，需要栈空间O(lgn)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its st]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Scramble String]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Scramble-String/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Scramble-String/</id>
    <published>2016-07-12T14:30:07.000Z</published>
    <updated>2016-07-12T14:32:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of s1 = “great”:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    great</span><br><span class="line">   /    <span class="string">\</span></span><br><span class="line">  gr    eat</span><br><span class="line"> / <span class="string">\</span>    /  <span class="string">\</span></span><br><span class="line">g   r  e   at</span><br><span class="line">           / <span class="string">\</span></span><br><span class="line">          a   t</span><br></pre></td></tr></table></figure></p>
<p>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node “gr” and swap its two children, it produces a scrambled string “rgeat”.<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    rgeat</span><br><span class="line">   /    <span class="string">\</span></span><br><span class="line">  rg    eat</span><br><span class="line"> / <span class="string">\</span>    /  <span class="string">\</span></span><br><span class="line">r   g  e   at</span><br><span class="line">           / <span class="string">\</span></span><br><span class="line">          a   t</span><br></pre></td></tr></table></figure></p>
<p>We say that “rgeat” is a scrambled string of “great”.</p>
<p>Similarly, if we continue to swap the children of nodes “eat” and “at”, it produces a scrambled string “rgtae”.<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    rgtae</span><br><span class="line">   /    <span class="string">\</span></span><br><span class="line">  rg    tae</span><br><span class="line"> / <span class="string">\</span>    /  <span class="string">\</span></span><br><span class="line">r   g  ta  e</span><br><span class="line">       / <span class="string">\</span></span><br><span class="line">      t   a</span><br></pre></td></tr></table></figure></p>
<p>We say that “rgtae” is a scrambled string of “great”.<br>Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len1 != len2) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(len1 == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(s1.equals(s2)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//假设只有ASCII字符</span></span><br><span class="line">        <span class="keyword">int</span>[] letters = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个字符串的出现的字符以及每个字符出现的次数都要一样，否则为false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">            letters[s1.charAt(i)]++;</span><br><span class="line">            letters[s2.charAt(i)]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(letters[s1.charAt(i)] != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i从0开始，stackoverflow</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>, i), s2.substring(<span class="number">0</span>,i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>, i), s2.substring(len2 - i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(<span class="number">0</span>,len2-i))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Reverse Nodes in k-Group]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Reverse-Nodes-in-k-Group/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Reverse-Nodes-in-k-Group/</id>
    <published>2016-07-12T12:53:01.000Z</published>
    <updated>2016-07-12T14:30:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>
<p>Only constant memory is allowed.</p>
<p>For example,<br>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到第k+1个节点</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; count != k)&#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            curr = reverseKGroup(curr, k);</span><br><span class="line">            <span class="comment">//此时head为没有反转部分的头结点</span></span><br><span class="line">            <span class="comment">//curr是已经反转部分的头结点</span></span><br><span class="line">            <span class="comment">//我们需要将head为头结点的k个节点反转后，将curr指向的已经反转的部分链接到head反转后的后面</span></span><br><span class="line">            <span class="comment">//举个例子原始链表为1-&gt;2-&gt;3-&gt;4-&gt;5, k = 2</span></span><br><span class="line">            <span class="comment">//此时为1-&gt;2-&gt;4-&gt;3-&gt;5，此时head指向1，curr指向4，我们要变成2-&gt;1-&gt;4-&gt;3-&gt;5</span></span><br><span class="line">            <span class="comment">//k-- &gt; 0</span></span><br><span class="line">            <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//先保存head的下一个节点，下一轮迭代使用</span></span><br><span class="line">                ListNode temp = head.next;</span><br><span class="line">                head.next = curr;</span><br><span class="line">                curr = head;</span><br><span class="line">                head = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            head = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不足k个节点，返回</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>If the nu]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Serialize and Deserialize Binary Tree]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Serialize-and-Deserialize-Binary-Tree/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Serialize-and-Deserialize-Binary-Tree/</id>
    <published>2016-07-12T11:55:28.000Z</published>
    <updated>2016-07-12T11:56:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>For example, you may serialize the following tree<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>as “[1,2,3,null,null,4,5]”, just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.<br>Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SPLITER = <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAN = <span class="string">"##"</span>;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//采用先序遍历的方法，边遍历边序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode node, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NAN).append(SPLITER);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(node.val).append(SPLITER);</span><br><span class="line">            serialize(node.left, sb);</span><br><span class="line">            serialize(node.right, sb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        nodes.addAll(Arrays.asList(data.split(SPLITER)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">deserialize</span><span class="params">(Deque&lt;String&gt; nodes)</span></span>&#123;</span><br><span class="line">        String val = nodes.poll();</span><br><span class="line">        <span class="keyword">if</span>(val.equals(NAN)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(val));</span><br><span class="line">        node.left = deserialize(nodes);</span><br><span class="line">        node.right = deserialize(nodes);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be st]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Longest Increasing Path in a Matrix]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Longest-Increasing-Path-in-a-Matrix/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Longest-Increasing-Path-in-a-Matrix/</id>
    <published>2016-07-12T08:24:25.000Z</published>
    <updated>2016-07-12T08:26:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p>Example 1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Return 4<br>The longest increasing path is [1, 2, 6, 9].</p>
<p>Example 2:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Return 4<br>The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//四个搜索方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> len = dfs(matrix, i, j, row, col, cache);</span><br><span class="line">                max = Math.max(max, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度搜索从[i][j]出发的最长递增路径的长度</span></span><br><span class="line">    <span class="comment">//cache缓存，即备忘录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] cache)</span></span>&#123;</span><br><span class="line">        <span class="comment">//已经搜索过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(cache[i][j] != <span class="number">0</span>) <span class="keyword">return</span> cache[i][j];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//四个方向搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//matrix[x][y] &lt;= matrix[i][j]可以避免使用visited[row][col]数组</span></span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= row || y &lt; <span class="number">0</span> || y &gt;= col || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span> + dfs(matrix, x, y, row, col, cache);</span><br><span class="line">            max = Math.max(len, max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache[i][j] = max;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either mov]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Invalid Parentheses]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Remove-Invalid-Parentheses/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Remove-Invalid-Parentheses/</id>
    <published>2016-07-12T07:50:20.000Z</published>
    <updated>2016-07-12T07:52:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p>
<p>Note: The input string may contain letters other than the parentheses ( and ).</p>
<p>Examples:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"()())()"</span> -&gt; [<span class="string">"()()()"</span>, <span class="string">"(())()"</span>]</span><br><span class="line"><span class="string">"(a)())()"</span> -&gt; [<span class="string">"(a)()()"</span>, <span class="string">"(a())()"</span>]</span><br><span class="line"><span class="string">")("</span> -&gt; [<span class="string">""</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用BFS，我们通过溢出"("或者")"然后判断括号是否有效，如果是该层上有效的括号，加入到结果集中，不用继续往下一层搜索</span></span><br><span class="line">    <span class="comment">//如果是无效的加入到队列中，在BFS的下一层处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//s.length() == 0,应该有res.add("");</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来排除重复组合</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(s);</span><br><span class="line">        visited.add(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一旦BFS在某一层找到了有效的括号组合，就不用继续往下一层继续搜索了</span></span><br><span class="line">        <span class="comment">//因为题目要求移除最少括号</span></span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           String str = queue.poll();</span><br><span class="line">           <span class="keyword">if</span>(isValid(str))&#123;</span><br><span class="line">               res.add(str);</span><br><span class="line">               found = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//找到有效组合，不用继续往下一层搜索</span></span><br><span class="line">           <span class="keyword">if</span>(found) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">               <span class="comment">//只移除括号</span></span><br><span class="line">               <span class="keyword">if</span>(str.charAt(i) == <span class="string">'('</span> || str.charAt(i) == <span class="string">')'</span>)&#123;</span><br><span class="line">                   String temp = str.substring(<span class="number">0</span>, i) + str.substring(i+<span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">if</span>(!visited.contains(temp))&#123;</span><br><span class="line">                       queue.offer(temp);</span><br><span class="line">                       visited.add(temp);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'('</span>) count++;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible resu]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Longest Consecutive Sequence]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Longest-Consecutive-Sequence/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Longest-Consecutive-Sequence/</id>
    <published>2016-07-12T06:33:07.000Z</published>
    <updated>2016-07-12T07:51:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given [100, 4, 200, 1, 3, 2],<br>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最直接的想法是排序，然后遍历一遍找出最长的subarray，时间复杂度为O(nlgn)</span></span><br><span class="line">    <span class="comment">//一种比较tricky的方法就是使用HashMap，key为序列的边界元素（也有非边界但用不上），value为该元素当前所属的最长序列的长度</span></span><br><span class="line">    <span class="comment">//因为只有是序列的边界元素才有可能增加其他序列的长度</span></span><br><span class="line">    <span class="comment">//比如[100, 4, 200, 1, 3, 2]，map里有&lt;2, 4&gt;，&lt;1,4&gt;,&lt;4,1&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(num))&#123;</span><br><span class="line">                <span class="comment">//左边能扩展多长</span></span><br><span class="line">                <span class="keyword">int</span> left = map.containsKey(num - <span class="number">1</span>) ? map.get(num - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//右边能扩展多长</span></span><br><span class="line">                <span class="keyword">int</span> right = map.containsKey(num + <span class="number">1</span>) ? map.get(num + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> sum = left + right + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                res = Math.max(res, sum);</span><br><span class="line"></span><br><span class="line">                map.put(num, sum);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//扩展序列边界元素对应的序列长度</span></span><br><span class="line">                <span class="comment">//左边界为num - left</span></span><br><span class="line">                <span class="comment">//右边界为num + right</span></span><br><span class="line">                <span class="comment">//如果num没有相邻元素，left,right都为0，相当于没做什么：）</span></span><br><span class="line">                map.put(num - left, sum);</span><br><span class="line">                map.put(num + right, sum);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不写这个也是可以的：）</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用HashSet存取所有元素，判断一个元素是否是一个序列的开始，如果是，不断的扩展该序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//使用HashSet存取所有元素，判断一个元素是否是一个序列的开始，如果是，不断的扩展该序列</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">//没有左邻居说明，该元素是序列的起始元素</span></span><br><span class="line">        <span class="keyword">if</span>(!set.contains(nums[i] - <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(set.contains(temp))&#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = Math.max(res,temp - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For exam]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]N-Queens I II]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-N-Queens-I-II/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-N-Queens-I-II/</id>
    <published>2016-07-12T02:41:41.000Z</published>
    <updated>2016-07-12T03:36:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="N-Queens_I">N-Queens I</h2><h3 id="题目描述">题目描述</h3><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br><img src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png" alt=""><br>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p>For example,<br>There exist two distinct solutions to the 4-queens puzzle:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [<span class="string">".Q.."</span>,  // Solution <span class="number">1</span></span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  // Solution <span class="number">2</span></span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)</span><br><span class="line">            Arrays.fill(board[i], <span class="string">'.'</span>);</span><br><span class="line">        solveNQueens(res, board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一行来尝试放置皇后，每一行皇后尝试放置每一列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">char</span>[][] board, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">            res.add(construct(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于每一行，尝试每一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(board, row, i))&#123;</span><br><span class="line">                board[row][i] = <span class="string">'Q'</span>;</span><br><span class="line">                solveNQueens(res, board, row + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                board[row][i] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断皇后是否可以放到[row][col]位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为是逐行逐行搜索结果，只需要检查已经放置过皇后的行</span></span><br><span class="line">        <span class="comment">//所以x的终止条件为x&lt;row，y的终止条件却为n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; row; x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; board[<span class="number">0</span>].length; y++)&#123;</span><br><span class="line">                <span class="comment">//检查该列、45度对角线、135度对角线</span></span><br><span class="line">                <span class="comment">//45度对角线的方程为x+y == row + col</span></span><br><span class="line">                <span class="comment">//135度对角线为x + col = y + row</span></span><br><span class="line">                <span class="keyword">if</span>(board[x][y] == <span class="string">'Q'</span> &amp;&amp; (y == col || x + y == row + col || x + col == y + row))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">construct</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] rows: board)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(rows));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码还能优化，使用标记数组，不用每次搜索放置皇后是否有效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)</span><br><span class="line">            Arrays.fill(board[i], <span class="string">'.'</span>);</span><br><span class="line">        <span class="comment">//标记数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[] flagCol = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] d1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] d2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        solveNQueens(res, board, <span class="number">0</span>, flagCol, d1, d2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一行来尝试放置皇后，每一行皇后尝试放置每一列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">boolean</span>[] flagCol, <span class="keyword">boolean</span>[] d1, <span class="keyword">boolean</span>[] d2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">            res.add(construct(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于每一行，尝试每一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flagCol[i] &amp;&amp; !d1[row + i] &amp;&amp; !d2[board[<span class="number">0</span>].length-<span class="number">1</span>+i-row])&#123;</span><br><span class="line">                flagCol[i] = d1[row + i] = d2[board[<span class="number">0</span>].length-<span class="number">1</span>+i-row] = <span class="keyword">true</span>;</span><br><span class="line">                board[row][i] = <span class="string">'Q'</span>;</span><br><span class="line">                solveNQueens(res, board, row + <span class="number">1</span>, flagCol, d1, d2);</span><br><span class="line">                flagCol[i] = d1[row + i] = d2[board[<span class="number">0</span>].length-<span class="number">1</span>+i-row] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                board[row][i] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">construct</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] rows: board)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(rows));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="N-Queens_II">N-Queens II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for N-Queens problem.</p>
<p>Now, instead outputting board configurations, return the total number of distinct solutions.<br><img src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png" alt=""></p>
<h3 id="代码-1">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//也可以使用HashSet，但没啥必要，还偏慢</span></span><br><span class="line">    <span class="comment">//n列,作为全局变量是因为懒得传参数:)</span></span><br><span class="line">    <span class="keyword">boolean</span>[] cols;</span><br><span class="line">    <span class="comment">//2n - 1条45度对角线，row + col为其boolean中下标，对一对角线的row+col相等</span></span><br><span class="line">    <span class="keyword">boolean</span>[] d1;</span><br><span class="line">    <span class="comment">//2n - 1条135度对角线，n-1 + col - row</span></span><br><span class="line">    <span class="keyword">boolean</span>[] d2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cols = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        d1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line">        d2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line">        backtracking(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试每一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)&#123;</span><br><span class="line">            <span class="comment">//如果某该列、两条对角线已经有皇后则不能放</span></span><br><span class="line">            <span class="keyword">if</span>(cols[col] || d1[row + col] || d2[n - <span class="number">1</span> + col - row]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//放置皇后</span></span><br><span class="line">            cols[col] = d1[row+col] = d2[n-<span class="number">1</span>+col-row] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(row+<span class="number">1</span>, n);</span><br><span class="line">            cols[col] = d1[row+col] = d2[n-<span class="number">1</span>+col-row] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="N-Queens_I">N-Queens I</h2><h3 id="题目描述">题目描述</h3><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard suc]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Surrounded Regions]]></title>
    <link href="http://blog.noobsky.com/2016/07/11/LeetCode-Surrounded-Regions/"/>
    <id>http://blog.noobsky.com/2016/07/11/LeetCode-Surrounded-Regions/</id>
    <published>2016-07-11T13:54:57.000Z</published>
    <updated>2016-07-11T15:24:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>For example,<br><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O O <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> O <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O <span class="keyword">X</span> <span class="keyword">X</span></span><br></pre></td></tr></table></figure></p>
<p>After running your function, the board should be:<br><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O <span class="keyword">X</span> <span class="keyword">X</span></span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] unionSet;<span class="comment">//并查集</span></span><br><span class="line">    <span class="keyword">boolean</span>[] hasEdgeO;<span class="comment">//表示每个并查集在矩阵的边上是否有一个O</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        unionSet = <span class="keyword">new</span> <span class="keyword">int</span>[row * col];</span><br><span class="line">        hasEdgeO = <span class="keyword">new</span> <span class="keyword">boolean</span>[unionSet.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化并查集，每个字符都是一个并查集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unionSet.length; i++) unionSet[i] = i;</span><br><span class="line">        <span class="comment">//初始化hasEdgeO</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unionSet.length; i++)&#123;</span><br><span class="line">            <span class="comment">//计算在矩阵中的下标</span></span><br><span class="line">            <span class="keyword">int</span> x = i / col, y = i % col;</span><br><span class="line">            hasEdgeO[i] = board[x][y] == <span class="string">'O'</span> &amp;&amp; (x ==<span class="number">0</span> || x == row - <span class="number">1</span> || y == <span class="number">0</span> || y == col - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历矩阵，如果某个字符和它上边或右边的字符相等，合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unionSet.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i / col, y = i % col, up = x - <span class="number">1</span>, right = y + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt;= <span class="number">0</span> &amp;&amp; board[x][y] == board[up][y]) union(i, i - col);</span><br><span class="line">            <span class="keyword">if</span>(right &lt; col &amp;&amp; board[x][y] == board[x][right]) union(i, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于矩阵中的每个字符O，如果它所在的集合没有edge O，那么该集合的所有元素都应该设置为X</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unionSet.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i / col, y = i % col;</span><br><span class="line">            <span class="keyword">if</span>(board[x][y] == <span class="string">'O'</span> &amp;&amp; !hasEdgeO[findSet(i)])&#123;</span><br><span class="line">                board[x][y] = <span class="string">'X'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并集合，记得两个集合有hasEdgeO则合并后的集合也要标记为hasEdgeO</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = findSet(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = findSet(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> hasEdgeO = <span class="keyword">this</span>.hasEdgeO[rootX] || <span class="keyword">this</span>.hasEdgeO[rootY];</span><br><span class="line">        unionSet[rootX] = rootY;</span><br><span class="line">        <span class="keyword">this</span>.hasEdgeO[rootY] = hasEdgeO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找每个集合的根，即代表元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSet</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(unionSet[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">        unionSet[x] = findSet(unionSet[x]);</span><br><span class="line">        <span class="keyword">return</span> unionSet[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用BFS的方法，不被包围的O是跟边界上O相连的，其他的O都是被包围的，会变成X的。所有我们使用BFS将跟边界上的O相连的O都标记为A。标记完之后，再遍历一遍矩阵，将O（被X包围的）改为X，A还原为O（没有被包围）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="comment">//边界元素</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || i == row - <span class="number">1</span> || j == <span class="number">0</span> || j == col - <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                        board[i][j] = <span class="string">'A'</span>;</span><br><span class="line">                        bfs(board, i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'A'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(i * col + j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = q.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> x = cur / col;</span><br><span class="line">            <span class="keyword">int</span> y = cur % col;</span><br><span class="line">            <span class="comment">//右边</span></span><br><span class="line">            <span class="keyword">if</span>(y + <span class="number">1</span> &lt; col &amp;&amp; board[x][y+<span class="number">1</span>] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                q.add(cur + <span class="number">1</span>);</span><br><span class="line">                board[x][y+<span class="number">1</span>] = <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下边</span></span><br><span class="line">            <span class="keyword">if</span>(x + <span class="number">1</span> &lt; row &amp;&amp; board[x+<span class="number">1</span>][y] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                q.add(cur + col);</span><br><span class="line">                board[x+<span class="number">1</span>][y] = <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左边</span></span><br><span class="line">            <span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[x][y-<span class="number">1</span>] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                q.add(cur - <span class="number">1</span>);</span><br><span class="line">                board[x][y-<span class="number">1</span>] = <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上边</span></span><br><span class="line">            <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[x-<span class="number">1</span>][y] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                q.add(cur - col);</span><br><span class="line">                board[x-<span class="number">1</span>][y] = <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p>
<p>A region is ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Word Ladder I II]]></title>
    <link href="http://blog.noobsky.com/2016/07/11/LeetCode-Word-Ladder-I-II/"/>
    <id>http://blog.noobsky.com/2016/07/11/LeetCode-Word-Ladder-I-II/</id>
    <published>2016-07-11T07:19:39.000Z</published>
    <updated>2016-07-11T08:04:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Word_Ladder_I">Word Ladder I</h2><h3 id="题目描述">题目描述</h3><p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each intermediate word must exist in the word list</li>
</ol>
<p>For example,</p>
<p>Given:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
</ul>
<h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//图问题，如果将每个单词看做是顶点可以发现就是求是否有路径从begingWord可以到达endWord，BFS解决</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, Set&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以到达的顶点集合</span></span><br><span class="line">        Set&lt;String&gt; reached = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        reached.add(beginWord);</span><br><span class="line">        wordList.add(endWord);</span><br><span class="line">        <span class="comment">//其实本题这里是指节点个数，并不是路径长度</span></span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!reached.contains(endWord))&#123;</span><br><span class="line">            <span class="comment">//每次新增的可达节点</span></span><br><span class="line">            Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">//对reached中每个字符串的每个字符进行a-z 26个字符的变换，变换后的字符如果在字典中，说明可达，加入reached集合中</span></span><br><span class="line">            <span class="keyword">for</span>(String word : reached)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++)&#123;</span><br><span class="line">                        <span class="comment">//有好多种写法，或者toCharArray后更改下标i的字符为ch然后再构造新字符串</span></span><br><span class="line">                        StringBuilder sb = <span class="keyword">new</span> StringBuilder(word);</span><br><span class="line">                        sb.setCharAt(i, ch);</span><br><span class="line">                        String temp = sb.toString();</span><br><span class="line">                        <span class="keyword">if</span>(wordList.contains(temp))&#123;</span><br><span class="line">                            toAdd.add(temp);</span><br><span class="line">                            <span class="comment">//标记该节点已经访问过，这里直接从wordList中直接删除</span></span><br><span class="line">                            wordList.remove(temp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            distance++;</span><br><span class="line">            <span class="comment">//如果没有新的可达节点，说明endWord不可达，return 0</span></span><br><span class="line">            <span class="keyword">if</span>(toAdd.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//这样做是为了提高性能</span></span><br><span class="line">            reached = toAdd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, Set&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        wordList.add(endWord);</span><br><span class="line">        wordList.remove(beginWord);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                String str = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(str.equals(endWord))<span class="keyword">return</span> level;</span><br><span class="line">                <span class="keyword">for</span>(String neighbor : neighbors(str,wordList))&#123;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">neighbors</span><span class="params">(String s, Set&lt;String&gt; wordList)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> [] chars = s.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++)&#123;</span><br><span class="line">                chars[i] = ch;</span><br><span class="line">                String word = <span class="keyword">new</span> String(chars);</span><br><span class="line">                <span class="keyword">if</span>(wordList.remove(word))&#123;</span><br><span class="line">                    res.add(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Word_Ladder_II">Word Ladder II</h2><h3 id="题目描述-1">题目描述</h3><h3 id="代码-1">代码</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Word_Ladder_I">Word Ladder I</h2><h3 id="题目描述">题目描述</h3><p>Given two words (beginWord and endWord), and a dictionary’s word list, fi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Add and Search Word - Data structure design]]></title>
    <link href="http://blog.noobsky.com/2016/07/11/LeetCode-Add-and-Search-Word-Data-structure-design/"/>
    <id>http://blog.noobsky.com/2016/07/11/LeetCode-Add-and-Search-Word-Data-structure-design/</id>
    <published>2016-07-11T06:12:10.000Z</published>
    <updated>2016-07-11T06:20:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Design a data structure that supports the following two operations:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">addWord</span><span class="params">(word)</span></span></span><br><span class="line">bool <span class="function"><span class="title">search</span><span class="params">(word)</span></span></span><br></pre></td></tr></table></figure></p>
<p>search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p>
<p>For example:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"bad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"dad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"mad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"pad"</span>)</span></span> -&gt; false</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"bad"</span>)</span></span> -&gt; true</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">".ad"</span>)</span></span> -&gt; true</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"b.."</span>)</span></span> -&gt; true</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>You may assume that all words are consist of lowercase letters a-z.</p>
<h2 id="代码">代码</h2><p>直接使用前缀树（trie树）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isWord = <span class="keyword">false</span>;</span><br><span class="line">        TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="comment">// Adds a word into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : word.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) node.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line">    <span class="comment">// contain the dot character '.' to represent any one letter.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match(word, <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//match函数，看根节点为node的trie树是否匹配word.substring(index);</span></span><br><span class="line">    <span class="comment">//分为两种情况一种是.，我们要遍历node的所有子节点，若子节点不为空且沿着该子节点能匹配，则返回true，如果遍历了26个子节点</span></span><br><span class="line">    <span class="comment">//都不匹配，返回false</span></span><br><span class="line">    <span class="comment">//如果字符不为.，判断node的子节点是否存在该字符，存在则递归判断否则返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String word, <span class="keyword">int</span> index, TrieNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= word.length()) <span class="keyword">return</span> node.isWord;</span><br><span class="line">        <span class="keyword">char</span> ch = word.charAt(index);</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="comment">//如果children节点有不为空可以继续往下搜索</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node.children.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.children[i] != <span class="keyword">null</span> &amp;&amp; match(word, index+<span class="number">1</span>, node.children[i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.children[ch - <span class="string">'a'</span>] != <span class="keyword">null</span> &amp;&amp; match(word, index + <span class="number">1</span>, node.children[ch - <span class="string">'a'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// WordDictionary wordDictionary = new WordDictionary();</span></span><br><span class="line"><span class="comment">// wordDictionary.addWord("word");</span></span><br><span class="line"><span class="comment">// wordDictionary.search("pattern");</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Design a data structure that supports the following two operations:<br><figure class="highlight stylus"><table><tr]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Water and Jug Problem]]></title>
    <link href="http://blog.noobsky.com/2016/07/11/LeetCode-Water-and-Jug-Problem/"/>
    <id>http://blog.noobsky.com/2016/07/11/LeetCode-Water-and-Jug-Problem/</id>
    <published>2016-07-11T04:42:17.000Z</published>
    <updated>2016-07-11T05:36:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.</p>
<p>If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.</p>
<p>Operations allowed:</p>
<ul>
<li>Fill any of the jugs completely with water.</li>
<li>Empty any of the jugs.</li>
<li>Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.</li>
</ul>
<p><strong>Example 1:</strong> (From the famous “Die Hard” example)</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">x = 3, y = 5, z = 4</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="string">True</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">x = 2, y = 6, z = 5</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="string">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><p>这是一个数学问题，主要运用贝祖定理，贝祖定理见维基百科<a href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity" target="_blank" rel="external">Bézout’s identity</a>和百度百科<a href="http://baike.baidu.com/view/1008375.htm" target="_blank" rel="external">贝祖定理</a>。主要内容如下：</p>
<figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="keyword">and</span> b <span class="keyword">be</span> nonzero integers <span class="keyword">and</span> <span class="keyword">let</span> d <span class="keyword">be</span> their greatest common divisor. Then there exist integers x</span><br><span class="line"><span class="keyword">and</span> y <span class="keyword">such</span> <span class="keyword">that</span> ax+<span class="keyword">by</span>=d</span><br><span class="line"></span><br><span class="line">In addition, the greatest common divisor d <span class="keyword">is</span> the smallest positive integer <span class="keyword">that</span> can <span class="keyword">be</span> written <span class="keyword">as</span> ax + <span class="keyword">by</span></span><br><span class="line"></span><br><span class="line">every integer <span class="keyword">of</span> the form ax + <span class="keyword">by</span> <span class="keyword">is</span> a multiple <span class="keyword">of</span> the greatest common divisor d.</span><br></pre></td></tr></table></figure>
<p>也就是说整数a和b和它们的最大公约数d，对于任意的整数x，y，ax+by都一定是d的倍数。所以基本的算法为使用贝祖定理，检查z是否为x和y最大公约数的倍数。在本题中如果a或b是负数，意味着我们把x容量或y容量的水倒掉。如果a或b是正数，意味着我们每次将x容量或者y容量的杯子装满水。</p>
<p>比如x = 4，y = 6，z = 8<br>GCD(4, 6) = 2，8是2的倍数，所以该输入时有效的，因为有：<br>-1<em>4 + 6 </em> 2 = 8</p>
<p>说明我们获得该解可以通过将容量为6的杯子两次充满水，将容量为4的杯子中水倒掉一次。具体过程为，将容量为6的杯子装满水，然后倒进4升水到容量为4的杯子，然后将容量为4的杯子中的水倒掉，然后将容量为6的杯子剩下的2升水导入容量为4的杯子中。然后将容量为6的杯子装满水，即得到8升水。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果x+y &lt; z return false</span></span><br><span class="line">        <span class="comment">//z == 0这个条件不能去掉</span></span><br><span class="line">        <span class="comment">//因为我们要防止GCD(x,y)==0,会发生除0异常</span></span><br><span class="line">        <span class="comment">//要使得GCD(x,y)==0，只能是x = 0,y = 0</span></span><br><span class="line">        <span class="comment">//而条件x + y &gt;= z使得只剩下x = 0, y = 0，z=0这种情况</span></span><br><span class="line">        <span class="comment">//加上z == 0就可以过滤掉</span></span><br><span class="line">        <span class="keyword">return</span> z == <span class="number">0</span> || x + y &gt;= z &amp;&amp; z % GCD(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求最大公约数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = b;</span><br><span class="line">            b = a % b;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的测试用例好像比较弱，x + y没有发生溢出，如果要防止溢出的话可以用long类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//求最大公约数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = b;</span><br><span class="line">            b = a % b;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的测试用例好像比较弱，x + y没有发生溢出，如果要防止溢出的话可以用long类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果x+y &lt; z return false</span></span><br><span class="line">        <span class="comment">//z == 0这个条件不能去掉</span></span><br><span class="line">        <span class="comment">//因为我们要防止GCD(x,y)==0,会发生除0异常</span></span><br><span class="line">        <span class="comment">//要使得GCD(x,y)==0，只能是x = 0,y = 0</span></span><br><span class="line">        <span class="comment">//而条件x + y &gt;= z使得只剩下x = 0, y = 0，z=0这种情况</span></span><br><span class="line">        <span class="comment">//加上z == 0就可以过滤掉</span></span><br><span class="line">        <span class="keyword">return</span> z == <span class="number">0</span> || (<span class="keyword">long</span>)x + y &gt;= z &amp;&amp; z % GCD(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Simplify Path]]></title>
    <link href="http://blog.noobsky.com/2016/07/10/LeetCode-Simplify-Path/"/>
    <id>http://blog.noobsky.com/2016/07/10/LeetCode-Simplify-Path/</id>
    <published>2016-07-10T15:41:39.000Z</published>
    <updated>2016-07-10T15:45:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”</p>
<p><strong>Corner Cases:</strong></p>
<ul>
<li>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.</li>
<li>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.<br>In this case, you should ignore redundant slashes and return “/home/foo”.</li>
</ul>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//想法挺tricky的，遇到有效的文件名（不是"",".",".."）则压入栈中，遇到"..",弹出栈顶元素，因为".."代表上一层</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath1</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; skip = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">".."</span>, <span class="string">"."</span>,<span class="string">""</span>));</span><br><span class="line">        <span class="keyword">for</span>(String dir : path.split(<span class="string">"/"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">".."</span>.equals(dir) &amp;&amp; !stack.isEmpty()) stack.pop();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!skip.contains(dir)) stack.push(dir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String res = "";</span></span><br><span class="line">        <span class="comment">// for(String dir: stack)&#123;</span></span><br><span class="line">        <span class="comment">//     res = "/" + dir + res;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(stack.peekLast() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.append(<span class="string">"/"</span>);</span><br><span class="line">            res.append(stack.pollLast());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//return res.length() == 0 ? "/" : res;</span></span><br><span class="line">        <span class="keyword">return</span> res.length() == <span class="number">0</span> ? <span class="string">"/"</span> : res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集合也可以不使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//其实集合也可以不使用</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Set&lt;String&gt; skip = new HashSet&lt;&gt;(Arrays.asList("..", ".",""));</span></span><br><span class="line">    <span class="keyword">for</span>(String dir : path.split(<span class="string">"/"</span>))&#123;</span><br><span class="line">        <span class="comment">// if("..".equals(dir) &amp;&amp; !stack.isEmpty()) stack.pop();</span></span><br><span class="line">        <span class="comment">// else if(!skip.contains(dir)) stack.push(dir);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">".."</span>.equals(dir))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty()) stack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="string">""</span>.equals(dir) &amp;&amp; !<span class="string">"."</span>.equals(dir))&#123;</span><br><span class="line">            stack.push(dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(String dir: stack)&#123;</span><br><span class="line">        res = <span class="string">"/"</span> + dir + res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res.length() == <span class="number">0</span> ? <span class="string">"/"</span> : res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt; “/home”]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Design Twitter]]></title>
    <link href="http://blog.noobsky.com/2016/07/10/LeetCode-Design-Twitter/"/>
    <id>http://blog.noobsky.com/2016/07/10/LeetCode-Design-Twitter/</id>
    <published>2016-07-10T11:21:25.000Z</published>
    <updated>2016-07-10T11:24:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods:</p>
<pre><code><span class="number">1</span>. postTweet(userId, tweetId): Compose a new tweet.
<span class="number">2</span>. getNewsFeed(userId): Retrieve the <span class="number">10</span> most recent tweet ids <span class="operator">in</span> the user's news feed. Each item <span class="operator">in</span> the news feed must be posted by users who the <span class="keyword">user</span> <span class="title">followed</span> <span class="operator">or</span> by the <span class="keyword">user</span> <span class="title">herself</span>. Tweets must be ordered from most recent to least recent.
<span class="number">3</span>. follow(followerId, followeeId): Follower follows a followee.
<span class="number">4</span>. unfollow(followerId, followeeId): Follower unfollows a followee.
</code></pre><p><strong>Example:</strong><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Twitter twitter = new Twitter();</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span> posts a new tweet (id = <span class="number">5</span>).</span><br><span class="line">twitter.postTweet(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span>'s news feed should return a list with <span class="number">1</span> tweet id -&gt; [<span class="number">5</span>].</span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span> follows <span class="keyword">user</span> <span class="title">2</span>.</span><br><span class="line">twitter.follow(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">2</span> posts a new tweet (id = <span class="number">6</span>).</span><br><span class="line">twitter.postTweet(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span>'s news feed should return a list with <span class="number">2</span> tweet ids -&gt; [<span class="number">6</span>, <span class="number">5</span>].</span><br><span class="line">// Tweet id <span class="number">6</span> should precede tweet id <span class="number">5</span> because it is posted after tweet id <span class="number">5</span>.</span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span> unfollows <span class="keyword">user</span> <span class="title">2</span>.</span><br><span class="line">twitter.unfollow(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span>'s news feed should return a list with <span class="number">1</span> tweet id -&gt; [<span class="number">5</span>],</span><br><span class="line">// since <span class="keyword">user</span> <span class="title">1</span> is no longer following <span class="keyword">user</span> <span class="title">2</span>.</span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间戳，发推文的使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> timeStamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存用户，key为用户id，value为对应的user</span></span><br><span class="line">    <span class="comment">//用HashMap存，可以非常容易判断用户是否存在</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, User&gt; userMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//推文，推文使用单链表链接起来</span></span><br><span class="line">    <span class="comment">//当我们获取某个人的推文时可以快速获取到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span></span>&#123;</span><br><span class="line">        <span class="comment">//推文id</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="comment">//发表时间，用时间戳表示</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> time;</span><br><span class="line">        <span class="comment">//指向下一条推文</span></span><br><span class="line">        <span class="keyword">public</span> Tweet next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            time = timeStamp++;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="comment">//用户id</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户followed的用户集合</span></span><br><span class="line">        <span class="keyword">public</span> Set&lt;Integer&gt; followed;</span><br><span class="line">        <span class="comment">//用户发的推文</span></span><br><span class="line">        <span class="keyword">public</span> Tweet tweetHead;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            followed = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">//用户肯定第一个先Follow自己</span></span><br><span class="line">            follow(id);</span><br><span class="line"></span><br><span class="line">            tweetHead = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            followed.add(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            followed.remove(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            <span class="comment">//生成一条推文</span></span><br><span class="line">            Tweet tweet = <span class="keyword">new</span> Tweet(id);</span><br><span class="line">            <span class="comment">//每次发推文时，将推文插入到推文链表的头部</span></span><br><span class="line">            tweet.next = tweetHead;</span><br><span class="line">            tweetHead = tweet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(userId))&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User(userId);</span><br><span class="line">            userMap.put(userId, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userMap.get(userId).post(tweetId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(userId)) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取userId用户的followed的用户（包括自己）</span></span><br><span class="line">        Set&lt;Integer&gt; users = userMap.get(userId).followed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将推文加入</span></span><br><span class="line">        PriorityQueue&lt;Tweet&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(users.size(), <span class="keyword">new</span> Comparator&lt;Tweet&gt;()&#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tweet a, Tweet b)</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> b.time - a.time;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> user : users)&#123;</span><br><span class="line">            Tweet t = userMap.get(user).tweetHead;</span><br><span class="line">            <span class="keyword">if</span>(t != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.offer(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty() &amp;&amp; n &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            Tweet t = pq.poll();</span><br><span class="line">            res.add(t.id);</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">if</span>(t.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.add(t.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(followerId))&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User(followerId);</span><br><span class="line">            userMap.put(followerId, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(followeeId))&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User(followeeId);</span><br><span class="line">            userMap.put(followeeId, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userMap.get(followerId).follow(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(followerId) || followerId == followeeId)&#123;</span><br><span class="line">            <span class="keyword">return</span>;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userMap.get(followerId).unfollow(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your Twitter object will be instantiated and called as such:</span><br><span class="line"> * Twitter obj = new Twitter();</span><br><span class="line"> * obj.postTweet(userId,tweetId);</span><br><span class="line"> * List&lt;Integer&gt; param_2 = obj.getNewsFeed(userId);</span><br><span class="line"> * obj.follow(followerId,followeeId);</span><br><span class="line"> * obj.unfollow(followerId,followeeId);</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to se]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Multiply Strings]]></title>
    <link href="http://blog.noobsky.com/2016/07/09/LeetCode-Multiply-Strings/"/>
    <id>http://blog.noobsky.com/2016/07/09/LeetCode-Multiply-Strings/</id>
    <published>2016-07-09T14:44:07.000Z</published>
    <updated>2016-07-09T15:09:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The numbers can be arbitrarily large and are non-negative.</li>
<li>Converting the input string to integer is NOT allowed.</li>
<li>You should NOT use internal library such as BigInteger.</li>
</ul>
<h2 id="代码">代码</h2><p>规律是： <code>num1[i] * num2[j]</code> will be placed at indices <code>[i + j</code>, <code>i + j + 1]</code> ，如下图：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/multiply.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//num1[i]*num2[j]的乘积位于结果中的下标[i+j, i+j+1]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">        <span class="comment">//数的低位位于字符串的后面，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> mul = (num1.charAt(i) - <span class="string">'0'</span>) * (num2.charAt(j) - <span class="string">'0'</span>);</span><br><span class="line">                <span class="comment">//记得加上res[i+j+1]</span></span><br><span class="line">                <span class="keyword">int</span> sum = mul + res[i+j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                res[i+j+<span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//不要漏了res[i+j]本身的部分</span></span><br><span class="line">                <span class="comment">//因为有多个i和j的组合num1[i]和num2[j]乘积会有一部分位于res[i+j]</span></span><br><span class="line">                res[i+j] = res[i+j] + sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// int i = 0;</span></span><br><span class="line">        <span class="comment">// for(i = 0; i &lt; m+n; i++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(res[i] != 0) break;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// for(int j = i; j &lt; m+n; j++)&#123;</span></span><br><span class="line">        <span class="comment">//     sb.append(res[j]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return sb.length() == 0 ? "0" : sb.toString();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> digit : res)&#123;</span><br><span class="line">            <span class="comment">//sb.length() != 0 || digit != 0</span></span><br><span class="line">            <span class="keyword">if</span>(!(sb.length() == <span class="number">0</span> &amp;&amp; digit == <span class="number">0</span>)) sb.append(digit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">"0"</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p><strong>Note:</]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Basic Calculator I II III]]></title>
    <link href="http://blog.noobsky.com/2016/07/08/LeetCode-Basic-Calculator-I-II/"/>
    <id>http://blog.noobsky.com/2016/07/08/LeetCode-Basic-Calculator-I-II/</id>
    <published>2016-07-08T13:49:45.000Z</published>
    <updated>2016-07-09T12:31:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Basic_Calculator_I">Basic Calculator I</h2><h3 id="题目描述">题目描述</h3><p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1 + 1"</span> = <span class="number">2</span></span><br><span class="line"><span class="string">" 2-1 + 2 "</span> = <span class="number">3</span></span><br><span class="line"><span class="string">"(1+(4+5+2)-3)+(6+8)"</span> = <span class="number">23</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong> Do not use the eval built-in library function.</p>
<h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始结果</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始符号</span></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//如果是多位数字字符，转化为数值</span></span><br><span class="line">                <span class="comment">//这样写是对的，1+1这样才不会跳过+号</span></span><br><span class="line">                <span class="comment">//先判断再进入，才不会让i多加一次，详见后面III</span></span><br><span class="line">                <span class="keyword">while</span>(i + <span class="number">1</span> &lt; len &amp;&amp; Character.isDigit(s.charAt(i+<span class="number">1</span>)))&#123;</span><br><span class="line">                    sum = sum * <span class="number">10</span> + s.charAt(i+<span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将转化后的数值加入到结果中</span></span><br><span class="line">                result += sign * sum;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span>)&#123;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'-'</span>)&#123;</span><br><span class="line">                sign = -<span class="number">1</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="comment">//将左括号前面部分的计算结果压入栈中</span></span><br><span class="line">                stack.push(result);</span><br><span class="line">                <span class="comment">//将左括号前面的正负号压入栈中</span></span><br><span class="line">                stack.push(sign);</span><br><span class="line">                <span class="comment">//并重新初始化result和sign</span></span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="comment">//先从栈中弹出的是符号，接着是前面部分的结果</span></span><br><span class="line">                result = result * stack.pop() + stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的tricky之处在左括号和右括号的处理，下面说说个人理解。<br><code>s.charAt(i) == &#39;-&#39;</code>:</p>
<p>遇到(时将左括号之前计算的结果和符号(即左括号前的加减号，加号为1减号为-1)压入栈中，后面遇到右括号时再取出来合并。比如(1+(4+5+2)-3)+(6+8)，第一个左括号时，即1前面的左括号，将前面的计算结果和符号0和1压入栈中，此时相当于在前面加上0+，表达式变成0+(1+(4+5+2)-3)+(6+8)，不影响结果。当遇到第二个左括号时即4前面的左括号时，将该左括号前面表达式的计算结果1和符号1压入栈中，结合下面右括号的分析就能领会到程序的tricky之处了。</p>
<p><code>s.charAt(i) == &#39;)&#39;</code>:</p>
<p>当遇到右括号时，从栈中取出遇到与该右括号配对的左括号时压入的左括号前面部分计算结果和符号进行结果的合并。比如当我们遇到2后面的右括号，当前的计算结果result为4+5+2=11，此时我们取出与2后面的右括号配对的左括号即4前面的左括号压入栈中的结果和符号，即符号1和结果1（其中符号1代表4前面的左括号前面为加号），然后进行合并，即我们将当前的结果11乘以符号1加上前面的结果1，也即是11<em>1 + 1 = 12。同理我们再来分析一下3后面的右括号，此时的计算结果result=12-3=9，我们取出与3后面右括号配对的1前面的左括号压入栈中的结果0和符号1，然后进行合并，即result </em> stack.pop() + stack.pop();–&gt;9 * 1 + 0 = 9。</p>
<p>下面的思想类似，但是注意的地方比较多<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录字符的数字值</span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//保存结果</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//代表符号</span></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(ch))&#123;</span><br><span class="line">                number = number * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'+'</span>)&#123;</span><br><span class="line">                <span class="comment">//说明前面的数字已经完了，我们可以将number加到结果中去,开始新的number的计算</span></span><br><span class="line">                result += sign * number;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'-'</span>)&#123;</span><br><span class="line">                result += sign * number;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                sign = -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'('</span>)&#123;</span><br><span class="line">                stack.push(result);</span><br><span class="line">                stack.push(sign);</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="comment">//右括号也代表一个数字的结束</span></span><br><span class="line">                result += sign * number;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                result = result * stack.pop() + stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后要记得计算最后一个number</span></span><br><span class="line">        <span class="keyword">if</span>(number != <span class="number">0</span>) result += sign * number;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Basic_Calculator_II">Basic Calculator II</h2><h3 id="问题描述">问题描述</h3><p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"3+2*2"</span> = <span class="number">7</span></span><br><span class="line"><span class="string">" 3/2 "</span> = <span class="number">1</span></span><br><span class="line"><span class="string">" 3+5 / 2 "</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong> Do not use the eval built-in library function.</p>
<h3 id="代码-1">代码</h3><p>这里没有括号只有加减乘除和空格，除法舍弃掉小数部分。思路就是就是用一个符号sign表示每个number前面的符号，当我们在s中遇到一个符号时，说明数字部分已经结束，可以根据number前面的符号sign来对number进行计算了。比如如果number前面的符号为+，则将number压入栈中；如果前面的符号为-则将-number压入栈中；如果是*，则从栈中pop出一个元素和该number相乘后结果压入栈中；如果是/,则从栈中pop出一个元素和该number相除后将结果压入栈中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里没有括号只有加减乘除和空格，除法舍弃掉小数部分</span></span><br><span class="line">    <span class="comment">// 思路就是就是用一个符号sign表示每个number前面的符号，当我们在s中遇到一个符号时，说明数字部分已经结束</span></span><br><span class="line">    <span class="comment">// 可以根据number前面的符号sign来对number进行计算了，比如如果number前面的符号为+，则将number压入栈中；</span></span><br><span class="line">    <span class="comment">// 如果前面的符号为-则将-number压入栈中；如果是*，则从栈中pop出一个元素和该number相乘后结果压入栈中；如果是/,</span></span><br><span class="line">    <span class="comment">// 则从栈中pop出一个元素和该number相除后将结果压入栈中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化为+相当于在表达式前面增加了一个+号，不影响结果</span></span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(ch))&#123;</span><br><span class="line">                number = number * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是+、-、*、/</span></span><br><span class="line">            <span class="comment">//或者是最后一个字符，进入该if</span></span><br><span class="line">            <span class="comment">//说明number已经结束，可以根据number前面的符号进行运算了</span></span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(ch) &amp;&amp; <span class="string">' '</span> != ch || i == length -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//number前面为加号</span></span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'+'</span>)&#123;</span><br><span class="line">                    stack.push(number);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">'-'</span>)&#123;</span><br><span class="line">                    stack.push(-number);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    stack.push(stack.pop() * number);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">'/'</span>)&#123;</span><br><span class="line">                    stack.push(stack.pop() / number);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新当前遇到的符号为下一个number前面的符号</span></span><br><span class="line">                sign = ch;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : stack)&#123;</span><br><span class="line">            result += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Basic_Calculator_III">Basic Calculator III</h2><h3 id="题目描述-1">题目描述</h3><p>自己出的题：），结合I和II进行表达式求值，即有+、-、*、/、空格和括号。</p>
<h3 id="代码-2">代码</h3><ul>
<li>解法一</li>
</ul>
<p>先将中缀表达式转化为后缀表达式（逆波兰式），然后进行计算。可以参见<a href="http://www.cnblogs.com/yinger/archive/2011/07/01/2095500.html" target="_blank" rel="external">表达式求值</a>。但其实我们可以在中缀转后缀的过程中同时表达式的值。见下面的解法二。</p>
<ul>
<li>解法二</li>
</ul>
<p>利用Shunting-yard algorithm算法，详见维基百科<a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm" target="_blank" rel="external">Shunting-yard algorithm</a>和geeksforgeeks的<a href="http://www.geeksforgeeks.org/expression-evaluation/" target="_blank" rel="external">Expression Evaluation</a>，算法如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> While there are still tokens <span class="built_in">to</span> be <span class="built_in">read</span> <span class="operator">in</span>,</span><br><span class="line">   <span class="number">1.1</span> Get <span class="operator">the</span> next <span class="keyword">token</span>.</span><br><span class="line">   <span class="number">1.2</span> If <span class="operator">the</span> <span class="keyword">token</span> is:</span><br><span class="line">       <span class="number">1.2</span><span class="number">.1</span> A <span class="built_in">number</span>: push <span class="keyword">it</span> onto <span class="operator">the</span> <span class="built_in">value</span> stack.</span><br><span class="line">       <span class="number">1.2</span><span class="number">.2</span> A <span class="built_in">variable</span>: <span class="built_in">get</span> its <span class="built_in">value</span>, <span class="operator">and</span> push onto <span class="operator">the</span> <span class="built_in">value</span> stack.</span><br><span class="line">       <span class="number">1.2</span><span class="number">.3</span> A left parenthesis: push <span class="keyword">it</span> onto <span class="operator">the</span> operator stack.</span><br><span class="line">       <span class="number">1.2</span><span class="number">.4</span> A <span class="constant">right</span> parenthesis:</span><br><span class="line">         <span class="number">1</span> While <span class="operator">the</span> thing <span class="command"><span class="keyword">on</span> <span class="title">top</span> <span class="title">of</span> <span class="title">the</span> <span class="title">operator</span> <span class="title">stack</span> <span class="title">is</span> <span class="title">not</span> <span class="title">a</span></span></span><br><span class="line">           left parenthesis,</span><br><span class="line">             <span class="number">1</span> Pop <span class="operator">the</span> operator <span class="built_in">from</span> <span class="operator">the</span> operator stack.</span><br><span class="line">             <span class="number">2</span> Pop <span class="operator">the</span> <span class="built_in">value</span> stack twice, getting <span class="constant">two</span> operands.</span><br><span class="line">             <span class="number">3</span> Apply <span class="operator">the</span> operator <span class="built_in">to</span> <span class="operator">the</span> operands, <span class="operator">in</span> <span class="operator">the</span> correct order.</span><br><span class="line">             <span class="number">4</span> Push <span class="operator">the</span> <span class="built_in">result</span> onto <span class="operator">the</span> <span class="built_in">value</span> stack.</span><br><span class="line">         <span class="number">2</span> Pop <span class="operator">the</span> left parenthesis <span class="built_in">from</span> <span class="operator">the</span> operator stack, <span class="operator">and</span> discard <span class="keyword">it</span>.</span><br><span class="line">       <span class="number">1.2</span><span class="number">.5</span> An operator (call <span class="keyword">it</span> thisOp):</span><br><span class="line">         <span class="number">1</span> While <span class="operator">the</span> operator stack is <span class="operator">not</span> <span class="constant">empty</span>, <span class="operator">and</span> <span class="operator">the</span> top thing <span class="command"><span class="keyword">on</span> <span class="title">the</span></span></span><br><span class="line">           operator stack has <span class="operator">the</span> same <span class="operator">or</span> greater precedence <span class="keyword">as</span> thisOp,</span><br><span class="line">           <span class="number">1</span> Pop <span class="operator">the</span> operator <span class="built_in">from</span> <span class="operator">the</span> operator stack.</span><br><span class="line">           <span class="number">2</span> Pop <span class="operator">the</span> <span class="built_in">value</span> stack twice, getting <span class="constant">two</span> operands.</span><br><span class="line">           <span class="number">3</span> Apply <span class="operator">the</span> operator <span class="built_in">to</span> <span class="operator">the</span> operands, <span class="operator">in</span> <span class="operator">the</span> correct order.</span><br><span class="line">           <span class="number">4</span> Push <span class="operator">the</span> <span class="built_in">result</span> onto <span class="operator">the</span> <span class="built_in">value</span> stack.</span><br><span class="line">         <span class="number">2</span> Push thisOp onto <span class="operator">the</span> operator stack.</span><br><span class="line"><span class="number">2.</span> While <span class="operator">the</span> operator stack is <span class="operator">not</span> <span class="constant">empty</span>,</span><br><span class="line">    <span class="number">1</span> Pop <span class="operator">the</span> operator <span class="built_in">from</span> <span class="operator">the</span> operator stack.</span><br><span class="line">    <span class="number">2</span> Pop <span class="operator">the</span> <span class="built_in">value</span> stack twice, getting <span class="constant">two</span> operands.</span><br><span class="line">    <span class="number">3</span> Apply <span class="operator">the</span> operator <span class="built_in">to</span> <span class="operator">the</span> operands, <span class="operator">in</span> <span class="operator">the</span> correct order.</span><br><span class="line">    <span class="number">4</span> Push <span class="operator">the</span> <span class="built_in">result</span> onto <span class="operator">the</span> <span class="built_in">value</span> stack.</span><br><span class="line"><span class="number">3.</span> At this point <span class="operator">the</span> operator stack should be <span class="constant">empty</span>, <span class="operator">and</span> <span class="operator">the</span> <span class="built_in">value</span></span><br><span class="line">   stack should have only <span class="constant">one</span> <span class="built_in">value</span> <span class="operator">in</span> <span class="keyword">it</span>, which is <span class="operator">the</span> final <span class="built_in">result</span>.</span><br></pre></td></tr></table></figure>
<p>总结一下就是：</p>
<p>使用两个栈stack，一个存数字一个存操作符，如果是数字直接存到数字stack中；如果是操作符(+、-、*、/)，有以下几种情况：</p>
<ol>
<li>当前操作符比上一个操作符（即操作符栈栈顶符号）优先级高，比如*高于+，那么直接进栈</li>
<li>当前操作符优先级低于或者等于上一个，那么就要把所有在操作符栈中高于等于当前操作符的全部计算完，再将当前操作符压入栈中。</li>
<li>当前符号是”(“，直接压入操作符栈中</li>
<li>当前符号是”)”，就要把所有”)”之前和与它配对的”(“之后的操作符全部计算完。就是不断计算直到操作符栈顶为”(“，并把左括号出栈。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作数栈</span></span><br><span class="line">        Stack&lt;Integer&gt; values = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//操作符栈，栈中只会有+、-、*、/和(</span></span><br><span class="line">        Stack&lt;Character&gt; ops = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//ch &gt;= '0' &amp;&amp; ch &lt;= '9'</span></span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(ch))&#123;</span><br><span class="line">                <span class="comment">// int number = 0;</span></span><br><span class="line">                <span class="comment">// 用s.charAt(i)不容易出错</span></span><br><span class="line">                <span class="comment">// ！！！不能这样写，这样写的话比如1+1时，会跳过+号，相当于i++了多了一次</span></span><br><span class="line">                <span class="comment">// while(i &lt; length &amp;&amp; Character.isDigit(s.charAt(i)))&#123;</span></span><br><span class="line">                <span class="comment">//     number = number * 10 + s.charAt(i) - '0';</span></span><br><span class="line">                <span class="comment">//     i++;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="keyword">int</span> number = s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//这样写比如1+1时i+1 = 1时为+号不会进入while循环，i也就不会++，不会跳过+号</span></span><br><span class="line">                <span class="keyword">while</span>(i+<span class="number">1</span> &lt; length &amp;&amp; Character.isDigit(s.charAt(i+<span class="number">1</span>)))&#123;</span><br><span class="line">                    number = number * <span class="number">10</span> + s.charAt(i+<span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                values.push(number);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'('</span>)&#123;</span><br><span class="line">                ops.push(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="comment">//一直计算，直到操作符栈顶为左括号</span></span><br><span class="line">                <span class="comment">//就是将一对括号()中的运算算完</span></span><br><span class="line">                <span class="keyword">while</span> (ops.peek() != <span class="string">'('</span>)&#123;</span><br><span class="line">                    values.push(calc(ops.pop(), values.pop(), values.pop()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将栈顶中左括号弹栈</span></span><br><span class="line">                ops.pop();</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'+'</span> || ch == <span class="string">'-'</span> || ch == <span class="string">'*'</span> || ch == <span class="string">'/'</span>)&#123;</span><br><span class="line">                <span class="comment">//操作符栈不为空，且栈顶操作符的优先级大于等于当前的优先级</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.empty() &amp;&amp; hasPrecedence(ch , ops.peek()))&#123;</span><br><span class="line">                    values.push(calc(ops.pop(), values.pop(), values.pop()));</span><br><span class="line">                &#125;</span><br><span class="line">                ops.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//s已经解析完，继续计算ops中的操作符</span></span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty())&#123;</span><br><span class="line">            values.push(calc(ops.pop(), values.pop(), values.pop()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果操作符op2比操作符op1有更高或者相同的优先级返回true</span></span><br><span class="line">    <span class="comment">//否则返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPrecedence</span><span class="params">(<span class="keyword">char</span> op1, <span class="keyword">char</span> op2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意遇到括号也不用继续计算了</span></span><br><span class="line">        <span class="keyword">if</span>(op2 == <span class="string">'('</span> || op2 == <span class="string">')'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//op1有更高的优先级</span></span><br><span class="line">        <span class="keyword">if</span>((op1 == <span class="string">'*'</span> || op1 == <span class="string">'/'</span>) &amp;&amp; (op2 == <span class="string">'+'</span> || op2 == <span class="string">'-'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算a op b</span></span><br><span class="line">    <span class="comment">//b为第二操作数，先从栈中弹出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">char</span> op, <span class="keyword">int</span> b, <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                <span class="keyword">return</span> a - b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">return</span> a * b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"cannot divide by zero"</span>);</span><br><span class="line">                <span class="keyword">return</span> a / b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Basic_Calculator_I">Basic Calculator I</h2><h3 id="题目描述">题目描述</h3><p>Implement a basic calculator to evaluate a simple expression st]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
