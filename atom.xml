<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-11-06T03:59:02.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Hadoop权威指南之Hadoop分布式文件系统]]></title>
    <link href="http://blog.noobsky.com/2016/10/31/Hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E4%B9%8BHadoop%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.noobsky.com/2016/10/31/Hadoop权威指南之Hadoop分布式文件系统/</id>
    <published>2016-10-31T10:41:18.000Z</published>
    <updated>2016-11-06T03:59:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="HDFS的设计">HDFS的设计</h2><ul>
<li>超大文件</li>
<li>流式数据访问</li>
<li>商用硬件</li>
<li>低时间延迟的数据访问</li>
<li>大量的小文件</li>
<li>多用户写入，任意修改文件</li>
</ul>
<h2 id="HDFS的概念">HDFS的概念</h2><h3 id="数据块">数据块</h3><p>HDFS块（block）的大小默认问64MB。HDFS的块比磁盘的块（512B）大，其目的是为了最小化寻址开销。</p>
<h3 id="namenode和datanode">namenode和datanode</h3><p>HDFS集群有两类节点以管理者-工作者模式运行，即一个namenode（管理者）和多个datanode（工作者）。namenode管理文件系统的命名空间。维护着文件系统树及整棵树内所有的文件和目录。这些信息以两个文件形式永久保存在本地磁盘上：命名空间镜像文件和编辑日志文件。</p>
<p>datanode是文件系统的数据节点。它们根据需要存储并检索数据块，并且定期向namenode发送它们所存储的块的列表。</p>
<p>没有namenode节点，文件系统将无法使用。所以，namenode的容错非常重要。Hadoop提供了两种机制：</p>
<ul>
<li>备份那些组成文件系统元数据持久状态的文件</li>
<li>运行一个辅助namenode</li>
</ul>
<h3 id="联邦HDFS">联邦HDFS</h3><h3 id="HDFS的高可用性">HDFS的高可用性</h3><p>Hadoop2.x在HDFS中增加了对高可用性的支持。该实现中，配置一对活动-备用（active-standby）namenode。当活动namenode失效，备用namenode就会接管它的任务并开始服务来自客户端的请求，不会出现明显的中断。实现这一目标架构调整如下：</p>
<ul>
<li>namenode之间需要通过高可用的共享存储实现编辑日志的共享</li>
<li>datanode需要同时向两个namenode发送数据块处理报告</li>
<li>客户端需要使用特定的机制来处理namenode的失效问题，对用户透明</li>
</ul>
<p><strong>故障切换与规避</strong></p>
<h2 id="命令行接口">命令行接口</h2><p>offer选择，网易传媒和祖龙娱乐</p>
<p>网易传媒：java研发，25w<br>祖龙游戏：java游戏服务器，30w，呆满一年说还有10w奖金</p>
<p>祖龙游戏工资高，但是是java游戏服务器，出路窄吗？以后还能跳槽到互联网吗？网易传媒技术怎么样？现在主要考虑以后个人技术成长，还有跳槽的认可度。我应该选哪个？多谢大家。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="HDFS的设计">HDFS的设计</h2><ul>
<li>超大文件</li>
<li>流式数据访问</li>
<li>商用硬件</li>
<li>低时间延迟的数据访问</li>
<li>大量的小文件</li>
<li>多用户写入，任意修改文件</li>
</ul]]>
    </summary>
    
      <category term="HDFS" scheme="http://blog.noobsky.com/tags/HDFS/"/>
    
      <category term="Hadoop" scheme="http://blog.noobsky.com/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之Trie（前缀树）问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/17/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8BTrie%EF%BC%88%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%89%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/17/面试算法之Trie（前缀树）问题集锦/</id>
    <published>2016-10-16T16:34:17.000Z</published>
    <updated>2016-10-16T16:38:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Implement_Trie_(Prefix_Tree)">Implement Trie (Prefix Tree)</h2><p>Implement a trie with insert, search, and startsWith methods.</p>
<p>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示该TrieNode的节点是否代表是一个word的结束</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">    <span class="comment">// 本题假设输入只包含a-z的26个小写字母</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ws初始指向根节点</span></span><br><span class="line">        TrieNode ws = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="comment">//使用ch-'a'来计算children的位置</span></span><br><span class="line">            <span class="comment">//children的下标与它代表的字符是一一对应的</span></span><br><span class="line">            <span class="keyword">if</span>(ws.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                ws.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ws指向children节点，进入下一次循环</span></span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个节点代表一个word的结束</span></span><br><span class="line">        ws.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TrieNode ws = root;</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; word.length(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     char ch = word.charAt(i);</span></span><br><span class="line">        <span class="comment">//     if(ws.children[ch - 'a'] == null) return false;</span></span><br><span class="line">        <span class="comment">//     ws = ws.children[ch - 'a'];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return ws.isWord;</span></span><br><span class="line">        TrieNode ws = searchHelper(word);</span><br><span class="line">        <span class="keyword">return</span> ws != <span class="keyword">null</span> &amp;&amp; ws.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TrieNode ws = root;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; prefix.length(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     char ch = prefix.charAt(i);</span></span><br><span class="line">        <span class="comment">//     if(ws.children[ch - 'a'] == null) return false;</span></span><br><span class="line">        <span class="comment">//     ws = ws.children[ch - 'a'];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// //这里跟search不同，只要prefix的每个字符在Trie树上出现，就是true</span></span><br><span class="line">        <span class="comment">// //而search要求还要是一个word的结束才代表是一个word否则是一个prefix</span></span><br><span class="line">        <span class="comment">// //其实search和startsWith函数代码非常相似，可以进行进一步的封装，减少冗余</span></span><br><span class="line">        <span class="comment">// return true;</span></span><br><span class="line">        <span class="keyword">return</span> searchHelper(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">searchHelper</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        TrieNode ws = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length() &amp;&amp; ws != <span class="keyword">null</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = key.charAt(i);</span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ws;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Trie trie = new Trie();</span></span><br><span class="line"><span class="comment">// trie.insert("somestring");</span></span><br><span class="line"><span class="comment">// trie.search("key");</span></span><br></pre></td></tr></table></figure>
<h2 id="Add_and_Search_Word_-_Data_structure_design">Add and Search Word - Data structure design</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isWord = <span class="keyword">false</span>;</span><br><span class="line">        TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="comment">// Adds a word into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : word.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) node.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line">    <span class="comment">// contain the dot character '.' to represent any one letter.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match(word, <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//match函数，看根节点为node的trie树是否匹配word.substring(index);</span></span><br><span class="line">    <span class="comment">//分为两种情况一种是.，我们要遍历node的所有子节点，若子节点不为空且沿着该子节点能匹配，则返回true，如果遍历了26个子节点</span></span><br><span class="line">    <span class="comment">//都不匹配，返回false</span></span><br><span class="line">    <span class="comment">//如果字符不为.，判断node的子节点是否存在该字符，存在则递归判断否则返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String word, <span class="keyword">int</span> index, TrieNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= word.length()) <span class="keyword">return</span> node.isWord;</span><br><span class="line">        <span class="keyword">char</span> ch = word.charAt(index);</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="comment">//如果children节点有不为空可以继续往下搜索</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node.children.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.children[i] != <span class="keyword">null</span> &amp;&amp; match(word, index+<span class="number">1</span>, node.children[i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.children[ch - <span class="string">'a'</span>] != <span class="keyword">null</span> &amp;&amp; match(word, index + <span class="number">1</span>, node.children[ch - <span class="string">'a'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// WordDictionary wordDictionary = new WordDictionary();</span></span><br><span class="line"><span class="comment">// wordDictionary.addWord("word");</span></span><br><span class="line"><span class="comment">// wordDictionary.search("pattern");</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Implement_Trie_(Prefix_Tree)">Implement Trie (Prefix Tree)</h2><p>Implement a trie with insert, search, and startsWith methods.</p>
]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Minimum Window Substring]]></title>
    <link href="http://blog.noobsky.com/2016/10/16/LeetCode-Minimum-Window-Substring/"/>
    <id>http://blog.noobsky.com/2016/10/16/LeetCode-Minimum-Window-Substring/</id>
    <published>2016-10-16T15:54:36.000Z</published>
    <updated>2016-10-16T15:10:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>For example,<br>S = “ADOBECODEBANC”<br>T = “ABC”<br>Minimum window is “BANC”.</p>
<p>Note:<br>If there is no such window in S that covers all characters in T, return the empty string “”.</p>
<p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p>
<h2 id="代码">代码</h2><p>基本思想就是使用两个指针start和end来表示一个滑动窗口。将end指针往后移动，找到一个有效窗口，包含t中所有字符。当得到一个有效窗口后，将start指针往前移动缩小窗口来找到一个最小的窗口。当然start指针往前移动的过程中要保证窗口是有效，即要包含t中所有的字符，如果窗口无效时要继续讲end指针往前移动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本思想就是使用两个指针start和end来表示一个滑动窗口</span></span><br><span class="line">    <span class="comment">// 将end指针往后移动，找到一个有效窗口，包含t中所有字符</span></span><br><span class="line">    <span class="comment">// 当得到一个有效窗口后，将start指针往前移动缩小窗口来找到一个最小的窗口</span></span><br><span class="line">    <span class="comment">// 当然start指针往前移动的过程中要保证窗口是有效，即要包含t中所有的字符，如果窗口无效时要继续讲end指针往前移动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设只有ASCII字符</span></span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="comment">//统计t中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            map[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, counter = t.length();</span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE, minStart = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//如果s中字符也在t中，counter--</span></span><br><span class="line">            <span class="keyword">if</span>(map[s.charAt(end)] &gt; <span class="number">0</span>) counter--;</span><br><span class="line">            <span class="comment">//如果s中的该字符没在t中出现，map[s.charAt[end]]会变成负数</span></span><br><span class="line">            map[s.charAt(end)]--;</span><br><span class="line">            end++;</span><br><span class="line">            <span class="comment">//我们找到了一个有效的窗口，start-end，该窗口中字符包含了t中的所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(counter == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(end -start &lt; minLen)&#123;</span><br><span class="line">                    <span class="comment">//记录窗口的长度和开始位置</span></span><br><span class="line">                    minLen = end - start;</span><br><span class="line">                    minStart = start;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将start往前移动，缩小滑动窗口</span></span><br><span class="line">                map[s.charAt(start)]++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//说明该符号也是t中的元素</span></span><br><span class="line">                <span class="keyword">if</span>(map[s.charAt(start)] &gt; <span class="number">0</span>) counter++;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minLen != Integer.MAX_VALUE) <span class="keyword">return</span> s.substring(minStart, minStart + minLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里自己使用数组模拟了一个HashMap，也可以使用Java中的HashMap，但速度肯定变慢了：）。上面的代码还有更简洁的写法，但是可读性就没有那么好了：），先拿上来看看吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设只有ASCII字符</span></span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="comment">//统计t中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) map[t.charAt(i)]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, counter = t.length(), minLen = Integer.MAX_VALUE, minStart = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//如果s中字符也在t中，counter--</span></span><br><span class="line">            <span class="comment">//如果s中的该字符没在t中出现，map[s.charAt[end]]会变成负数</span></span><br><span class="line">            <span class="keyword">if</span>(map[s.charAt(end++)]-- &gt; <span class="number">0</span>) counter--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//我们找到了一个有效的窗口，start-end，该窗口中字符包含了t中的所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(counter == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(end -start &lt; minLen) minLen = end - (minStart = start);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将start往前移动，缩小滑动窗口</span></span><br><span class="line">                <span class="comment">//说明该符号也是t中的元素</span></span><br><span class="line">                <span class="keyword">if</span>(map[s.charAt(start++)]++ == <span class="number">0</span>) counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minLen != Integer.MAX_VALUE ? s.substring(minStart, minStart + minLen) : <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有个大神根据这个解法给出一个解决substring问题的模板：）。对于大多数substring问题，一般是给定一个字符串让我们查找满足一些限制条件的substring。一般的方法就是使用HashMap和两个指针。模板如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSubstring</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用数组模拟hashmap</span></span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">//用于检查窗口中substring是否有效</span></span><br><span class="line">    <span class="keyword">int</span> counter; <span class="comment">// check whether the substring is valid</span></span><br><span class="line">    <span class="comment">//两个指针，一个指向窗口头部，一个指向窗口尾部</span></span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;<span class="comment">//two pointers, one point to tail and one  head</span></span><br><span class="line">    <span class="comment">//子字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> d;<span class="comment">//the length of substring</span></span><br><span class="line">    <span class="comment">//用于初始化hashmap</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;<span class="comment">/* initialize the hash map here */</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">        <span class="comment">//满足条件时修改计数器</span></span><br><span class="line">        <span class="keyword">if</span>(map[s.charAt(end++)]-- ?)&#123; <span class="comment">/* modify counter here */</span> &#125;</span><br><span class="line">        <span class="comment">//当计算器满足条件时进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="comment">/* counter condition */</span>)&#123;</span><br><span class="line">            <span class="comment">//如果找到更小的值，更新d</span></span><br><span class="line">            <span class="comment">/* update d here if finding minimum*/</span></span><br><span class="line">            <span class="comment">//将begin指针往前移动使得窗口无效/有效</span></span><br><span class="line">            <span class="comment">//increase begin to make it invalid/valid again</span></span><br><span class="line">            <span class="comment">//修改计数器</span></span><br><span class="line">            <span class="keyword">if</span>(map[s.charAt(begin++)++ ?])&#123;<span class="comment">/*modify counter here*/</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update d here if finding maximum*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当要求查找的是最大substring，我们需要在内层while循环结束之后才更新最大值因为内层循环来保证substring是有效的。而如果是查找最小的substring，我们在内层while循环中更新最小值。</p>
<p>应用此模板解决Longest Substring with At Most Two Distinct Characters的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>, counter = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//没有出现过的字符，计算器加1</span></span><br><span class="line">            <span class="keyword">if</span>(map[s.charAt(end++)]++ == <span class="number">0</span>) counter++;</span><br><span class="line">            <span class="comment">//不同的字符大于两个，移动指针使窗口重新有效</span></span><br><span class="line">            <span class="comment">//如果begin指向的字符只出现了一次，移动begin指针后，有效字符减1</span></span><br><span class="line">            <span class="keyword">while</span>(counter &gt; <span class="number">2</span>) <span class="keyword">if</span>(map[s.charAt(begin++)]-- == <span class="number">1</span>) counter--;</span><br><span class="line">            d = Math.max(d, end - begin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>解决Longest Substring Without Repeating Characters的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>, counter = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.length()) &#123;</span><br><span class="line">            <span class="comment">//大于0说明出现重复字符</span></span><br><span class="line">            <span class="keyword">if</span> (map[s.charAt(end++)]++ &gt; <span class="number">0</span>) counter++;</span><br><span class="line">            <span class="keyword">while</span> (counter &gt; <span class="number">0</span>) <span class="keyword">if</span> (map[s.charAt(begin++)]-- &gt; <span class="number">1</span>) counter--;</span><br><span class="line">            d = Math.max(d, end - begin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in comple]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之Hard难度集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/16/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8BHard%E9%9A%BE%E5%BA%A6%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/16/面试算法之Hard难度集锦/</id>
    <published>2016-10-16T12:25:57.000Z</published>
    <updated>2016-10-18T16:02:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="N-Queens">N-Queens</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span></span><br><span class="line"><span class="comment">//         List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         char[][] board = new char[n][n];</span></span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; board.length; i++)</span></span><br><span class="line"><span class="comment">//             Arrays.fill(board[i], '.');</span></span><br><span class="line"><span class="comment">//         solveNQueens(res, board, 0);</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     //一行来尝试放置皇后，每一行皇后尝试放置每一列</span></span><br><span class="line"><span class="comment">//     public void solveNQueens(List&lt;List&lt;String&gt;&gt; res, char[][] board, int row)&#123;</span></span><br><span class="line"><span class="comment">//         if(row == board.length)&#123;</span></span><br><span class="line"><span class="comment">//             res.add(construct(board));</span></span><br><span class="line"><span class="comment">//             return;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         //对于每一行，尝试每一列</span></span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; board[0].length; i++)&#123;</span></span><br><span class="line"><span class="comment">//             if(isValid(board, row, i))&#123;</span></span><br><span class="line"><span class="comment">//                 board[row][i] = 'Q';</span></span><br><span class="line"><span class="comment">//                 solveNQueens(res, board, row + 1);</span></span><br><span class="line"><span class="comment">//                 //回溯</span></span><br><span class="line"><span class="comment">//                 board[row][i] = '.';</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     //判断皇后是否可以放到[row][col]位置</span></span><br><span class="line"><span class="comment">//     public boolean isValid(char[][] board, int row, int col)&#123;</span></span><br><span class="line"><span class="comment">//         //因为是逐行逐行搜索结果，只需要检查已经放置过皇后的行</span></span><br><span class="line"><span class="comment">//         //所以x的终止条件为x&lt;row，y的终止条件却为n</span></span><br><span class="line"><span class="comment">//         for(int x = 0; x &lt; row; x++)&#123;</span></span><br><span class="line"><span class="comment">//             for(int y = 0; y &lt; board[0].length; y++)&#123;</span></span><br><span class="line"><span class="comment">//                 //检查该列、45度对角线、135度对角线</span></span><br><span class="line"><span class="comment">//                 //45度对角线的方程为x+y == row + col</span></span><br><span class="line"><span class="comment">//                 //135度对角线为x + col = y + row</span></span><br><span class="line"><span class="comment">//                 if(board[x][y] == 'Q' &amp;&amp; (y == col || x + y == row + col || x + col == y + row))</span></span><br><span class="line"><span class="comment">//                     return false;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         return true;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     private List&lt;String&gt; construct(char[][] board)&#123;</span></span><br><span class="line"><span class="comment">//         List&lt;String&gt; res = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         for(char[] rows: board)&#123;</span></span><br><span class="line"><span class="comment">//             res.add(new String(rows));</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)</span><br><span class="line">            Arrays.fill(board[i], <span class="string">'.'</span>);</span><br><span class="line">        <span class="comment">//标记数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[] flagCol = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] d1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] d2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        solveNQueens(res, board, <span class="number">0</span>, flagCol, d1, d2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一行来尝试放置皇后，每一行皇后尝试放置每一列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">boolean</span>[] flagCol, <span class="keyword">boolean</span>[] d1, <span class="keyword">boolean</span>[] d2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">            res.add(construct(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于每一行，尝试每一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flagCol[i] &amp;&amp; !d1[row + i] &amp;&amp; !d2[board[<span class="number">0</span>].length-<span class="number">1</span>+i-row])&#123;</span><br><span class="line">                flagCol[i] = d1[row + i] = d2[board[<span class="number">0</span>].length-<span class="number">1</span>+i-row] = <span class="keyword">true</span>;</span><br><span class="line">                board[row][i] = <span class="string">'Q'</span>;</span><br><span class="line">                solveNQueens(res, board, row + <span class="number">1</span>, flagCol, d1, d2);</span><br><span class="line">                flagCol[i] = d1[row + i] = d2[board[<span class="number">0</span>].length-<span class="number">1</span>+i-row] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                board[row][i] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">construct</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] rows: board)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(rows));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="N-Queens_II">N-Queens II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//也可以使用HashSet，但没啥必要，还偏慢</span></span><br><span class="line">    <span class="comment">//n列,作为全局变量是因为懒得传参数:)</span></span><br><span class="line">    <span class="keyword">boolean</span>[] cols;</span><br><span class="line">    <span class="comment">//2n - 1条45度对角线，row + col为其boolean中下标，对一对角线的row+col相等</span></span><br><span class="line">    <span class="keyword">boolean</span>[] d1;</span><br><span class="line">    <span class="comment">//2n - 1条135度对角线，n-1 + col - row</span></span><br><span class="line">    <span class="keyword">boolean</span>[] d2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cols = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        d1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line">        d2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line">        backtracking(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试每一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)&#123;</span><br><span class="line">            <span class="comment">//如果某该列、两条对角线已经有皇后则不能放</span></span><br><span class="line">            <span class="keyword">if</span>(cols[col] || d1[row + col] || d2[n - <span class="number">1</span> + col - row]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//放置皇后</span></span><br><span class="line">            cols[col] = d1[row+col] = d2[n-<span class="number">1</span>+col-row] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(row+<span class="number">1</span>, n);</span><br><span class="line">            cols[col] = d1[row+col] = d2[n-<span class="number">1</span>+col-row] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove_Duplicate_Letters">Remove Duplicate Letters</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public String removeDuplicateLetters(String s) &#123;</span></span><br><span class="line">    <span class="comment">//     int[] cnt = new int[26];</span></span><br><span class="line">    <span class="comment">//     int pos = 0; // the position for the smallest s[i]</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; s.length(); i++) cnt[s.charAt(i) - 'a']++;</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; s.length(); i++) &#123;</span></span><br><span class="line">    <span class="comment">//         if (s.charAt(i) &lt; s.charAt(pos)) pos = i;</span></span><br><span class="line">    <span class="comment">//         if (--cnt[s.charAt(i) - 'a'] == 0) break;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return s.length() == 0 ? "" : s.charAt(pos) + removeDuplicateLetters(s.substring(pos + 1).replaceAll("" + s.charAt(pos), ""));</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间复杂度为O(kn)，k为唯一字符的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)  count[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="comment">//题目要求字典序最小，如何贪心选择s[pos]</span></span><br><span class="line">        <span class="comment">//选择左边最小的字符，并且保证s[i...length]包含所有唯一的字符，</span></span><br><span class="line">        <span class="comment">//break条件是遇到词频最小的字符</span></span><br><span class="line">        <span class="comment">//贪心选择：假设词频最小的字符为s[i],那么贪心选择s[0...i]中最小的字符</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &lt; s.charAt(pos)) pos = i;</span><br><span class="line">            <span class="comment">//找到唯一字符或者词频最小的字符，循环终止</span></span><br><span class="line">            <span class="keyword">if</span>(--count[s.charAt(i) - <span class="string">'a'</span>] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//贪心选择后s.charAt(pos),如何构造新字符串</span></span><br><span class="line">        <span class="comment">//抛弃s[pos]左边的字符，移除s[pos+1...length]中为s[pos]的字符</span></span><br><span class="line">        <span class="keyword">return</span> s.length() == <span class="number">0</span> ? <span class="string">""</span> : s.charAt(pos) + removeDuplicateLetters(s.substring(pos+<span class="number">1</span>).replaceAll(<span class="string">""</span>+s.charAt(pos), <span class="string">""</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间复杂度为O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) freq[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录字符是否在栈中</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line"></span><br><span class="line">            freq[ch - <span class="string">'a'</span>]--;</span><br><span class="line">            <span class="comment">//已在栈中</span></span><br><span class="line">            <span class="keyword">if</span>(visited[ch-<span class="string">'a'</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//栈顶字符字符比当前字符大而且后面还有该字符，弹栈</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; ch &amp;&amp; freq[stack.peek() - <span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//弹栈并且设置为不在栈中false</span></span><br><span class="line">                visited[stack.pop() - <span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            stack.push(ch);</span><br><span class="line">            visited[ch - <span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//这样遍历栈相当于把栈逆过来：），意外发现</span></span><br><span class="line">        <span class="comment">// for(char ch : stack)&#123;</span></span><br><span class="line">        <span class="comment">//     sb.append(ch);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//return sb.toString();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LRU_Cache">LRU Cache</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span></span>&#123;</span><br><span class="line">  <span class="comment">//双向链表</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node pre;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">  <span class="comment">//容量和计算器</span></span><br><span class="line">  <span class="keyword">int</span> capacity, count;</span><br><span class="line"></span><br><span class="line">  Node head, tail;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//双向链表</span></span><br><span class="line">    head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.pre = head;</span><br><span class="line">    head.pre = <span class="keyword">null</span>;</span><br><span class="line">    tail.next = <span class="keyword">null</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//双向链表中删除一个节点</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    node.pre.next = node.next;</span><br><span class="line">    node.next.pre = node.pre;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将一个节点加到双向链表的头部</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    node.next = head.next;</span><br><span class="line">    head.next.pre = node;</span><br><span class="line"></span><br><span class="line">    node.pre = head;</span><br><span class="line">    head.next = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    Node node = map.get(key);</span><br><span class="line">    <span class="comment">//key已经存在，更新value，并将节点移到双链表的头部</span></span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">      node.value = value;</span><br><span class="line">      <span class="comment">//将该节点移到头部</span></span><br><span class="line">      deleteNode(node);</span><br><span class="line">      addToHead(node);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">      map.put(key, node);</span><br><span class="line"></span><br><span class="line">      addToHead(node);</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">if</span>(count &gt; capacity)&#123;</span><br><span class="line">        map.remove(tail.pre.key);</span><br><span class="line">        deleteNode(tail.pre);</span><br><span class="line">        count--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    Node node = map.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">      deleteNode(node);</span><br><span class="line">      addToHead(node);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sliding_Window_Maximum">Sliding Window Maximum</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//维护一个最大堆，并维护堆的大小为k即窗口大小，则堆顶元素即为每个滑动窗口的最大值</span></span><br><span class="line">    <span class="comment">// public int[] maxSlidingWindow(int[] nums, int k) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0 || k &lt;= 0) return new int[0];</span></span><br><span class="line">    <span class="comment">//     //Collections.reverseOrder()返回一个逆序的Comparator，则构建一个最大堆</span></span><br><span class="line">    <span class="comment">//     //Arrays.sort(arr, Collections.reverseOrder())</span></span><br><span class="line">    <span class="comment">//     PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span></span><br><span class="line">    <span class="comment">//     int[] res = new int[nums.length - k + 1];</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         //滑动窗口大小已经为k，删除窗口最左边的元素，为下一个元素腾空间</span></span><br><span class="line">    <span class="comment">//         if(i &gt;= k) pq.remove(nums[i-k]);</span></span><br><span class="line">    <span class="comment">//         pq.offer(nums[i]);</span></span><br><span class="line">    <span class="comment">//         //窗口大小已经为k</span></span><br><span class="line">    <span class="comment">//         if(i - k + 1 &gt;= 0) res[i-k+1] = pq.peek();</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用双端队列存元素在数组中的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//nums.length - k + 1个滑动窗口</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="comment">//dq.peek() == i-k</span></span><br><span class="line">            <span class="keyword">if</span>(!dq.isEmpty() &amp;&amp; dq.peek() &lt; i - k + <span class="number">1</span>)&#123;</span><br><span class="line">                dq.poll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//我们将nums[i]加入队尾之前，如果队列中元素小于nums[i]，则可以删除，因为他们不可能是滑动窗口的最大值</span></span><br><span class="line">            <span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt; nums[i])&#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dq.offer(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) res[i-k+<span class="number">1</span>] = nums[dq.peek()];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Minimum_Window_Substring">Minimum Window Substring</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本思想就是使用两个指针start和end来表示一个滑动窗口</span></span><br><span class="line">    <span class="comment">// 将end指针往后移动，找到一个有效窗口，包含t中所有字符</span></span><br><span class="line">    <span class="comment">// 当得到一个有效窗口后，将start指针往前移动缩小窗口来找到一个最小的窗口</span></span><br><span class="line">    <span class="comment">// 当然start指针往前移动的过程中要保证窗口是有效，即要包含t中所有的字符，如果窗口无效时要继续讲end指针往前移动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow1</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设只有ASCII字符</span></span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="comment">//统计t中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            map[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, counter = t.length();</span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE, minStart = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//如果s中字符也在t中，counter--</span></span><br><span class="line">            <span class="keyword">if</span>(map[s.charAt(end)] &gt; <span class="number">0</span>) counter--;</span><br><span class="line">            <span class="comment">//如果s中的该字符没在t中出现，map[s.charAt[end]]会变成负数</span></span><br><span class="line">            map[s.charAt(end)]--;</span><br><span class="line">            end++;</span><br><span class="line">            <span class="comment">//我们找到了一个有效的窗口，start-end，该窗口中字符包含了t中的所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(counter == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(end -start &lt; minLen)&#123;</span><br><span class="line">                    <span class="comment">//记录窗口的长度和开始位置</span></span><br><span class="line">                    minLen = end - start;</span><br><span class="line">                    minStart = start;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将start往前移动，缩小滑动窗口</span></span><br><span class="line">                map[s.charAt(start)]++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//说明该符号也是t中的元素</span></span><br><span class="line">                <span class="keyword">if</span>(map[s.charAt(start)] &gt; <span class="number">0</span>) counter++;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minLen != Integer.MAX_VALUE) <span class="keyword">return</span> s.substring(minStart, minStart + minLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设只有ASCII字符</span></span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="comment">//统计t中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) map[t.charAt(i)]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, counter = t.length(), minLen = Integer.MAX_VALUE, minStart = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//如果s中字符也在t中，counter--</span></span><br><span class="line">            <span class="comment">//如果s中的该字符没在t中出现，map[s.charAt[end]]会变成负数</span></span><br><span class="line">            <span class="keyword">if</span>(map[s.charAt(end++)]-- &gt; <span class="number">0</span>) counter--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//我们找到了一个有效的窗口，start-end，该窗口中字符包含了t中的所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(counter == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(end -start &lt; minLen) minLen = end - (minStart = start);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将start往前移动，缩小滑动窗口</span></span><br><span class="line">                <span class="comment">//说明该符号也是t中的元素</span></span><br><span class="line">                <span class="keyword">if</span>(map[s.charAt(start++)]++ == <span class="number">0</span>) counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minLen != Integer.MAX_VALUE ? s.substring(minStart, minStart + minLen) : <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Word_Break_II">Word Break II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">    <span class="comment">//直接使用DFS会超时，我们可以使用带备忘的DFS，利用HashMap缓存来剪枝</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DFS(s, wordDict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在上面的for循环中，我们循环的对象是字典，但是在实际情况中，字典可能非常大</span></span><br><span class="line">    <span class="comment">//我们应该用字符串s来作为循环对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">DFS</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(s)) <span class="keyword">return</span> map.get(s);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(s)) res.add(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            String word = s.substring(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span>(wordDict.contains(word))&#123;</span><br><span class="line">                List&lt;String&gt; subList = DFS(s.substring(i), wordDict);</span><br><span class="line">                <span class="keyword">for</span>(String sub: subList)&#123;</span><br><span class="line">                    res.add(word + <span class="string">" "</span> + sub);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.put(s, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Longest_Valid_Parentheses">Longest Valid Parentheses</h2><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p>
<p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">')'</span>)&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        <span class="keyword">int</span> lastIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty()) lastIndex = stack.peek();</span><br><span class="line">        longest = Math.max(longest, i-lastIndex);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        stack.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Palindrome_Partitioning_II">Palindrome Partitioning II</h2><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cut[i]表示前i个字符最小分割次数s[0...i-1]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] cut = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化cut，最大可能的分割次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)&#123;</span><br><span class="line">            cut[i] = i-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//从s[i]向两边扩展回文字符串</span></span><br><span class="line">            <span class="comment">//回文长度为奇数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; i - j &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; len &amp;&amp; s.charAt(i-j) == s.charAt(i+j); j++)&#123;</span><br><span class="line">                <span class="comment">//s[i-j]到s[i+j]已经是回文</span></span><br><span class="line">                <span class="comment">//s[0...i-j-1]|s[i-j...i+j]</span></span><br><span class="line">                <span class="comment">//cut[i-j]表示s[0...i-j-1]的最小分割次数，如果s[0...i-j-1]的最小分割次数加上1（即i-j-1和i-j分割的一次）</span></span><br><span class="line">                <span class="comment">//第次数比cut[i+j+1]小，则更新cut[i+j+1]</span></span><br><span class="line">                cut[i+j+<span class="number">1</span>] = Math.min(cut[i+j+<span class="number">1</span>], <span class="number">1</span>+cut[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回文长度为偶数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i - j + <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i+j &lt; len &amp;&amp; s.charAt(i-j+<span class="number">1</span>) == s.charAt(i+j); j++)&#123;</span><br><span class="line">                cut[i+j+<span class="number">1</span>] = Math.min(cut[i+j+<span class="number">1</span>], <span class="number">1</span>+cut[i-j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cut[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="N-Queens">N-Queens</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class=]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL事务隔离级别]]></title>
    <link href="http://blog.noobsky.com/2016/10/14/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://blog.noobsky.com/2016/10/14/MySQL事务隔离级别/</id>
    <published>2016-10-13T16:34:57.000Z</published>
    <updated>2016-10-13T16:41:32.000Z</updated>
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">隔离级别</th>
<th style="text-align:left">脏读</th>
<th style="text-align:left">不可重复读</th>
<th style="text-align:left">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">未提交读</td>
<td style="text-align:left">可能</td>
<td style="text-align:left">可能</td>
<td style="text-align:left">可能</td>
</tr>
<tr>
<td style="text-align:left">已提交读</td>
<td style="text-align:left">不可能</td>
<td style="text-align:left">可能</td>
<td style="text-align:left">可能</td>
</tr>
<tr>
<td style="text-align:left">可重复读</td>
<td style="text-align:left">不可能</td>
<td style="text-align:left">不可能</td>
<td style="text-align:left">可能</td>
</tr>
<tr>
<td style="text-align:left">可串行化</td>
<td style="text-align:left">不可能</td>
<td style="text-align:left">不可能</td>
<td style="text-align:left">不可能</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">隔离级别</th>
<th style="text-align:left">脏读</th>
<th style="text-align:left">不可重复读</th>
<th st]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之栈问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/13/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/13/面试算法之栈问题集锦/</id>
    <published>2016-10-13T08:44:31.000Z</published>
    <updated>2016-10-13T16:35:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Valid_Parentheses">Valid Parentheses</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> curr = s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(<span class="string">")&#125;]"</span>.contains(curr+<span class="string">""</span>))&#123;</span><br><span class="line">                    <span class="keyword">char</span> top = stack.pop();</span><br><span class="line">                    <span class="keyword">if</span>((top+<span class="string">""</span>+curr).equals(<span class="string">"()"</span>) || (top+<span class="string">""</span>+curr).equals(<span class="string">"&#123;&#125;"</span>) || (top+<span class="string">""</span>+curr).equals(<span class="string">"[]"</span>) ) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"(&#123;["</span>.contains(curr+<span class="string">""</span>))&#123;</span><br><span class="line">                    stack.push(curr);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="string">")&#125;]"</span>.contains(curr+<span class="string">""</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               stack.push(curr);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Implement_Queue_using_Stacks">Implement Queue using Stacks</h2><p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) – Push element x to the back of queue.</li>
<li>pop() – Removes the element from in front of queue.</li>
<li>peek() – Get the front element.</li>
<li>empty() – Return whether the queue is empty.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span>&#123;</span><br><span class="line">  Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    stack1.push(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">        stack2.push(stack1.pop());      </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stack2.pop();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">        stack2.push(stack1.pop());      </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack2.peek();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Implement_Stack_using_Queues">Implement Stack using Queues</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>&#123;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="comment">//O(n)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    queue.offer(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queue.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">      queue.offer(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//O(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue.poll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//O(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.peek();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//O(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.size() == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Min_Stack">Min Stack</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储stack的最小值</span></span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty() || x &lt; stack2.peek())&#123;</span><br><span class="line">            stack2.push(x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack2.push(stack2.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your MinStack object will be instantiated and called as such:</span><br><span class="line"> * MinStack obj = new MinStack();</span><br><span class="line"> * obj.push(x);</span><br><span class="line"> * obj.pop();</span><br><span class="line"> * int param_3 = obj.top();</span><br><span class="line"> * int param_4 = obj.getMin();</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="Binary_Search_Tree_Iterator">Binary Search Tree Iterator</h2><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//很自然的思路就是将所有的树节点放入array中，然后利用索引指针进行next和hashNext</span></span><br><span class="line"><span class="comment">//满足O(1)time但是不满足O(h)memory</span></span><br><span class="line"><span class="comment">//我们可以利用栈，首先将树的left branch压栈，此时栈顶元素为最小的元素，当调用next弹出栈顶元素</span></span><br><span class="line"><span class="comment">//后，最小元素并不在栈中，我们需要寻找到最小元素然后入栈。此时树中元素最小元素在弹出元素的右子树的left branch</span></span><br><span class="line"><span class="comment">//这一点是由BST的性质决定的，所以我们next之后需要将弹出元素的右子树的left branch入栈。</span></span><br><span class="line"><span class="comment">//此种解法满足O(h)memory,next O(1), hashNext的平均时间能达到O(1)</span></span><br><span class="line"><span class="comment">//我们用next遍历整颗树，则next函数会遍历每个节点，run time为O(n),所以对于整棵树来说，平均运行时间为O(n)/n=O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        pushLeftBranch(temp.right);</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLeftBranch</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your BSTIterator will be called like this:</span><br><span class="line"> * BSTIterator i = new BSTIterator(root);</span><br><span class="line"> * while (i.hasNext()) v[f()] = i.next();</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="Simplify_Path">Simplify Path</h2><p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String dir : path.split(<span class="string">"/"</span>))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">".."</span>.equals(dir))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty()) stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="string">""</span>.equals(dir) &amp;&amp; !<span class="string">"."</span>.equals(dir))&#123;</span><br><span class="line">                stack.push(dir);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(String dir: stack)&#123;</span><br><span class="line">            res = <span class="string">"/"</span> + dir + res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.length() == <span class="number">0</span> ? <span class="string">"/"</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Verify_Preorder_Serialization_of_a_Binary_Tree">Verify Preorder Serialization of a Binary Tree</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder == <span class="keyword">null</span> || preorder.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    String[] nodes = preorder.split(<span class="string">","</span>);</span><br><span class="line">    <span class="keyword">int</span> diff = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String node: nodes)&#123;</span><br><span class="line">      <span class="keyword">if</span>(--diff &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(!node.equals(<span class="string">"#"</span>)) diff += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diff == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Evaluate_Reverse_Polish_Notation">Evaluate Reverse Polish Notation</h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Some examples:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"+"</span>, <span class="string">"3"</span>, <span class="string">"*"</span>]<span class="function"> -&gt;</span> <span class="function"><span class="params">((<span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span>)</span> -&gt;</span> <span class="number">9</span></span><br><span class="line">[<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>]<span class="function"> -&gt;</span> <span class="function"><span class="params">(<span class="number">4</span> + (<span class="number">13</span> / <span class="number">5</span>))</span> -&gt;</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String token : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"+"</span>.equals(token))&#123;</span><br><span class="line">                stack.push(stack.pop() + stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"-"</span>.equals(token))&#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(token))&#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"/"</span>.equals(token))&#123;</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                stack.push(b / a);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Maximal_Rectangle">Maximal Rectangle</h2><h2 id="Largest_Rectangle_in_Histogram">Largest Rectangle in Histogram</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//长方形的面积由组成的所有bar的最矮的bar决定</span></span><br><span class="line">    <span class="comment">//对于每一个bar我们计算该bar是矩形中最小的bar时矩形的面积</span></span><br><span class="line">    <span class="comment">//这些矩形面积中最大的即为所求</span></span><br><span class="line">    <span class="comment">//为了计算bar x为最小bar时矩形的面积，我们需要bar x左边更小的bar的下标和bar x右边更小的bar</span></span><br><span class="line">    <span class="comment">//我们用栈保存每个bar，当遇到一个更小的bar时，我们弹出栈顶的bar x，计算该bar为最小bar的矩形的面积</span></span><br><span class="line">    <span class="comment">//弹栈后栈顶的bar为bar x左边更小的bar，当前的bar的为bar x右边更小的bar</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="comment">//存bar对应的下标</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len;)&#123;</span><br><span class="line">            <span class="comment">//应该在heights的最后面加一个高度为0的bar</span></span><br><span class="line">            <span class="comment">//否则如果heights数组为递增时：1、2、3、4、5不会发生计算</span></span><br><span class="line">            <span class="keyword">int</span> h = (i == len) ? <span class="number">0</span> : heights[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当当前bar的高度大于栈顶bar的高度时，将当前bar压入栈中</span></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty() || h &gt;= heights[stack.peek()])&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tp = stack.pop();</span><br><span class="line">                <span class="comment">//计算以heights[tp]为最小bar的矩形的面积，并更新maxArea的值</span></span><br><span class="line">                maxArea = Math.max(maxArea, heights[tp] * (stack.isEmpty() ? i : i-<span class="number">1</span>-stack.peek()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Valid_Parentheses">Valid Parentheses</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</spa]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之位运算集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/13/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BD%8D%E8%BF%90%E7%AE%97%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/13/面试算法之位运算集锦/</id>
    <published>2016-10-13T01:34:40.000Z</published>
    <updated>2016-10-13T03:57:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Reverse_Bits">Reverse Bits</h2><p>Reverse bits of a given 32 bits unsigned integer.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="comment">// public int reverseBits(int n) &#123;</span></span><br><span class="line">    <span class="comment">//     int result = 0;</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; 32; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         //n&amp;1的结果为n最右边的一个比特位</span></span><br><span class="line">    <span class="comment">//         result += n &amp; 1;</span></span><br><span class="line">    <span class="comment">//         //n无符号右移一位，去掉最右边的一个比特位</span></span><br><span class="line">    <span class="comment">//         n = n &gt;&gt;&gt; 1;</span></span><br><span class="line">    <span class="comment">//         //左移一位，最后一位不用左移</span></span><br><span class="line">    <span class="comment">//         if(i &lt; 31) result = result &lt;&lt; 1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return result;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化，可以将32无符号数转换为四个byte，反正每一个byte并转化为int，byte使用缓存存储来提高性能</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Byte, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//无符号右移的优先级比*低，不确定就加括号</span></span><br><span class="line">            bytes[i] = (<span class="keyword">byte</span>)((n &gt;&gt;&gt; i*<span class="number">8</span>) &amp; (<span class="number">0xFF</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            result += reverseBytes(bytes[i]);</span><br><span class="line">            <span class="comment">//左移八位</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">3</span>) result = result &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">reverseBytes</span><span class="params">(<span class="keyword">byte</span> b)</span></span>&#123;</span><br><span class="line">        Integer value = map.get(b);</span><br><span class="line">        <span class="comment">//缓存中存在，直接返回缓存中对应的值</span></span><br><span class="line">        <span class="keyword">if</span>(value != <span class="keyword">null</span>) <span class="keyword">return</span> value;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            value += (b&gt;&gt;&gt;i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//b = b &gt;&gt;&gt; 1;</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">7</span>) value = value &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入缓存</span></span><br><span class="line">        map.put(b,value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Convert_a_Number_to_Hexadecimal">Convert a Number to Hexadecimal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[] map = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    String res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">      res = map[num &amp; <span class="number">15</span>] + res;</span><br><span class="line">      num &gt;&gt;&gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Power_of_Two">Power of Two</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &amp; (n-<span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sum_of_Two_Integers">Sum of Two Integers</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum, carry;</span><br><span class="line">    do&#123;</span><br><span class="line">      sum = a ^ b;</span><br><span class="line">      carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      a = sum;</span><br><span class="line">      b = carry;</span><br><span class="line">    &#125;<span class="keyword">while</span>(b != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = a, carry;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">      sum = a ^ b;</span><br><span class="line">      carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">      a = sum;</span><br><span class="line">      b = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Number_of_1_Bits">Number of 1 Bits</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// // you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="comment">// public int hammingWeight(int n) &#123;</span></span><br><span class="line">    <span class="comment">//     int count = 0;</span></span><br><span class="line">    <span class="comment">//     while(n != 0)&#123;</span></span><br><span class="line">    <span class="comment">//         // if((n &amp; 1)==1)&#123;</span></span><br><span class="line">    <span class="comment">//         //     count++;</span></span><br><span class="line">    <span class="comment">//         // &#125;</span></span><br><span class="line">    <span class="comment">//         //更好的写法</span></span><br><span class="line">    <span class="comment">//         count = count + (n &amp; 1);</span></span><br><span class="line">    <span class="comment">//         n = n &gt;&gt;&gt; 1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return count;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int hammingWeight(int n)&#123;</span></span><br><span class="line">    <span class="comment">//     return Integer.bitCount(n);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//将n最右边为1的比特位置为0</span></span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Power_of_Four">Power of Four</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((num-<span class="number">1</span>)&amp;num)==<span class="number">0</span> &amp;&amp; (num-<span class="number">1</span>)%<span class="number">3</span>==<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//return  num &gt; 0 &amp;&amp; (num&amp;(num-1)) == 0 &amp;&amp; (num&amp;0x55555555) != 0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Find_the_Difference">Find the Difference</h2><p>Given two strings s and t which consist of only lowercase letters.</p>
<p>String t is generated by random shuffling string s and then add one more letter at a random position.</p>
<p>Find the letter that was added in t.</p>
<p>Example:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Input:</span></span><br><span class="line">s = <span class="string">"abcd"</span></span><br><span class="line">t = <span class="string">"abcde"</span></span><br><span class="line"></span><br><span class="line"><span class="label">Output:</span></span><br><span class="line">e</span><br><span class="line"></span><br><span class="line"><span class="label">Explanation:</span></span><br><span class="line"><span class="string">'e'</span> is the letter that was added.</span><br></pre></td></tr></table></figure></p>
<p>用异或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            ch ^= s.charAt(i);</span><br><span class="line">            ch ^= t.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ch ^= t.charAt(t.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Majority_Element">Majority Element</h2><p>不用位运算，用摩尔投票算法更简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自己的想法</span></span><br><span class="line">        <span class="comment">// if(nums == null || nums.length == 0) return -1;</span></span><br><span class="line">        <span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">        <span class="comment">// return nums[nums.length/2];</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>, candidate = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                candidate = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>延伸：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//超过n/3的元素个数少于等于2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> candidate1 = nums[<span class="number">0</span>], candidate2 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//这种写法当测试用例为[8,8,7,7,7]时不能通过</span></span><br><span class="line">            <span class="comment">// if(count1 == 0)&#123;</span></span><br><span class="line">            <span class="comment">//     candidate1 = nums[i];</span></span><br><span class="line">            <span class="comment">//     count1 = 1;</span></span><br><span class="line">            <span class="comment">// &#125;else if(count2 == 0)&#123;</span></span><br><span class="line">            <span class="comment">//     candidate2 = nums[i];</span></span><br><span class="line">            <span class="comment">//     count2 = 1;</span></span><br><span class="line">            <span class="comment">// &#125;else if(nums[i] == candidate1)&#123;</span></span><br><span class="line">            <span class="comment">//     count1++;</span></span><br><span class="line">            <span class="comment">// &#125;else if(nums[i] == candidate2)&#123;</span></span><br><span class="line">            <span class="comment">//     count2++;</span></span><br><span class="line">            <span class="comment">// &#125;else&#123;</span></span><br><span class="line">            <span class="comment">//     count1--;</span></span><br><span class="line">            <span class="comment">//     count2--;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count1 == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate1 = nums[i];</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count2 == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate2 = nums[i];</span><br><span class="line">                count2 = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count1 &gt; nums.length / <span class="number">3</span>) res.add(candidate1);</span><br><span class="line">        <span class="keyword">if</span>(count2 &gt; nums.length / <span class="number">3</span>) res.add(candidate2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// public class Solution&#123;</span></span><br><span class="line"><span class="comment">//     public List&lt;Integer&gt; majorityElement(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">//     if (nums == null || nums.length == 0)</span></span><br><span class="line"><span class="comment">//         return new ArrayList&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">//     List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">//     int number1 = nums[0], number2 = nums[0], count1 = 0, count2 = 0, len = nums.length;</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//         if (nums[i] == number1)</span></span><br><span class="line"><span class="comment">//             count1++;</span></span><br><span class="line"><span class="comment">//         else if (nums[i] == number2)</span></span><br><span class="line"><span class="comment">//             count2++;</span></span><br><span class="line"><span class="comment">//         else if (count1 == 0) &#123;</span></span><br><span class="line"><span class="comment">//             number1 = nums[i];</span></span><br><span class="line"><span class="comment">//             count1 = 1;</span></span><br><span class="line"><span class="comment">//         &#125; else if (count2 == 0) &#123;</span></span><br><span class="line"><span class="comment">//             number2 = nums[i];</span></span><br><span class="line"><span class="comment">//             count2 = 1;</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             count1--;</span></span><br><span class="line"><span class="comment">//             count2--;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     count1 = 0;</span></span><br><span class="line"><span class="comment">//     count2 = 0;</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//         if (nums[i] == number1)</span></span><br><span class="line"><span class="comment">//             count1++;</span></span><br><span class="line"><span class="comment">//         else if (nums[i] == number2)</span></span><br><span class="line"><span class="comment">//             count2++;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     if (count1 &gt; len / 3)</span></span><br><span class="line"><span class="comment">//         result.add(number1);</span></span><br><span class="line"><span class="comment">//     if (count2 &gt; len / 3)</span></span><br><span class="line"><span class="comment">//         result.add(number2);</span></span><br><span class="line"><span class="comment">//     return result;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Binary_Watch">Binary Watch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; times = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; h++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; m++)&#123;</span><br><span class="line">                <span class="comment">// if(Integer.bitCount((h&lt;&lt;6) + m) == num)&#123;</span></span><br><span class="line">                <span class="comment">//     times.add(String.format("%d:%02d", h, m));</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">//或者</span></span><br><span class="line">                <span class="keyword">if</span>(Integer.bitCount(h)+Integer.bitCount(m) == num)&#123;</span><br><span class="line">                    times.add(String.format(<span class="string">"%d:%02d"</span>, h, m));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Single_Number">Single Number</h2><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res = res ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Single_Number_II">Single Number II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[j] &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) count++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      res |= ((count % <span class="number">3</span>) &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Single_Number_III">Single Number III</h2><p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">int</span> xorRes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) xorRes = xorRes ^ nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> firstOneBitMask = (xorRes &amp; (xorRes-<span class="number">1</span>)) ^ xorRes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i] &amp; firstOneBitMask == <span class="number">0</span>)&#123;</span><br><span class="line">        res[<span class="number">0</span>] = res[<span class="number">0</span>] ^ nums[i];</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res[<span class="number">1</span>] = res[<span class="number">1</span>] ^ nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Maximum_Product_of_Word_Lengths">Maximum Product of Word Lengths</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用一个int来记录一个字符串中出现的字符，题目说只包含26个小写字母，一个int有32比特位，足够表示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words == <span class="keyword">null</span> || words.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = words.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">//使用masks[i]记录words[i]含有的字符信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历words[i]的每个字符，masks[i]的最低比特位表示words[i]是否含有字符a(1表示含有</span></span><br><span class="line">            <span class="comment">//，0表示不含)，最高位表示是否含有字符z</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch: words[i].toCharArray())&#123;</span><br><span class="line">                masks[i] |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxProduct = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">                <span class="comment">//(masks[i] &amp; masks[j]) == 0表示两个word没有相同的字符</span></span><br><span class="line">                <span class="keyword">if</span>((masks[i] &amp; masks[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    maxProduct = Math.max(maxProduct, words[i].length()*words[j].length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个int来记录一个字符串中出现的字符，题目说只包含26个小写字母，一个int有32比特位，足够表示</span></span><br><span class="line">    <span class="comment">//我们还可以先对words数组按字符串长度排序，后面就可以进行剪枝优化,排序为O(nlgn)，不影响O(n*n)的时间复杂度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words == <span class="keyword">null</span> || words.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对words数组按字符串长度排序</span></span><br><span class="line">        Arrays.sort(words, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> b.length() - a.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = words.length;</span><br><span class="line">        <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">//使用masks[i]记录words[i]含有的字符信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历words[i]的每个字符，masks[i]的最低比特位表示words[i]是否含有字符a(1表示含有</span></span><br><span class="line">            <span class="comment">//，0表示不含)，最高位表示是否含有字符z</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch: words[i].toCharArray())&#123;</span><br><span class="line">                masks[i] |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxProduct = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="comment">//words[i].length() * words[i].length()是words[i]最大可能的maxProduct</span></span><br><span class="line">            <span class="keyword">if</span>(words[i].length() * words[i].length() &lt; maxProduct) <span class="keyword">break</span>; <span class="comment">//剪枝优化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">                <span class="comment">//(masks[i] &amp; masks[j]) == 0表示两个word没有相同的字符</span></span><br><span class="line">                <span class="keyword">if</span>((masks[i] &amp; masks[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    maxProduct = Math.max(maxProduct, words[i].length()*words[j].length());</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//剪枝，越前面的字符串求到的maxProduct越大</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Subsets">Subsets</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位操作</span></span><br><span class="line">    <span class="comment">//[] =&gt; 000 [1] =&gt; 001 [2] =&gt; 010 ...... [1, 2, 3] =&gt; 111</span></span><br><span class="line">    <span class="comment">//[1,3,5]</span></span><br><span class="line">    <span class="comment">//[] =&gt; 000 [1] =&gt; 001 [2] =&gt; 010 ...... [1, 3, 5] =&gt; 111</span></span><br><span class="line">    <span class="comment">//所以逻辑很简单，二进制表示中代表i的比特位为1表示i在subset中，否则不在,比如001中代表1的比特位为1</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//可以不排序</span></span><br><span class="line">        <span class="comment">//Arrays.sort(nums);</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">1</span> &lt;&lt; nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; subSet = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="comment">//i&amp;(1 &lt;&lt; j)可以避免死循环，但其实这里没有负数</span></span><br><span class="line">                <span class="comment">//(i&gt;&gt;j) &amp; 1的写法也是可以的</span></span><br><span class="line">                <span class="keyword">if</span>((i &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) subSet.add(nums[j]);</span><br><span class="line">                <span class="comment">//if(((i &gt;&gt; j) &amp; 1) != 0) subSet.add(nums[j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.add(subSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Missing_Number">Missing Number</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可以利用异或，异或有交换性质，除了一个missing number以外，每一个number都会存在一个下标跟这个number相等</span></span><br><span class="line"><span class="comment">//相等的数异或为0，一个数跟0异或为自己本身，所以我们只要遍历一遍数组，每次异或下标i和nums[i]</span></span><br><span class="line"><span class="comment">//[0,1,3]:0^0^1^1^2^3</span></span><br><span class="line"><span class="comment">//2^3 = 10^11 = 1 如何转换为最终结果2，答案是再异或上nums.length,01^11 = 10 = 2</span></span><br><span class="line"><span class="comment">//如果这种想法正确的话，我们很容易猜到最后要异或上数组的长度，比如特例[0,1],返回2，就是0异或nums.length</span></span><br><span class="line"><span class="comment">//如果不用这种特例来猜也是可以说明的</span></span><br><span class="line"><span class="comment">//分两种情况：第一种情况是数组所有的元素都有相应的下边对应，那么missing number为nums.length,而数组里的数异或为0，则返回</span></span><br><span class="line"><span class="comment">//0 ^ nums.length = nums.length</span></span><br><span class="line"><span class="comment">//第二种情况是数组里不是所有的元素都有相应的下边对应，也就是missing number为nums中的某一个元素，这种情况下nums.length</span></span><br><span class="line"><span class="comment">//必为数组中的一个元素，比如[1,0,3,4]，假设下边i没有元素对应，则此时相当于i^nums.length^nums.length = i</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        result = result ^ i ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result ^ nums.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber1</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        sum += i - nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Counting_Bits">Counting Bits</h2><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// //bits[i] = bits[i/2] + i%2;</span></span><br><span class="line">    <span class="comment">// //i/2相当于将i(i&gt;=0)右移一位，对于奇数(最右边的比特位为1,&amp;1一定为1)来说,少了一个为1的比特位，需要加1（i%2或者i&amp;1），</span></span><br><span class="line">    <span class="comment">// //对于偶数来说(最右边的比特位为0，&amp;1一定为0)来说，为1的比特位不变</span></span><br><span class="line">    <span class="comment">// public int[] countBits(int num) &#123;</span></span><br><span class="line">    <span class="comment">//     int[] bits = new int[num+1];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt;= num; i++) bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1);</span></span><br><span class="line">    <span class="comment">//     return bits;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bits[i] = bits[i &amp; (i-1)] + 1;</span></span><br><span class="line">    <span class="comment">//i &amp; (i-1)的结果就是讲i最右边为1的比特位置为0，使i的比特位减少1，加上1即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) bits[i] = bits[i &amp; (i-<span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Bitwise_AND_of_Numbers_Range">Bitwise AND of Numbers Range</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//[m,n]范围内的数按位与的结果为m与n二进制表示左边（高位）的共同部分</span></span><br><span class="line">    <span class="comment">// public int rangeBitwiseAnd(int m, int n) &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int step = 0;</span></span><br><span class="line">    <span class="comment">//     while(m != n)&#123;</span></span><br><span class="line">    <span class="comment">//         m &gt;&gt;= 1;</span></span><br><span class="line">    <span class="comment">//         n &gt;&gt;= 1;</span></span><br><span class="line">    <span class="comment">//         step++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return m&lt;&lt;step;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            i &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m*i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; m)&#123;</span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n &amp; m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Reverse_Bits">Reverse Bits</h2><p>Reverse bits of a given 32 bits unsigned integer.</p>
<figure class="highlight java"><table><tr><t]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之深度优先搜索算法集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/12/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/12/面试算法之深度优先搜索算法集锦/</id>
    <published>2016-10-12T10:56:20.000Z</published>
    <updated>2016-10-16T07:26:51.000Z</updated>
    <content type="html"><![CDATA[<p>见二叉树问题集锦，二叉树好多问题都能用DFS解决。</p>
<h2 id="Number_of_IsLands">Number of IsLands</h2><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example 1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00000</span></span><br></pre></td></tr></table></figure></p>
<p>Answer: 1</p>
<p>Example 2:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br></pre></td></tr></table></figure></p>
<p>Answer: 3</p>
<p>使用DFS，当遇到某个节点的值为1时，小岛数量加一，然后将该节点上下左右的1都标记为0.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">//DFS标记周围节点</span></span><br><span class="line">                    DFSMarking(grid, i, j);</span><br><span class="line">                    <span class="comment">//BFS标记周围节点</span></span><br><span class="line">                    <span class="comment">//BFS(grid, i, j);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS标记周围节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSMarking</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] != <span class="string">'1'</span> ) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="comment">// DFSMarking(grid, i-1, j);</span></span><br><span class="line">        <span class="comment">// DFSMarking(grid, i+1, j);</span></span><br><span class="line">        <span class="comment">// DFSMarking(grid, i, j-1);</span></span><br><span class="line">        <span class="comment">// DFSMarking(grid, i, j+1);</span></span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dirs.length; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> row = i+dirs[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> col = j+dirs[k][<span class="number">1</span>];</span><br><span class="line">            DFSMarking(grid, row, col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        <span class="comment">//Mark up all the adjacent '1'</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">            grid[temp[<span class="number">0</span>]][temp[<span class="number">1</span>]] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dirs.length; k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> row = temp[<span class="number">0</span>]+dirs[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> col = temp[<span class="number">1</span>]+dirs[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(row &lt; <span class="number">0</span> || row &gt;= grid.length || col &lt; <span class="number">0</span> || col &gt;= grid[<span class="number">0</span>].length || grid[row][col] != <span class="string">'1'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                   queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;row, col&#125;);</span><br><span class="line">                   <span class="comment">//需要将该节点标记为0，不然访问该节点的邻居节点时，该节点可能重复加入队列中</span></span><br><span class="line">                   <span class="comment">//该作用相当于visited数组，表示该节点已经访问过了</span></span><br><span class="line">                   grid[row][col] = <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Number_of_IsLands-1">Number of IsLands</h2><p>A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example:</p>
<p>Given m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]].<br>Initially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 &gt;represents land).<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>Operation #1: addLand(0, 0) turns the water at grid0 into a land.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span>   Number of islands = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Operation #2: addLand(0, 1) turns the water at grid0 into a land.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span>   Number of islands = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Operation #3: addLand(1, 2) turns the water at grid1 into a land.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span>   Number of islands = <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>Operation #4: addLand(2, 1) turns the water at grid2 into a land.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span>   Number of islands = <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>We return the result as an array: [1, 1, 2, 3]</p>
<p>很典型的union-find题。因为这里是动态的增加land，要能随时求出有多少个island，最简单的方法就是union-find。我们可以定义一个counter, 每增加一个land, 增加counter, 然后我们搜索那个land邻居区域，发现root不一样的话，意味着可以union, 每union一次，意味着两个island合并成一个，减小counter, 统计最终的counter值，即是增加land后的最终island的个数。</p>
<p>为了减小时间复杂度，代码实现是QuickUnion + Path Compression, Path Compression目的是为了调整树的高度，保持很平的树，而不是越来越高，这样找root不会出现worst case.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">numIslands</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] positions)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] roots = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];<span class="comment">//表示各个index对应的root</span></span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.fill(roots, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//统计小岛数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; positions.length; i++)&#123;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">int</span> index = positions[i][<span class="number">0</span>]*n + positions[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      id[index] = index;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dirs.length; j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> row = positions[i][<span class="number">0</span>] + dirs[j][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> col = positions[i][<span class="number">1</span>] + dirs[j][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; n &amp;&amp; roots[row*n + col] != -<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">int</span> root = findRoot(roots, row * n + col);</span><br><span class="line">          <span class="comment">// 发现root不等的情况下，才union, 同时减小count</span></span><br><span class="line">          <span class="keyword">if</span>(root != index)&#123;</span><br><span class="line">            roots[root] = index;</span><br><span class="line">            count--;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      res.add(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span>[] roots, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i != roots[i])&#123;</span><br><span class="line">      roots[i] = roots[roots[i]];</span><br><span class="line">      i = roots[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Longest_Increasing_Path_in_a_Matrix">Longest Increasing Path in a Matrix</h2><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p>Example 1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Return 4<br>The longest increasing path is [1, 2, 6, 9].</p>
<p>Example 2:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Return 4<br>The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//四个搜索方向</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">              <span class="keyword">int</span> len = dfs(matrix, i, j, row, col, cache);</span><br><span class="line">              maxLen = Math.max(maxLen, len);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> maxLen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//深度搜索从[i][j]出发的最长递增路径的长度</span></span><br><span class="line">  <span class="comment">//cache缓存，即备忘录</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] cache)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache[i][j] != <span class="number">0</span>) <span class="keyword">return</span> cache[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//四个方向搜索</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">      <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= row || y &lt; <span class="number">0</span> || y &gt;= col || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> len = <span class="number">1</span> + dfs(matrix, x, y, row, col);</span><br><span class="line">      max = Math.max(len, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache[i][j] = max;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove_Invalid_Parentheses">Remove Invalid Parentheses</h2><p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p>
<p>Note: The input string may contain letters other than the parentheses ( and ).</p>
<p>Examples:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"()())()"</span> -&gt; [<span class="string">"()()()"</span>, <span class="string">"(())()"</span>]</span><br><span class="line"><span class="string">"(a)())()"</span> -&gt; [<span class="string">"(a)()()"</span>, <span class="string">"(a())()"</span>]</span><br><span class="line"><span class="string">")("</span> -&gt; [<span class="string">""</span>]</span><br></pre></td></tr></table></figure></p>
<p>BFS:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//排除重复</span></span><br><span class="line">  Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  queue.offer(s);</span><br><span class="line">  visited.add(s);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一旦BFS在某一层找到了有效的括号组合，就不用继续往下一层继续搜索了</span></span><br><span class="line">  <span class="comment">//因为题目要求移除最少括号</span></span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    String str = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(isValid(str))&#123;</span><br><span class="line">      res.add(str);</span><br><span class="line">      found = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到有效组合，不用继续往下一层搜索</span></span><br><span class="line">    <span class="keyword">if</span>(found) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(str.charAt(i) == <span class="string">'('</span> || str.charAt(i) == <span class="string">')'</span>)&#123;</span><br><span class="line">        String temp = str.substring(<span class="number">0</span>, i) + str.substring(i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!visited.contains(temp))&#123;</span><br><span class="line">          queue.offer(temp);</span><br><span class="line">          visited.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">      <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">      <span class="keyword">if</span>(ch == <span class="string">'('</span>) count++;</span><br><span class="line">      <span class="keyword">if</span>(ch == <span class="string">')'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        count--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Surrounded_Regions">Surrounded Regions</h2><p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>For example,<br><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O O <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> O <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O <span class="keyword">X</span> <span class="keyword">X</span></span><br></pre></td></tr></table></figure></p>
<p>After running your function, the board should be:</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O <span class="keyword">X</span> <span class="keyword">X</span></span><br></pre></td></tr></table></figure>
<p>BFS:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="comment">//边界元素</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || i == row - <span class="number">1</span> || j == <span class="number">0</span> || j == col - <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                        board[i][j] = <span class="string">'A'</span>;</span><br><span class="line">                        bfs(board, i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'A'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] cur = q.poll();</span><br><span class="line">            <span class="keyword">int</span>[][] dirs= &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dirs.length; k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> row = cur[<span class="number">0</span>] + dirs[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> col = cur[<span class="number">1</span>] + dirs[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(row &lt; <span class="number">0</span> || row &gt;= board.length || col &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].length || board[row][col] != <span class="string">'O'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;row, col&#125;);</span><br><span class="line">                    board[row][col] = <span class="string">'A'</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>见二叉树问题集锦，二叉树好多问题都能用DFS解决。</p>
<h2 id="Number_of_IsLands">Number of IsLands</h2><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), co]]>
    </summary>
    
      <category term="DFS" scheme="http://blog.noobsky.com/tags/DFS/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java单例模式]]></title>
    <link href="http://blog.noobsky.com/2016/10/09/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.noobsky.com/2016/10/09/Java单例模式/</id>
    <published>2016-10-09T14:29:05.000Z</published>
    <updated>2016-10-09T01:54:17.000Z</updated>
    <content type="html"><![CDATA[<p>单例模式应该是设计模式中最容易理解，也是最容易手写代码，但这并不意味着简单，想要写对、用对单例模式还是需要费一番脑筋的。因为其中的坑不少，它也常作为面试题来考。本文对Java中常见的单例模式写法做一个总结。</p>
<h2 id="饿汉式">饿汉式</h2><p>饿汉式就是在类第一次加载到内存中就进行初始化</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>声明成static，类加载时就初始化</li>
<li>final意味着该实例不能重新生成，确保只有一个实例存在</li>
<li>private构造函数表明这个类不能调用构造方法生成其他实例</li>
<li>既然这个类不能调用构造方法形成实例，那么我们需要一个静态的方法getInstance()让其获得一个实例</li>
</ul>
<p>这种方法的好处是编写简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。但是这种方法无法做到延迟创建对象。但是我们很多时候都希望对象可以尽可能地延迟加载，从而减小负载，所以就需要下面的懒汉式。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//去掉final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法使用懒加载模式，由私有构造器和一个共有静态方法构成，在工厂方法中对singleton进行null判断，如果是null就new一个出来，最后返回singleton对象。这种方法可以实现延迟加载，但是有一个致命弱点：线程不安全。在单线程下可以正常工作，如果有多条线程同时调用getSingleton()方法时，很大可能导致重复创建对象。比如第一个线程进行singleton == null后还没执行后面的new，第二个线程也进行singleton == null判断时也为true，此时两个线程都会new出一个不同实例。</p>
<h2 id="线程安全的懒汉式">线程安全的懒汉式</h2><p>为了解决上面线程不安全的问题，最简单的方法就是把getSingleton方法设置为synchronize（同步）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//去掉final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做虽然是线程安全的，能解决多实例问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了同步代码块和双重检验锁。</p>
<h2 id="兼顾线程安全和效率">兼顾线程安全和效率</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="built_in">Singleton</span> &#123;</span><br><span class="line">    private <span class="keyword">static</span> <span class="built_in">Singleton</span> <span class="built_in">singleton</span> = <span class="literal">null</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    private <span class="built_in">Singleton</span>()&#123;&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">Singleton</span> getSingleton()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">singleton</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized (<span class="built_in">Singleton</span>.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">singleton</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="built_in">singleton</span> = new <span class="built_in">Singleton</span>()<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">singleton</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法被称为“双重检查锁”，顾名思义，就是在getSingleton方法中，进行两次null检查。</p>
<ul>
<li>第一null检查，如果实例创建了，就没必要进行同步了直接返回</li>
<li>如果没创建，就开始线程同步</li>
<li>第二个null检查，如果被同步的线程中，有一个线程创建了对象，那么其他线程就不需要创建了<br>第一次null检查极大提升了并发度，去掉第一次null检查跟上面的线程安全的懒汉式效果差不多。第二次null检查也是必须的，如果去掉，如下：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果有多个线程同时通过(singleton== null)的条件检查（因为他们并行运行），虽然我们的synchronized方法会帮助我们同步所有的线程，让我们并行线程变成串行的一个一个去new，同样会出现很多实例。</p>
<p>双重检查锁的代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面3件事情。</p>
<ol>
<li>给singleton分配内存</li>
<li>调用Singleton的构造函数来初始化成员变量，形成实例</li>
<li>将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）<br>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时instance已经是非 null了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。我们只需要将 instance 变量声明成 volatile 就可以了。<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>有些人认为使用volatile的原因是可见性，也就是可以保证线程在本地不会存有singleton的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完1-2-3 之后或者1-3-2之后，不存在执行到1-3然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>但是需要注意的是volatile的禁止指令重排优化这条语义知道JDK1.5才能正确使用。所以在JDK1.5之前双重检查锁的形式的单例模式是无法保证线程安全的。</p>
<p>为了个延迟加载，搞出来这么多问题，我们还是使用前面的饿汉式吧：）。</p>
<h2 id="静态内部类法">静态内部类法</h2><p>《Effective Java》中推荐使用静态内部类的方式实现单例模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这种方式，仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>
<h2 id="高大上的枚举Enum">高大上的枚举Enum</h2><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Jaye <span class="keyword">on</span> <span class="number">16</span>/<span class="number">5</span>/<span class="number">18</span>.</span><br><span class="line"> */</span><br><span class="line">public <span class="class"><span class="keyword">enum</span>  <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>居然用枚举！！看上去好牛逼，通过Singleton.INSTANCE来访问，这比调用getInstance()方法简单多了。</p>
<p>默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>单例模式应该是设计模式中最容易理解，也是最容易手写代码，但这并不意味着简单，想要写对、用对单例模式还是需要费一番脑筋的。因为其中的坑不少，它也常作为面试题来考。本文对Java中常见的单例模式写法做一个总结。</p>
<h2 id="饿汉式">饿汉式</h2><p>饿汉式就是]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://blog.noobsky.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Implement strStr()]]></title>
    <link href="http://blog.noobsky.com/2016/10/09/LeetCode-Implement-strStr/"/>
    <id>http://blog.noobsky.com/2016/10/09/LeetCode-Implement-strStr/</id>
    <published>2016-10-09T01:21:48.000Z</published>
    <updated>2016-10-09T01:22:27.000Z</updated>
    <content type="html"><![CDATA[<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public int strStr(String haystack, String needle) &#123;</span></span><br><span class="line">    <span class="comment">//     return haystack.indexOf(needle);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int strStr(String haystack, String needle)&#123;</span></span><br><span class="line">    <span class="comment">//     if(haystack == null || needle == null) return -1;</span></span><br><span class="line">    <span class="comment">//     //""和""返回0，但是""和"a"返回-1</span></span><br><span class="line">    <span class="comment">//     if(haystack.length() == 0) return needle.length() == 0 ? 0:-1;</span></span><br><span class="line">    <span class="comment">//     //暴力法</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; haystack.length()-needle.length() + 1; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         int j = 0;</span></span><br><span class="line">    <span class="comment">//         for(; j &lt; needle.length(); j++)&#123;</span></span><br><span class="line">    <span class="comment">//             if(haystack.charAt(i+j) != needle.charAt(j)) break;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if(j == needle.length()) return i;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; ; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (j == needle.length()) <span class="keyword">return</span> i;</span><br><span class="line">              <span class="keyword">if</span> (i + j == haystack.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (needle.charAt(j) != haystack.charAt(i + j)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之二叉树问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/09/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/09/面试算法之二叉树问题集锦/</id>
    <published>2016-10-08T16:24:12.000Z</published>
    <updated>2016-10-11T04:07:24.000Z</updated>
    <content type="html"><![CDATA[<p>二叉树的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      TreeNode left;</span><br><span class="line">      TreeNode right;</span><br><span class="line">      TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Symmetric_Tree">Symmetric Tree</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">/ \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>是symmetric</p>
<p>而<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>不是symmetric的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//DFS方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric1</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span> isMirror(root.left, root.right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断左右子树是否为镜像</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> t1.val == t2.val &amp;&amp; isMirror(t1.left, t2.right) &amp;&amp; isMirror(t1.right, t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode t1 = queue.poll();</span><br><span class="line">            TreeNode t2 = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            queue.offer(t1.left);</span><br><span class="line">            queue.offer(t2.right);</span><br><span class="line">            queue.offer(t1.right);</span><br><span class="line">            queue.offer(t2.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sum_of_Left_Leaves">Sum of Left Leaves</h2><p>求全部左叶子之和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode curr = queue.poll();</span><br><span class="line">            <span class="comment">//因为是左叶子，所以判断curr.left的左右节点是否为空</span></span><br><span class="line">            <span class="keyword">if</span>(curr.left != <span class="keyword">null</span> &amp;&amp; curr.left.left == <span class="keyword">null</span> &amp;&amp; curr.left.right == <span class="keyword">null</span>) res += curr.left.val;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curr.left != <span class="keyword">null</span>) queue.offer(curr.left);</span><br><span class="line">            <span class="keyword">if</span>(curr.right != <span class="keyword">null</span>) queue.offer(curr.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_Paths">Binary Tree Paths</h2><p>返回二叉树所有根到叶子的路径<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line">/   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>All root-to-leaf paths are:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1-&gt;2-&gt;5"</span>, <span class="string">"1-&gt;3"</span>]</span><br></pre></td></tr></table></figure>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        binaryTreePathsHelper(root, res, sb);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreePathsHelper</span><span class="params">(TreeNode root, List&lt;String&gt; res, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> length = sb.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">          res.add(sb.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          sb.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">          binaryTreePathsHelper(root.left, res, sb);</span><br><span class="line">          binaryTreePathsHelper(root.right, res, sb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯，remove掉最后一个加的元素</span></span><br><span class="line">        sb.setLength(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span>(root != <span class="keyword">null</span>) searchPaths(root, res, <span class="string">""</span>);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本身算法时间复杂度为O(n)，但是字符串”+“操作也为O(n)，所以可以改用上面的StringBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchPaths</span><span class="params">(TreeNode root, List&lt;String&gt; res, String path)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) res.add(path+root.val);</span><br><span class="line">      <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) searchPaths(root.left, res, path + root.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">      <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) searchPaths(root.right, res, path + root.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Lowest_Common_Ancestor_of_a_Binary_Search_Tree">Lowest Common Ancestor of a Binary Search Tree</h2><p>二叉搜索树的最低公共祖先（LCA）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//root.val大于p.val和q.val，则p和q的lCA在左子树</span></span><br><span class="line">  <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span>(root.left, p, q);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="keyword">return</span>(root.right, p, q);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尾递归可以改写为迭代的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">  <span class="comment">//相乘大于0，说明同号，p和q在root的同一侧</span></span><br><span class="line">  <span class="keyword">while</span>((root.val - p.val)*(root.val - q.val) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    root = p.val &lt; root.val ? root.left : root.right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Invert_Binary_Tree">Invert Binary Tree</h2><p>Invert a binary tree.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>to</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>DFS：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  TreeNode left = invertTree(root.left);</span><br><span class="line">  TreeNode right = invertTree(root.right);</span><br><span class="line"></span><br><span class="line">  root.left = right;</span><br><span class="line">  root.right = left;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用BFS代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.offer(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    TreeNode current = queue.poll();</span><br><span class="line">    TreeNode temp = current.left;</span><br><span class="line">    current.left = current.right;</span><br><span class="line">    current.right = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(current.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">      queue.offer(current.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(current.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">      queue.offer(current.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Same_Tree">Same Tree</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//上面两句可以合并成一句if(p == null || q == null) return p == q;</span></span><br><span class="line">  <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Minimum_Depth_of_Binary_Tree">Minimum Depth of Binary Tree</h2><p>如果左右子树都不为空，则最小深度为左右子树最小值+1<br>如果左右子树有一个为空，则最小深度为另一不为空子树的 最小深度+1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以使用BFS<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            level++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) <span class="keyword">return</span> level;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Maximum_Depth_of_Binary_Tree">Maximum Depth of Binary Tree</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BFS，每个节点都会进队列一次，节点出队列时统计即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Path_Sum">Path Sum</h2><p>root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Path_Sum_II">Path Sum II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        List&lt;Integer&gt; current = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        pathSum(root, sum, res, current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; current)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        current.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList(current));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pathSum(root.left, sum - root.val, res, current);</span><br><span class="line">            pathSum(root.right, sum - root.val, res, current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current.remove(current.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_Zigzag_Level_Order_Traversal">Binary Tree Zigzag Level Order Traversal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//DFS</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder1(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt;= level)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; subList = res.get(level);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//偶数层，从左往右</span></span><br><span class="line">        <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">0</span>) subList.add(root.val);</span><br><span class="line">        <span class="comment">//奇数层，从右往左</span></span><br><span class="line">        <span class="keyword">else</span> subList.add(<span class="number">0</span>, root.val);</span><br><span class="line"></span><br><span class="line">        DFS(res, root.left, level + <span class="number">1</span>);</span><br><span class="line">        DFS(res, root.right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root)&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">//从左往右</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeftToRight = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//每层的节点个数</span></span><br><span class="line">            <span class="keyword">int</span> levelNumber = queue.size();</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; subList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(isLeftToRight)&#123;</span><br><span class="line">                    subList.add(node.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    subList.add(<span class="number">0</span>, node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下一层跟该层的顺序相反，取非</span></span><br><span class="line">            isLeftToRight = !isLeftToRight;</span><br><span class="line">            res.add(subList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Balanced_Binary_Tree">Balanced Binary Tree</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此种方法比较容易想到，O(nlgn)</span></span><br><span class="line">    <span class="comment">// public boolean isBalanced(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return true;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return Math.abs(depth(root.left) - depth(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int depth(TreeNode root)&#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return Math.max(depth(root.left), depth(root.right)) + 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfsHeight(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfsHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftHeight = dfsHeight(root.left);</span><br><span class="line">        <span class="keyword">if</span>(leftHeight == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightHeight = dfsHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span>(rightHeight == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Validate_Binary_Search_Tree">Validate Binary Search Tree</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= min || root.val &gt;= max) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, min, root.val) &amp;&amp; isValidBST(root.right, root.val, max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用long类型不是长久之计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 改进形参用对象Integer和非空指针来判断</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, Integer min, Integer max)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span> (min == <span class="keyword">null</span> || root.val &gt; min) &amp;&amp; (max == <span class="keyword">null</span> || root.val &lt; max) &amp;&amp; isValidBST(root.left, min, root.val) &amp;&amp; isValidBST(root.right, root.val, max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kth_Smallest_Element_in_a_BST">Kth Smallest Element in a BST</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// //二叉搜索树，左儿子比根节点小，右儿子比根节点大</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计左子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> count = countNodes(root.left);</span><br><span class="line">        <span class="comment">//左子树的节点个数大于等于k，说明第k小的元素在左子树中，递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.left, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第k个元素在右子树中，相当于在右子树中寻找第k-count-1小的元素</span></span><br><span class="line">        <span class="keyword">if</span>(count &lt; k-<span class="number">1</span>) <span class="keyword">return</span> kthSmallest(root.right, k - count -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//count = k-1,说明左子树有k-1个节点，跟该节点即为第k小的元素</span></span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>迭代代码如下，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        TreeNode curr = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> curr.val;</span><br><span class="line"></span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_Right_Side_View">Binary Tree Right Side View</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span>            &lt;-<span class="comment">--</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;-<span class="comment">--</span></span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;-<span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>return [1, 3, 4]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rightView(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一层就取一个，而且是最右边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightView</span><span class="params">(TreeNode root, List&lt;Integer&gt; res, <span class="keyword">int</span> currHeight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//tricky，因为一层就取一个（最右边的），当res.size()==currHeight时，说明该元素就是该层最右边的元素</span></span><br><span class="line">        <span class="keyword">if</span>(res.size() == currHeight) res.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右边优先</span></span><br><span class="line">        rightView(root.right, res, currHeight+<span class="number">1</span>);</span><br><span class="line">        rightView(root.left, res, currHeight+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Search_Tree_Iterator">Binary Search Tree Iterator</h2><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//很自然的思路就是将所有的树节点放入array中，然后利用索引指针进行next和hashNext</span></span><br><span class="line"><span class="comment">//满足O(1)time但是不满足O(h)memory</span></span><br><span class="line"><span class="comment">//我们可以利用栈，首先将树的left branch压栈，此时栈顶元素为最小的元素，当调用next弹出栈顶元素</span></span><br><span class="line"><span class="comment">//后，最小元素并不在栈中，我们需要寻找到最小元素然后入栈。此时树中元素最小元素在弹出元素的右子树的left branch</span></span><br><span class="line"><span class="comment">//这一点是由BST的性质决定的，所以我们next之后需要将弹出元素的右子树的left branch入栈。</span></span><br><span class="line"><span class="comment">//此种解法满足O(h)memory,next O(1), hashNext的平均时间能达到O(1)</span></span><br><span class="line"><span class="comment">//我们用next遍历整颗树，则next函数会遍历每个节点，run time为O(n),所以对于整棵树来说，平均运行时间为O(n)/n=O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        pushLeftBranch(temp.right);</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLeftBranch</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your BSTIterator will be called like this:</span><br><span class="line"> * BSTIterator i = new BSTIterator(root);</span><br><span class="line"> * while (i.hasNext()) v[f()] = i.next();</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="Populating_Next_Right_Pointers_in_Each_Node">Populating Next Right Pointers in Each Node</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree with next pointer.</span><br><span class="line"> * public class TreeLinkNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeLinkNode left, right, next;</span><br><span class="line"> *     TreeLinkNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//思路比较直接，直接迭代法遍历,分层处理</span></span><br><span class="line">    <span class="comment">//注意，所有节点的next都初始化为null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode levelStart = root;</span><br><span class="line">        TreeLinkNode curr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(levelStart != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//从每一层的第一个节点开始处理</span></span><br><span class="line">            curr = levelStart;</span><br><span class="line">            <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr.left != <span class="keyword">null</span>) curr.left.next = curr.right;</span><br><span class="line">                <span class="keyword">if</span>(curr.right != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) curr.right.next = curr.next.left;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//换到下一层第一个节点</span></span><br><span class="line">            levelStart = levelStart.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Convert_Sorted_Array_to_Binary_Search_Tree">Convert Sorted Array to Binary Search Tree</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意判断是否为start&gt;end,不然会发生数组越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//取中间节点作为树的root，可以保证是height balanced的BST</span></span><br><span class="line">        <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, start, mid-<span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal">Construct Binary Tree from Preorder and Inorder Traversal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length != inorder.length) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//preorder[0]一定是树的根，然后在inorder中找到preorder[0],将inorder分成了两部分，前半部分是preorder[0]</span></span><br><span class="line"><span class="comment">//的左子树，右半部分是preorder[0]的右子树，然后在子数组中递归处理。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preStart &gt; preorder.length - <span class="number">1</span> || inStart &gt; inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出preorder[preStart]在inorder中的下标</span></span><br><span class="line">    <span class="comment">//题目中假设没有重复元素</span></span><br><span class="line">    <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] == preorder[preStart])&#123;</span><br><span class="line">            inIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root.left = helper(preStart + <span class="number">1</span>, inStart, inIndex - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">    <span class="comment">//右子树根节点的索引：preStart + inIndex - inStart + 1，稍微举个例子算算就可以了</span></span><br><span class="line">    root.right = helper(preStart + inIndex - inStart + <span class="number">1</span>, inIndex + <span class="number">1</span>, inEnd, preorder, inorder);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal">Construct Binary Tree from Inorder and Postorder Traversal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder == <span class="keyword">null</span> || postorder == <span class="keyword">null</span> || inorder.length != postorder.length) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(postorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//postorder[postorder.length - 1]为树的根节点,然后在inorder中找到postorder[postorder.length - 1]的索引</span></span><br><span class="line">    <span class="comment">//将inorder分成两部分，分别为左右子树，递归处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> postEnd, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postEnd &lt; <span class="number">0</span> || inStart &gt; inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postEnd]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == postorder[postEnd])&#123;</span><br><span class="line">                inIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = helper(postEnd - (inEnd - inIndex) - <span class="number">1</span> ,inStart,inIndex - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">        root.right = helper(postEnd - <span class="number">1</span>, inIndex+<span class="number">1</span>, inEnd, inorder, postorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sum_Root_to_Leaf_Numbers">Sum Root to Leaf Numbers</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> sum*<span class="number">10</span>+root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(root.left, sum * <span class="number">10</span>+root.val) + sum(root.right, sum * <span class="number">10</span> + root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Unique_Binary_Search_Trees">Unique Binary Search Trees</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//G(n): the number of unique BST for a sequence of length n,序列长度为n的不同BST的数量</span></span><br><span class="line">    <span class="comment">//F(i, n), 1 &lt;= i &lt;= n: the number of unique BST, where the number i is the root of BST,</span></span><br><span class="line">    <span class="comment">//and the sequence ranges from 1 to n.i为根节点，序列为1到n，不同BST的数量</span></span><br><span class="line">    <span class="comment">//则G(n) = F(1,n) + F(2,n)+F(3,n)+......+F(n,n);G(0) = 1(空树),G(1) = 1</span></span><br><span class="line">    <span class="comment">//F(i,n) = G(i-1)*G(n-i)</span></span><br><span class="line">    <span class="comment">//G(n) = G(0)*G(n-1)+G(1)*G(n-2)+......+G(n-1)G(0)</span></span><br><span class="line">    <span class="comment">//G(2) = G(0)G(1) + G(1)G(0)</span></span><br><span class="line">    <span class="comment">//G(3) = G(0)(2)+G(1)G(1)+G(2)G(0)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] G = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                G[i] += G[j-<span class="number">1</span>]*G[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Unique_Binary_Search_Trees_II">Unique Binary Search Trees II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> genTreeList(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分治算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">genTreeList</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次用[start, end]之间数为根</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">//然后递归求解根i左边[start, i-1]形成的左子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftList = genTreeList(start, i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//递归求解根i右边[i+1, end]区间形成的右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; rightList = genTreeList(i+<span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//左子树中的每个节点都能作为根节点的左孩子</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left : leftList)&#123;</span><br><span class="line">                <span class="comment">//右子树中的每个节点都能作为根节点的右孩子</span></span><br><span class="line">                <span class="comment">//所以将所有的不同的组合加入结果集中</span></span><br><span class="line">                <span class="keyword">for</span>(TreeNode right: rightList)&#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = left;</span><br><span class="line">                    root.right = right;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_Maximum_Path_Sum">Binary Tree Maximum Path Sum</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. Node only</span></span><br><span class="line"><span class="comment">//2. L-sub + Node</span></span><br><span class="line"><span class="comment">//3. R-sub + Node</span></span><br><span class="line"><span class="comment">//4. L-sub + Node + R-sub</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Java中pass by value，不像C++的引用或者指针</span></span><br><span class="line">    <span class="comment">//解决办法是用全局变量、数组、包装类，这里用全局变量</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">//因为存在负数，所以最大值不一定是roog+l-sub+r-sub</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxPathDown(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该函数计算路径最高节点为node的最大路径和(返回值)，并更新全局最大值</span></span><br><span class="line">    <span class="comment">//returns the maximum sum of the path that can be extended to input node's parent.</span></span><br><span class="line">    <span class="comment">//返回能扩展输入节点（node）的父节点的路径的最大和</span></span><br><span class="line">    <span class="comment">//能扩展输入节点node的父节点的路径只有三种情况：</span></span><br><span class="line">    <span class="comment">//1. node only</span></span><br><span class="line">    <span class="comment">//2. node + l-sub</span></span><br><span class="line">    <span class="comment">//3. node + r-sub</span></span><br><span class="line">    <span class="comment">//而node+l-sub+r-sub是不能扩展node的父节点的</span></span><br><span class="line">    <span class="comment">// private int maxPathDown(TreeNode node)&#123;</span></span><br><span class="line">    <span class="comment">//     if(node == null) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int left = maxPathDown(node.left);</span></span><br><span class="line">    <span class="comment">//     int right = maxPathDown(node.right);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //表示通过node节点能到达node的parent节点的最大和，作为返回值返回给父节点的函数调用</span></span><br><span class="line">    <span class="comment">//     //因为更新全局最大值也要用到所以先用局部变量存起来，不用重复计算</span></span><br><span class="line">    <span class="comment">//     int maxPathAcrossNodeToParent = Math.max(node.val, Math.max(left, right) + node.val);</span></span><br><span class="line">    <span class="comment">//     //更新全局最大值</span></span><br><span class="line">    <span class="comment">//     max = Math.max(max, Math.max(node.val + left + right, maxPathAcrossNodeToParent));</span></span><br><span class="line">    <span class="comment">//     //return Math.max(node.val, Math.max(left, right) + node.val);</span></span><br><span class="line">    <span class="comment">//     return maxPathAcrossNodeToParent;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实maxPathDown的可以优化如下：</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathDown</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//节点存在负数，如果为负数则对路径最大和没有任何帮助，抛弃即可</span></span><br><span class="line">        <span class="comment">//left或right至少大于0才对max有帮助</span></span><br><span class="line">        <span class="comment">//这样处理后更新全局最大值时用max跟node.val + left + right比较即可</span></span><br><span class="line">        <span class="comment">//node.val + left + right代表了node、node+l-sub、node+r-sub、node+l-sub+r-sub最大值</span></span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>,maxPathDown(node.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, maxPathDown(node.right));</span><br><span class="line"></span><br><span class="line">        max = Math.max(max, node.val + left + right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(node.val, Math.max(left, right) + node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lowest_Common_Ancestor_of_a_Binary_Tree">Lowest Common Ancestor of a Binary Tree</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> v1, v2;</span><br><span class="line">    <span class="comment">// public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span></span><br><span class="line">    <span class="comment">//     //发现目标(p或q)节点就通过返回该目标节点标记该子树发现了某个目标节点</span></span><br><span class="line">    <span class="comment">//     if(root == null || root == p || root == q) return root;</span></span><br><span class="line">    <span class="comment">//     //查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">    <span class="comment">//     TreeNode left = lowestCommonAncestor(root.left, p, q);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">    <span class="comment">//     TreeNode right = lowestCommonAncestor(root.right, p, q);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //都不为空，说明p和q两个目标节点正好有一个在左子树中有一个在右子树中，则LCA为root</span></span><br><span class="line">    <span class="comment">//     if(left != null &amp;&amp; right  != null) return root;</span></span><br><span class="line">    <span class="comment">//     //如果left(或者right)不为空，而且left为p或者q节点，如果在left(left为p或者q)的子树中查找p和q的LCA，则必定是left</span></span><br><span class="line">    <span class="comment">//     return left != null ? left : right;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//如果有一个节点没在二叉树里的话应该做如下修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        v1 = <span class="keyword">false</span>;</span><br><span class="line">        v2 = <span class="keyword">false</span>;</span><br><span class="line">        TreeNode LCA = lowestCommonAncestorHelper(root, p, q);</span><br><span class="line">        <span class="keyword">if</span>(v1 &amp;&amp; v2) <span class="keyword">return</span> LCA;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestorHelper</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//发现目标(p或q)节点就通过返回该目标节点标记该子树发现了某个目标节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root == p)&#123;</span><br><span class="line">            v1 = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//不能直接返回，如果直接返回，比如树为[2, 2], p = 2(root节点), q = 2(root.left节点)</span></span><br><span class="line">            <span class="comment">//会判断错误，因为只把v1设置为true之后就直接返回，但是v2也应该为true</span></span><br><span class="line">            <span class="comment">//return root;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == q)&#123;</span><br><span class="line">            v2 = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//return root;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        TreeNode left = lowestCommonAncestorHelper(root.left, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        TreeNode right = lowestCommonAncestorHelper(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这里判断返回才能正确处理类似树为[2, 2], p = 2(root节点), q = 2(root.left节点)的情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//都不为空，说明p和q两个目标节点正好有一个在左子树中有一个在右子树中，则LCA为root</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right  != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//如果left(或者right)不为空，而且left为p或者q节点，如果在left(left为p或者q)的子树中查找p和q的LCA，则必定是left</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>二叉树的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span>]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sort List]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Sort-List/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Sort-List/</id>
    <published>2016-10-08T14:45:35.000Z</published>
    <updated>2016-10-08T15:13:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将list分为两部分</span></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找链表中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分为两部分，pre为空说明slow前面前面没有元素，前半部分单链表为空</span></span><br><span class="line">        <span class="comment">// if(pre != null) pre.next = null;</span></span><br><span class="line">        <span class="comment">// else head = null;</span></span><br><span class="line">        <span class="comment">//这里因为前面if(head == null || head.next == null) return head;保证了起码有两个元素才会往下运行</span></span><br><span class="line">        <span class="comment">//则保证会进入while循环，则pre一定不会为空(前半部分单链表不可能为空)，写成上面先判空也可以</span></span><br><span class="line">        <span class="comment">//置为空，将链表割断</span></span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode l1 = sortList(head);</span><br><span class="line">        ListNode l2 = sortList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l1 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l2 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l2;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">quickSort</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  ListNode smallDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), small = smallDummy;</span><br><span class="line">  ListNode largeDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), large = largeDummy;</span><br><span class="line">  ListNode equalDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), equal = equalDummy;</span><br><span class="line"></span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.val &lt; head.val)&#123;</span><br><span class="line">      small.next = curr;</span><br><span class="line">      small = small.next;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr.val &gt; head.val)&#123;</span><br><span class="line">      large.next = curr;</span><br><span class="line">      large = large.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      equal.next = curr;</span><br><span class="line">      equal = equal.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  small.next = large.next = equal.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(merge(quickSort(smallDummy.next), quickSort(largeDummy.next)), equalDummy.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">            current.next = l1;</span><br><span class="line">            <span class="comment">//current = current.next;</span></span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            current.next = l2;</span><br><span class="line">            <span class="comment">//current = current.next;</span></span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if(l1 != null)&#123;</span></span><br><span class="line">    <span class="comment">//     current.next = l1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if(l2 != null)&#123;</span></span><br><span class="line">    <span class="comment">//     current.next = l2;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<figure class="highlight java"><table><]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Max Points on a Line]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Max-Points-on-a-Line/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Max-Points-on-a-Line/</id>
    <published>2016-10-08T13:52:36.000Z</published>
    <updated>2016-10-08T16:03:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>暴力法，注意相同的点和x坐标相等的点（斜率无穷大）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a point.</span><br><span class="line"> * class Point &#123;</span><br><span class="line"> *     int x;</span><br><span class="line"> *     int y;</span><br><span class="line"> *     Point() &#123; x = 0; y = 0; &#125;</span><br><span class="line"> *     Point(int a, int b) &#123; x = a; y = b; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(points.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> points.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++)&#123;</span><br><span class="line">      <span class="comment">//key为斜率，value为点数</span></span><br><span class="line">      HashMap&lt;Double, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="comment">//x坐标相等的点的数量</span></span><br><span class="line">      <span class="keyword">int</span> samex = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//记录相同点</span></span><br><span class="line">      <span class="keyword">int</span> samep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">          <span class="keyword">if</span>((points[j].x == points[i].x) &amp;&amp; (points[j].y == points[i].y))&#123;</span><br><span class="line">            samep++;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(points[j].x == points[i].x)&#123;</span><br><span class="line">            samex++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">double</span> k = (<span class="keyword">double</span>)(points[j].y - points[i].y) / (<span class="keyword">double</span>)(points[j].x - points[i].x);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(map.containsKey(k))&#123;</span><br><span class="line">            map.put(k, map.get(k) + <span class="number">1</span>);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(k, <span class="number">2</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          result = Math.max(result, map.get(k) + samep);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      result = Math.max(result, samex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>暴力法，注意相]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之Two Pointers问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8BTwo-Pointers%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/08/面试算法之Two-Pointers问题集锦/</id>
    <published>2016-10-08T12:18:29.000Z</published>
    <updated>2016-10-16T01:48:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Valid_Palindrome">Valid Palindrome</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>For example,<br>“A man, a plan, a canal: Panama” is a palindrome.<br>“race a car” is not a palindrome.</p>
<p>Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        s = s.toLowerCase();</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; length &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) left++;</span><br><span class="line">            <span class="keyword">while</span>(right &gt;= <span class="number">0</span> &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) right--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(left) != s.charAt(right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove_Duplicates_from_Sorted_Array">Remove Duplicates from Sorted Array</h2><p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public int removeDuplicates(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int newLength = 1;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] != nums[i-1]) nums[newLength++] = nums[i];</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return newLength;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="comment">//第一个元素直接往里面放，后面nums[i]只要不跟前一个放进去的相等都能往里面放</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">1</span> || num != nums[i-<span class="number">1</span>])</span><br><span class="line">                nums[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse_Vowels_of_a_String">Reverse Vowels of a String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String vowels = <span class="string">"aeiouAEIOU"</span>;</span><br><span class="line">    <span class="comment">// public String reverseVowels(String s) &#123;</span></span><br><span class="line">    <span class="comment">//     if(s == null || s.length() == 0) return s;</span></span><br><span class="line">    <span class="comment">//     char[] chs = s.toCharArray();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int length = chs.length;</span></span><br><span class="line">    <span class="comment">//     int left = 0;</span></span><br><span class="line">    <span class="comment">//     int right = length - 1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     char temp;</span></span><br><span class="line">    <span class="comment">//     while(left &lt; right)&#123;</span></span><br><span class="line">    <span class="comment">//         while(left &lt; right &amp;&amp; !isVowels(chs[left])) left++;</span></span><br><span class="line">    <span class="comment">//         while(left &lt; right &amp;&amp; !isVowels(chs[right])) right--;</span></span><br><span class="line">    <span class="comment">//         temp = chs[left];</span></span><br><span class="line">    <span class="comment">//         chs[left] = chs[right];</span></span><br><span class="line">    <span class="comment">//         chs[right] = temp;</span></span><br><span class="line">    <span class="comment">//         left++;</span></span><br><span class="line">    <span class="comment">//         right--;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return new String(chs);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public boolean isVowels(char c)&#123;</span></span><br><span class="line">    <span class="comment">//     c = Character.toLowerCase(c);</span></span><br><span class="line">    <span class="comment">//     if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') return true;</span></span><br><span class="line">    <span class="comment">//     return false;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = chs.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; vowels.indexOf(chs[left])==-<span class="number">1</span>) left++;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; vowels.indexOf(chs[right])==-<span class="number">1</span>) right--;</span><br><span class="line">            temp = chs[left];</span><br><span class="line">            chs[left] = chs[right];</span><br><span class="line">            chs[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse_String">Reverse String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] temp = s.toCharArray();</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temp.length-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] temp = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = temp.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = temp[left];</span><br><span class="line">            temp[left] = temp[right];</span><br><span class="line">            temp[right] = ch;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Move_Zeroes">Move Zeroes</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public void moveZeroes(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] == 0)&#123;</span></span><br><span class="line">    <span class="comment">//             boolean exchange = false;</span></span><br><span class="line">    <span class="comment">//             for(int j = i+1; j &lt; nums.length; j++)&#123;</span></span><br><span class="line">    <span class="comment">//                 if(nums[j] != 0)&#123;</span></span><br><span class="line">    <span class="comment">//                     int temp = nums[i];</span></span><br><span class="line">    <span class="comment">//                     nums[i] = nums[j];</span></span><br><span class="line">    <span class="comment">//                     nums[j] = temp;</span></span><br><span class="line">    <span class="comment">//                     exchange = true;</span></span><br><span class="line">    <span class="comment">//                     break;</span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             if(!exchange)&#123;</span></span><br><span class="line">    <span class="comment">//                 break;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// public void moveZeroes(int[] nums)&#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return;</span></span><br><span class="line">    <span class="comment">//     int current = 0;</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] != 0)&#123;</span></span><br><span class="line">    <span class="comment">//             int temp = nums[current];</span></span><br><span class="line">    <span class="comment">//             nums[current++] = nums[i];</span></span><br><span class="line">    <span class="comment">//             nums[i] = temp;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> insertPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) nums[insertPos++] = num;</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (insertPos &lt; nums.length) &#123;</span><br><span class="line">        nums[insertPos++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Intersection_of_Two_Arrays">Intersection of Two Arrays</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用HashSet，分别遍历两个数组</span></span><br><span class="line">    <span class="comment">//首先把第一个数组加入到集合中</span></span><br><span class="line">    <span class="comment">//然后遍历第二个数组时判断集合中是否包含元素</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(n)，空间复杂度为O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//利用集合对交集进行去重</span></span><br><span class="line">        Set&lt;Integer&gt; intersect = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num1: nums1)&#123;</span><br><span class="line">            set.add(num1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num2: nums2)&#123;</span><br><span class="line">            <span class="comment">//nums1中包含</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(num2))&#123;</span><br><span class="line">                intersect.add(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[intersect.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : intersect)&#123;</span><br><span class="line">            res[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//另外还可以先排序然后使用tow pointers，类似merge array，时间复杂度为O(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[set.size()];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : set)&#123;</span><br><span class="line">            res[k++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或者对一个数组排序，然后使用二分搜索在排序数组中搜索另一个数组的元素</span></span><br><span class="line">    <span class="comment">//时间复杂度都为O(nlgn)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Intersection_of_Two_Arrays_II">Intersection of Two Arrays II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用HashMap，key为nums1中的元素，value为该元素出现的次数</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(n)，空间复杂度为O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num1 : nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num1))&#123;</span><br><span class="line">                map.put(num1, map.get(num1) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num1, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num2: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num2) &amp;&amp; map.get(num2) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                result.add(num2);</span><br><span class="line">                map.put(num2, map.get(num2) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer num: result)&#123;</span><br><span class="line">            res[i++] = num;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间复杂度为O(nlgn)， 空间复杂度为O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : result)&#123;</span><br><span class="line">            res[k++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Linked_List_Cycle">Linked List Cycle</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判圈算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Linked_List_Cycle_II">Linked List Cycle II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public ListNode detectCycle(ListNode head) &#123;</span></span><br><span class="line">    <span class="comment">//     if(head == null) return head;</span></span><br><span class="line">    <span class="comment">//     ListNode slow = head, fast = head;</span></span><br><span class="line">    <span class="comment">//     boolean isCycle = false;</span></span><br><span class="line">    <span class="comment">//     while(fast != null &amp;&amp; fast.next != null)&#123;</span></span><br><span class="line">    <span class="comment">//         fast = fast.next.next;</span></span><br><span class="line">    <span class="comment">//         slow = slow.next;</span></span><br><span class="line">    <span class="comment">//         if(slow == fast )&#123;</span></span><br><span class="line">    <span class="comment">//             isCycle = true;</span></span><br><span class="line">    <span class="comment">//             break;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     if(isCycle == false) return null;</span></span><br><span class="line">    <span class="comment">//     //有circle</span></span><br><span class="line">    <span class="comment">//     slow = head;</span></span><br><span class="line">    <span class="comment">//     while(slow != fast)&#123;</span></span><br><span class="line">    <span class="comment">//         slow = slow.next;</span></span><br><span class="line">    <span class="comment">//         fast = fast.next;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return slow;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast )&#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Palindrome_Linked_List">Palindrome Linked List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断回文的一种有效方法就是反转后一半然后跟前一半相比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="comment">//fast != null 和判断fast.next != null的方式比较直接</span></span><br><span class="line">        <span class="comment">//当总节点数为偶数时，当循环结束时，fast处于尾节点的后一节点（即指向null），而slow指向n/2+1的位置，即后一半的开头节点</span></span><br><span class="line">        <span class="comment">//当总结点数为奇数时，fast节点处于尾节点，slow处于中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//奇数情况，</span></span><br><span class="line">            <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            slow = reverseList(slow);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(slow.val != head.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                head = head.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove_Element">Remove Element</h2><p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example:<br>Given input array nums = [3,2,2,3], val = 3</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//并不需要真正删除元素，我们只需要返回“删除”元素后数组的新长度</span></span><br><span class="line">    <span class="comment">//时间复杂度：O(n),该方法关注于不等于val的元素，如果含有很多不等于val的元素，则浪费很多的移动次数</span></span><br><span class="line">    <span class="comment">//比如[1,2,3,5,4],val为4的时候</span></span><br><span class="line">    <span class="comment">// public int removeElement(int[] nums, int val) &#123;</span></span><br><span class="line">    <span class="comment">//     int begin = 0;</span></span><br><span class="line">    <span class="comment">//     //遍历数组，将所有不等于val元素依次放入原数组中（从index=0的地方依次往后放）</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] != val) nums[begin++] = nums[i];</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return begin;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//上面的解法关注不等于val的元素，同理我们的关注点也可以是等于val的元素</span></span><br><span class="line">    <span class="comment">//我们可以将数组尾部的元素移动到等于val的元素的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                nums[i] = nums[n-<span class="number">1</span>];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Merge_Sorted_Array">Merge Sorted Array</h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mergeIndex = m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nums1Index = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nums2Index = n-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类似链表的合并，但是需要注意的因为需要复用nums1的空间，如果从头开始遍历合并的话，nums有些数还没来得及合并就已经被覆盖了，所以应该从尾部开始合并</span></span><br><span class="line">        <span class="keyword">while</span>(nums1Index &gt;= <span class="number">0</span> &amp;&amp; nums2Index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[nums1Index] &gt; nums2[nums2Index])&#123;</span><br><span class="line">                nums1[mergeIndex--] = nums1[nums1Index--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[mergeIndex--] = nums2[nums2Index--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(nums1Index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            nums1[mergeIndex--] = nums1[nums1Index--];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(nums2Index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            nums1[mergeIndex--] = nums2[nums2Index--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove_Nth_Node_From_End_of_List">Remove Nth Node From End of List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了处理特殊情况，比如删除最后一个元素，用一个虚拟头结点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode first = dummy,second = dummy;</span><br><span class="line">        <span class="comment">//找出倒数第n-1个节点（参考找出倒数第k个节点的题目）</span></span><br><span class="line">        <span class="comment">//第一个指针先向前走n-2步后指向n-1个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后第二个指针跟第一个指针同时前进，当第一个指针指向最后一个元素时，第二个指针指向倒数第n-1个元素</span></span><br><span class="line">        <span class="keyword">while</span>(first.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        second.next = second.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3Sum_Closest">3Sum Closest</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果nums.length&lt;3,如何处理，随时沟通:)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序，然后我们就能慢慢逼近target</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化结果，找三个数，nums[0]+nums[1]+nums[nums.length - 1]</span></span><br><span class="line">        <span class="keyword">int</span> result = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//int result = nums[0] + nums[1]+nums[nums.length - 1];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(result - target) &gt; Math.abs(sum - target))&#123;</span><br><span class="line">                    result = sum;</span><br><span class="line">                    <span class="keyword">if</span>(result == target) <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//sum &gt; target ? right-- : left++;</span></span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target) left++;</span><br><span class="line">                <span class="keyword">else</span> right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Rotate_List">Rotate List</h2><p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,<br>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//k可能大于链表的长度length，所以我们需要知道链表的长度来取模得到正确的k</span></span><br><span class="line">    <span class="comment">//我们只需要将末尾k%length个节点移到链表的头部，这些节点处于第(length-k%length)th个节点之后</span></span><br><span class="line">    <span class="comment">//所以我们需要两个指针分别指向链表最后一个节点和第(length-k%length)th个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode fast = dummy, slow = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="comment">//统计链表长度，顺便让fast指向最后一个节点</span></span><br><span class="line">        <span class="keyword">for</span>( length = <span class="number">0</span>; fast.next != <span class="keyword">null</span>; length++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让slow指针指向第length - k % length 个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = length - k % length; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//rotate</span></span><br><span class="line">        <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL，k = 2，fast指向5，slow指向3</span></span><br><span class="line"></span><br><span class="line">        fast.next = dummy.next;</span><br><span class="line">        dummy.next = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sort_Colors">Sort Colors</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将0往左边放，2往右边放</span></span><br><span class="line">    <span class="comment">//维护两个索引指针left、和right，left初始为0，right初始为nums.length-1</span></span><br><span class="line">    <span class="comment">//然后遍历数组，遇到0时交换到left位置，遇到2时交换到right位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环终止条件为i&lt;=right</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">                nums[left] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[right];</span><br><span class="line">                nums[right] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                <span class="comment">//交换过来的nums[right]有可能是0，i不能++</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove_Duplicates_from_Sorted_Array_II">Remove Duplicates from Sorted Array II</h2><p>Follow up for “Remove Duplicates”:<br>What if duplicates are allowed at most twice?</p>
<p>For example,<br>Given sorted array nums = [1,1,1,2,2,3],</p>
<p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//前两个元素直接加入，后面的元素nums[i]只要不跟前面倒数第二个放进去的nums[i-2]相等都能往里面放</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">2</span> || num != nums[i-<span class="number">2</span>])</span><br><span class="line">                nums[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Longest_Substring_Without_Repeating_Characters">Longest Substring Without Repeating Characters</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用HashMap记住字符和它对应的index</span></span><br><span class="line">    <span class="comment">//然后使用两个指针left和right，初始时指向index为0的位置，然后移动right指针遍历string中的字符，同时更新HashMap</span></span><br><span class="line">    <span class="comment">//如果right指向的字符HashMap已经存在，说明出现重复字符了，需要把left指针指向该字符上一次出现位置的右边和现在位置中的大者</span></span><br><span class="line">    <span class="comment">//在这个过程中，不管更新最长无重复字符字符串的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; s.length(); right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                <span class="comment">//这里需要注意，这样写不对，我们需要确保map.get(s.charAt(right))+1 &gt; left才能赋值</span></span><br><span class="line">                <span class="comment">//不然会出现left指针往回移动的情况,比如s="abba",让right指向最右边的a时，left=2</span></span><br><span class="line">                <span class="comment">//如果直接赋值left = 1,left后退了，b字符重复，造成结果不正确</span></span><br><span class="line">                <span class="comment">//left = map.get(s.charAt(right)) + 1;</span></span><br><span class="line">                left = Math.max(left, map.get(s.charAt(right))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(right), right);</span><br><span class="line">            maxLen = Math.max(maxLen, right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>, counter = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//couter统计重复字符</span></span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.length()) &#123;</span><br><span class="line">            <span class="comment">//大于0说明出现重复字符</span></span><br><span class="line">            <span class="keyword">if</span> (map[s.charAt(end++)]++ &gt; <span class="number">0</span>) counter++;</span><br><span class="line">            <span class="keyword">while</span> (counter &gt; <span class="number">0</span>) <span class="keyword">if</span> (map[s.charAt(begin++)]-- &gt; <span class="number">1</span>) counter--;</span><br><span class="line">            <span class="comment">//counter==0时没有重复字符，可以更新长度</span></span><br><span class="line">            d = Math.max(d, end - begin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Partition_List">Partition List</h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//维护两个临时链表，然后遍历一个原链表，将val小于x的存到第一个临时链表中，</span></span><br><span class="line">    <span class="comment">//其他的存到第二个临时链表中，然后将两个临时链接起来即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//维护虚拟头结点</span></span><br><span class="line">        ListNode dummy1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>), dummy2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr1 = dummy1, curr2 = dummy2;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">                curr1.next = head;</span><br><span class="line">                curr1 = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr2.next = head;</span><br><span class="line">                curr2 = head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2，最后curr2指向5，curr2.next指向2，</span></span><br><span class="line">        <span class="comment">//我们需要将curr2.next置为null，不然会出现circle</span></span><br><span class="line">        curr2.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将第一个链表跟第二个链表链接起来</span></span><br><span class="line">        curr1.next = dummy2.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4Sum">4Sum</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//先排序，后面更好处理</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - <span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> target3Sum = target - nums[j];</span><br><span class="line">            <span class="comment">//排重</span></span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span> || j &gt; <span class="number">0</span> &amp;&amp; nums[j] != nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = j+<span class="number">1</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">                    <span class="comment">//进行nums[i] != nums[i-1]判断去除重复的结果，就不用利用集合去重了</span></span><br><span class="line">                    <span class="keyword">if</span>(i == j+<span class="number">1</span> ||(i &gt; j+<span class="number">1</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                        <span class="comment">//先固定第一个数nums[i]，然后在数组的剩下部分查找两元素之和等于-nums[i]的组合</span></span><br><span class="line">                        <span class="keyword">int</span> sum = target3Sum-nums[i];</span><br><span class="line">                        <span class="comment">//使用两个索引指针，一头一尾进行扫荡</span></span><br><span class="line">                        <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(nums[left] + nums[right] == sum)&#123;</span><br><span class="line">                                <span class="comment">//找到一种组合，加入结果集中</span></span><br><span class="line">                                res.add(Arrays.asList(nums[j], nums[i], nums[left], nums[right]));</span><br><span class="line">                                <span class="comment">//跳过重复元素</span></span><br><span class="line">                                <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left+<span class="number">1</span>] == nums[left]) left++;</span><br><span class="line">                                <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right-<span class="number">1</span>] == nums[right]) right--;</span><br><span class="line">                                left++;</span><br><span class="line">                                right--;</span><br><span class="line">                            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &lt; sum) left++;<span class="comment">//数组有序，小于sum时，增大左边数才有可能相等</span></span><br><span class="line">                            <span class="keyword">else</span> right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Container_With_Most_Water">Container With Most Water</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea1</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最大面积</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//面积由更矮的一条线决定</span></span><br><span class="line">            maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left));</span><br><span class="line">            <span class="comment">//因为左边的高度小于右边的高度，移动右边那根线是没有作用的，移动右边的线形成的面积都是小于等于当前的面积</span></span><br><span class="line">            <span class="comment">//假设移动右边即right--，如果移动后height[new right] &gt; height[left]，那么还是左边线的高度更低，</span></span><br><span class="line">            <span class="comment">//面积等于当前面积；如果移动后height[new right] &lt; height[left]，那么形成的面积更小，所以移动right是没有帮助的</span></span><br><span class="line">            <span class="comment">//只能移动left</span></span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//同理右边高度更小的话，移动左边是没有作用的，只能移动右边</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> h = Math.min(height[left], height[right]);</span><br><span class="line"></span><br><span class="line">            maxArea = Math.max(maxArea, h * (right - left));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//往右寻找高度更高的线</span></span><br><span class="line">            <span class="keyword">while</span>(height[left] &lt;= h &amp;&amp; left &lt; right) left++;</span><br><span class="line">            <span class="comment">//往左寻找高度比h更高的线，形成的面积才有可能大于当前面积</span></span><br><span class="line">            <span class="keyword">while</span>(height[right] &lt;= h &amp;&amp; left &lt; right) right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Minimum_Size_Subarray_Sum">Minimum Size Subarray Sum</h2><p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>For example, given the array [2,3,1,2,4,3] and s = 7,<br>the subarray [4,3] has the minimal length under the problem constraint.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 维护两个索引指针left和right，初始时两个指针指向数组首元素(下标0)，然后right往右移动，并将right指针遇到的元素求sum</span></span><br><span class="line">    <span class="comment">// 当sum &gt;= s时，也就是找到了子数组和大于等于s的子数组，更新最小的子数组长度minLen,</span></span><br><span class="line">    <span class="comment">// 然后从sum中减去left指针指向的数组元素，接着left指针往右移动，只要sum还大于等于s，继续减去left指向元素</span></span><br><span class="line">    <span class="comment">// 则更新最小的子数组长度，直到sum &lt; s时内层while结束，ringt指针继续往右移动进行下一次循环</span></span><br><span class="line">    <span class="comment">// 每执行一次外层while循环，其实是找到里以nums[right]结尾的且子数组和大于等于s的所以子数组。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始时left和right指向数组首元素</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.length)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//出现了子数组和大于等于s的子数组</span></span><br><span class="line">            <span class="comment">//该循环不会让left大于right，因为当left==right - 1时sum为0，题目说了s为正数</span></span><br><span class="line">            <span class="comment">//不用加left&lt;right</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">                <span class="comment">//跟新minLen</span></span><br><span class="line">                minLen = Math.min(minLen, right - left);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Two_Sum_II_-_Input_array_is_sorted">Two Sum II - Input array is sorted</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] indices = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length &lt; <span class="number">2</span>) <span class="keyword">return</span> indices;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                indices[<span class="number">0</span>] = left + <span class="number">1</span>;</span><br><span class="line">                indices[<span class="number">1</span>] = right+ <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Valid_Palindrome">Valid Palindrome</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之二分搜索问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/08/面试算法之二分搜索问题集锦/</id>
    <published>2016-10-08T09:07:05.000Z</published>
    <updated>2016-10-08T12:50:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="First_Bad_Version">First Bad Version</h2><p>给定一个判断版本是否是坏版本的函数，查找[1…n]中第一个坏的版本<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span><br><span class="line">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//int mid = left + (right - left)/2;</span></span><br><span class="line">            <span class="keyword">if</span>(!isBadVersion(mid)) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     public int firstBadVersion(int n) &#123;</span></span><br><span class="line"><span class="comment">//     int start = 1, end = n;</span></span><br><span class="line"><span class="comment">//     while (start &lt; end) &#123;</span></span><br><span class="line"><span class="comment">//         int mid = start + (end-start) / 2;</span></span><br><span class="line"><span class="comment">//         if (!isBadVersion(mid)) start = mid + 1;</span></span><br><span class="line"><span class="comment">//         else end = mid;            </span></span><br><span class="line"><span class="comment">//     &#125;        </span></span><br><span class="line"><span class="comment">//     return start;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Guess_Number_Higher_or_Lower">Guess Number Higher or Lower</h2><p>给定辅助guess(int num)函数，返回3种结果<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> lower</span><br><span class="line"> <span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> higher</span><br><span class="line"> <span class="number">0</span> : Congrats! You got <span class="keyword">it</span>!</span><br></pre></td></tr></table></figure></p>
<p>代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The guess API is defined in the parent class GuessGame.</span><br><span class="line">   @param num, your guess</span><br><span class="line">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span><br><span class="line">      int guess(int num); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(guess(mid) == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(guess(mid) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 1 : My number is higher,这里的My number是指要你猜的那个数</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Sqrt(x)">Sqrt(x)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid == x / mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; x / mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_a_2D_Matrix">Search a 2D Matrix</h2><p>矩阵每一行升序，每一行的第一个元素大于前一行的最后一个元素<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Given target = 3, return true.</p>
<p>每一行从左到右组成有序数组，数组下标范围为[0,row*col-1]，可以使用二分搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//row*col矩阵转换为数组=&gt;matrix[i][j] =&gt; array[i * col + j]</span></span><br><span class="line"><span class="comment">//数组转换为矩阵array[i] =&gt; matrix[i / col][i % col]</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">      <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">          <span class="keyword">int</span> mid = left+(right - left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Find_Peak_Element">Find Peak Element</h2><p>给定数组，num[i] ≠ num[i+1]，查找peek元素，并返回其下标</p>
<p>You may imagine that num[-1] = num[n] = -∞.</p>
<p>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//local maximum就是一个peek</span></span><br><span class="line">    <span class="comment">//mid = (left + right)/2,mid1 = mid + 1</span></span><br><span class="line">    <span class="comment">//如果nums[mid] &lt; nums[mid1]，那么nums[mid1...right]一定有peek，为什么？</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid1右边的数只能增加或者减少，如果mid1右边的数一直增加，则nums[right]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid1右边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="comment">//同理nums[mid] &gt; nums[mid1]，那么nums[left, mid]一定有peek，道理是一样的</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid左边的数只能增加或者减少，如果mid左边的数一直增加，则nums[left]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid左边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> mid1 = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右边一定有peek</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid1])&#123;</span><br><span class="line">                left = mid1;</span><br><span class="line">            <span class="comment">//左边一定有peek</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="comment">//如果出现相等就不符合题目中相邻元素不相等，可以抛异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历的方法不符合时间复杂度，但是实现非常tricky</span></span><br><span class="line">    <span class="comment">// public int findPeakElement(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     //右边有减小的话则peek出现</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] &lt; nums[i-1]) return i-1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //否则元素一直增大到最右边元素就是peek</span></span><br><span class="line">    <span class="comment">//     return nums.length - 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kth_Smallest_Element_in_a_BST">Kth Smallest Element in a BST</h2><p>寻找BST中第k小的元素<br>利用BST的性质，递归搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计左子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> count = countNodes(root.left);</span><br><span class="line">        <span class="comment">//左子树的节点个数大于等于k，说明第k小的元素在左子树中，递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.left, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第k个元素在右子树中，相当于在右子树中寻找第k-count-1小的元素</span></span><br><span class="line">        <span class="keyword">if</span>(count &lt; k-<span class="number">1</span>) <span class="keyword">return</span> kthSmallest(root.right, k - count -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//count = k-1,说明左子树有k-1个节点，跟该节点即为第k小的元素</span></span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以利用中序遍历，边遍历边查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用中序遍历法，因为中序遍历二叉树是有序的</span></span><br><span class="line"><span class="comment">//使用递归中序遍历</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    count = k;</span><br><span class="line">    dfsHelper(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) dfsHelper(root.left);</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">        number = root.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) dfsHelper(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_for_a_Range">Search for a Range</h2><p>给定有序数组，查找目标数在数组的开始和结束位置<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找左边界：mid = (left+right)/2，下取整，往左偏</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找左边界，所以right = mid</span></span><br><span class="line">    <span class="comment">// 2和3可以合并，合并后：if(nums[mid] &lt; target) left = mid+1; else right = mid;</span></span><br><span class="line">    <span class="comment">// 找右边界：mid = (left+right)/2+1，上取整，往右篇</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找右边界，所以left = mid</span></span><br><span class="line">    <span class="comment">// 1和3可以合并，合并后：if(nums[mid] &gt; target) right = mid-1; else left = mid;</span></span><br><span class="line">    <span class="comment">// 就是两种二分搜索的写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[left] != target) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> res[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line">        right = nums.length - <span class="number">1</span>;<span class="comment">//第二次时，left可以不重新设置为0，设置了也没错，多余而已</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//上取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有左边界，就一定能执行到这里，而且不用判断，right最起码等于前面判断左边界</span></span><br><span class="line">        res[<span class="number">1</span>] = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_a_2D_Matrix_II">Search a 2D Matrix II</h2><p>m*n的矩阵，每一行从左往右升序，每一列从上往下升序，在矩阵查找目标元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始比较位置为右上角即matrix[0][col-1],如果target大于该值，那么target不可能在该row，因为每一row都是升序，可以排除该row</span></span><br><span class="line">    <span class="comment">//如果target小于该值，那么target不可能在该col，因为每一col都是升序的，可以排除该col，</span></span><br><span class="line">    <span class="comment">//如果相等，返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[row][col])&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[row][col])&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Search_in_Rotated_Sorted_Array_II">Search in Rotated Sorted Array II</h2><p>[4 5 6 7 0 1 2]，考虑有重复元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//左半部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右半部分有序</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, rigth = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//左半部分有序</span></span><br><span class="line">      <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[] &lt; nums[right])&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Find_Minimum_in_Rotated_Sorted_Array">Find Minimum in Rotated Sorted Array</h2><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;<span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有重复元素呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="comment">//nums[mid] &gt; nums[right],nums[left:mid]有序，搜索右边</span></span><br><span class="line">    <span class="comment">//nums[mid] &lt; nums[right],nums[mid:right]有序，搜索左边</span></span><br><span class="line">    <span class="comment">//nums[mid] = nums[right],有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">    <span class="comment">//但可以肯定排除nums[right],即使min = A[right],排除A[right]并没有使min丢失</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Valid_Perfect_Square">Valid Perfect Square</h2><p>判断是否为完全平方数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里可以直接用数学规律</span></span><br><span class="line">    <span class="comment">//1 = 1</span></span><br><span class="line">    <span class="comment">//4 = 1 + 3</span></span><br><span class="line">    <span class="comment">//9 = 1 + 3 + 5</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//但是这里我们需要注意的是我们不能用加法来做</span></span><br><span class="line">    <span class="comment">//因为加法存在溢出的问题，我们可以逆向考虑，</span></span><br><span class="line">    <span class="comment">//用减法，减1、3...，看看最后num是否会为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            num -= i;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们不知道这个规律，之前实现过sqrt，同理这里也可以使用二分搜索</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//除法是下取整的，mid取值偏小</span></span><br><span class="line">            <span class="comment">//取值偏小的mid的平方都大于num，那么平方根肯定小于mid，所以right = mid - 1</span></span><br><span class="line">            <span class="comment">//除法防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(mid &gt; num / mid)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//小于等于</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &lt; num / mid)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果这样写会造成死循环，比如5</span></span><br><span class="line">                <span class="comment">//if(num % mid == 0) return true;</span></span><br><span class="line">                <span class="keyword">return</span> num % mid == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Find_the_Duplicate_Number">Find the Duplicate Number</h2><p>数组nums包含n+1个元素，每个元素的值在[1,n]区间<br>类似找到链表环的起点，快慢指针<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="LIS最长递增子序列">LIS最长递增子序列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.排序后的序列和原序列求LCS最长公共子序列</span></span><br><span class="line">    <span class="comment">//2.dp (O(n*n))</span></span><br><span class="line">    <span class="comment">//3.dp (O(nlgn))</span></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int[] ends = new int[nums.length];</span></span><br><span class="line">    <span class="comment">//     int len = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //二分搜索可以利用Arrays.binarySearch(int[] a, int fromIndex, int toIndex, int key),</span></span><br><span class="line">    <span class="comment">//     //该函数的返回值是这样的：如果a中存在key，则返回key在a中的index，不存在key返回-insertionpoint-1，所以</span></span><br><span class="line">    <span class="comment">//     //此时insertionpoint =  -(返回值+1)</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         int ret = Arrays.binarySearch(ends, 0, len, nums[i]);</span></span><br><span class="line">    <span class="comment">//         //小于0，不存在key，计算插入位置</span></span><br><span class="line">    <span class="comment">//         if(ret &lt; 0) ret = -(ret+1);</span></span><br><span class="line">    <span class="comment">//         //或者使用自己二分搜索函数</span></span><br><span class="line">    <span class="comment">//         //int ret = binarySearch(ends, 0, len, nums[i]);</span></span><br><span class="line">    <span class="comment">//         ends[ret] = nums[i];</span></span><br><span class="line">    <span class="comment">//         //在ends尾部增加了一个元素</span></span><br><span class="line">    <span class="comment">//         if(ret == len) len++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return len;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不记得Arrays.binarySearch返回值的含义，可以自己写一个二分搜索函数，</span></span><br><span class="line">    <span class="comment">//如果存在key返回index，不存在时返回插入位置的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = fromIndex, right = toIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == key) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; key) right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[j] = max(dp[i]) + 1 i&lt;j&amp;&amp;nums[i] &lt; nums[j]</span></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums)&#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int res = 0;</span></span><br><span class="line">    <span class="comment">//     int[] dp = new int[nums.length];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     for(int j = 0; j &lt; nums.length; j++)&#123;</span></span><br><span class="line">    <span class="comment">//         //也可以在前面用Arrays.fill(dp, 1)</span></span><br><span class="line">    <span class="comment">//         dp[j] = 1;</span></span><br><span class="line">    <span class="comment">//         for(int i = 0; i &lt; j; i++)&#123;</span></span><br><span class="line">    <span class="comment">//             if(nums[i] &lt; nums[j]) dp[j] = Math.max(dp[j], dp[i]+1);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         res = Math.max(res, dp[j]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums)&#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int[] numsCopy = new int[nums.length];</span></span><br><span class="line">    <span class="comment">//     numsCopy = Arrays.copyOfRange(nums, 0, nums.length);</span></span><br><span class="line">    <span class="comment">//     Arrays.sort(numsCopy);</span></span><br><span class="line">    <span class="comment">//     //System.arraycopy(nums, 0, numsCopy, 0, nums.length);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int dp[][] = new int[nums.length+1][nums.length+1];</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt;= nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 0; j &lt;= nums.length; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             if(i == 0 || j == 0) dp[i][j] = 0;</span></span><br><span class="line">    <span class="comment">//             else&#123;</span></span><br><span class="line">    <span class="comment">//                 if(nums[i-1] == numsCopy[j-1])&#123;</span></span><br><span class="line">    <span class="comment">//                     dp[i][j] = dp[i-1][j-1]+1;</span></span><br><span class="line">    <span class="comment">//                 &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                     dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);</span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return dp[nums.length][nums.length];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Russian_Doll_Envelopes">Russian Doll Envelopes</h2><p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>
<p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<p>Example:<br>Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分两步</span></span><br><span class="line">    <span class="comment">//1. 信封按宽升序高降序排序</span></span><br><span class="line">    <span class="comment">//2. 对信封的高找最长递增子序列</span></span><br><span class="line">    <span class="comment">//因为信封的宽已经是升序，我们只要考虑信封的高就可以了</span></span><br><span class="line">    <span class="comment">//[3, 4]是装不下[3, 3]，所以我们需要将[3, 4]排在[3, 3]的前面，如果排序排成了[3,3] [3,4]会被当成递增序列，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span> || envelopes[<span class="number">0</span>].length != <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[<span class="number">0</span>] == arr2[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="comment">//高度降序</span></span><br><span class="line">                    <span class="keyword">return</span> arr2[<span class="number">1</span>] - arr1[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] envelope : envelopes)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(dp, <span class="number">0</span>, len, envelope[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                index = -(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[index] = envelope[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(index == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="First_Bad_Version">First Bad Version</h2><p>给定一个判断版本是否是坏版本的函数，查找[1…n]中第一个坏的版本<br><figure class="highlight java"><table><tr><td class]]>
    </summary>
    
      <category term="Binary Search" scheme="http://blog.noobsky.com/tags/Binary-Search/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Find K Pairs with Smallest Sums]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Find-K-Pairs-with-Smallest-Sums/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Find-K-Pairs-with-Smallest-Sums/</id>
    <published>2016-10-08T08:46:58.000Z</published>
    <updated>2016-10-08T08:49:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.</p>
<p>Define a pair (u,v) which consists of one element from the first array and one element from the second array.</p>
<p>Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums.</p>
<p>Example 1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],  k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Return: [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">The first <span class="number">3</span> pairs are returned from the sequence:</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],  k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Return: [<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">The first <span class="number">2</span> pairs are returned from the sequence:</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">3</span>],  k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Return: [<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">All possible pairs are returned from the sequence:</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路">解题思路</h2><p>类似两路归并排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;Tuple&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.length &amp;&amp; j &lt; k; j++) pq.offer(<span class="keyword">new</span> Tuple(<span class="number">0</span>,j,nums1[<span class="number">0</span>]+nums2[j]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(k, nums1.length*nums2.length); i++)&#123;</span><br><span class="line">            Tuple temp = pq.poll();</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums1[temp.x], nums2[temp.y]&#125;);</span><br><span class="line">            <span class="keyword">if</span>(temp.x == nums1.length - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> Tuple(temp.x+<span class="number">1</span>, temp.y, nums1[temp.x+<span class="number">1</span>]+nums2[temp.y]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tuple</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Tuple that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - that.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.</p>
<p>Define a pair ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Permutations I II]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Permutations-I-II/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Permutations-I-II/</id>
    <published>2016-10-08T06:22:34.000Z</published>
    <updated>2016-10-08T16:15:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Permutations_I">Permutations I</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of distinct numbers, return all possible permutations.</p>
<p>For example,<br>[1,2,3] have the following permutations:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><ul>
<li><p>一般思路</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(nums, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void permute(<span class="keyword">int</span>[]nums, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">int</span> start)&#123;</span><br><span class="line">        <span class="comment">//产生了一个permutation</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= nums.length)&#123;</span><br><span class="line">            <span class="comment">//如果Arrays.asList(arr)的参数arr是原生数组的话并不能得到你想要的结果，</span></span><br><span class="line">            <span class="comment">//Arrays.asList(T...a)形参为可变长参数，如果传入int[] nums的话，会将int[]看做一个类型</span></span><br><span class="line">            <span class="comment">//List list = Arrays.asList(nums)则list.size() == 1;</span></span><br><span class="line">            <span class="comment">//res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums)));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//还是乖乖遍历吧，或者加多一个参数</span></span><br><span class="line">            <span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">list</span>.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">list</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">            <span class="comment">//注意第三个参数是start+1不是i+1</span></span><br><span class="line">            permute(nums, res, start+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//相当于还原回来</span></span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void swap(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码比较简洁易懂</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute(nums, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void permute(<span class="keyword">int</span>[] nums, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">List</span>&lt;Integer&gt; curr)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//curr中已经包含nums[i],跳过本次循环</span></span><br><span class="line">            <span class="keyword">if</span>(curr.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            permute(nums, res, curr);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Permutations_II">Permutations II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br>[1,1,2] have the following unique permutations:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码-1">代码</h3><ul>
<li><p>比较tricky的写法</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//注意排序，让重复的数相邻</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        helper(nums, used, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void helper(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, <span class="keyword">List</span>&lt;Integer&gt; curr, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//only insert duplicate element when the previous duplicate element has been inserted</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            helper(nums, used, curr, res);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常规思路加排重</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; permuteUnique(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute(nums, res, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> permute(<span class="built_in">int</span>[] nums, <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res, <span class="built_in">int</span> start)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">            <span class="built_in">List</span>&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> <span class="built_in">num</span>: nums) &#123;temp.add(<span class="built_in">num</span>);&#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//set在for循环外面定义，在里面定义错误</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; <span class="literal">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">set</span>.add(nums[i]))&#123;</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">                permute(nums, res, start+<span class="number">1</span>);</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> swap(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> x, <span class="built_in">int</span> y)&#123;</span><br><span class="line">        <span class="built_in">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Permutations_I">Permutations I</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of distinct numbers, return all possible permutation]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Preorder/Inorder/Postorder Traversal]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/</id>
    <published>2016-10-08T06:20:02.000Z</published>
    <updated>2016-10-08T16:03:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>return [1,2,3].</p>
<h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    preorder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    preorder(root.left,res);</span><br><span class="line">    preorder(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_Inorder_Traversal">Binary Tree Inorder Traversal</h2><h3 id="题目描述-1">题目描述</h3><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree [1,null,2,3],<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>return [1,3,2].</p>
<h3 id="代码-1">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inorder(root,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    inorder(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    TreeNode node = stack.pop();</span><br><span class="line">    res.add(node.val);</span><br><span class="line">    <span class="comment">//栈是先进后出，应该先把右子树进栈，先访问左子树</span></span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  TreeNode curr = root;</span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//如果curr非空，把curr加入栈，然后curr指向curr的左儿子</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">      stack.push(curr);</span><br><span class="line">      curr = curr.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//curr为空，跳出while循环，说明已经向左走到尽头，弹出当前栈顶元素，进行访问，然后指向右儿子</span></span><br><span class="line">    curr = stack.pop();</span><br><span class="line">    res.add(curr.val);</span><br><span class="line">    curr = curr.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Binary_Tree_Postorder_Traversal">Binary Tree Postorder Traversal</h2><h3 id="题目描述-2">题目描述</h3><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>return [3,2,1].</p>
<h3 id="代码-2">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    postorder(root,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorder(root.left, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    postorder(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前序遍历是root-left-right,后序是left-right-root</span></span><br><span class="line">    <span class="comment">//如果把前序遍历稍微修改下，改为root-right-left，则可以发现这种顺序跟后序的完全相反，最后reverse一下结果就行了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="comment">//栈是先进后出，要想先访问右子树，则先进栈左子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree, return the preorde]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google 2016面试题]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/Google-2016%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.noobsky.com/2016/10/08/Google-2016面试题/</id>
    <published>2016-10-08T02:17:47.000Z</published>
    <updated>2016-10-08T08:06:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="轴对称">轴对称</h2><h3 id="题目描述">题目描述</h3><p>给定平面上的n个点，问是否存在一条平行于y轴的直线，使得这n个点相对于这条直线对称。</p>
<p><strong>Follow-up</strong><br>是否存在一条直线使得这n个点关于这条直线对称？</p>
<h3 id="算法分析">算法分析</h3><p>因为对称轴一定平行于y轴，这看起来缩小了穷举范围（可是我们真的要穷举可能的对称轴吗？有实无限个可能点对称轴…）</p>
<p>那么我们怎么找到那条对称轴？对称轴的特点就是每一个点都在另一边有一个对应的点。第一想法是：最左边的点一定对应某个最右边的点，因此最左边的点和最右边的点的中点应该在对称轴上。当然还有很多其他的找对称轴的方法，比如求所有x坐标的平均值。</p>
<p>找到了对称轴的位置，我们就可以通过HashMap判断是否每一个点都有对应的点，最后输出答案即可。</p>
<p>时间复杂度为O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReflected</span><span class="params">(Point[] points)</span></span>&#123;</span><br><span class="line">    <span class="comment">//最右边点的x坐标值</span></span><br><span class="line">    <span class="keyword">int</span> max = Math.MIN_VALUE;</span><br><span class="line">    <span class="comment">//最左边点的x坐标值</span></span><br><span class="line">    <span class="keyword">int</span> min = Math.MAX_VALUE;</span><br><span class="line">    <span class="comment">//key为y坐标值，value为y坐标值为key的所有点的x坐标值的集合</span></span><br><span class="line">    HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">      <span class="comment">//找出最左边和最右边对应点的x坐标值</span></span><br><span class="line">      max = Math.max(max, points[i].x);</span><br><span class="line">      min = Math.min(min, points[i].x);</span><br><span class="line">      <span class="keyword">if</span>(!map.containsKey(points[i].y))&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(points[i].x);</span><br><span class="line">        map.put(points[i].y, set);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.get(points[i].y).add(points[i].x);</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//max-y0 = y0-min; p-y0 = y0 - p' =&gt; p' = max+min-p</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++)&#123;</span><br><span class="line">      <span class="comment">//根据对称轴判断其他点是否都有对应的点</span></span><br><span class="line">      <span class="keyword">if</span>(!map.containsKey(points[i].y) || !map.get(points[i].y).contains(max+min-points[i].x))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">int</span> y;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">()</span></span>&#123;x = <span class="number">0</span>; y = <span class="number">0</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;x = a; y = b;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组补丁">数组补丁</h2><h3 id="题目描述-1">题目描述</h3><p>给出一个从小到大排好序的整数数组nums和一个整数n，在数组中添加若干个补丁（元素）使得[1,n]的区间内的所有数都可以表示成nums中若干个数的和。返回最少需要添加的补丁个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>], n = <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>返回1，表示至少需要添加1个数｛2｝，才可以表示1到6之间所有数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">2</span>:</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>], n = <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>返回2，表示至少需要添加两个数｛2，4｝，才可以表示1到20之间所有数。</p>
<p>我们不妨先思考一个简单的问题，如果nums数组为空，那么最少需要多少个数字才能表示1到n之间所有数？相信大家都可以想到一个贪心算法，即按照1、2、4、8…都顺序添加，每次加入都数都比之前所有数的总和大1，直到总和大于n。本题的难点是预先给出了一些数，但这不影响我们的贪心策略：假设nums当前至多可以表示1到m之间的所有数，加入m+1；直到m大于等于n。</p>
<p>变量miss表示[0,n]中我们缺少的最小的和，也就是说nums中元素求和我们已经能得到[0,miss)范围内的数<br>遍历nums数组，如果nums[i] &lt;= miss,那么我们可以将我们能得到的和的范围[0,miss)扩充到[0,miss+nums[i]);如果nums[i] &gt; miss,那么我们将不能连续扩充[0,miss),也就是说[0,miss+nums[i])的一些元素我们不能得到，则这时我们需要patch元素，那么应该patch什么数？我们采用贪心算法，我们patch的元素为miss，因为选择miss可以得到最大的连续区间[0, miss+miss)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化为缺少1</span></span><br><span class="line">    <span class="keyword">int</span> miss = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//统计patch的数量</span></span><br><span class="line">    <span class="keyword">int</span> patch = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">//如果溢出，miss小于0</span></span><br><span class="line">    <span class="keyword">while</span>(miss &gt; <span class="number">0</span> &amp;&amp; miss &lt;= n)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i &lt; nums.length &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">        miss = miss + nums[i];</span><br><span class="line">        i++;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//扩充miss</span></span><br><span class="line">        miss = miss + miss;</span><br><span class="line">        patch++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> patch;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="不构造树的情况下验证先序遍历">不构造树的情况下验证先序遍历</h2><h3 id="题目描述-2">题目描述</h3><p>给出一个字符序列，问该序列是否是一棵合法的二叉树的先序遍历？<br>找到一种不需要构造二叉树的方法。<br>For example：<br>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>是下面这颗二叉树的先序遍历。其中＃代表空节点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">9</span></span><br><span class="line">       /      \</span><br><span class="line">      <span class="number">3</span>       <span class="number">2</span></span><br><span class="line">    /   \   /    \</span><br><span class="line">   <span class="number">4</span>     <span class="number">1</span> <span class="preprocessor">#      <span class="number">6</span></span></span><br><span class="line"> /   \  / \      / \</span><br><span class="line"><span class="preprocessor">#    #  #  #    #   #</span></span><br></pre></td></tr></table></figure></p>
<h3 id="分析解答">分析解答</h3><p>通过观察上图中二叉树我们可以发现，一棵合法的二叉树去掉某个叶子节点后仍是合法的二叉树。在给出的字符序列中，叶子节点有很明显的特征，即叶子节点之后一定紧跟两个空节点＃。通过不断的把number,#,#的子串缩成空节点#(把number,#,#子串替换为#)，如果最后字符序列可以缩短到只有一个字符＃，那它就是我们要找的合法的先序遍历了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span></span>&#123;</span><br><span class="line">    String s = preorder;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.length() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> index = s.indexOf(<span class="string">",#,#"</span>);</span><br><span class="line">      <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> start = index;</span><br><span class="line">      <span class="comment">//找到,#,#前一个节点</span></span><br><span class="line">      <span class="comment">//有可能数字有多位</span></span><br><span class="line">      <span class="keyword">while</span>(start &gt; <span class="number">0</span> &amp;&amp; s.charAt(start-<span class="number">1</span>) != <span class="string">','</span>)&#123;</span><br><span class="line">        start--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(s.charAt(start) == <span class="string">'#'</span>)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      s = s.substring(<span class="number">0</span>,start)+s.substring(index+<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"#"</span>) &amp;&amp; flag) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摆动排序_II">摆动排序 II</h2><p>给出一个整数数组nums，重新排列nums使得nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…<br>Example:<br>nums = [1, 5, 1, 1, 6, 4], 一个可能的答案是[1, 4, 1, 5, 1, 6]<br>数据保证必定有解。</p>
<h2 id="分析解答-1">分析解答</h2><p>本题有一种简单的做法，先快速排序，然后把最小的一半依次放在奇数位上，最大的一半依次放在偶数位上。算法复杂度是快速排序的复杂度O(NlogN)。仔细思考后发现快速排序不是必要的，只需要找到中位数即可。利用快速排序的思想找中位数的期望时间复杂度是O(N)。为了防止相等的数放在一起，需要注意放置的顺序。笔者采用的方法是依nums长度分两种情况：若长度为奇数，把比中位数小的依次放在0,2,4,…位置，比中位数大的依次放在length-2,length-4,…位置；若长度为偶数，把比中位数小的依次放在length-2,length-4,…位置，比中位数大的依次放在1,3,5,…位置。其余位置填充中位数。这样可以保证中位数一定与较小与较大的数相邻（题目保证一定有解）。</p>
<p>排序解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先排序数组，然后将数组的前半部分和后半部分merge起来</span></span><br><span class="line">    <span class="comment">//把更大的一般放到奇数下标中，更小的一半放到偶数下标中</span></span><br><span class="line">    <span class="comment">//比如nums=[1,2,3,4,5,6,7]</span></span><br><span class="line">    <span class="comment">//4 3 2 1</span></span><br><span class="line">    <span class="comment">// 7 6 5 = &gt; 4 7 3 6 2 5 1</span></span><br><span class="line">    <span class="comment">//该种解法只要输入中存在valid answer就能正确找到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        <span class="comment">//排序，分成两部分</span></span><br><span class="line">        Arrays.sort(copy);</span><br><span class="line">        <span class="comment">//left初始时指向中间元素的后一元素</span></span><br><span class="line">        <span class="keyword">int</span> right = nums.length, left = (nums.length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? copy[--left] : copy[--right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="矩阵中的最长上升路径">矩阵中的最长上升路径</h2><h3 id="题目描述-3">题目描述</h3><p>给出一个数字矩阵，寻找一条最长上升路径，每个位置只能向上下左右四个位置移动。<br>Example：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>返回 4，最长上升路径是[1, 2, 6, 9].</p>
<h3 id="分析解答-2">分析解答</h3><p>最直观的做法是穷举每一个数字作为起点，dfs寻找最长上升路径，时间复杂度是指数级别的。仔细思考dfs有些盲目，此题中的最长上升路径很符合bfs的特点（每次向外扩展一层），bfs可以显著降低时间复杂度，朴素的bfs复杂度为O(n^4)，因为在bfs的过程中，每个位置最多会经过k次（k为到这个点对最长上升路径长度，最大可能为n^2）。如果使用动态规划的思路，把到每个位置的最长上升路径长度储存下来，那每个点只会计算一次，可以使复杂度变为O(n^2)。当前位置最长上升路径可以通过周围四个点的最长上升路径而得到。但是这里有个问题就是动态规划的穷举顺序，有两种方法解决，一是通过拓扑排序来确定穷举顺序，因为最长上升路径总是从小到大扩展的；二是通过记忆化搜索实现动态规划，记忆化搜索是搜索和动态规划的结合，在搜索过程中记录已经求解完毕的状态，使得每个状态只需进行一次搜索。在本题中，dp[i][j]记录在(i,j)位置可以得到的最长上升路径，其值通过搜索相邻四个位置的dp值确定；flag[i][j]表示(i,j)位置的解是否已经搜索完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//四个搜索方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> len = dfs(matrix, i, j, row, col, cache);</span><br><span class="line">                max = Math.max(max, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度搜索从[i][j]出发的最长递增路径的长度</span></span><br><span class="line">    <span class="comment">//cache缓存，即备忘录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] cache)</span></span>&#123;</span><br><span class="line">        <span class="comment">//已经搜索过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(cache[i][j] != <span class="number">0</span>) <span class="keyword">return</span> cache[i][j];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//四个方向搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//matrix[x][y] &lt;= matrix[i][j]可以避免使用visited[row][col]数组</span></span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= row || y &lt; <span class="number">0</span> || y &gt;= col || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span> + dfs(matrix, x, y, row, col, cache);</span><br><span class="line">            max = Math.max(len, max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache[i][j] = max;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="岛屿计数2">岛屿计数2</h2><h2 id="Count_of_Smaller_Numbers_After_Self(数组计数)">Count of Smaller Numbers After Self(数组计数)</h2><h3 id="题目描述-4">题目描述</h3><p>给定一个数组nums,返回一个计数数组count，count[i]表示nums中第i个右边有多少个数小于nums[i]<br>Example:<br>nums = [5, 2, 6, 1]<br>输出[2,1,1,0]</p>
<h3 id="分析解答-3">分析解答</h3><p>此题不难给出O(N^2)的算法，先穷举nums中每个位置i，再穷举右边的数计算有多少个小于nums[i]。难点在于利用数据结构进行优化从而降低时间复杂度。线段树（segment tree）和平衡树（Balanced Binary Tree）是两种可以使用的数据结构。</p>
<p>线段树的每个节点表示一段区间，记录这个区间的某些信息，其基本思想是把区间一分为二，二分为四。。。直到不可再分（因此叶子节点的区间只包含一个数），如此可以把任意区间表示成log（区间大小）个子区间的拼接，以降低查询时间复杂度。在本题中，假设nums中的数字范围在0到maxnum之间，那么建树的区间为[0,maxnum]（也就是根节点所表示的区间）。每个节点记录其表示区间内的数字个数。本题涉及两种线段树基本操作：插入和查询。插入操作把nums[i]插入到线段树相应位置，同时对所有经过的区间的sum值进行累加；查询操作需要查询区间[0,nums[i]-1]所包含的数字个数，利用已经建好的线段树把查询区间分割为若干个节点所表示的区间，统计并返回这些节点的sum值之和。</p>
<p>平衡树用途更广，代码复杂度也更高，是一种保持叶子节点深度平衡的二叉搜索树，有多种方法实现，因篇幅有限不再赘述，大家可以自行在网上搜索学习。</p>
<h2 id="翻转游戏（Flip_Game_II）">翻转游戏（Flip Game II）</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&amp;mid=401839317&amp;idx=1&amp;sn=0660926cc1e5edab1b92aa8160fa93e6&amp;scene=21#wechat_redirect" target="_blank" rel="external">详见</a></p>
<p>搜索+回溯：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWin</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] state = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span>)&#123;</span><br><span class="line">        state[i] = <span class="keyword">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        state[i] = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search(state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">boolean</span>[] state)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; state.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//连续加号</span></span><br><span class="line">      <span class="keyword">if</span>(state[i] &amp;&amp; state[i+<span class="number">1</span>])&#123;</span><br><span class="line">        state[i] = <span class="keyword">false</span>;</span><br><span class="line">        state[i+<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//不能继续翻转</span></span><br><span class="line">        <span class="keyword">if</span>(!search(state))&#123;</span><br><span class="line">          state[i] = <span class="keyword">true</span>;</span><br><span class="line">          state[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//能继续翻转，回溯</span></span><br><span class="line">          state[i] = <span class="keyword">true</span>;</span><br><span class="line">          state[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="吹气球">吹气球</h2><h3 id="题目描述-5">题目描述</h3><p>有n个气球，编号为0到n-1，每个气球都有一个分数，存在nums数组中。每次吹气球i可以得到的分数为 nums[left] <em> nums[i] </em> nums[right]，left和right分别表示i气球相邻的两个气球。当i气球被吹爆后，其左右两气球即为相邻。要求吹爆所有气球，得到最多的分数。<br>注释:<br>(1) 你可以假设nums[-1] = nums[n] = 1<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>Example:<br>给出[3, 1, 5, 8]<br>返回167</p>
<p>dp解法：<br>Definition:<br>     dp[i][j]表示吹爆i到j之间的气球所能得到的最大分数</p>
<p>Function:<br>     dp[i][j] = max(dp[i][k-1] + score(k) + dp[k+1][j]) 对于所有k属于{i,j}</p>
<p>Intialize:<br>     dp[i][i] = 0 for each i.</p>
<p>Answer:<br>     dp[1][n]</p>
<h2 id="题目链接">题目链接</h2><p><a href="http://posts.careerengine.us/p/579993895afff74f7f7f9e42" target="_blank" rel="external">题目</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="轴对称">轴对称</h2><h3 id="题目描述">题目描述</h3><p>给定平面上的n个点，问是否存在一条平行于y轴的直线，使得这n个点相对于这条直线对称。</p>
<p><strong>Follow-up</strong><br>是否存在一条直线使得这n个]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Kth Smallest Element in a Sorted Matrix]]></title>
    <link href="http://blog.noobsky.com/2016/10/07/LeetCode-Kth-Smallest-Element-in-a-Sorted-Matrix/"/>
    <id>http://blog.noobsky.com/2016/10/07/LeetCode-Kth-Smallest-Element-in-a-Sorted-Matrix/</id>
    <published>2016-10-07T11:51:14.000Z</published>
    <updated>2016-10-08T08:32:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p><strong>Example:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">9</span>],</span><br><span class="line">   [<span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">   [<span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>]</span><br><span class="line">],</span><br><span class="line">k = <span class="number">8</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">13.</span></span><br></pre></td></tr></table></figure></p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ n2.</p>
<h2 id="解题思路">解题思路</h2><p>每一列、每一行都是有序的。其实这个问题类似k路归并排序。全部行或者全部列就是那k路有序数组。<br>可以利用最小堆。<br>首先利用第一行（或第一列）构造最小堆。然后进行k-1次取出最小堆的堆顶元素，取出堆顶元素之后，将所取堆顶元素所在列的下一元素加入最小堆中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int n = matrix.length;</span></span><br><span class="line">        PriorityQueue&lt;Tuple&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> bound = matrix.length &lt; k ? matrix.length : k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; i++) pq.offer(<span class="keyword">new</span> Tuple(<span class="number">0</span>,i,matrix[<span class="number">0</span>][i]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            Tuple t = pq.poll();</span><br><span class="line">            <span class="comment">//已经是某列的最后一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(t.row == matrix.length-<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> Tuple(t.row+<span class="number">1</span>, t.col, matrix[t.row+<span class="number">1</span>][t.col]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要知道元素对应的行或者列，所以使用Tuple类表示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tuple</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, col, val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.row = row;</span><br><span class="line">        <span class="keyword">this</span>.col = col;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Tuple that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - that.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest eleme]]>
    </summary>
    
      <category term="Binary Search" scheme="http://blog.noobsky.com/tags/Binary-Search/"/>
    
      <category term="Heap" scheme="http://blog.noobsky.com/tags/Heap/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
