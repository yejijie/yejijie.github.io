<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-06-26T07:53:46.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Intersection of Two Arrays I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Intersection-of-Two-Arrays-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Intersection-of-Two-Arrays-I-II/</id>
    <published>2016-06-26T07:10:50.000Z</published>
    <updated>2016-06-26T07:53:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Intersection_of_Two_Arrays_I">Intersection of Two Arrays I</h2><h3 id="题目描述">题目描述</h3><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong> Example: </strong><br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>
<p><strong> Note: </strong></p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
<h3 id="代码">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	 <span class="comment">//使用HashSet，分别遍历两个数组</span></span><br><span class="line">    <span class="comment">//首先把第一个数组加入到集合中</span></span><br><span class="line">    <span class="comment">//然后遍历第二个数组时判断集合中是否包含元素</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(n)，空间复杂度为O(n)</span></span><br><span class="line">    public <span class="built_in">int</span>[] intersection(<span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; <span class="literal">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//利用集合对交集进行去重</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; intersect = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num1: nums1)&#123;</span><br><span class="line">            <span class="literal">set</span>.add(num1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num2: nums2)&#123;</span><br><span class="line">            <span class="comment">//nums1中包含</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">set</span>.contains(num2))&#123;</span><br><span class="line">                intersect.add(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[intersect.size()];</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer <span class="built_in">num</span> : intersect)&#123;</span><br><span class="line">            res[i++] = <span class="built_in">num</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//另外还可以先排序然后使用tow pointers，类似merge array，时间复杂度为O(n)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">set</span>.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">set</span>.size()];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : <span class="built_in">set</span>)&#123;</span><br><span class="line">            res[k++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或者对一个数组排序，然后使用二分搜索在排序数组中搜索另一个数组的元素</span></span><br><span class="line">    <span class="comment">//时间复杂度都为O(nlgn)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Intersection_of_Two_Arrays_II">Intersection of Two Arrays II</h2><h3 id="题目描述-1">题目描述</h3><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong> Example: </strong><br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>
<p><strong> Note: </strong></p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p><strong> Follow up: </strong></p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<h3 id="代码-1">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Solution</span>&#123;</span><br><span class="line">	    //使用<span class="type">HashMap</span>，key为nums1中的元素，value为该元素出现的次数</span><br><span class="line">    //时间复杂度为O(n)，空间复杂度为O(n)</span><br><span class="line">    public <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> new <span class="type">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">Integer</span>, <span class="type">Integer</span>&gt; map = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; <span class="literal">result</span> = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num1 : nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num1))&#123;</span><br><span class="line">                map.put(num1, map.get(num1) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num1, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num2: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num2) &amp;&amp; map.get(num2) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="literal">result</span>.add(num2);</span><br><span class="line">                map.put(num2, map.get(num2) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] res = new <span class="type">int</span>[<span class="literal">result</span>.size()];</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Integer</span> num: <span class="literal">result</span>)&#123;</span><br><span class="line">            res[i++] = num;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Solution</span>&#123;</span><br><span class="line">	    //时间复杂度为O(nlgn)， 空间复杂度为O(n)</span><br><span class="line">    public <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> new <span class="type">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">Arrays</span>.sort(nums1);</span><br><span class="line">        <span class="type">Arrays</span>.sort(nums2);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; <span class="literal">result</span> = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="literal">result</span>.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] res = new <span class="type">int</span>[<span class="literal">result</span>.size()];</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Integer</span> num : <span class="literal">result</span>)&#123;</span><br><span class="line">            res[k++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution_to_3rd_follow-up_question">Solution to 3rd follow-up question</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What <span class="keyword">if</span> elements <span class="keyword">of</span> nums2 are stored <span class="function_start"><span class="keyword">on</span></span> disk, <span class="keyword">and</span> <span class="keyword">the</span> memory <span class="keyword">is</span> limited such <span class="keyword">that</span> you cannot load all elements <span class="keyword">into</span> <span class="keyword">the</span> memory <span class="keyword">at</span> once?</span><br></pre></td></tr></table></figure>
<ul>
<li><p>If only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</p>
</li>
<li><p>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), then read 2 elements from each array at a time in memory, record intersections.</p>
</li>
</ul>
<p>Thanks for the solution. I think the second part of the solution is impractical, if you read 2 elements at a time, this procedure will take forever. In principle, we want minimize the number of disk access during the run-time.</p>
<p>An improvement can be sort them using external sort, read (let’s say) 2G of each into memory and then using the 2 pointer technique, then read 2G more from the array that has been exhausted. Repeat this until no more data to read from disk.</p>
<p>But I am not sure this solution is good enough for an interview setting. Maybe the interviewer is expecting some solution using Map-Reduce paradigm.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Intersection_of_Two_Arrays_I">Intersection of Two Arrays I</h2><h3 id="题目描述">题目描述</h3><p>Given two arrays, write a function to compu]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Count of Smaller Numbers After Self and Count of Range Sum]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Count-of-Smaller-Numbers-After-Self-and-Count-of-Range-Sum/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Count-of-Smaller-Numbers-After-Self-and-Count-of-Range-Sum/</id>
    <published>2016-06-26T04:03:35.000Z</published>
    <updated>2016-06-26T04:03:35.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximum Gap]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Maximum-Gap/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Maximum-Gap/</id>
    <published>2016-06-26T03:01:25.000Z</published>
    <updated>2016-06-26T03:33:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Try to solve it in linear time/space.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>
<h2 id="代码">代码</h2><ul>
<li>解法一</li>
</ul>
<p>排序，依次计算相邻元素，时间复杂度不符合要求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//时间复杂度为O(nlgn)不符合要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxGap = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            maxGap = Math.max(maxGap, nums[i+<span class="number">1</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<p>[Thoughts]<br>Suppose there are N elements and they range from A to B.<br>Then the maximum gap will be no smaller than ceiling[(B - A) / (N - 1)]<br>Let the length of a bucket to be len = ceiling[(B - A) / (N - 1)], then we will have at most num = (B - A) / len + 1 of bucket<br>for any number K in the array, we can easily find out which bucket it belongs by calculating loc = (K - A) / len and therefore maintain the maximum and minimum elements in each bucket.<br>Since the maximum difference between elements in the same buckets will be at most len - 1, so the final answer will not be taken from two elements in the same buckets.<br>For each non-empty buckets p, find the next non-empty buckets q, then q.min - p.max could be the potential answer to the question. Return the maximum of all those values.</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">//时间复杂度为O(nlgn)不符合要求</span></span><br><span class="line">    <span class="comment">// public int maximumGap(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length &lt;= 1) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     Arrays.sort(nums);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int maxGap = Integer.MIN_VALUE;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length - 1; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         maxGap = Math.max(maxGap, nums[i+1] - nums[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return maxGap;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//桶排序</span></span><br><span class="line">    <span class="comment">//最大的gap必定是两个相邻桶的最小值和最大值之差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maximumGap(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">min</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//求数组中最大最小元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num: nums)&#123;</span><br><span class="line">            <span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, num);</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不然后面的gap会为0，/gap抛出除0异常</span></span><br><span class="line">        <span class="comment">//或者后面的gap至少为1，Math.max(1, ...);</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span> == <span class="built_in">max</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// the minimum possibale gap, ceiling of the integer division</span></span><br><span class="line">        <span class="comment">//也是桶的range</span></span><br><span class="line">        <span class="built_in">int</span> gap = (<span class="built_in">int</span>)Math.<span class="built_in">ceil</span>((<span class="keyword">double</span>)(<span class="built_in">max</span> - <span class="built_in">min</span>) / (nums.length - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> bucketLen = (<span class="built_in">max</span> - <span class="built_in">min</span>)/gap + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只保存桶的最大最小元素即可</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] bucketsMin = <span class="keyword">new</span> <span class="built_in">int</span>[bucketLen];</span><br><span class="line">        <span class="built_in">int</span>[] bucketsMax = <span class="keyword">new</span> <span class="built_in">int</span>[bucketLen];</span><br><span class="line">        </span><br><span class="line">        Arrays.<span class="built_in">fill</span>(bucketsMin, Integer.MAX_VALUE);</span><br><span class="line">        Arrays.<span class="built_in">fill</span>(bucketsMax, Integer.MIN_VALUE);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num: nums)&#123;</span><br><span class="line">            <span class="built_in">int</span> bucketIndex = (num - <span class="built_in">min</span>) / gap;</span><br><span class="line">            <span class="comment">//更新每个桶的最大最小值</span></span><br><span class="line">            bucketsMin[bucketIndex] = Math.<span class="built_in">min</span>(bucketsMin[bucketIndex], num);</span><br><span class="line">            bucketsMax[bucketIndex] = Math.<span class="built_in">max</span>(bucketsMax[bucketIndex], num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> maxGap = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//前一个桶的最大值</span></span><br><span class="line">        <span class="built_in">int</span> prev = <span class="built_in">min</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bucketLen; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucketsMin[i] == Integer.MAX_VALUE) <span class="keyword">continue</span>;<span class="comment">//empty bucket</span></span><br><span class="line">            maxGap = Math.<span class="built_in">max</span>(maxGap, bucketsMin[i] - prev);</span><br><span class="line">            prev = bucketsMax[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Tr]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sliding Window Maximum]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-Sliding-Window-Maximum/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-Sliding-Window-Maximum/</id>
    <published>2016-06-25T13:01:48.000Z</published>
    <updated>2016-06-25T16:33:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>] -<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [-<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span> [-<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>Therefore, return the max sliding window as [3,3,5,5,6,7].</p>
<p><strong> Note: </strong><br>You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong> Follow up: </strong><br>Could you solve it in linear time?</p>
<p><strong> Hint: </strong></p>
<ol>
<li>How about using a data structure such as deque (double-ended queue)?</li>
<li>The queue size need not be the same as the window’s size.</li>
<li>Remove redundant elements and the queue should store only elements that need to be considered.</li>
</ol>
<h2 id="代码">代码</h2><ul>
<li>解法一</li>
</ul>
<p>使用堆，维护一个大小为k的最大堆，堆中存放滑动窗口的中元素，时间复杂度为O(nlgk)，空间复杂度为O(k)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//维护一个最大堆，并维护堆的大小为k即窗口大小，则堆顶元素即为每个滑动窗口的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//Collections.reverseOrder()返回一个逆序的Comparator，则构建一个最大堆</span></span><br><span class="line">        <span class="comment">//Arrays.sort(arr, Collections.reverseOrder())</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//滑动窗口大小已经为k，删除窗口最左边的元素，为下一个元素腾空间</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) pq.remove(nums[i-k]);</span><br><span class="line">            pq.offer(nums[i]);</span><br><span class="line">            <span class="comment">//窗口大小已经为k</span></span><br><span class="line">            <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) res[i-k+<span class="number">1</span>] = pq.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>解法二</li>
</ul>
<p>使用双端队列，时间复杂度为O(n)，空间复杂度为O(k)。<br>当遍历到数组中一个新元素时，将该元素与队列中队尾元素相比较，如果末尾元素比新元素小，则移除末尾元素，直到该队列的末尾元素比新元素大或者队列为空时才停止。这样我们可以保证队头元素是窗口[i-(k-1), i]中最大的元素，其实队列中的窗口中元素降序。由于我们我们新加数的时候，已经把很多没用的元素移除了，无法正确的判断队列中滑动窗口的大小。这里比较tricky的就是在队列中保存元素在数组中下标，这样既能知道这个数的值，也能判断该数是不是窗口最左边的数。这里的均摊时间复杂度为O(n)，因为每个元素被加入队列和移除队列各一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//使用双端队列存元素在数组中的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//nums.length - k + 1个滑动窗口</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="comment">//dq.peek() == i-k</span></span><br><span class="line">            <span class="comment">//滑动窗口大小已经为k，删除窗口最左边的元素，为下一个元素腾空间</span></span><br><span class="line">            <span class="keyword">if</span>(!dq.isEmpty() &amp;&amp; dq.peek() &lt; i - k + <span class="number">1</span>)&#123;</span><br><span class="line">                dq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//我们将nums[i]加入队尾之前，如果队列中元素小于nums[i]，则可以删除，因为他们不可能是滑动窗口的最大值</span></span><br><span class="line">            <span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt; nums[i])&#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dq.offer(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) res[i-k+<span class="number">1</span>] = nums[dq.peek()];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the ve]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]One Edit Distance And Edit Distance]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-One-Edit-Distance-And-Edit-Distance/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-One-Edit-Distance-And-Edit-Distance/</id>
    <published>2016-06-25T04:00:10.000Z</published>
    <updated>2016-06-25T12:03:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="One_Edit_Distance">One Edit Distance</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Edit_Distance">Edit Distance</h2><h3 id="题目描述-1">题目描述</h3><p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
<h3 id="代码-1">代码</h3><p>dp[i][j]表示word1[0…i-1]转换到word2[0…j-1]的最少操作步数(编辑距离)。 下面来看状态转移方程。<br>边界情况：</p>
<ul>
<li><p>dp[i][0] = i</p>
</li>
<li><p>dp[0][j] = j </p>
</li>
</ul>
<p>这两个结论都很显然，比如word1[0…i-1]到空字符串””的编辑距离显然是i（i次删除）。</p>
<p>接下来看word1[0…i-1]到word2[0…j-1]，子问题就是word1[0…i-2]转换到word2[0…j-2]的编辑距离，也就是dp[i-1][j-1]。现在考虑word1[i-1]和word2[j-1]关系，如果它们相等，则dp[i][j] = dp[i-1][j-1]，如果word1[i-1]和word2[j-1]不相等，则有以下三种情况。</p>
<ol>
<li>替换：将word1[i-1]替换成word2[j-1]，则dp[i][j] = dp[i-1][j-1] + 1 </li>
<li>删除：将word1[i-1]删除后，则dp[i][j] = dp[i-1][j] + 1</li>
<li>插入：将word2[j-1]插入到word1[i-1]的后面，则dp[i][j] = dp[i][j-1] + 1</li>
</ol>
<p>所以，状态转移方程如下：</p>
<ol>
<li>dp[i][0] = i;</li>
<li>dp[0][j] = j;</li>
<li>dp[i][j] = dp[i-1][j-1] + 1, if word1[i-1] = word2[j-1]</li>
<li>dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1, dp[i][j-1] + 1), if word1[i-1] != word2[j-1]</li>
</ol>
<p>根据以上状态转移方程，可得如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word1 == null || word2 == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=n; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>, dp[i-<span class="number">1</span>][j] + <span class="number">1</span>), dp[i][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp[i][j]只跟dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]有关系，其实我们并不需要维护m*n的矩阵，维护一行或一列就可以了，空间复杂度能够降到O(m)或者O(n)。</p>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.geeksforgeeks.org/dynamic-programming-set-5-edit-distance/" target="_blank" rel="external">Dynamic Programming | Set 5 (Edit Distance)</a><br><a href="https://leetcode.com/discuss/43398/20ms-detailed-explained-c-solutions-o-n-space" target="_blank" rel="external">20ms Detailed Explained C++ Solutions (O(n) Space)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="One_Edit_Distance">One Edit Distance</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Edit_Distance">Edit Distance</h2><h3 id="]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Distinct Subsequences]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-Distinct-Subsequences/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-Distinct-Subsequences/</id>
    <published>2016-06-25T02:34:18.000Z</published>
    <updated>2016-06-25T03:25:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>Here is an example:<br>S = “rabbbit”, T = “rabbit”</p>
<p>Return 3.</p>
<h2 id="代码">代码</h2><p>dp[i][j]表示T[0…j-1]在S[0…i-1]中distinc subsequences的数量，则以S =”rabbbit”,T = “rabbit”为例）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    r a b b b i t</span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">r <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">a <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">i <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">t <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>所以状态转移方程为</p>
<p>dp[0][0] = 1; // T和S都是空串.<br>dp[0][1 … S.length() - 1] = 1; // T是空串，S只有一种子序列匹配。<br>dp[1 … T.length() - 1][0] = 0; // S是空串，T不是空串，S没有子序列匹配。<br>dp[i][j] = dp[i][j - 1] + (T[i - 1] == S[j - 1] ? dp[i - 1][j - 1] : 0).1 &lt;= i &lt;= T.length(), 1 &lt;= j &lt;= S.length()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(s.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return t.length() == 0 ? 1 : 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(t.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i-<span class="number">1</span>) == s.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[t.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a st]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Trapping Rain Water]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-Trapping-Rain-Water/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-Trapping-Rain-Water/</id>
    <published>2016-06-25T01:00:24.000Z</published>
    <updated>2016-06-25T01:39:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="http://articles.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt=""><br>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<h2 id="代码">代码</h2><p>对任意位置i，在i上的积水，由左右两边最高的bar：A[left] = max{A[j], j<i}, a[right]="max{A[j]," j="">i}决定。定义Hmin = min(A[left], A[right])，则积水量Si为：</i},></p>
<p>Hmin &lt;= A[i]时，Si = 0<br>Hmin &gt; A[i]时，Si = Hmin - A[i]</p>
<p>简单的说，对于某个值A[i]来说，能trapped的最多的water取决于在i之前最高海拔leftMostHeight[i]和i右边最高的海拔值rightMostHeight[i]。如果min(leftMostHeight[i], rightMostHeight[i]) &gt; A[i]，那么在i这个位置上能trapped的water就是min(leftMostHeight[i], rightMostHeight[i]) - A[i]。所以根据以上思想，进行两遍for循环，第一遍从左到右计算数组leftMostHeight，第二遍从右到左计算rightMostHeight同时也可以计算出i位置的结果。时间复杂度为O(n)，空间复杂度为O(n)。 </p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">// public int trap(int[] height) &#123;</span></span><br><span class="line">    <span class="comment">//     if(height == null || height.length == 0) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int res = 0;</span></span><br><span class="line">    <span class="comment">//     //非负数组，可以初始化为0，否则考虑height[0]</span></span><br><span class="line">    <span class="comment">//     int max = 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int[] leftMostHeight = new int[height.length];</span></span><br><span class="line">    <span class="comment">//     int[] rightMostHeight = new int[height.length];</span></span><br><span class="line">    <span class="comment">//     //leftMostHeight[i]为0~i-1中的最大值</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; height.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         leftMostHeight[i] = max;</span></span><br><span class="line">    <span class="comment">//         max = Math.max(max, height[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     max = 0;</span></span><br><span class="line">    <span class="comment">//     for(int i = height.length - 1; i &gt;= 0; i--)&#123;</span></span><br><span class="line">    <span class="comment">//         rightMostHeight[i] = max;</span></span><br><span class="line">    <span class="comment">//         max = Math.max(max, height[i]);</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">//         int container = Math.min(leftMostHeight[i], rightMostHeight[i]);</span></span><br><span class="line">    <span class="comment">//         res += container &gt; height[i] ? container - height[i] : 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其实rightMostHeight数组没必要存了，直接用max变量保存就可以了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> trap(<span class="built_in">int</span>[] <span class="variable">height</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">height</span> == <span class="keyword">null</span> || <span class="variable">height</span>.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//非负数组，可以初始化为0，否则考虑height[0]</span></span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] leftMostHeight = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="variable">height</span>.length];</span><br><span class="line">        <span class="comment">//leftMostHeight[i]为0~i-1中的最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="variable">height</span>.length; i++)&#123;</span><br><span class="line">            leftMostHeight[i] = <span class="built_in">max</span>;</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, <span class="variable">height</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="variable">height</span>.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> container = Math.<span class="built_in">min</span>(leftMostHeight[i], <span class="built_in">max</span>);</span><br><span class="line">            res += container &gt; <span class="variable">height</span>[i] ? container - <span class="variable">height</span>[i] : <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, <span class="variable">height</span>[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有更tricky的方法只扫描一遍即可，这里先贴上C++代码，有时间再研究一下：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> trap(<span class="built_in">int</span> A[], <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>; <span class="built_in">int</span> <span class="built_in">right</span>=n-<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> maxleft=<span class="number">0</span>, maxright=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[<span class="built_in">left</span>]&lt;=A[<span class="built_in">right</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[<span class="built_in">left</span>]&gt;=maxleft) maxleft=A[<span class="built_in">left</span>];</span><br><span class="line">                <span class="keyword">else</span> res+=maxleft-A[<span class="built_in">left</span>];</span><br><span class="line">                <span class="built_in">left</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[<span class="built_in">right</span>]&gt;=maxright) maxright= A[<span class="built_in">right</span>];</span><br><span class="line">                <span class="keyword">else</span> res+=maxright-A[<span class="built_in">right</span>];</span><br><span class="line">                <span class="built_in">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much wat]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Find the Duplicate Number]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Find-the-Duplicate-Number/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Find-the-Duplicate-Number/</id>
    <published>2016-06-21T10:02:00.000Z</published>
    <updated>2016-06-21T10:02:00.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Preorder/Inorder/Postorder Traversal]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/</id>
    <published>2016-06-21T06:20:02.000Z</published>
    <updated>2016-06-21T06:21:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Binary_Tree_Inorder_Traversal">Binary Tree Inorder Traversal</h2><h3 id="题目描述-1">题目描述</h3><h3 id="代码-1">代码</h3><h2 id="Binary_Tree_Postorder_Traversal">Binary Tree Postorder Traversal</h2><h3 id="题目描述-2">题目描述</h3><h3 id="代码-2">代码</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Binary_Tree_Ino]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Fraction to Recurring Decimal]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Fraction-to-Recurring-Decimal/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Fraction-to-Recurring-Decimal/</id>
    <published>2016-06-21T06:11:07.000Z</published>
    <updated>2016-06-21T06:12:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>For example,</p>
<ul>
<li>Given numerator = 1, denominator = 2, return “0.5”.</li>
<li>Given numerator = 2, denominator = 1, return “2”.</li>
<li>Given numerator = 2, denominator = 3, return “0.(6)”.</li>
</ul>
<p><strong> Hint: </strong></p>
<ol>
<li>No scary math, just apply elementary math knowledge. Still remember how to perform a long division?</li>
<li>Try a long division on 4/9, the repeating part is obvious. Now try 4/333. Do you see a pattern?</li>
<li>Be wary of edge cases! List out as many test cases as you can think of and test your code thoroughly.</li>
</ol>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分母为0</span></span><br><span class="line">        <span class="keyword">if</span>(denominator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"NaN"</span>;</span><br><span class="line">        <span class="keyword">if</span>(numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//异或为true说明符合相异</span></span><br><span class="line">        <span class="keyword">if</span>((numerator &gt; <span class="number">0</span>) ^ (denominator &gt; <span class="number">0</span>)) sb.append(<span class="string">"-"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//MIN_VALUE的绝对值会溢出，所以用long类型</span></span><br><span class="line">        <span class="keyword">long</span> num = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)numerator);</span><br><span class="line">        <span class="keyword">long</span> den = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)denominator);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//整数部分</span></span><br><span class="line">        sb.append(num/den);</span><br><span class="line">        </span><br><span class="line">        num = num % den;</span><br><span class="line">        <span class="comment">//能整除直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不能整除，存在小数部分，先加入小数点</span></span><br><span class="line">        sb.append(<span class="string">"."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//余数</span></span><br><span class="line">        <span class="keyword">long</span> remainder = num;</span><br><span class="line">        <span class="comment">//使用HashMap记录余数和在结果res中的下标，记录下标是因为出现循环小数要插入括号</span></span><br><span class="line">        <span class="comment">//key为余数，value为下标</span></span><br><span class="line">        <span class="comment">//当重复出现某一个余数时说明结果为循环小数</span></span><br><span class="line">        HashMap&lt;Long, Integer&gt; <span class="built_in">map</span>= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(remainder != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//出现重复余数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(remainder))&#123;</span><br><span class="line">                sb.insert(<span class="built_in">map</span>.get(remainder), <span class="string">"("</span>);</span><br><span class="line">                sb.append(<span class="string">")"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将余数加入map中</span></span><br><span class="line">            <span class="built_in">map</span>.put(remainder, sb.length());</span><br><span class="line">            <span class="comment">//并计算一位小数</span></span><br><span class="line">            remainder *= <span class="number">10</span>;</span><br><span class="line">            sb.append(remainder/den);</span><br><span class="line">            remainder = remainder % den;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Flatten Binary Tree to Linked List]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Flatten-Binary-Tree-to-Linked-List/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Flatten-Binary-Tree-to-Linked-List/</id>
    <published>2016-06-21T03:16:39.000Z</published>
    <updated>2016-06-21T05:24:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>The flattened tree should look like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong> Hints: </strong><br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
<h2 id="代码">代码</h2><p>直接先序遍历，从头到尾把节点链接起来：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">private</span> TreeNode lastVisited = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用先序遍历，top-down</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">flatten</span>(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">        TreeNode savedRight = root.right;</span><br><span class="line">        <span class="keyword">if</span>(lastVisited != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastVisited.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//在这里会修改上一访问节点的right指向，应该先保存</span></span><br><span class="line">            <span class="comment">//比如先序遍历到3时，lastVisited指向2（此时结果为1-&gt;2），然后在这里修改2的节点的left为null，right节点为3</span></span><br><span class="line">            <span class="comment">//遍历完3节点后，接着遍历节点4，但是如果我们不提前保存节点4，我们就找不到4了因为节点2的右节点已经被修改为3</span></span><br><span class="line">            <span class="comment">//这就是需要保存右节点的原因</span></span><br><span class="line">            lastVisited.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        lastVisited = root;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">flatten</span>(root.left);</span><br><span class="line">        <span class="keyword">flatten</span>(savedRight);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者采用前插构建单链表的形式，bottom-up方式</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//前序、中序、后序遍历好像都不是</span></span><br><span class="line">    <span class="comment">//这里引出一种新的遍历方式</span></span><br><span class="line">    <span class="comment">//先遍历右子树，然后左子树，根节点，有点类似后序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      1</span></span><br><span class="line">    <span class="comment">//     / \</span></span><br><span class="line">    <span class="comment">//    2   5</span></span><br><span class="line">    <span class="comment">//   / \   \</span></span><br><span class="line">    <span class="comment">//  3   4   6</span></span><br><span class="line">    <span class="comment">//比如题目中树采用该种遍历方式的结果为6、5、4、3、2、1相当于结果的逆序，但是如果我们采用前插构建单链表的方式</span></span><br><span class="line">    <span class="comment">//就可以把该结果反转过来，变成1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，这里讲left节点都置为空，就能将树退化为单链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null，prev开始指向null，然后指向6，然后指向5，然后指向4，然后指向3......</span></span><br><span class="line">    <span class="comment">//prev上一次遍历的节点</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">flatten</span>(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//先右子树</span></span><br><span class="line">        <span class="keyword">flatten</span>(root.right);</span><br><span class="line">        <span class="keyword">flatten</span>(root.left);</span><br><span class="line">        </span><br><span class="line">        root.right = prev;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//更新prev的指向</span></span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代的方式，暂时没咋研究，有时间再研究，好像跟Morris traversal有关系。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//迭代的方式</span></span><br><span class="line">    <span class="keyword">public</span> void flatten(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.<span class="keyword">left</span> != null) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> last = cur.<span class="keyword">left</span>;</span><br><span class="line">                <span class="keyword">while</span> (last.<span class="keyword">right</span> != null) last = last.<span class="keyword">right</span>;</span><br><span class="line">                last.<span class="keyword">right</span> = cur.<span class="keyword">right</span>;</span><br><span class="line">                cur.<span class="keyword">right</span> = cur.<span class="keyword">left</span>;</span><br><span class="line">                cur.<span class="keyword">left</span> = null;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.<span class="keyword">right</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlig]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Decode Ways]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Decode-Ways/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Decode-Ways/</id>
    <published>2016-06-21T00:10:11.000Z</published>
    <updated>2016-06-26T03:39:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'A'</span> <span class="subst">-&gt; </span><span class="number">1</span></span><br><span class="line"><span class="string">'B'</span> <span class="subst">-&gt; </span><span class="number">2</span></span><br><span class="line"><span class="attribute">...</span></span><br><span class="line"><span class="string">'Z'</span> <span class="subst">-&gt; </span><span class="number">26</span></span><br></pre></td></tr></table></figure></p>
<p>Given an encoded message containing digits, determine the total number of ways to decode it.</p>
<p>For example,<br>Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).</p>
<p>The number of ways decoding “12” is 2.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//类似Climbing Stairs，只是多了一些限制条件</span></span><br><span class="line">    <span class="comment">//nums[i]：表示字符串s[0...i-1]的解码方式的总数</span></span><br><span class="line">    <span class="comment">//nums[i] = nums[i-1] if s[i-1] is valid char</span></span><br><span class="line">    <span class="comment">//or nums[i-1] + nums[i-2] if s[i-1] and s[i-2] to gether is still a valid char</span></span><br><span class="line">    <span class="comment">// public int numDecodings(String s) &#123;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(s == null || s.length() == 0) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int[] nums = new int[s.length() + 1];</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     //表示空字符串只有一种解码方式</span></span><br><span class="line">    <span class="comment">//     nums[0] = 1;</span></span><br><span class="line">    <span class="comment">//     //只含有s[0]一个字符的解码方式，如果是有效字符不为'0'则有一种方式，否则为零</span></span><br><span class="line">    <span class="comment">//     nums[1] = s.charAt(0) != '0' ? 1 : 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     for(int i = 2; i &lt;= s.length(); i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(isValid(s.substring(i-1,i)))&#123;</span></span><br><span class="line">    <span class="comment">//             nums[i] += nums[i-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">//         if(isValid(s.substring(i-2, i)))&#123;</span></span><br><span class="line">    <span class="comment">//             nums[i] += nums[i-2];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return nums[s.length()];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> value = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">1</span> &amp;&amp; value &lt;= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//表示空字符串只有一种解码方式</span></span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//只含有s[0]一个字符的解码方式，如果是有效字符不为'0'则有一种方式，否则为零</span></span><br><span class="line">        nums[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = Integer.parseInt(s.substring(i-<span class="number">1</span>, i));</span><br><span class="line">            <span class="keyword">int</span> second = Integer.parseInt(s.substring(i-<span class="number">2</span>, i));</span><br><span class="line">            <span class="keyword">if</span>(first &gt;= <span class="number">1</span> &amp;&amp; first &lt;= <span class="number">9</span>)&#123;</span><br><span class="line">                nums[i] += nums[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意second要大于等于10</span></span><br><span class="line">            <span class="keyword">if</span>(second &gt;= <span class="number">10</span> &amp;&amp; second &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                nums[i] += nums[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两种写法都是top down dp，我们还可以用bottom up dp的方式，从字符串尾部往前dp。nums[i]表示s[i…s.length]的解码方式。以’0’开头的字符串解码方式为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//空字符串的解码方式</span></span><br><span class="line">        nums[length] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        nums[length-<span class="number">1</span>] = s.charAt(length - <span class="number">1</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>) <span class="keyword">continue</span>;<span class="comment">//以0开头的字符串都是无效的字符串，解码方式为0，默认初始化为0，写nums[i] = 0也可以</span></span><br><span class="line">            <span class="keyword">else</span> nums[i] = Integer.parseInt(s.substring(i, i+<span class="number">2</span>)) &lt;= <span class="number">26</span> ? nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] : nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:<br><figure class="h]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Reverse Words in a String I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/20/LeetCode-Reverse-Words-in-a-String-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/20/LeetCode-Reverse-Words-in-a-String-I-II/</id>
    <published>2016-06-20T12:52:55.000Z</published>
    <updated>2016-06-20T13:55:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Reverse_Words_in_a_String_I">Reverse Words in a String I</h2><h3 id="题目描述">题目描述</h3><p>Given an input string, reverse the string word by word.</p>
<p>For example,<br>Given s = “the sky is blue”,<br>return “blue is sky the”.</p>
<p>Update (2015-02-12):<br>For C programmers: Try to solve it in-place in O(1) space.</p>
<h3 id="代码">代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	 <span class="comment">//使用split函数切割，然后逆序append起来即可</span></span><br><span class="line">    <span class="comment">//考虑前导空格、words之间多个空格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> reverseWords(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一个空格或多个空格split</span></span><br><span class="line">        <span class="keyword">String</span>[] strs = s.<span class="built_in">trim</span>().<span class="built_in">split</span>(<span class="string">"\\s+"</span>);</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = strs.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            sb.<span class="built_in">append</span>(strs[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.<span class="built_in">append</span>(strs[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法就是逆序遍历字符串，使用两个指针追踪words的开始和结尾，当我们遍历到words的开始时，将words append到结果中。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//j指针初始指向字符串最后一个字符的下一位置，在每一次迭代中j指向上一个遍历的空格</span></span><br><span class="line">        <span class="keyword">int</span> j = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//遍历到空格，更新j的指向，指向新的空格</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">' '</span>)&#123;<span class="comment">//charAt(i - 1) == ' '说明i当前指向某个word的开头，可以获取到该word</span></span><br><span class="line">                <span class="keyword">if</span>(sb.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                    sb.append(<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(s.substring(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//其他情况直接跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse_Words_in_a_String_II">Reverse Words in a String II</h2><h3 id="题目描述-1">题目描述</h3><p>Similar to Question [Reverse Words in a String], but with the following constraints:<br>“The input string does not contain leading or trailing spaces and the words are always separated by a single space.”<br>Could you do it in-place without allocating extra space?</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将整个字符串翻转，然后将每个word翻转</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] s)</span></span>&#123;</span><br><span class="line">       reverse(s, <span class="number">0</span>, s.length - <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//j指向每个word的开始</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i == s.length - <span class="number">1</span> || s[i] == <span class="string">' '</span> )&#123;</span><br><span class="line">               reverse(s, j, i);</span><br><span class="line">               j = i+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">           <span class="keyword">char</span> temp = s[end];</span><br><span class="line">           s[end] = s[start];</span><br><span class="line">           s[start] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Reverse_Words_in_a_String_I">Reverse Words in a String I</h2><h3 id="题目描述">题目描述</h3><p>Given an input string, reverse the string wor]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Divide Two Integers]]></title>
    <link href="http://blog.noobsky.com/2016/06/20/LeetCode-Divide-Two-Integers/"/>
    <id>http://blog.noobsky.com/2016/06/20/LeetCode-Divide-Two-Integers/</id>
    <published>2016-06-20T08:37:13.000Z</published>
    <updated>2016-06-20T11:49:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//最直接的方法就是不断用被除数减去除数，直到被除数小于除数，迭代次数为结果大小</span></span><br><span class="line">    <span class="comment">//这里介绍一种方法，用例子来说明：dividend = 15， divisor = 3</span></span><br><span class="line">    <span class="comment">//15-3 = 12，结果为整数，我们尝试减多一点，我们将3左移一位得6，15-6 = 9仍然是正数，我们还可以减更多一点</span></span><br><span class="line">    <span class="comment">//再讲3左移一位得12，15-12 = 3仍然大于0，我们尝试3再左移得24这回不可以了。所以最多减去12。12是除数3左移两位得到，4*3 = 12</span></span><br><span class="line">    <span class="comment">//那么我们怎么得到这个4，我们初始化为1，然后除数3左移时，1也左移。3左移两次1左移两次为4。我们将4加到相除的结果中（初始化</span></span><br><span class="line">    <span class="comment">//为0）。上面的过程就像 15 = 3*4 + 3。现在我们得到商为4，余数为3。</span></span><br><span class="line">    <span class="comment">//然后我们继续以上过程，新的被除数dividend = 3，除数divisor = 3，3 - 3 = 0。迭代结束，这次没有发生左移，所以结果中加上</span></span><br><span class="line">    <span class="comment">//1&lt;&lt;0 = 1，最后我们等到5。</span></span><br><span class="line">    <span class="comment">//我们还需要处理溢出，有以下情况:</span></span><br><span class="line">    <span class="comment">//1. divisor = 0；</span></span><br><span class="line">    <span class="comment">//2. dividend = Integer.MIN_VALUE，divisor = -1（因为 Math.abs(MIN_VALUE) = MAX_VALUE + 1）</span></span><br><span class="line">    <span class="comment">//最后还要考虑正负号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor == <span class="number">0</span> || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//除数和被除数符号相异时为负，否则为正，用异或</span></span><br><span class="line">        <span class="keyword">int</span> sign = ((dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换为整数处理，Integer.MIN_VALUE绝对值会溢出，用long类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> dvd = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)dividend);</span><br><span class="line">        <span class="keyword">long</span> dvs = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环终止条件为被除数小于除数</span></span><br><span class="line">        <span class="keyword">while</span>(dvd &gt;= dvs)&#123;</span><br><span class="line">            <span class="keyword">long</span> temp = dvs, factor = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(dvd &gt;= (temp&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//左移一位</span></span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                factor &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dvd -= temp;</span><br><span class="line">            res += factor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sign == <span class="number">1</span> ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实用long也不是长久之计，如果输入时long类型，咱又用什么好，用BigInteger:)，那如果。。。其实主要的溢出就是Intege.MIN_VALUE，绝对值后会溢出，那么就对MIN_VALUE单独处理好了；还有temp左移可能溢出。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//其实用long也不是长久之计，如果输入时long类型，咱又用什么好，用BigInteger:)，那如果。。。</span></span><br><span class="line">    <span class="comment">//其实主要的溢出就是Intege.MIN_VALUE，绝对值后会溢出，那么就对MIN_VALUE单独处理好了</span></span><br><span class="line">    <span class="comment">//还有temp左移可能溢出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dividend == Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(divisor == <span class="number">1</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="comment">//奇数跟前者等价，偶数跟后者等价</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> ((divisor&amp;<span class="number">1</span>) == <span class="number">1</span>) ? divide(dividend + <span class="number">1</span>, divisor) : divide(dividend &gt;&gt; <span class="number">1</span>, divisor &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(divisor == Integer.MIN_VALUE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if(divisor == 1) return dividend;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//除数和被除数符号相异时为负，否则为正，用异或</span></span><br><span class="line">        <span class="keyword">int</span> sign = ((dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换为整数处理，Integer.MIN_VALUE绝对值会溢出，用long类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dvd = Math.<span class="built_in">abs</span>(dividend);</span><br><span class="line">        <span class="keyword">int</span> dvs = Math.<span class="built_in">abs</span>(divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环终止条件为被除数小于除数</span></span><br><span class="line">        <span class="keyword">while</span>(dvd &gt;= dvs)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dvs, factor = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//(temp &lt;&lt; 1) &gt; divisor是避免temp左移溢出造成死循环，溢出了(temp &lt;&lt; 1) &lt; divisor</span></span><br><span class="line">            <span class="comment">//比如dividend = Integer.MAX_VALUE, divisor = 1或2，死循环</span></span><br><span class="line">            <span class="keyword">while</span>(dvd &gt;= (temp &lt;&lt; <span class="number">1</span>) &amp;&amp; ((temp &lt;&lt; <span class="number">1</span>) &gt; dvs))&#123;</span><br><span class="line">                <span class="comment">//左移一位</span></span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                factor &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dvd -= temp;</span><br><span class="line">            res += factor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sign == <span class="number">1</span> ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(lgn)，空间复杂度为O(1)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Largest Number]]></title>
    <link href="http://blog.noobsky.com/2016/06/20/LeetCode-Largest-Number/"/>
    <id>http://blog.noobsky.com/2016/06/20/LeetCode-Largest-Number/</id>
    <published>2016-06-20T03:39:22.000Z</published>
    <updated>2016-06-20T07:54:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Largest_Number">Largest Number</h2><h3 id="题目描述">题目描述</h3><p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.</p>
<p>Note: The result may be very large, so you need to return a string instead of an integer.</p>
<h3 id="代码">代码</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">public</span> class Solution &#123;</span><br><span class="line">    //将nums转换为字符串数组，然后将字符串排序，这个排序比较讲究不是纯粹的升序或者降序，然后将字符串append起来即可</span><br><span class="line">    //因为越大的数字越在前面最后组成的数字越大</span><br><span class="line">    //但是这里需要注意的是两个字符串长度不相等，一个字符串又是另一个字符串的前缀的时候</span><br><span class="line">    //比如[<span class="string">"121"</span>, <span class="string">"12"</span>]如果按字典序降序(直接用return <span class="literal">s2</span>.compareTo(<span class="literal">s1</span>))排序结果为<span class="number">121</span>、<span class="number">12</span>，最后结果为<span class="string">"121"</span>+<span class="string">"12"</span>但是这个结果小于</span><br><span class="line">    //<span class="string">"12"</span>+<span class="string">"121"</span>，所以我们应该按<span class="literal">s1</span>+<span class="literal">s2</span>和<span class="literal">s2</span>+<span class="literal">s1</span>降序排即可</span><br><span class="line">    public <span class="keyword">String </span>largestNumber(int[] nums) &#123;</span><br><span class="line">        <span class="preprocessor">if</span>(nums == null <span class="title">||</span> nums.length == <span class="number">0</span>) return <span class="string">""</span><span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">String[] </span><span class="keyword">strs </span>= new <span class="keyword">String[nums.length];</span><br><span class="line"></span>        </span><br><span class="line">        for(int i = <span class="number">0</span><span class="comment">; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">            // <span class="keyword">strs[i] </span>= nums[i] + <span class="string">""</span><span class="comment">;</span></span><br><span class="line">            <span class="keyword">strs[i] </span>= <span class="keyword">String.valueOf(nums[i]);</span><br><span class="line"></span>        &#125;</span><br><span class="line">        </span><br><span class="line">        Comparator&lt;<span class="keyword">String&gt; </span>comp = new Comparator&lt;<span class="keyword">String&gt;()&#123;</span><br><span class="line"></span>            <span class="comment">@Override</span></span><br><span class="line">            public int compare(<span class="keyword">String </span><span class="literal">s1</span>, <span class="keyword">String </span><span class="literal">s2</span>)&#123;</span><br><span class="line">                //以下两句非常关键<span class="keyword">strs </span>= &#123;<span class="string">"121"</span>, <span class="string">"12"</span>&#125;<span class="comment">;</span></span><br><span class="line">                <span class="literal">s1</span> = <span class="literal">s1</span> + <span class="literal">s2</span><span class="comment">;</span></span><br><span class="line">                <span class="literal">s2</span> = <span class="literal">s2</span> + <span class="literal">s1</span><span class="comment">;</span></span><br><span class="line">                return <span class="literal">s2</span>.compareTo(<span class="literal">s1</span>)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        Arrays.sort(<span class="keyword">strs, </span>comp)<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        <span class="preprocessor">if</span>(<span class="keyword">strs[0].equals("0")) </span>return <span class="string">"0"</span><span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">StringBuilder </span><span class="literal">sb</span> = new <span class="keyword">StringBuilder();</span><br><span class="line"></span>        for(int i = <span class="number">0</span><span class="comment">; i &lt; strs.length; i++)&#123;</span></span><br><span class="line">            <span class="literal">sb</span>.append(<span class="keyword">strs[i]);</span><br><span class="line"></span>        &#125;</span><br><span class="line">        </span><br><span class="line">        return <span class="literal">sb</span>.toString()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外类似的题目还有从数中删除k位并且不改变数字的顺序使得留下的数字最大/最小，LeetCode上没有，LintCode上倒是有，之前面试也遇到了。</p>
<h2 id="Delete_Digits">Delete Digits</h2><h3 id="题目描述-1">题目描述</h3><p>Given string A representative a positive integer which has N digits, remove any k digits of the number, the remaining digits are arranged according to the original order to become a new positive integer.</p>
<p>Find the smallest integer after remove k digits.</p>
<p>N &lt;= 240 and k &lt;= N,</p>
<p><strong> Example </strong><br>Given an integer A = “178542”, k = 4</p>
<p>return a string “12”</p>
<h3 id="代码-1">代码</h3><p>其实这道题的思路和Largest Number的思路相似，都是贪婪算法，不同的是在Largest Number中，是较大的数在前，较小的数在后；这道题目中是较小的数在前，较大的数在后。因为我们要求最小的数，所以需要让排在最前的数字较小就可以，要做到这一点，我们依次比较两个相邻的数字，如果前一个数字比后一个数字大，则将前一个数字删除；如果前一个数字比后一个数字小，则不变，继续比较后面的数字。当进行到最后一个数字时，不需要再比较，直接将其删除即可。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *<span class="doctag">@param</span> A: A positive integer which has N digits, A is a string.</span><br><span class="line">     *<span class="doctag">@param</span> k: Remove k digits.</span><br><span class="line">     *<span class="doctag">@return</span>: A string</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> String DeleteDigits(String str, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span> || k &gt;= str.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="comment">//使用StringBuilder或者StringBuffer删除字符方便</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sb.length(); j++)&#123;</span><br><span class="line">                <span class="comment">//如果遍历到最后一个字符还没找到升序，说明整个数是降序的删除最后一个就可以了</span></span><br><span class="line">                <span class="keyword">if</span>(j == sb.length() - <span class="number">1</span> || sb.charAt(j) &gt; sb.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                    sb.deleteCharAt(j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除k个数字后可能有前导0，应该跳过</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sb.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.charAt(i) != <span class="string">'0'</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">return</span> sb.substring(i, sb.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理如果要删除k位使剩下的最大也是类似的，将上面代码中的<code>sb.charAt(j) &gt; sb.charAt(j+1)</code>改为<code>sb.charAt(j) &lt; sb.charAt(j+1)</code>。以上代码的时间复杂度为O(nk)，空间复杂度为O(1)。上面的代码的内层for循环每次都是从下标0开始往后比较，其实是多余的，已经比较过的数字就不用比较了。我们可以用j来记录上次的位置，这样相当于使用了两个pointers，优化之后最坏的时间复杂度为O(2n)，两个指针都从左至右走一遍。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *@param A: A positive integer which has N digits, A is a string.</span><br><span class="line">     *@param k: Remove k digits.</span><br><span class="line">     *@return: A string</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">DeleteDigits</span><span class="params">(String str, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == null || str.length() == <span class="number">0</span> || k &gt;= str.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="comment">//使用StringBuilder或者StringBuffer删除字符方便</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; sb.length(); j++)&#123;</span><br><span class="line">                <span class="comment">//如果遍历到最后一个字符还没找到升序，说明整个数是降序的删除最后一个就可以了</span></span><br><span class="line">                <span class="keyword">if</span>(j == sb.length() - <span class="number">1</span> || sb.charAt(j) &gt; sb.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                    sb.deleteCharAt(j);</span><br><span class="line">                    j--;<span class="comment">//回退一步就可以了</span></span><br><span class="line">                    <span class="comment">//j == 0时，j--为-1，越界，修正</span></span><br><span class="line">                    <span class="keyword">if</span>(j == -<span class="number">1</span>) j = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除k个数字后可能有前导0，应该跳过</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sb.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.charAt(i) != <span class="string">'0'</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.substring(i, sb.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.cnblogs.com/AndyJee/p/4527382.html" target="_blank" rel="external">(笔试题)删除K位数字</a><br><a href="http://www.geeksforgeeks.org/build-lowest-number-by-removing-n-digits-from-a-given-number/" target="_blank" rel="external">Build Lowest Number by Removing n digits from a given number</a><br><a href="http://www.jianshu.com/p/a0e0936ed93e" target="_blank" rel="external">Delete Digits</a><br><a href="http://codinggamestart.blogspot.com/2015/08/lintcode-delete-digits.html" target="_blank" rel="external">Lintcode: Delete Digits</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Largest_Number">Largest Number</h2><h3 id="题目描述">题目描述</h3><p>Given a list of non negative integers, arrange them such that they form]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Contains Duplicate I II III]]></title>
    <link href="http://blog.noobsky.com/2016/06/19/LeetCode-Contains-Duplicate-I-II-III/"/>
    <id>http://blog.noobsky.com/2016/06/19/LeetCode-Contains-Duplicate-I-II-III/</id>
    <published>2016-06-19T06:15:09.000Z</published>
    <updated>2016-06-20T02:42:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Contains_Duplicate_I">Contains Duplicate I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<h3 id="代码">代码</h3><ul>
<li>解法一</li>
</ul>
<p>直接遍历搜索，没遍历到某个元素nums[i]，逐一判断该元素跟前面的元素是否相等，时间复杂度为O(n<sup>2</sup>)， 超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == nums[i]) <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Time Limit Exceeded</span></span><br></pre></td></tr></table></figure>
<ul>
<li>解法二 </li>
</ul>
<p>排序后再遍历搜索，只有比较相邻元素就可，时间复杂度为O(nlgn)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>解法三（推荐）</li>
</ul>
<p>使用HashMap或HashSet，使用HashMap也可以但是value用不上，直接用HashSet（HashSet就是用HashMap实现的），HashSet的查找和插入都是O(1)的，所以总的时间复杂度为O(n)，不过需要O(n)的空间复杂度：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> containsDuplicate(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">    Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> x: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>.contains(x)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="built_in">set</span>.<span class="built_in">add</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果内存没什么限制的话，推荐使用这种方法。</p>
<h2 id="Contains_Duplicate_II">Contains Duplicate II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.</p>
<h3 id="代码-1">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - j; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]  == nums[i+j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力法，时间复杂度O(nk)，超时</p>
<ul>
<li>解法二 </li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> containsNearbyDuplicate(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Integer,Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(nums[i]))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-<span class="built_in">map</span>.<span class="built_in">get</span>(nums[i]) &lt;= k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果之前存在该key，但索引差不小于等于k，则覆盖掉之前的元素，如果不覆盖，后面有相等元素</span></span><br><span class="line">            <span class="comment">//跟之前的比会出现大于k的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>.put(nums[i],i);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用HashMap，key为数组元素，value为对应的index</p>
<ul>
<li>解法三（推荐）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tricky，利用HashSet维护一个窗口为k的滑动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">//窗口大小应该是k+1</span></span><br><span class="line">        <span class="comment">//[0...k]是符合的</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; k) <span class="built_in">set</span>.remove(nums[i-k-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">set</span>.add(nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//后面remove也可以</span></span><br><span class="line">        <span class="comment">//if(i &gt;= k) set.remove(nums[i-k]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Contains_Duplicate_III">Contains Duplicate III</h2><h3 id="题目描述-2">题目描述</h3><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.</p>
<h3 id="代码-2">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//在窗口k中找到[nums[i] - t, nums[i] + t]那么就返回true</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(nlgk)</span></span><br><span class="line">    <span class="comment">//利用TreeSet维护一个大小为K的滑动窗口，TreeSet寻找[nums[i] - t, nums[i] + t]的时间复杂度为O(lgk)</span></span><br><span class="line">    <span class="comment">//所以该程序的时间复杂度为O(nlgk)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">       TreeSet&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//寻找set中小于等于nums[i]+t的最大的数</span></span><br><span class="line">            <span class="comment">//虽然有nums[i]+t会发生溢出，但是遍历到后面某个数nums[j] - t还是能找到nums[i]的</span></span><br><span class="line">            Integer <span class="built_in">floor</span> = <span class="built_in">set</span>.<span class="built_in">floor</span>(nums[i] + t);<span class="comment">//lg(k)</span></span><br><span class="line">            <span class="comment">//寻找set中大于等于num[i]-t的最小的数</span></span><br><span class="line">            Integer <span class="built_in">ceil</span> = <span class="built_in">set</span>.ceiling(nums[i] - t);<span class="comment">//lg(k)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">floor</span> != null &amp;&amp; <span class="built_in">floor</span> &gt;= nums[i]) ||(<span class="built_in">ceil</span> != null &amp;&amp; <span class="built_in">ceil</span> &lt;= nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>.add(nums[i]);</span><br><span class="line">            <span class="comment">//[0...k]移除nums[0],为下一次循环做准备,下一次i=i+1=k+1，k+1 - 0 &gt; k了要移除一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) <span class="built_in">set</span>.remove(nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了引出下一种解法，我们先进行一些简单的推导：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果： | nums<span class="string">[i]</span> - nums<span class="string">[j]</span> | &lt;= t   式a</span><br><span class="line"></span><br><span class="line">等价： | nums<span class="string">[i]</span> / t - nums<span class="string">[j]</span> / t | &lt;= <span class="number">1</span>   式b</span><br><span class="line"></span><br><span class="line">推出： | floor(nums<span class="string">[i]</span> / t) - floor(nums<span class="string">[j]</span> / t) | &lt;= <span class="number">1</span>   式c</span><br><span class="line"></span><br><span class="line">​等价： floor(nums<span class="string">[j]</span> / t) ∈ &#123;floor(nums<span class="string">[i]</span> / t) - <span class="number">1</span>, floor(nums<span class="string">[i]</span> / t), floor(nums<span class="string">[i]</span> / t) + <span class="number">1</span>&#125; 式d</span><br></pre></td></tr></table></figure>
<p>其中式b是式c的充分非必要条件，因为逆否命题与原命题等价，所以：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果： floor(nums<span class="string">[j]</span> / t) ∉ &#123;floor(nums<span class="string">[i]</span> / t) - <span class="number">1</span>, floor(nums<span class="string">[i]</span> / t), floor(nums<span class="string">[i]</span> / t) + <span class="number">1</span>&#125; 非d</span><br><span class="line"></span><br><span class="line">推出： | nums<span class="string">[i]</span> - nums<span class="string">[j]</span> | &gt; t   非a</span><br></pre></td></tr></table></figure>
<p>因此只需要维护一个大小为k的窗口（字典）numDict，其中键为nums[i] / t，值为nums[i]。</p>
<p>遍历数组nums时，检查nums[i]与键集{floor(nums[i] / t) - 1, floor(nums[i] / t), floor(nums[i] / t) + 1}对应的值的差值即可。</p>
<p>根据以上分析，可得如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	 <span class="comment">//滑动窗口+桶</span></span><br><span class="line">    <span class="comment">//维护一个大小为t的桶，相差如果|nums[i] - num[j]| &lt;= t那么这两个数会被分配到同一个桶或者相邻的桶</span></span><br><span class="line">    <span class="comment">//分配都同一个桶的元素之差&lt;=t(元素是正数才满足)，但是分配到相邻桶的元素之差不一定是&lt;=</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//key为桶的编号，value为nums[i]</span></span><br><span class="line">        Map&lt;Long, Long&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//重新映射数组中元素全部转化为正数</span></span><br><span class="line">            <span class="keyword">long</span> remappedNum = (<span class="keyword">long</span>)nums[i] - Integer.MIN_VALUE;</span><br><span class="line">            <span class="comment">//将的桶的大小取为t+1是避免t为0时需要另外的代码,前面t为负数时已经直接返回了t+1不会为0</span></span><br><span class="line">            <span class="keyword">long</span> bucket = remappedNum / ((<span class="keyword">long</span>)t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//[-3, 3] k = 1, t = 4</span></span><br><span class="line">            <span class="comment">//如果不转换为正数的，对于以上测试用例会失败</span></span><br><span class="line">            <span class="comment">//-3和3都映射到同一个桶中，但是值之差并不小于等于t</span></span><br><span class="line">            <span class="comment">//下面的判断中分配到同一桶中的元素直接就默认小于等于t(对于正数来说是成立的)，所以前面全部转换为正数</span></span><br><span class="line">            <span class="comment">//那么-3和3分配到不同的桶中。其实不重新映射数组中的元素也是可以的，此时分配到同一个桶的元素也需要判断是否&lt;=t</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(bucket) || (<span class="built_in">map</span>.containsKey(bucket - <span class="number">1</span>) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket - <span class="number">1</span>) &lt;= t) || (<span class="built_in">map</span>.containsKey(bucket + <span class="number">1</span>) &amp;&amp; <span class="built_in">map</span>.get(bucket + <span class="number">1</span>) - remappedNum &lt;= t))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">map</span>.put(bucket, remappedNum);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)&#123;</span><br><span class="line">                <span class="keyword">long</span> lastBucket = ((<span class="keyword">long</span>) nums[i - k] - Integer.MIN_VALUE) / ((<span class="keyword">long</span>) t + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">map</span>.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码成功AC，我尝试了一下不对数组中的元素重新映射，当元素分配到同一个桶中时仍然检查它们的之差是否小于等于t，但是我没有把数组中的元素转化为long类型，导致两数相减时溢出导致判断错误，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> remappedNum = nums[i];<span class="comment">// - Integer.MIN_VALUE;</span></span><br><span class="line">            <span class="keyword">int</span> bucket = remappedNum / ( t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//不需要重新映射但还是应该要long类型，因为remappedNum - map.get(bucket)等会发生溢出</span></span><br><span class="line">            <span class="comment">//nums = [-1,2147483647] k = 1  t = 2147483647就因为发生溢出而判断为true，正确的应该为false</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">map</span>.containsKey(bucket) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket) &lt;= t)</span><br><span class="line">                    || (<span class="built_in">map</span>.containsKey(bucket - <span class="number">1</span>) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket - <span class="number">1</span>) &lt;= t)</span><br><span class="line">                    || (<span class="built_in">map</span>.containsKey(bucket + <span class="number">1</span>) &amp;&amp; <span class="built_in">map</span>.get(bucket + <span class="number">1</span>) - remappedNum &lt;= t))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.entrySet().size() &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">int</span> lastBucket = nums[i - k] / (t + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">map</span>.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>.put(bucket, remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将数组中的元素强制转行为long类型时成功AC，推荐下面完善后AC的代码：</p>
<ul>
<li>解法二(推荐)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//不重新映射，nums转换为long类型，但是相同的桶也需要比较值之差是否小于等于t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Long, Long&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//不映射</span></span><br><span class="line">            <span class="keyword">long</span> remappedNum = (<span class="keyword">long</span>) nums[i];<span class="comment">// - Integer.MIN_VALUE;</span></span><br><span class="line">            <span class="keyword">long</span> bucket = remappedNum / ((<span class="keyword">long</span>) t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//要转换为long类型，是因为这里相减会发生溢出</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">map</span>.containsKey(bucket) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket) &lt;= t)</span><br><span class="line">                    || (<span class="built_in">map</span>.containsKey(bucket - <span class="number">1</span>) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket - <span class="number">1</span>) &lt;= t)</span><br><span class="line">                        || (<span class="built_in">map</span>.containsKey(bucket + <span class="number">1</span>) &amp;&amp; <span class="built_in">map</span>.get(bucket + <span class="number">1</span>) - remappedNum &lt;= t))</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.entrySet().size() &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastBucket = ((<span class="keyword">long</span>) nums[i - k]) / ((<span class="keyword">long</span>) t + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">map</span>.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>.put(bucket, remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="https://leetcode.com/discuss/38206/ac-o-n-solution-in-java-using-buckets-with-explanation" target="_blank" rel="external">AC O(N) solution in Java using buckets with explanation</a><br><a href="http://bookshadow.com/weblog/2015/06/03/leetcode-contains-duplicate-iii/" target="_blank" rel="external">[LeetCode]Contains Duplicate III</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Contains_Duplicate_I">Contains Duplicate I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of integers, find if the array contains any ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Range Sum Query 1D/2D - Immutable/Mutable]]></title>
    <link href="http://blog.noobsky.com/2016/06/19/LeetCode-Range-Sum-Query-1D-2D-Immutable-Mutable/"/>
    <id>http://blog.noobsky.com/2016/06/19/LeetCode-Range-Sum-Query-1D-2D-Immutable-Mutable/</id>
    <published>2016-06-19T01:22:05.000Z</published>
    <updated>2016-06-19T06:12:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Range_Sum_Query_-_Immutable">Range Sum Query - Immutable</h2><h3 id="题目描述">题目描述</h3><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p><strong> Example: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">2</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">1</span></span><br><span class="line">sumRange(<span class="number">2</span>, <span class="number">5</span>) -&gt; -<span class="number">1</span></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">5</span>) -&gt; -<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong> Note: </strong></p>
<ol>
<li>You may assume that the array does not change.</li>
<li>There are many calls to sumRange function.</li>
</ol>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NumArray &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// private int[] nums;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// public NumArray(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     //在初始化的时候使用dp计算前i个数的和。自己的想法队了，但是使用的额外的数组，面试是可以问清楚是否可以更改nums数组中的元素</span></span><br><span class="line">    <span class="comment">//     for(int i = 1;i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         nums[i] = nums[i] + nums[i-1];</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     this.nums = nums;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int sumRange(int i, int j) &#123;</span></span><br><span class="line">    <span class="comment">//     //前i==0时登记与前i个数的和</span></span><br><span class="line">    <span class="comment">//     if(i == 0) return nums[j];</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return nums[j] - nums[i-1];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) sums[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> sums[i] = sums[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> sums[j];</span><br><span class="line">        <span class="keyword">return</span> sums[j] - sums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumArray numArray = new NumArray(nums);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(0, 1);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(1, 2);</span></span><br></pre></td></tr></table></figure>
<h2 id="Range_Sum_Query_-_Mutable">Range Sum Query - Mutable</h2><h3 id="题目描述-1">题目描述</h3><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p>The update(i, val) function modifies nums by updating the element at index i to val.<br><strong> Example: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">9</span></span><br><span class="line">update(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><strong> Note: </strong></p>
<ol>
<li>The array is only modifiable by the update function.</li>
<li>You may assume the number of calls to update and sumRange function is distributed evenly.</li>
</ol>
<h3 id="代码-1">代码</h3><p>暴力法会超时：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> sumRange(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = i; l &lt;= j; l++) &#123;</span><br><span class="line">        <span class="keyword">sum</span> += data[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> update(<span class="keyword">int</span> i, <span class="keyword">int</span> val) &#123;</span><br><span class="line">    nums[i] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用分段树，sumRange和update的时间复杂度都是O(lgn):</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Segment Tree，sumRange和update都是O(lgn)</span></span><br><span class="line">    <span class="comment">//叶子节点为数组中的元素，内部节点(非叶子节点)代表了该节点下叶子的和</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录该节点下叶子包含数组中[start, end]的元素</span></span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        <span class="comment">//nums[start...end]直接的元素之和</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">sum</span>;</span><br><span class="line">        <span class="comment">//左右孩子</span></span><br><span class="line">        SegmentTreeNode left, right;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">public</span> SegmentTreeNode(<span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SegmentTreeNode root = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> NumArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        root = buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用nums中[start...end]的元素构造SegmentTree</span></span><br><span class="line">    <span class="keyword">private</span> SegmentTreeNode buildTree(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            SegmentTreeNode node = <span class="keyword">new</span> SegmentTreeNode(start, end);</span><br><span class="line">            <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">                node.<span class="keyword">sum</span> = nums[start];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//进入这个分支，[start...end]起码有两个元素，node.left和node.right都不会为空</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">                node.left = buildTree(nums, start, mid);</span><br><span class="line">                node.right = buildTree(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">                <span class="comment">//左子树加上右子树的和</span></span><br><span class="line">                node.<span class="keyword">sum</span> = node.left.<span class="keyword">sum</span> + node.right.<span class="keyword">sum</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> update(<span class="keyword">int</span> i, <span class="keyword">int</span> val) &#123;</span><br><span class="line">        update(root, i, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> update(SegmentTreeNode root, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.start == root.end)&#123;</span><br><span class="line">            root.<span class="keyword">sum</span> = val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = root.start + (root.end - root.start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos &lt;= mid)&#123;<span class="comment">//在左子树中</span></span><br><span class="line">                update(root.left, pos, val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                update(root.right, pos, val);</span><br><span class="line">            &#125;</span><br><span class="line">            root.<span class="keyword">sum</span> = root.left.<span class="keyword">sum</span> + root.right.<span class="keyword">sum</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sumRange(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">return</span> sumRange(root, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sumRange(SegmentTreeNode root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.start == start &amp;&amp; root.end == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="keyword">sum</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//计算root.start和root.end的中间值</span></span><br><span class="line">            <span class="keyword">int</span> mid = root.start + (root.end - root.start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(end &lt;= mid)&#123;<span class="comment">//全部在左子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.left, start, end);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start &gt;= mid + <span class="number">1</span>)&#123;<span class="comment">//全部在右子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.right, start, end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//分散在左右子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.left, start, mid) + sumRange(root.right, mid+<span class="number">1</span>, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumArray numArray = new NumArray(nums);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(0, 1);</span></span><br><span class="line"><span class="comment">// numArray.update(1, 10);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(1, 2);</span></span><br></pre></td></tr></table></figure>
<p>分段树还能用来解决Range Minimum Query问题，详见<a href="http://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank" rel="external">Segment Tree | Set 2 (Range Minimum Query)</a></p>
<h2 id="Range_Sum_Query_2D_-_Immutable">Range Sum Query 2D - Immutable</h2><h3 id="题目描述-2">题目描述</h3><p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p>
<p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt=""><br>The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</p>
<h3 id="代码-2">代码</h3><p>sum[i+1][j+1]表示matrix[0][0]到matrix[i][j]构成的区域的和<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-----+-+-------+     +--------+-----+     +-----+---------+     +-----+--------+</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">     </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">        </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">     </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">        </span>|</span><br><span class="line">+-----+-+       |<span class="string">     +--------+     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     +-----+        </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">  =  </span>|<span class="string">              </span>|<span class="string">  +  </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">  -  </span>|<span class="string">              </span>|</span><br><span class="line">+-----+-+       |<span class="string">     </span>|<span class="string">              </span>|<span class="string">     +-----+         </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|<span class="string">     </span>|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|<span class="string">     </span>|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">+---------------+     +--------------+     +---------------+     +--------------+</span><br><span class="line"></span><br><span class="line">   sums[i][j]      =    sums[i-1][j]    +     sums[i][j-1]    -   sums[i-1][j-1]   +  </span><br><span class="line"></span><br><span class="line">                        matrix[i-1][j-1]</span><br></pre></td></tr></table></figure></p>
<p>所以本题的所求区域的面积为：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br><span class="line">|<span class="string">               </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">          </span>|</span><br><span class="line">|<span class="string">   (r1,c1)     </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">          </span>|</span><br><span class="line">|<span class="string">   +------+    </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   +---------+    </span>|<span class="string">   +---+          </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">      </span>|<span class="string">    </span>|<span class="string"> = </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string"> - </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string"> - </span>|<span class="string">      (r1,c2) </span>|<span class="string"> + </span>|<span class="string">   (r1,c1)    </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">      </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">   +------+    </span>|<span class="string">   +---------+    </span>|<span class="string">   +---+           </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">        (r2,c2)</span>|<span class="string">   </span>|<span class="string">       (r2,c2)</span>|<span class="string">   </span>|<span class="string">   (r2,c1)     </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br></pre></td></tr></table></figure></p>
<p>根据以上思路，可得以下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NumMatrix &#123;</span><br><span class="line">    <span class="comment">//构造一个二维数组，sum[row+1][col+1]，加多第0行和第0列可以避免检查边界情况</span></span><br><span class="line">    <span class="comment">//相当于在第0行加了一行全为0的元素，第0列加了一列全为0的元素</span></span><br><span class="line">    <span class="comment">//sum[i+1][j+1]表示matrix[0][0]到matrix[i][j]构成的区域的和</span></span><br><span class="line">    <span class="comment">//sum[i][j] = sum[i-1][j]+sum[i][j-1] - sum[i-1][j-1]+matrix[i-1][j-1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)&#123;</span><br><span class="line">                sum[i][j] = sum[i-<span class="number">1</span>][j] + sum[i][j-<span class="number">1</span>] - sum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//虽然题目中已经假设 row1 ≤ row2 and col1 ≤ col2.</span></span><br><span class="line">        <span class="comment">//可以确保一下</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">if</span>(row1 &gt; row2)&#123;</span><br><span class="line">            temp = row2;</span><br><span class="line">            row2 = row1;</span><br><span class="line">            row1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col1 &gt; col2)&#123;</span><br><span class="line">            temp = col2;</span><br><span class="line">            col2 = col1;</span><br><span class="line">            col1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - sum[row2+<span class="number">1</span>][col1]- sum[row1][col2+<span class="number">1</span>] + sum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumMatrix numMatrix = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(0, 1, 2, 3);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(1, 2, 3, 4);</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="https://en.wikipedia.org/wiki/Segment_tree" target="_blank" rel="external">Segment tree</a><br><a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank" rel="external">Segment Tree | Set 1 (Sum of given range)</a><br><a href="http://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank" rel="external">Segment Tree | Set 2 (Range Minimum Query)</a><br><a href="http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/" target="_blank" rel="external">Binary Indexed Tree or Fenwick tree</a>_<br><a href="https://leetcode.com/articles/range-sum-query-mutable/" target="_blank" rel="external">Range Sum Query - Mutable</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Range_Sum_Query_-_Immutable">Range Sum Query - Immutable</h2><h3 id="题目描述">题目描述</h3><p>Given an integer array nums, find the sum of ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Validate Binary Search Tree]]></title>
    <link href="http://blog.noobsky.com/2016/06/19/LeetCode-Validate-Binary-Search-Tree/"/>
    <id>http://blog.noobsky.com/2016/06/19/LeetCode-Validate-Binary-Search-Tree/</id>
    <published>2016-06-19T01:14:53.000Z</published>
    <updated>2016-06-19T01:17:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">2</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Binary tree [1,2,3], return false.</p>
<h2 id="代码">代码</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> isValidBST(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);</span></span><br><span class="line">        <span class="comment">//return isValidBST(root, null, null);</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这样写有bug，比如root.val = Integer.MAX_VALUE就判断错误了</span></span><br><span class="line">    <span class="comment">// public boolean isValidBST(TreeNode root, int minVal, int maxVal)&#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return true;</span></span><br><span class="line">    <span class="comment">//     if(root.val &gt;= maxVal || root.val &lt;= minVal) return false;</span></span><br><span class="line">    <span class="comment">//     return isValidBST(root.left, minVal, root.val) &amp;&amp; isValidBST(root.right, root.val, maxVal);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改进形参用对象Integer和非空指针来判断</span></span><br><span class="line">    <span class="comment">// public boolean isValidBST(TreeNode root, Integer min, Integer max)&#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return true;</span></span><br><span class="line">    <span class="comment">//     return (min == null || root.val &gt; min) &amp;&amp; (max == null || root.val &lt; max) &amp;&amp; isValidBST(root.left, min, root.val) &amp;&amp; isValidBST(root.right, root.val, max);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或者使用long类型，因为数的定义val是int类型的</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> isValidBST(TreeNode root, <span class="keyword">long</span> <span class="built_in">min</span>, <span class="keyword">long</span> <span class="built_in">max</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= <span class="built_in">min</span> || root.val &gt;= <span class="built_in">max</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, <span class="built_in">min</span>, root.val) &amp;&amp; isValidBST(root.right, root.val, <span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follow]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Longest Substring Without Repeating Characters]]></title>
    <link href="http://blog.noobsky.com/2016/06/18/LeetCode-Longest-Substring-Without-Repeating-Characters/"/>
    <id>http://blog.noobsky.com/2016/06/18/LeetCode-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2016-06-18T13:17:07.000Z</published>
    <updated>2016-06-18T13:18:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:</p>
<p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p>
<p>Given “bbbbb”, the answer is “b”, with the length of 1.</p>
<p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<h2 id="代码">代码</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用HashMap记住字符和它对应的index</span></span><br><span class="line">    <span class="comment">//然后使用两个指针left和right，初始时指向index为0的位置，然后移动right指针遍历string中的字符，同时更新HashMap</span></span><br><span class="line">    <span class="comment">//如果right指向的字符HashMap已经存在，说明出现重复字符了，需要把left指针指向该字符上一次出现位置的右边和现在位置中的大者</span></span><br><span class="line">    <span class="comment">//在这个过程中，不管更新最长无重复字符字符串的长度</span></span><br><span class="line">    <span class="keyword">public</span> int lengthOfLongestSubstring(<span class="type">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HashMap</span>&lt;<span class="type">Character</span>, <span class="type">Integer</span>&gt; <span class="built_in">map</span> = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int <span class="keyword">right</span> = <span class="number">0</span>; <span class="keyword">right</span> &lt; s.length(); <span class="keyword">right</span>++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(s.charAt(<span class="keyword">right</span>)))&#123;</span><br><span class="line">                <span class="comment">//这里需要注意，这样写不对，我们需要确保map.get(s.charAt(right))+1 &gt; left才能赋值</span></span><br><span class="line">                <span class="comment">//不然会出现left指针往回移动的情况,比如s="abba",让right指向最右边的a时，left=2</span></span><br><span class="line">                <span class="comment">//如果直接赋值left = 1,left后退了，b字符重复，造成结果不正确</span></span><br><span class="line">                <span class="comment">//left = map.get(s.charAt(right)) + 1;</span></span><br><span class="line">                <span class="keyword">left</span> = <span class="type">Math</span>.<span class="built_in">max</span>(<span class="keyword">left</span>, <span class="built_in">map</span>.<span class="keyword">get</span>(s.charAt(<span class="keyword">right</span>))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>.put(s.charAt(<span class="keyword">right</span>), <span class="keyword">right</span>);</span><br><span class="line">            maxLen = <span class="type">Math</span>.<span class="built_in">max</span>(maxLen, <span class="keyword">right</span>-<span class="keyword">left</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:</p>
<p>Giv]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximum Subarray And Maximum Product Subarray]]></title>
    <link href="http://blog.noobsky.com/2016/06/18/LeetCode-Maximum-Subarray-And-Maximum-Product-Subarray/"/>
    <id>http://blog.noobsky.com/2016/06/18/LeetCode-Maximum-Subarray-And-Maximum-Product-Subarray/</id>
    <published>2016-06-18T06:45:38.000Z</published>
    <updated>2016-06-18T11:46:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Maximum_Subarray">Maximum Subarray</h2><h3 id="题目描述">题目描述</h3><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p>
<p><strong> More practice: </strong><br>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<h3 id="代码">代码</h3><p>dp[i]:表示最后一个元素为nums[i]的子数组的最大和。那么：<br>dp[i] = max(dp[i-1] + num[i], nums[i])或者dp[i] = nums[i] + dp[i-1] &gt; 0 ? dp[i-1] : 0;<br>也就是说如果下标i之前的子数组和dp[i-1]大于0才对dp[i]有帮助，如果小于等于0的话，没有帮助甚至是负作用<br>那么最终的最大子数组和maxSum = max(dp[0], dp[1], dp[2]……dp[nums.length - 1])。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//dp[i]:表示最后一个元素为nums[i]的子数组的最大和。</span></span><br><span class="line">    <span class="comment">//dp[i] = max(dp[i-1] + num[i], nums[i])或者dp[i] = nums[i] + dp[i-1] &gt; 0 ? dp[i-1] : 0;</span></span><br><span class="line">    <span class="comment">//也就是说如果下标i之前的子数组和dp[i-1]大于0才对dp[i]有帮助，如果小于等于0的话，没有帮助甚至是负作用</span></span><br><span class="line">    <span class="comment">//那么最终的最大子数组和maxSum = max(dp[0], dp[1], dp[2]......dp[nums.length - 1]);</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxEndingHere = nums[<span class="number">0</span>], maxSoFar = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            maxEndingHere = Math.max(nums[i], maxEndingHere+nums[i]);</span><br><span class="line">            maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return maxSoFar;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面的变量虽然可读性好，但总觉得怪怪的:)</span></span><br><span class="line">    <span class="comment">//原始版本如下：</span></span><br><span class="line">    <span class="comment">//使用了O(n)的内存空间，其实这些空间是可以省掉，因为dp[i]只跟dp[i-1]有关系</span></span><br><span class="line">    <span class="comment">//所以我们用一个变量记住上次的dp结果就可以了，改进后就是上面的程序:)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Maximum_Product_Subarray">Maximum Product Subarray</h2><h3 id="题目描述-1">题目描述</h3><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p>
<h3 id="代码-1">代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">//max[i]：表示最后一个元素是nums[i]的子数组的最大乘积</span></span><br><span class="line">    <span class="comment">//min[i]：表示最后一个元素是nums[i]的子数组的最小乘积</span></span><br><span class="line">    <span class="comment">//max[i] = max(max[i-1]*nums[i], min[i-1]*nums[i], nums[i])</span></span><br><span class="line">    <span class="comment">//min[i] = min(max[i-1]*nums[i], min[i-1]*nums[i], nums[i])</span></span><br><span class="line">    <span class="comment">//最终的最大子数组乘积maxProduct = max(max[0], max[1],......, max[nums.length - 1])</span></span><br><span class="line">    <span class="comment">//这里既要维护最大值和维护最小值，因为乘法比假发特殊，负负得正，两个很小的负数相乘可能很大</span></span><br><span class="line">    <span class="comment">//有可能变成最大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maxProduct(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] <span class="built_in">max</span> = <span class="keyword">new</span> <span class="built_in">int</span>[nums.length];</span><br><span class="line">        <span class="built_in">int</span>[] <span class="built_in">min</span> = <span class="keyword">new</span> <span class="built_in">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">max</span>[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">min</span>[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> maxProduct = <span class="built_in">max</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="built_in">max</span>[i] = Math.<span class="built_in">max</span>(Math.<span class="built_in">max</span>(<span class="built_in">max</span>[i-<span class="number">1</span>]*nums[i], <span class="built_in">min</span>[i-<span class="number">1</span>]*nums[i]), nums[i]);</span><br><span class="line">            <span class="built_in">min</span>[i] = Math.<span class="built_in">min</span>(Math.<span class="built_in">min</span>(<span class="built_in">max</span>[i-<span class="number">1</span>]*nums[i], <span class="built_in">min</span>[i-<span class="number">1</span>]*nums[i]), nums[i]);</span><br><span class="line">            maxProduct = Math.<span class="built_in">max</span>(maxProduct, <span class="built_in">max</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面的程序我们使用了O(n)的内存空间，使用了两个额外的数组max和min，每个max[i]只与max[i-1]有关，</span></span><br><span class="line">    <span class="comment">//所以其实我们可以省掉这些内存空间，使用几个变量就可以了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maxProduct(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> maxHerePre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> minHerePre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> maxProduct = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> minHere, maxHere;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            maxHere = Math.<span class="built_in">max</span>(Math.<span class="built_in">max</span>(maxHerePre*nums[i], minHerePre*nums[i]), nums[i]);</span><br><span class="line">            minHere = Math.<span class="built_in">min</span>(Math.<span class="built_in">min</span>(maxHerePre*nums[i], minHerePre*nums[i]), nums[i]);</span><br><span class="line">            </span><br><span class="line">            maxProduct = Math.<span class="built_in">max</span>(maxProduct, maxHere);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录前一元素结尾的最大最小值为下次循环做准备</span></span><br><span class="line">            maxHerePre = maxHere;</span><br><span class="line">            minHerePre = minHere;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Maximum_Subarray">Maximum Subarray</h2><h3 id="题目描述">题目描述</h3><p>Find the contiguous subarray within an array (containing at least o]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
