<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-10-02T16:12:02.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Redis设计与实现之数据库]]></title>
    <link href="http://blog.noobsky.com/2016/10/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://blog.noobsky.com/2016/10/02/Redis设计与实现之数据库/</id>
    <published>2016-10-02T13:18:54.000Z</published>
    <updated>2016-10-02T16:12:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="服务器中的数据库">服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">  redisDb *db;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//服务器的数据库数量</span></span><br><span class="line">  int dbnum;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dbnum属性的值有服务器的database选项决定，默认情况下，该选项的值为16，所以redis服务器默认会创建19个数据库。</p>
<h2 id="切换数据库">切换数据库</h2><p>每个Redis客户端都有自己的目标数据库，每当客服端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。</p>
<p>默认情况，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p>
<p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">//记录客户端当前正在使用的数据库</span></span><br><span class="line">  redisDb *db;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;redisClient</span><br></pre></td></tr></table></figure></p>
<p>通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能–这就是SELECT命令的实现原理。</p>
<h2 id="数据库键空间">数据库键空间</h2><p>Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">  dict *dict;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键也就是数据库的键，每个键都是一个字符串对象</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li>
</ul>
<h3 id="添加新键">添加新键</h3><p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</p>
<h3 id="删除键">删除键</h3><h3 id="更新键">更新键</h3><h3 id="对键取值">对键取值</h3><h3 id="其他键空间操作">其他键空间操作</h3><h2 id="设置键的生存时间或过期时间">设置键的生存时间或过期时间</h2><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live, TTL）,在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p>
<p>还可通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间。</p>
<p>TTL命令和PTT命令返回键的剩余生存时间。</p>
<h3 id="设置过期时间">设置过期时间</h3><ul>
<li>EXPIRE <key> <ttl> 生存时间为ttl秒</ttl></key></li>
<li>PEXPIRE <key> <ttl> 生存时间为ttl毫秒</ttl></key></li>
<li>EXPIREAT <key> <timestamp> 过期时间为timestamp所指定的秒数时间戳</timestamp></key></li>
<li>PEXPIREAT <key> <timestamp> 过期时间为timestamp所指定的毫秒数时间戳</timestamp></key></li>
</ul>
<p>实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的。</p>
<h3 id="保存过期时间">保存过期时间</h3><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）</li>
<li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间（毫秒精度的时间戳）</li>
</ul>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">  dict *expires</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移除过期时间">移除过期时间</h3><p>PERSIST命令可以移除一个键的过期时间</p>
<p>该命令会在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p>
<h3 id="计算并返回剩余生存时间">计算并返回剩余生存时间</h3><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间</p>
<h3 id="过期键的判定">过期键的判定</h3><ul>
<li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间</li>
<li>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期</li>
</ul>
<h2 id="过期键删除策略">过期键删除策略</h2><h3 id="定时删除">定时删除</h3><p>在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</p>
<p>该策略对内存友好，可以保证过期键尽可能快地被删除，并释放过期键所占用的内存</p>
<p>缺点是对CPU时间是不友好的，在过期键多时删除过期键的行为可能会占用相当一部分CPU时间，会对服务器的响应时间和吞吐量造成影响。</p>
<p>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式–无序链表，查找时间复杂度为O(n)，不能高效地处理大量时间事件。</p>
<h3 id="惰性删除">惰性删除</h3><p>放任键过期不管，但每次从键空间获取键时，都检查取得的键是否过期，如果过期，则删除；如果没有过期，就返回该键。</p>
<p>对CPU友好，对内存不友好，内存泄漏</p>
<h3 id="定期删除">定期删除</h3><ul>
<li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li>
<li>惰性删除浪费太多内存，有内存泄漏的危险</li>
</ul>
<p>定期删除策略是前两种策略的一种整合和折中：</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
<li>通过定期删除过期键有效地减少了因为过期键而带来的内存浪费</li>
</ul>
<p>合理设置删除操作的执行时长和执行频率</p>
<h2 id="Redis的过期键删除策略">Redis的过期键删除策略</h2><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>
<h3 id="生成RDB文件">生成RDB文件</h3><p>执行SAVE命令或者BGSAVE命令时，程序会对数据库中的键进行检查，忽略已经过期的键</p>
<h3 id="载入RDB文件">载入RDB文件</h3><ul>
<li>服务器是主服务器时，载入RDB文件时，忽略过期的键</li>
<li>从服务器，载入RDB文件时，不论是否过期都会被载入数据库中</li>
</ul>
<h3 id="AOF文件写入">AOF文件写入</h3><p>键过期，但没有被惰性删除或者定期删除，那么AOF文件没有影响<br>当过期键被惰性删除或者定期删除时，程序会向AOF文件追加一条DEL命令</p>
<h3 id="AOF重写">AOF重写</h3><p>过期的键不会被保存到重写后的AOF中</p>
<h3 id="复制">复制</h3><h2 id="数据库通知">数据库通知</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="服务器中的数据库">服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：<br><f]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之对象]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之对象/</id>
    <published>2016-09-30T12:56:57.000Z</published>
    <updated>2016-10-02T13:17:54.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。</p>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<p>通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</p>
<p>除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制：当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p>
<p>最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。</p>
<h2 id="对象的类型与编码">对象的类型与编码</h2><p>Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> \*ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<h3 id="类型">类型</h3><p>对象的type属性记录了对象的类型，这个属性可以是下表列出的常量的其中一个。<br>| 类型常量 | 对象的名称     |<br>| :————- | :————- |<br>| REDIS_STRING       | 字符串对象       |<br>| REDIS_LIST       | 列表对象       |<br>| REDIS_HASH       | 哈希对象       |<br>| REDIS_SET       | 集合对象       |<br>| REDIS_ZSET       | 有序集合对象       |</p>
<p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；</li>
<li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，</li>
</ul>
<h3 id="编码和底层实现">编码和底层实现</h3><p>对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。</p>
<p>encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是下表列出的常量的其中一个。</p>
<table>
<thead>
<tr>
<th style="text-align:left">编码常量</th>
<th style="text-align:left">编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">REDIS_ENCODING_INT</td>
<td style="text-align:left">long 类型的整数</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_EMBSTR</td>
<td style="text-align:left">embstr 编码的简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_RAW</td>
<td style="text-align:left">简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_HT</td>
<td style="text-align:left">字典</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_LINKEDLIST</td>
<td style="text-align:left">双端链表</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_ZIPLIST</td>
<td style="text-align:left">压缩列表</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_INTSET</td>
<td style="text-align:left">整数集合</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_SKIPLIST</td>
<td style="text-align:left">跳跃表和字典</td>
</tr>
</tbody>
</table>
<h2 id="字符串常量">字符串常量</h2><p>字符串对象的编码可以是int、raw或者embstr。</p>
<p>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。</p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 32 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。</p>
<p>embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构，</p>
<p>embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的， 但使用 embstr 编码的字符串对象来保存短字符串值有以下好处：</p>
<ul>
<li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。</li>
<li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ul>
<p>最后要说的是， 可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。</p>
<p>最后要说的是， 可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。</p>
<p>在有需要的时候， 程序会将保存在字符串对象里面的字符串值转换回浮点数值， 执行某些操作， 然后再将执行操作所得的浮点数值转换回字符串值， 并继续保存在字符串对象里面。</p>
<p>字符串对象保存各类型值的编码方式如下：<br>| 值 | 编码 |<br>| :————- | :————- |<br>| 可以用long类型保存的整数       | int       |<br>| 可以用long double类型保存的浮点数       | embstr或者raw       |<br>| 字符串值，或者因为长度太大而没办法用long类型表示的整数，又或者因为长度太大而没有办法用long double类型表示的浮点数       | embstr 或者 raw       |</p>
<h3 id="编码的转换">编码的转换</h3><p>int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。</p>
<p>对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。</p>
<p>另外， 因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>
<h3 id="字符串命令的实现">字符串命令的实现</h3><h2 id="列表对象">列表对象</h2><p>列表对象的编码可以是ziplist或者linkedlist。</p>
<p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点(entry)保存了一个列表元素。</p>
<p>另一方面，linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p>
<p>注意， linkedlist 编码的列表对象在底层的双端链表结构中包含了多个字符串对象， 这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现， 字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。</p>
<h3 id="编码转换">编码转换</h3><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li>
<li>列表对象保存的元素数量小于 512 个；<br>不能满足这两个条件的列表对象需要使用 linkedlist 编码。</li>
</ul>
<p>注意<br>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 list-max-ziplist-value 选项和 list-max-ziplist-entries 选项的说明。</p>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面， 对象的编码也会从 ziplist 变为 linkedlist 。</p>
<h3 id="列表命令的实现">列表命令的实现</h3><h2 id="哈希对象">哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable。</p>
<p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ul>
<p>另一方面， hashtable 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
<h3 id="编码转换-1">编码转换</h3><p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li>
<li>哈希对象保存的键值对数量小于 512 个；<br>不能满足这两个条件的哈希对象需要使用 hashtable 编码。</li>
</ul>
<p>注意：<br>这两个条件的上限值是可以修改的， 具体请看配置文件中关于 hash-max-ziplist-value 选项和 hash-max-ziplist-entries 选项的说明。</p>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 ziplist 变为 hashtable 。</p>
<h3 id="哈希命令的实现">哈希命令的实现</h3><h2 id="哈希对象-1">哈希对象</h2><p>集合对象的编码可以是 intset 或者 hashtable 。</p>
<p>intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。</p>
<p>另一方面， hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 。</p>
<h3 id="编码转换-2">编码转换</h3><p>当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码：</p>
<p>集合对象保存的所有元素都是整数值；<br>集合对象保存的元素数量不超过 512 个；<br>不能满足这两个条件的集合对象需要使用 hashtable 编码。</p>
<p>注意</p>
<p>第二个条件的上限值是可以修改的， 具体请看配置文件中关于 set-max-intset-entries 选项的说明。</p>
<p>对于使用 intset 编码的集合对象来说， 当使用 intset 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 intset 变为 hashtable 。</p>
<h3 id="集合命令的实现">集合命令的实现</h3><h2 id="有序集合对象">有序集合对象</h2><p>有序集合的编码可以是ziplist或者skiplist。</p>
<p>有序集合的编码可以是 ziplist 或者 skiplist 。</p>
<p>ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。</p>
<p>skiplist 编码的有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zset &#123;</span><br><span class="line"></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></p>
<p>zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 object 属性保存了元素的成员， 而跳跃表节点的 score 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</p>
<p>除此之外， zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。</p>
<p>有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 double 类型的浮点数。 值得一提的是， 虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p>
<p>为什么有序集合需要同时使用跳跃表和字典来实现？</p>
<p>在理论上来说， 有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现， 但无论单独使用字典还是跳跃表， 在性能上对比起同时使用字典和跳跃表都会有所降低。</p>
<p>举个例子， 如果我们只使用字典来实现有序集合， 那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留， 但是， 因为字典以无序的方式来保存集合元素， 所以每次在执行范围型操作 —— 比如 ZRANK 、 ZRANGE 等命令时， 程序都需要对字典保存的所有元素进行排序， 完成这种排序需要至少 O(NlogN) 时间复杂度， 以及额外的 O(N) 内存空间 （因为要创建一个数组来保存排序后的元素）。</p>
<p>另一方面， 如果我们只使用跳跃表来实现有序集合， 那么跳跃表执行范围型操作的所有优点都会被保留， 但因为没有了字典， 所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(log N) 。</p>
<p>因为以上原因， 为了让有序集合的查找和范围型操作都尽可能快地执行， Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p>
<h3 id="编码的转换-1">编码的转换</h3><p>当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码：</p>
<p>有序集合保存的元素数量小于 128 个；<br>有序集合保存的所有元素成员的长度都小于 64 字节；<br>不能满足以上两个条件的有序集合对象将使用 skiplist 编码。</p>
<p>注意</p>
<p>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 zset-max-ziplist-entries 选项和 zset-max-ziplist-value 选项的说明。</p>
<p>对于使用 ziplist 编码的有序集合对象来说， 当使用 ziplist 编码所需的两个条件中的任意一个不能被满足时， 程序就会执行编码转换操作， 将原本储存在压缩列表里面的所有集合元素转移到 zset 结构里面， 并将对象的编码从 ziplist 改为 skiplist 。</p>
<h3 id="有序集合命令的实现">有序集合命令的实现</h3><h2 id="类型检查与命令多态">类型检查与命令多态</h2><p>Redis中用于操作键的命令基本上可以分为两种类型。<br>其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。</p>
<p>而另一种命令只能对特定类型的键执行， 比如说：</p>
<ul>
<li>SET 、 GET 、 APPEND 、 STRLEN 等命令只能对字符串键执行；</li>
<li>HDEL 、 HSET 、 HGET 、 HLEN 等命令只能对哈希键执行；</li>
<li>RPUSH 、 LPOP 、 LINSERT 、 LLEN 等命令只能对列表键执行；</li>
<li>SADD 、 SPOP 、 SINTER 、 SCARD 等命令只能对集合键执行；</li>
<li>ZADD 、 ZCARD 、 ZRANK 、 ZSCORE 等命令只能对有序集合键执行</li>
</ul>
<h3 id="类型检查的实现">类型检查的实现</h3><p>从上面发生类型错误的代码示例可以看出， 为了确保只有指定类型的键可以执行某些特定的命令， 在执行一个类型特定的命令之前， Redis 会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。</p>
<p>类型特定命令所进行的类型检查是通过 redisObject 结构的 type 属性来实现的：</p>
<ul>
<li>在执行一个类型特定命令之前， 服务器会先检查输入数据库键的值对象是否为执行命令所需的类型， 如果是的话， 服务器就对键执行指定的命令；</li>
<li>否则， 服务器将拒绝执行命令， 并向客户端返回一个类型错误。</li>
</ul>
<h3 id="多态命令的实现">多态命令的实现</h3><p>Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外， 还会根据值对象的编码方式， 选择正确的命令实现代码来执行命令。</p>
<p>举个例子， 在前面介绍列表对象的编码时我们说过， 列表对象有 ziplist 和 linkedlist 两种编码可用， 其中前者使用压缩列表 API 来实现列表命令， 而后者则使用双端链表 API 来实现列表命令。</p>
<p>现在， 考虑这样一个情况， 如果我们对一个键执行 LLEN 命令， 那么服务器除了要确保执行命令的是列表键之外， 还需要根据键的值对象所使用的编码来选择正确的 LLEN 命令实现：</p>
<ul>
<li>如果列表对象的编码为 ziplist ， 那么说明列表对象的实现为压缩列表， 程序将使用 ziplistLen 函数来返回列表的长度；</li>
<li>如果列表对象的编码为 linkedlist ， 那么说明列表对象的实现为双端链表， 程序将使用 listLength 函数来返回双端链表的长度；</li>
</ul>
<p>借用面向对象方面的术语来说， 我们可以认为 LLEN 命令是多态（polymorphism）的： 只要执行 LLEN 命令的是列表键， 那么无论值对象使用的是 ziplist 编码还是 linkedlist 编码， 命令都可以正常执行。</p>
<h2 id="内存回收">内存回收</h2><p>因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。</p>
<p>每个对象的引用计数信息由 redisObject 结构的 refcount 属性记录：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    int refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时， 引用计数的值会被初始化为 1 ；</li>
<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。</li>
</ul>
<p>下表列出了修改对象引用计数的 API ， 这些 API 分别用于增加、减少、重置对象的引用计数。<br>| 函数 | 作用 |<br>| :————- | :————- |<br>| incrRefCount | 将对象的引用计数数值增一 |<br>| decrRefCount | 将对象的引用计数数值增一，当对象的引用计数值等于0时，释放对象 |<br>| resetRefCount | 将对象的引用计数数值设置为0，但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。 |</p>
<p>对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。</p>
<p>作为例子， 以下代码展示了一个字符串对象从创建到释放的整个过程：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象 s ，对象的引用计数为 1</span></span><br><span class="line">robj *s = <span class="function"><span class="title">createStringObject</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象 s 执行各种操作 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象 s 的引用计数减一，使得对象的引用计数变为 0</span></span><br><span class="line"><span class="comment">// 导致对象 s 被释放</span></span><br><span class="line"><span class="function"><span class="title">decrRefCount</span><span class="params">(s)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其他不同类型的对象也会经历类似的过程。</p>
<h2 id="对象共享">对象共享</h2><p>除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有对象共享的作用。</p>
<p>举个例子， 假设键 A 创建了一个包含整数值 100 的字符串对象作为值对象，</p>
<p>如果这时键 B 也要创建一个同样保存了整数值 100 的字符串对象作为值对象， 那么服务器有以下两种做法：</p>
<p>为键 B 新创建一个包含整数值 100 的字符串对象；<br>让键 A 和键 B 共享同一个字符串对象；<br>以上两种方法很明显是第二种方法更节约内存。</p>
<p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ul>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。</li>
</ul>
<p>共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存。</p>
<p>比如说， 假设数据库中保存了整数值 100 的键不只有键 A 和键 B 两个， 而是有一百个， 那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存的数据。</p>
<p>目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>
<p>注意</p>
<p>创建共享字符串对象的数量可以通过修改 redis.h/REDIS_SHARED_INTEGERS 常量来修改。</p>
<p>另外， 这些共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（linkedlist 编码的列表对象、 hashtable 编码的哈希对象、 hashtable 编码的集合对象、以及 zset 编码的有序集合对象）都可以使用这些共享对象。</p>
<p>为什么 Redis 不共享包含字符串的对象？</p>
<p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p>
<ul>
<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>
<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>
<li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。<br>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。</li>
</ul>
<h2 id="对象的空转时长">对象的空转时长</h2><p>除了前面介绍过的 type 、 encoding 、 ptr 和 refcount 四个属性之外， redisObject 结构包含的最后一个属性为 lru 属性， 该属性记录了对象最后一次被命令程序访问的时间：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; <span class="keyword">SET</span> msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 等待一小段时间</span></span><br><span class="line">redis&gt; <span class="built_in">OBJECT</span> IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 等待一阵子</span></span><br><span class="line">redis&gt; <span class="built_in">OBJECT</span> IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">180</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 访问 msg 键的值</span></span><br><span class="line">redis&gt; <span class="keyword">GET</span> msg</span><br><span class="line"><span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 键处于活跃状态，空转时长为 0</span></span><br><span class="line">redis&gt; <span class="built_in">OBJECT</span> IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>注意</p>
<p>OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 lru 属性。</p>
<p>除了可以被 OBJECT IDLETIME 命令打印出来之外， 键的空转时长还有另外一项作用： 如果服务器打开了 maxmemory 选项， 并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru ， 那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>
<p>配置文件的 maxmemory 选项和 maxmemory-policy 选项的说明介绍了关于这方面的更多信息。</p>
<h2 id="重点回顾">重点回顾</h2><ul>
<li>Redis 数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。</li>
<li>Redis 会共享值为 0 到 9999 的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。</p>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、]]>
    </summary>
    
      <category term="Redis设计与实现" scheme="http://blog.noobsky.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Redis" scheme="http://blog.noobsky.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之压缩列表]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之压缩列表/</id>
    <published>2016-09-30T11:52:52.000Z</published>
    <updated>2016-09-30T12:56:25.000Z</updated>
    <content type="html"><![CDATA[<p>压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p>
<p>同理，当一个哈希键只包含少量键值对，而且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</p>
<h2 id="压缩列表的构成">压缩列表的构成</h2><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。压缩列表的各个组成部分如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">---------------------------------------------------------------------</span><br><span class="line">| zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend |</span><br><span class="line">---------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">长度</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">zlbytes</td>
<td style="text-align:left">uint32_t</td>
<td style="text-align:left">4字节</td>
<td style="text-align:left">记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</td>
</tr>
<tr>
<td style="text-align:left">zltail</td>
<td style="text-align:left">uint32_t</td>
<td style="text-align:left">4字节</td>
<td style="text-align:left">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td style="text-align:left">zllen</td>
<td style="text-align:left">uint16_t</td>
<td style="text-align:left">2字节</td>
<td style="text-align:left">记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td style="text-align:left">entryX</td>
<td style="text-align:left">列表节点</td>
<td style="text-align:left">不定</td>
<td style="text-align:left">压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td style="text-align:left">zlend</td>
<td style="text-align:left">uint8_t</td>
<td style="text-align:left">1字节</td>
<td style="text-align:left">特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td>
</tr>
</tbody>
</table>
<h2 id="压缩列表节点的构成">压缩列表节点的构成</h2><p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中， 字节数组可以是以下三种长度的其中一种：</p>
<ul>
<li>长度小于等于 63 （2^{6}-1）字节的字节数组；</li>
<li>长度小于等于 16383 （2^{14}-1） 字节的字节数组；</li>
<li>长度小于等于 4294967295 （2^{32}-1）字节的字节数组；</li>
</ul>
<p>而整数值则可以是以下六种长度的其中一种：</p>
<ul>
<li>4 位长，介于 0 至 12 之间的无符号整数；</li>
<li>1 字节长的有符号整数；</li>
<li>3 字节长的有符号整数；</li>
<li>int16_t 类型整数；</li>
<li>int32_t 类型整数；</li>
<li>int64_t 类型整数。</li>
</ul>
<p>每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成， 如下所示。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">----------------------------------------------</span><br><span class="line">| previous_entry_length | encoding | content |</span><br><span class="line">----------------------------------------------</span></span><br></pre></td></tr></table></figure></p>
<h3 id="previous_entry_length">previous_entry_length</h3><p>节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</p>
<p>previous_entry_length 属性的长度可以是 1 字节或者 5 字节：</p>
<ul>
<li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p>因为节点的 previous_entry_length 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。</p>
<p>举个例子， 如果我们有一个指向当前节点起始地址的指针 c ， 那么我们只要用指针 c 减去当前节点 previous_entry_length 属性的值， 就可以得出一个指向前一个节点起始地址的指针 p。</p>
<p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的： 只要我们拥有了一个指向某个节点起始地址的指针， 那么通过这个指针以及这个节点的 previous_entry_length 属性， 程序就可以一直向前一个节点回溯， 最终到达压缩列表的表头节点。</p>
<h3 id="encoding">encoding</h3><p>节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度：</p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</li>
<li>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</li>
</ul>
<h3 id="content">content</h3><p>节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定。</p>
<h2 id="连锁更新">连锁更新</h2><h2 id="重点回顾">重点回顾</h2><ul>
<li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li>
<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p>
<p>同理，当一个哈希键只包含少量键值对，而且每个键值对的键和值]]>
    </summary>
    
      <category term="Redis设计与实现" scheme="http://blog.noobsky.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Redis" scheme="http://blog.noobsky.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之整数集合]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之整数集合/</id>
    <published>2016-09-30T09:27:52.000Z</published>
    <updated>2016-09-30T11:52:23.000Z</updated>
    <content type="html"><![CDATA[<p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素时，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p>
<h2 id="整数集合的实现">整数集合的实现</h2><p>整数集合(intset)是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p>
<p>每个intset.h/intset结构表示一个整数集合：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> intset &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p>
<p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数据项(item)，各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</p>
<p>length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。</p>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：</p>
<ul>
<li>如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT32 ， 那么 contents 就是一个 int32_t 类型的数组， 数组里的每个项都是一个 int32_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT64 ， 那么 contents 就是一个 int64_t 类型的数组， 数组里的每个项都是一个 int64_t 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）。</li>
</ul>
<h2 id="升级">升级</h2><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ul>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ul>
<h2 id="升级的好处">升级的好处</h2><p>整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。</p>
<h3 id="提升灵活性">提升灵活性</h3><p>因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>
<p>比如说， 我们一般只使用 int16_t 类型的数组来保存 int16_t 类型的值， 只使用 int32_t 类型的数组来保存 int32_t 类型的值， 诸如此类。</p>
<p>但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 int16_t 、 int32_t 或者 int64_t 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</p>
<h3 id="节约内存">节约内存</h3><p>当然， 要让一个数组可以同时保存 int16_t 、 int32_t 、 int64_t 三种类型的值， 最简单的做法就是直接使用 int64_t 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 int16_t 类型或者 int32_t 类型的值， 数组都需要使用 int64_t 类型的空间去保存它们， 从而出现浪费内存的情况。</p>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<p>比如说， 如果我们一直只向整数集合添加 int16_t 类型的值， 那么整数集合的底层实现就会一直是 int16_t 类型的数组， 只有在我们要将 int32_t 类型或者 int64_t 类型的值添加到集合时， 程序才会对数组进行升级。</p>
<h2 id="降级">降级</h2><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<h2 id="重点回顾">重点回顾</h2><ul>
<li>整数集合是集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素时，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p>
<h2 id="整数集合的实现">整数集合的实现</h2><p>整数集合(intset)是Redis用于保存]]>
    </summary>
    
      <category term="Redis设计与实现" scheme="http://blog.noobsky.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Redis" scheme="http://blog.noobsky.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之跳跃表]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之跳跃表/</id>
    <published>2016-09-30T07:35:58.000Z</published>
    <updated>2016-09-30T09:25:49.000Z</updated>
    <content type="html"><![CDATA[<p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所有有不少程序都使用跳跃表来代替平衡树。</p>
<p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表作为有序集合键的底层实现。</p>
<p>Reids只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p>
<h2 id="跳跃表节点">跳跃表节点</h2><p>跳跃表节点的实现由redis.h/zskiplistNode结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 跳跃表节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="keyword">struct</span> zskiplistNode *backward;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="keyword">struct</span> zskiplistNode *forward;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p>
<h3 id="层">层</h3><p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p>
<h3 id="前进指针">前进指针</h3><p>每个层都有一个指向表尾方向的前进指针（level[i].forward 属性）， 用于从表头向表尾方向访问节点。</p>
<h3 id="跨度">跨度</h3><p>层的跨度（level[i].span 属性）用于记录两个节点之间的距离：</p>
<ul>
<li>两个节点之间的跨度越大， 它们相距得就越远。</li>
<li>指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。</li>
</ul>
<p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p>
<h3 id="后退指针">后退指针</h3><p>节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p>
<h3 id="分值和成员">分值和成员</h3><p>节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p>
<p>节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p>
<p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p>
<h2 id="跳跃表">跳跃表</h2><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表。但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息</p>
<p>zskiplist结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 跳跃表</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
<p>header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</p>
<p>通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</p>
<p>level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。</p>
<h2 id="重点回顾">重点回顾</h2><ul>
<li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。</li>
<li>Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成， 其中 zskiplist 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示跳跃表节点。</li>
<li>每个跳跃表节点的层高都是 1 至 32 之间的随机数。</li>
<li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下，跳跃表的效]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之字典]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AD%97%E5%85%B8/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之字典/</id>
    <published>2016-09-30T02:09:52.000Z</published>
    <updated>2016-09-30T07:41:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="字典的实现">字典的实现</h2><h3 id="哈希表">哈希表</h3><p>Redis字典所使用的哈希表由dict.h/dictht结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span><br><span class="line"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 哈希表</span><br><span class="line"> *</span><br><span class="line"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p>
<p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</p>
<p>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</p>
<p>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</p>
<h3 id="哈希表节点">哈希表节点</h3><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 哈希表节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="keyword">struct</span> dictEntry *next;</span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</p>
<p>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</p>
<h3 id="字典">字典</h3><p>Redis 中的字典由 dict.h/dict 结构表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 字典</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p>
<p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
<li>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 字典类型特定函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictType &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p>
<p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p>
<h2 id="哈希算法">哈希算法</h2><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis 计算哈希值和索引值的方法如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line"><span class="title">hash</span> = dict-&gt;<span class="typedef"><span class="keyword">type</span>-&gt;hashFunction<span class="container">(<span class="title">key</span>)</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="preprocessor"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line"><span class="title">index</span> = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>
<h2 id="解决键冲突">解决键冲突</h2><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p>因为 dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面。</p>
<h2 id="rehash">rehash</h2><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li><p>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）：</p>
<ul>
<li>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；</li>
<li>如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</li>
</ul>
</li>
<li><p>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</p>
</li>
<li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<h3 id="哈希表的扩展与收缩">哈希表的扩展与收缩</h3><p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ul>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；<br>其中哈希表的负载因子可以通过公式：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span></span><br><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>
<p>根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p>
<p>另一方面， 当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。</p>
<h2 id="渐进式rehash">渐进式rehash</h2><p>扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>
<p>这样做的原因在于， 如果 ht[0] 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ul>
<li>为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li>
</ul>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<h3 id="渐进式rehash执行期间的哈希表操作">渐进式rehash执行期间的哈希表操作</h3><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<h2 id="重点回顾">重点回顾</h2><ul>
<li>字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。</li>
<li>Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。</li>
<li>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</li>
<li>哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。</li>
<li>在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="字典的实现">字典的实现</h2><h3 id="哈希表">哈希表</h3><p>Redis字典所使用的哈希表由dict.h/dictht结构定义：<br><figure class="highlight c"><table><tr><td class="gutt]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之链表]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之链表/</id>
    <published>2016-09-29T16:18:29.000Z</published>
    <updated>2016-09-30T02:01:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="链表和链表节点的实现">链表和链表节点的实现</h2><p>每个链表节点使用一个adlist.h/listNode结构来表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 双端链表节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="keyword">struct</span> listNode *prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="keyword">struct</span> listNode *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>
<p>链表结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 双端链表结构</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">list</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p>list 结构为链表提供了表头指针 head 、表尾指针 tail ， 以及链表长度计数器 len ， 而 dup 、 free 和 match 成员则是用于实现多态链表所需的类型特定函数：</p>
<ul>
<li>dup 函数用于复制链表节点所保存的值；</li>
<li>free 函数用于释放链表节点所保存的值；</li>
<li>match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li>
</ul>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双端：链表节点带有prev和next指针， 获取某个节点的前置节点和后置节点的复杂度都是O(1) 。</li>
<li>无环： 表头节点的prev指针和表尾节点的next指针都指向NULL ， 对链表的访问以NULL为终点。</li>
<li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</li>
<li>多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h2 id="链表和链表节点的API">链表和链表节点的API</h2><h2 id="重点回顾">重点回顾</h2><ul>
<li>链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。</li>
<li>每个链表节点由一个 listNode 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。</li>
<li>每个链表使用一个 list 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。</li>
<li>因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL ， 所以 Redis 的链表实现是无环链表。</li>
<li>通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="链表和链表节点的实现">链表和链表节点的实现</h2><p>每个链表节点使用一个adlist.h/listNode结构来表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><s]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之简单动态字符串]]></title>
    <link href="http://blog.noobsky.com/2016/09/29/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://blog.noobsky.com/2016/09/29/Redis设计与实现之简单动态字符串/</id>
    <published>2016-09-29T04:00:39.000Z</published>
    <updated>2016-09-30T01:38:40.000Z</updated>
    <content type="html"><![CDATA[<p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串(simple dynamic string, SDS)的抽象类型，并将SDS用作Redis的默认字符表示。</p>
<h2 id="SDS的定义">SDS的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 保存字符串对象的结构</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> sdshdr &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。</p>
<h2 id="SDS与C字符串的区别">SDS与C字符串的区别</h2><p>根据传统， C 语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串， 并且字符数组的最后一个元素总是空字符 ‘\0’ 。<br>C 语言使用的这种简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求， 本节接下来的内容将详细对比 C 字符串和 SDS 之间的区别， 并说明 SDS 比 C 字符串更适用于 Redis 的原因。</p>
<h3 id="常数复杂度获取字符串长度">常数复杂度获取字符串长度</h3><p>C字符串并不记录自身的长度信息，获取长度需遍历整个字符串，时间复杂度为O(n)。而SDS获取字符串的长度可以直接访问SDS的len属性即可获得字符串的长度，时间复杂度为O(1)</p>
<h3 id="杜绝缓冲区溢出">杜绝缓冲区溢出</h3><p>SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。</p>
<h3 id="减少修改字符串时带来的内存重分配次数">减少修改字符串时带来的内存重分配次数</h3><p>在 SDS 中， buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 free 属性记录。</p>
<p>通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。</p>
<ul>
<li>空间预分配</li>
</ul>
<p>空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。</p>
<ul>
<li>惰性空间释放</li>
</ul>
<p>惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。</p>
<h3 id="二进制安全">二进制安全</h3><h3 id="兼容部分C字符串函数">兼容部分C字符串函数</h3><p>虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 <string.h> 库定义的函数。</string.h></p>
<h2 id="总结">总结</h2><table>
<thead>
<tr>
<th style="text-align:left">C字符串</th>
<th style="text-align:left">SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">获取字符串长度的复杂度为 O(N)</td>
<td style="text-align:left">获取字符串长度的复杂度为 O(1)</td>
</tr>
<tr>
<td style="text-align:left">API 是不安全的，可能会造成缓冲区溢出</td>
<td style="text-align:left">API 是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td style="text-align:left">修改字符串长度 N 次必然需要执行 N 次内存重分配</td>
<td style="text-align:left">修改字符串长度 N 次最多需要执行 N 次内存重分配</td>
</tr>
<tr>
<td style="text-align:left">只能保存文本数据</td>
<td style="text-align:left">可以保存文本或者二进制数据</td>
</tr>
<tr>
<td style="text-align:left">可以使用所有 <string.h> 库中的函数</string.h></td>
<td style="text-align:left">可以使用一部分 <string.h> 库中的函数</string.h></td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串(simple dynamic string, SDS)的抽象类型，并将SDS用作Redis的默认字符表示。</p>
<h2 id="SDS的定义">SDS的定义</]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之动态规划问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/09/28/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/09/28/面试算法之动态规划问题集锦/</id>
    <published>2016-09-28T01:57:10.000Z</published>
    <updated>2016-09-29T13:29:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="计算数组下标i与j之间的元素之和">计算数组下标i与j之间的元素之和</h2><p>用sum[i]来存储0到i之间元素的和，0到j的和减去0到i-1的和(即sum[j]-sum[i-1])即为所求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumArray</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) sums[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> sums[i] = sums[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> sums[j];</span><br><span class="line">        <span class="keyword">return</span> sums[j] - sums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="计算二维矩阵矩形区域的值">计算二维矩阵矩形区域的值</h2><p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt=""></p>
<p>sum[i+1][j+1]表示matrix[0][0]到matrix[i][j]构成的区域的和<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-----+-+-------+     +--------+-----+     +-----+---------+     +-----+--------+</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">     </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">        </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">     </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">        </span>|</span><br><span class="line">+-----+-+       |<span class="string">     +--------+     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     +-----+        </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">  =  </span>|<span class="string">              </span>|<span class="string">  +  </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">  -  </span>|<span class="string">              </span>|</span><br><span class="line">+-----+-+       |<span class="string">     </span>|<span class="string">              </span>|<span class="string">     +-----+         </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|<span class="string">     </span>|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|<span class="string">     </span>|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">+---------------+     +--------------+     +---------------+     +--------------+</span><br><span class="line"></span><br><span class="line">   sums[i][j]      =    sums[i-1][j]    +     sums[i][j-1]    -   sums[i-1][j-1]   +  </span><br><span class="line"></span><br><span class="line">                        matrix[i-1][j-1]</span><br></pre></td></tr></table></figure></p>
<p>所以区域和的计算方法如下图：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br><span class="line">|<span class="string">               </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">          </span>|</span><br><span class="line">|<span class="string">   (r1,c1)     </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">          </span>|</span><br><span class="line">|<span class="string">   +------+    </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   +---------+    </span>|<span class="string">   +---+          </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">      </span>|<span class="string">    </span>|<span class="string"> = </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string"> - </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string"> - </span>|<span class="string">      (r1,c2) </span>|<span class="string"> + </span>|<span class="string">   (r1,c1)    </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">      </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">   +------+    </span>|<span class="string">   +---------+    </span>|<span class="string">   +---+           </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">        (r2,c2)</span>|<span class="string">   </span>|<span class="string">       (r2,c2)</span>|<span class="string">   </span>|<span class="string">   (r2,c1)     </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造一个二维数组，sum[row+1][col+1]，加多第0行和第0列可以避免检查边界情况</span></span><br><span class="line">    <span class="comment">//相当于在第0行加了一行全为0的元素，第0列加了一列全为0的元素</span></span><br><span class="line">    <span class="comment">//sum[i+1][j+1]表示matrix[0][0]到matrix[i][j]构成的区域的和</span></span><br><span class="line">    <span class="comment">//sum[i][j] = sum[i-1][j]+sum[i][j-1] - sum[i-1][j-1]+matrix[i-1][j-1]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)&#123;</span><br><span class="line">                sum[i][j] = sum[i-<span class="number">1</span>][j] + sum[i][j-<span class="number">1</span>] - sum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//虽然题目中已经假设 row1 ≤ row2 and col1 ≤ col2.</span></span><br><span class="line">        <span class="comment">//可以确保一下</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">if</span>(row1 &gt; row2)&#123;</span><br><span class="line">            temp = row2;</span><br><span class="line">            row2 = row1;</span><br><span class="line">            row1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col1 &gt; col2)&#123;</span><br><span class="line">            temp = col2;</span><br><span class="line">            col2 = col1;</span><br><span class="line">            col1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - sum[row2+<span class="number">1</span>][col1]- sum[row1][col2+<span class="number">1</span>] + sum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumMatrix numMatrix = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(0, 1, 2, 3);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(1, 2, 3, 4);</span></span><br></pre></td></tr></table></figure>
<h2 id="Range_Sum_Query_-_Mutable">Range Sum Query - Mutable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Segment Tree，sumRange和update都是O(lgn)</span></span><br><span class="line">    <span class="comment">//叶子节点为数组中的元素，内部节点(非叶子节点)代表了该节点下叶子的和</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录该节点下叶子包含数组中[start, end]的元素</span></span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        <span class="comment">//nums[start...end]直接的元素之和</span></span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="comment">//左右孩子</span></span><br><span class="line">        SegmentTreeNode left, right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SegmentTreeNode</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SegmentTreeNode root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        root = buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用nums中[start...end]的元素构造SegmentTree</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SegmentTreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            SegmentTreeNode node = <span class="keyword">new</span> SegmentTreeNode(start, end);</span><br><span class="line">            <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">                node.sum = nums[start];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//进入这个分支，[start...end]起码有两个元素，node.left和node.right都不会为空</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">                node.left = buildTree(nums, start, mid);</span><br><span class="line">                node.right = buildTree(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">                <span class="comment">//左子树加上右子树的和</span></span><br><span class="line">                node.sum = node.left.sum + node.right.sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update(root, i, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(SegmentTreeNode root, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.start == root.end)&#123;</span><br><span class="line">            root.sum = val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = root.start + (root.end - root.start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos &lt;= mid)&#123;<span class="comment">//在左子树中</span></span><br><span class="line">                update(root.left, pos, val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                update(root.right, pos, val);</span><br><span class="line">            &#125;</span><br><span class="line">            root.sum = root.left.sum + root.right.sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sumRange(root, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(SegmentTreeNode root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.start == start &amp;&amp; root.end == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//计算root.start和root.end的中间值</span></span><br><span class="line">            <span class="keyword">int</span> mid = root.start + (root.end - root.start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(end &lt;= mid)&#123;<span class="comment">//全部在左子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.left, start, end);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start &gt;= mid + <span class="number">1</span>)&#123;<span class="comment">//全部在右子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.right, start, end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//分散在左右子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.left, start, mid) + sumRange(root.right, mid+<span class="number">1</span>, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumArray numArray = new NumArray(nums);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(0, 1);</span></span><br><span class="line"><span class="comment">// numArray.update(1, 10);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(1, 2);</span></span><br></pre></td></tr></table></figure>
<h2 id="House_Robber">House Robber</h2><p>相邻的房子只能抢一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以不使用O(n)的空间复杂度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = Math.max(pre+nums[i], curr);</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="House_Robber_II">House Robber II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//房子首尾相连形成了一个圈，所以i间房子和i+1间房子只能有一间抢，或者两者都不抢</span></span><br><span class="line">    <span class="comment">//如果假设第i间不抢，则我们可以打断该圈，比如1-&gt;2-&gt;3-&gt;1则变成了2-&gt;3如果1不抢，</span></span><br><span class="line">    <span class="comment">//我们假设第i间房子不抢，剩下的房子组成的连续序列用House Robber的方法求解出最大值max1</span></span><br><span class="line">    <span class="comment">//然后假设第i+1间房子不抢，剩下的房子组成的连续序列用House Robber的方法求解出最大值max2，max1和max2的较大者即为所求</span></span><br><span class="line">    <span class="comment">//为了编程简单，我们选择i=n，i+1=0，也就是说我们把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后比较两个值取</span></span><br><span class="line">    <span class="comment">//取其中的最大值即为所求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(robHelper(nums, <span class="number">0</span>, nums.length-<span class="number">2</span>), robHelper(nums, <span class="number">1</span>, nums.length-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robHelper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = Math.max(pre+nums[i], curr);</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Climbing_Stairs">Climbing Stairs</h2><p>爬楼梯，每次只能走一步或者二步，求不同的方法数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">  res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  res[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">      res[i] = res[i-<span class="number">2</span>] + res[i-<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//前一级阶梯不同路径数</span></span><br><span class="line">    <span class="keyword">int</span> oneStep = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//前两级阶梯的不同路径数</span></span><br><span class="line">    <span class="keyword">int</span> twoStep = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> allWays = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        allWays = oneStep + twoStep;</span><br><span class="line">        twoStep = oneStep;</span><br><span class="line">        oneStep = allWays;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allWays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Minimum_Path_Sum">Minimum Path Sum</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态转移方程：sum[i][j] = grid[i][j]+min(sum[i-1][j], sum[i][j-1])</span></span><br><span class="line"><span class="comment">//注意处理边界情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length;</span><br><span class="line">    <span class="keyword">if</span>(row == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实sum数组可以省掉，直接在grid数组上进行</span></span><br><span class="line">    <span class="keyword">int</span> sum[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) sum[i][j] = grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) sum[i][j] = sum[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) sum[i][j] = sum[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> sum[i][j] = Math.min(sum[i-<span class="number">1</span>][j], sum[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Unique_Paths">Unique Paths</h2><p>左上到右下，只能往右或往下走，求不同的路径数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a[m][n] = a[m-1][n]+a[m][n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//grid[0][1] = 1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            grid[i][j] = (i == <span class="number">0</span> || j == <span class="number">0</span>) ? <span class="number">1</span> : grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//a[m][n] = a[m-1][n]+a[m][n-1]</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">     <span class="comment">//第一排和第一列都为1</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">         grid[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">         grid[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">             grid[i][j] = grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique_Paths_II">Unique Paths II</h2><p>类似Unique Paths，但是如果值为1表示为障碍不能通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> grid[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) grid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">0</span> : grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) grid[<span class="number">0</span>][j] = (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) ? <span class="number">0</span> : grid[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                grid[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以但是不够好理解</span></span><br><span class="line">    <span class="comment">// public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span></span><br><span class="line">    <span class="comment">//     int m = obstacleGrid.length;</span></span><br><span class="line">    <span class="comment">//     if(m == 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int n = obstacleGrid[0].length;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int grid[][] = new int[m+1][n+1];</span></span><br><span class="line">    <span class="comment">//     grid[0][1] = 1;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt;= m; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 1; j &lt;= n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             grid[i][j] = obstacleGrid[i-1][j-1] == 1 ? 0 : grid[i-1][j]+grid[i][j-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return grid[m][n];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Guess_Number_Higher_or_Lower_II">Guess Number Higher or Lower II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> solve(dp, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//top-down，效率不高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[][] dp, <span class="keyword">int</span> left , <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[left][right] != <span class="number">0</span>) <span class="keyword">return</span> dp[left][right];</span><br><span class="line"></span><br><span class="line">        dp[left][right] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            dp[left][right] = Math.min(dp[left][right], i + Math.max(solve(dp, left, i-<span class="number">1</span>), solve(dp, i+<span class="number">1</span>, right)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[left][right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bottom-up</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int len = 1; len &lt; n; len++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int i = 1; i &lt;= n-len; i++)&#123;</span></span><br><span class="line">        <span class="comment">//         int j = i + len;</span></span><br><span class="line">        <span class="comment">//         int min = Integer.MAX_VALUE;</span></span><br><span class="line">        <span class="comment">//         for(int k = i; k &lt; j; k++)&#123;</span></span><br><span class="line">        <span class="comment">//             int temp = k + Math.max(dp[i][k-1], dp[k+1][j]);</span></span><br><span class="line">        <span class="comment">//             min = Math.min(min, temp);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         dp[i][j] = min;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n-len; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; j; k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], k + Math.max(dp[i][k-<span class="number">1</span>], dp[k+<span class="number">1</span>][j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Largest_Divisible_Subset">Largest Divisible Subset</h2><p>每一对(Si, Sj)都满足Si%Sj=0或者Sj%Si=0，类似LIS<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要排序，排序后相当于求最大递增子序列</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//dp数组dp[i]表示最大元素为num[i]的longest divisible subset的长度</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//为了得到序列我们需要记录每个nums[i]的前驱元素，所以我们prev数组来记录nums[i]前驱元素的下标</span></span><br><span class="line">        <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录largest divisible subset的最大长度</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最大长度最大元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//如果j = i开始，不用写dp[i] = 1;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span> &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//记录前驱元素的下标</span></span><br><span class="line">                    prev[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//dp[i]大于maxLen则更新最大长度和下标</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxLen)&#123;</span><br><span class="line">                maxLen = dp[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据prev数组找出largest divisible subset的所以元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++)&#123;</span><br><span class="line">            <span class="comment">//res.add(nums[maxIndex]);//这样添加其实是元素的逆序，但题目中也没有要求是顺序的</span></span><br><span class="line">            <span class="comment">//如果要求需要按顺序，当然这里顺序也不是原始数组的顺序，是排序后的顺序</span></span><br><span class="line">            res.add(<span class="number">0</span>, nums[maxIndex]);</span><br><span class="line">            maxIndex = prev[maxIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Decode_Ways">Decode Ways</h2><p>字母A-Z分别对应1-26，使用这个映射对信息进行编码。给定一个编码后的信息求不同的解码数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类似Climbing Stairs，只是多了一些限制条件</span></span><br><span class="line">    <span class="comment">//nums[i]：表示字符串s[0...i-1]的解码方式的总数</span></span><br><span class="line">    <span class="comment">//nums[i] = nums[i-1] if s[i-1] is valid char</span></span><br><span class="line">    <span class="comment">//or nums[i-1] + nums[i-2] if s[i-1] and s[i-2] to gether is still a valid char</span></span><br><span class="line">    <span class="comment">// public int numDecodings(String s) &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     if(s == null || s.length() == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int[] nums = new int[s.length() + 1];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //表示空字符串只有一种解码方式</span></span><br><span class="line">    <span class="comment">//     nums[0] = 1;</span></span><br><span class="line">    <span class="comment">//     //只含有s[0]一个字符的解码方式，如果是有效字符不为'0'则有一种方式，否则为零</span></span><br><span class="line">    <span class="comment">//     nums[1] = s.charAt(0) != '0' ? 1 : 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     for(int i = 2; i &lt;= s.length(); i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(isValid(s.substring(i-1,i)))&#123;</span></span><br><span class="line">    <span class="comment">//             nums[i] += nums[i-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         if(isValid(s.substring(i-2, i)))&#123;</span></span><br><span class="line">    <span class="comment">//             nums[i] += nums[i-2];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return nums[s.length()];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> value = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">1</span> &amp;&amp; value &lt;= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表示空字符串只有一种解码方式</span></span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//只含有s[0]一个字符的解码方式，如果是有效字符不为'0'则有一种方式，否则为零</span></span><br><span class="line">        nums[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = Integer.parseInt(s.substring(i-<span class="number">1</span>, i));</span><br><span class="line">            <span class="keyword">int</span> second = Integer.parseInt(s.substring(i-<span class="number">2</span>, i));</span><br><span class="line">            <span class="comment">//0开头，比如类似01，下面两个if都不会执行</span></span><br><span class="line">            <span class="keyword">if</span>(first &gt;= <span class="number">1</span> &amp;&amp; first &lt;= <span class="number">9</span>)&#123;</span><br><span class="line">                nums[i] += nums[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意second要大于等于10</span></span><br><span class="line">            <span class="keyword">if</span>(second &gt;= <span class="number">10</span> &amp;&amp; second &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                nums[i] += nums[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上两种写法都是top down dp，我们还可以用bottom up dp的方式，从字符串尾部往前dp</span></span><br><span class="line">    <span class="comment">//nums[i]表示s[i...s.length]的解码方式</span></span><br><span class="line">    <span class="comment">//以'0'开头的字符串解码方式为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings2</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//空字符串的解码方式</span></span><br><span class="line">        nums[length] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        nums[length-<span class="number">1</span>] = s.charAt(length - <span class="number">1</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>) <span class="keyword">continue</span>;<span class="comment">//以0开头的字符串都是无效的字符串，解码方式为0，默认初始化为0，写nums[i] = 0也可以</span></span><br><span class="line">            <span class="keyword">else</span> nums[i] = Integer.parseInt(s.substring(i, i+<span class="number">2</span>)) &lt;= <span class="number">26</span> ? nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] : nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique_Binary_Search_Trees">Unique Binary Search Trees</h2><p>节点数为n的不同BST的数量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//G(n): the number of unique BST for a sequence of length n,序列长度为n的不同BST的数量</span></span><br><span class="line">    <span class="comment">//F(i, n), 1 &lt;= i &lt;= n: the number of unique BST, where the number i is the root of BST,</span></span><br><span class="line">    <span class="comment">//and the sequence ranges from 1 to n.i为根节点，序列为1到n，不同BST的数量</span></span><br><span class="line">    <span class="comment">//则G(n) = F(1,n) + F(2,n)+F(3,n)+......+F(n,n);G(0) = 1(空树),G(1) = 1</span></span><br><span class="line">    <span class="comment">//F(i,n) = G(i-1)*G(n-i)</span></span><br><span class="line">    <span class="comment">//G(n) = G(0)*G(n-1)+G(1)*G(n-2)+......+G(n-1)G(0)</span></span><br><span class="line">    <span class="comment">//G(2) = G(0)G(1) + G(1)G(0)</span></span><br><span class="line">    <span class="comment">//G(3) = G(0)(2)+G(1)G(1)+G(2)G(0)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] G = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                G[i] += G[j-<span class="number">1</span>]*G[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique_Binary_Search_Trees_II">Unique Binary Search Trees II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> genTreeList(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分治算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">genTreeList</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次用[start, end]之间数为根</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">//然后递归求解根i左边[start, i-1]形成的左子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftList = genTreeList(start, i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//递归求解根i右边[i+1, end]区间形成的右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; rightList = genTreeList(i+<span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//左子树中的每个节点都能作为根节点的左孩子</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left : leftList)&#123;</span><br><span class="line">                <span class="comment">//右子树中的每个节点都能作为根节点的右孩子</span></span><br><span class="line">                <span class="comment">//所以将所有的不同的组合加入结果集中</span></span><br><span class="line">                <span class="keyword">for</span>(TreeNode right: rightList)&#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = left;</span><br><span class="line">                    root.right = right;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Count_Numbers_with_Unique_Digits">Count Numbers with Unique Digits</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//10以后的都没必要算了</span></span><br><span class="line">        n = Math.min(n, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>, count = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            count = count * (<span class="number">9</span>-i+<span class="number">2</span>);</span><br><span class="line">            res += count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> uniqueDigits = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> availableNumber = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用availableNumber &gt; 0来去掉那些多余的计算跟用Math.min(10,n);效果类似</span></span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">1</span> &amp;&amp; availableNumber &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            uniqueDigits = uniqueDigits * availableNumber;</span><br><span class="line">            res += uniqueDigits;</span><br><span class="line">            availableNumber--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Perfect_Squares">Perfect Squares</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i]表示正整数i最少能由多少个完全平方数之和组成</span></span><br><span class="line">    <span class="comment">//则dp[i] = min(dp[i - j*j]) + 1，i - j*j &gt;= 0 &amp;&amp; j &gt;= 1 ==&gt; j &lt;= sqrt(i) &amp;&amp; j &gt;= 1</span></span><br><span class="line">    <span class="comment">// public int numSquares(int n) &#123;</span></span><br><span class="line">    <span class="comment">//     if(n &lt;= 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int[] dp = new int[n+1];</span></span><br><span class="line">    <span class="comment">//     //全部元素初始化为最大值</span></span><br><span class="line">    <span class="comment">//     Arrays.fill(dp, Integer.MAX_VALUE);</span></span><br><span class="line">    <span class="comment">//     dp[0] = 0;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt;= n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 1; i - j*j &gt;= 0; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             dp[i] = Math.min(dp[i], dp[i - j*j] + 1);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return dp[n];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n % <span class="number">4</span> == <span class="number">0</span>) n = n / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">8</span> == <span class="number">7</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a =<span class="number">0</span>; a * a &lt;= n; a++)&#123;</span><br><span class="line">            <span class="keyword">int</span> b = (<span class="keyword">int</span>)Math.sqrt(n - a*a);</span><br><span class="line">            <span class="keyword">if</span>(a * a + b* b == n)&#123;</span><br><span class="line">                <span class="keyword">return</span> (a &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) + (b &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ugly_Number_II">Ugly Number II</h2><p>第n个丑数，丑数是素数因子只包含2，3，5的正整数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ugly[0] = 1</span></span><br><span class="line">    <span class="comment">//ugly[1] = min(2*ugly[0], 3*ugly[0], 5*ugly[0])</span></span><br><span class="line">    <span class="comment">//ugly[2] = min(2*ugly[1], 3*ugly[0], 5*ugly[0])</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ugly = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>, index3 = <span class="number">0</span>, index5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;i++)&#123;</span><br><span class="line">            ugly[i] = Math.min(Math.min(<span class="number">2</span> * ugly[index2], <span class="number">3</span> * ugly[index3]), <span class="number">5</span> * ugly[index5]);</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">2</span> * ugly[index2]) index2++;</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">3</span> * ugly[index3]) index3++;</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">5</span> * ugly[index5]) index5++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ugly[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Maximal_Square">Maximal Square</h2><p>给定二维二进制矩阵（值为1或0），找到只包含1的最大的正方形并返回其面积<br>比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>返回4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]表示在点matrix[i][j]最大的正方形的边长</span></span><br><span class="line">    <span class="comment">//边界：dp[i][j] = matrix[i][j], i=0 or j = 0</span></span><br><span class="line">    <span class="comment">//if matrix[i][j] == 0: dp[i][j] = 0, i &gt; 0, j &gt; 0</span></span><br><span class="line">    <span class="comment">//if matrix[i][j] == 1: 那么dp[i][j]由左边、上方、左上方的dp决定</span></span><br><span class="line">    <span class="comment">//dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="comment">//i == 0 || j == 0是边界情况</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//可以不写，java默认初始化为0</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新最长边长</span></span><br><span class="line">                maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实几个if-else也可以合并起来，代码更简洁一些，想不到也没关系，上面的代码可读性更好</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare1</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Integer_Break">Integer Break</h2><p>将一个正整数拆成至少两个整数使得这些整数乘积最大，并返回乘积<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2 = 1+1,1</span></span><br><span class="line">    <span class="comment">//3 = 1+2,2</span></span><br><span class="line">    <span class="comment">//4 = 2+2,4</span></span><br><span class="line">    <span class="comment">//5 = 2+3,6</span></span><br><span class="line">    <span class="comment">//6 = 3+3,9</span></span><br><span class="line">    <span class="comment">//7 = 3+4,12</span></span><br><span class="line">    <span class="comment">//8 = 2+3+3,18</span></span><br><span class="line">    <span class="comment">//9 = 3+3+3,27</span></span><br><span class="line">    <span class="comment">//10 = 3+3+2+2,36</span></span><br><span class="line">    <span class="comment">//11 = 3*3*3*2</span></span><br><span class="line">    <span class="comment">//12 = 3*3*3*3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            product *= <span class="number">3</span>;</span><br><span class="line">            n = n -<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        product *= n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[n] = max(max(i,dp[i])*max(n-i,dp[n-i])),i = 1..n/2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j,dp[j])*Math.max(i-j,dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Maximum_Subarray">Maximum Subarray</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        sum = Math.max(sum+nums[i], nums[i]);</span><br><span class="line"></span><br><span class="line">        maxSum = Math.max(maxSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//max[i]：表示最后一个元素是nums[i]的子数组的最大乘积</span></span><br><span class="line">    <span class="comment">//min[i]：表示最后一个元素是nums[i]的子数组的最小乘积</span></span><br><span class="line">    <span class="comment">//max[i] = max(max[i-1]*nums[i], min[i-1]*nums[i], nums[i])</span></span><br><span class="line">    <span class="comment">//min[i] = min(max[i-1]*nums[i], min[i-1]*nums[i], nums[i])</span></span><br><span class="line">    <span class="comment">//最终的最大子数组乘积maxProduct = max(max[0], max[1],......, max[nums.length - 1])</span></span><br><span class="line">    <span class="comment">//这里既要维护最大值和维护最小值，因为乘法比假发特殊，负负得正，两个很小的负数相乘可能很大</span></span><br><span class="line">    <span class="comment">//有可能变成最大</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProduct = max[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//max[i]的最大值也可能是nums[i]，比如[0,2]时max[1]就为2</span></span><br><span class="line">            max[i] = Math.max(Math.max(max[i-<span class="number">1</span>]*nums[i], min[i-<span class="number">1</span>]*nums[i]), nums[i]);</span><br><span class="line">            <span class="comment">//max[i] = Math.max(max[i-1]*nums[i], min[i-1]*nums[i]);</span></span><br><span class="line"></span><br><span class="line">            min[i] = Math.min(Math.min(max[i-<span class="number">1</span>]*nums[i], min[i-<span class="number">1</span>]*nums[i]), nums[i]);</span><br><span class="line">            <span class="comment">//min[i] = Math.min(max[i-1]*nums[i], min[i-1]*nums[i]);</span></span><br><span class="line"></span><br><span class="line">            maxProduct = Math.max(maxProduct, max[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面的程序我们使用了O(n)的内存空间，使用了两个额外的数组max和min，每个max[i]只与max[i-1]有关，</span></span><br><span class="line">    <span class="comment">//所以其实我们可以省掉这些内存空间，使用几个变量就可以了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxHerePre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> minHerePre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProduct = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minHere, maxHere;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            maxHere = Math.max(Math.max(maxHerePre*nums[i], minHerePre*nums[i]), nums[i]);</span><br><span class="line">            minHere = Math.min(Math.min(maxHerePre*nums[i], minHerePre*nums[i]), nums[i]);</span><br><span class="line"></span><br><span class="line">            maxProduct = Math.max(maxProduct, maxHere);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录前一元素结尾的最大最小值为下次循环做准备</span></span><br><span class="line">            maxHerePre = maxHere;</span><br><span class="line">            minHerePre = minHere;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Counting_Bits">Counting Bits</h2><p>给定一个非负整数num，计算[0,num]中每个数二进制中1的个数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// //bits[i] = bits[i/2] + i%2;</span></span><br><span class="line">    <span class="comment">// //i/2相当于将i(i&gt;=0)右移一位，对于奇数(最右边的比特位为1,&amp;1一定为1)来说,少了一个为1的比特位，需要加1（i%2或者i&amp;1），</span></span><br><span class="line">    <span class="comment">// //对于偶数来说(最右边的比特位为0，&amp;1一定为0)来说，为1的比特位不变</span></span><br><span class="line">    <span class="comment">// public int[] countBits(int num) &#123;</span></span><br><span class="line">    <span class="comment">//     int[] bits = new int[num+1];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt;= num; i++) bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1);</span></span><br><span class="line">    <span class="comment">//     return bits;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bits[i] = bits[i &amp; (i-1)] + 1;</span></span><br><span class="line">    <span class="comment">//i &amp; (i-1)的结果就是讲i最右边为1的比特位置为0，使i的比特位减少1，加上1即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) bits[i] = bits[i &amp; (i-<span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Coin_Change">Coin Change</h2><p>给定不同面值的硬币和一个总额，计算最小的硬币个数来组合成总额，如果组合不出来返回-1。注意每个硬币可以使用多次。</p>
<p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>
<p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i]表示组合成总额为i需要的最少的硬币数量</span></span><br><span class="line">    <span class="comment">//dp[i] = min(dp[i-coins[j]] + 1), coins[j] &lt;= i, 0 &lt;= j &lt; coins.length</span></span><br><span class="line">    <span class="comment">//返回dp[i]即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化为最大值为amount+1，总额为amount至多需要硬币amount个硬币</span></span><br><span class="line">        <span class="comment">//不能初始化为Integer.MAX_VALUE，因为状态转移方程有dp[i] + 1，会溢出:(</span></span><br><span class="line">        <span class="comment">//Arrays.fill(dp, Integer.MAX_VALUE);</span></span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= amount; i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = 0; j &lt; coins.length; j++)&#123;</span></span><br><span class="line">        <span class="comment">//         if(coins[j] &lt;= i)&#123;</span></span><br><span class="line">        <span class="comment">//             dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin: coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt;= amount; i++)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Distinct_Subsequences">Distinct Subsequences</h2><p>给定字符串S和T，计算S中包含不同的子序列T的数目，S = “rabbbit”, T = “rabbit”，返回3<br>空串是任何字符串的子序列<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  S 0123....j</span><br><span class="line">T +----------+</span><br><span class="line">  |<span class="string">1111111111</span>|</span><br><span class="line">0 |<span class="string">0         </span>|</span><br><span class="line">1 |<span class="string">0         </span>|</span><br><span class="line">2 |<span class="string">0         </span>|</span><br><span class="line">. |<span class="string">0         </span>|</span><br><span class="line">. |<span class="string">0         </span>|</span><br><span class="line">i |<span class="string">0         </span>|</span><br></pre></td></tr></table></figure></p>
<p>java代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(s.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return t.length() == 0 ? 1 : 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(t.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//dp[i+1][j+1] means that S[0..j] contains T[0..i] that many times as distinct subsequences.</span></span><br><span class="line">        <span class="comment">//Therefor the result will be dp[T.length()][S.length()].</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//空串是任何字符串的子序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i-<span class="number">1</span>) == s.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[t.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="计算数组下标i与j之间的元素之和">计算数组下标i与j之间的元素之和</h2><p>用sum[i]来存储0到i之间元素的和，0到j的和减去0到i-1的和(即sum[j]-sum[i-1])即为所求。<br><figure class="highlight java]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法]]></title>
    <link href="http://blog.noobsky.com/2016/09/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.noobsky.com/2016/09/26/排序算法/</id>
    <published>2016-09-25T17:54:40.000Z</published>
    <updated>2016-09-25T17:57:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="快速排序">快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int i = left-1;</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, right);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            quickSort(nums, left, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//int[] nums = &#123;1,2,3,4,5,6&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> QuickSort().quickSort(nums,<span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            System.out.println(num + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapsize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left(i);</span><br><span class="line">        <span class="keyword">int</span> r = right(i);</span><br><span class="line">        <span class="keyword">int</span> largest = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l &lt; heapsize &amp;&amp; heap[l] &gt; heap[largest])</span><br><span class="line">            largest = l;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; heapsize &amp;&amp; heap[r] &gt; heap[largest])</span><br><span class="line">            largest = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(largest != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = heap[i];</span><br><span class="line">            heap[i] = heap[largest];</span><br><span class="line">            heap[largest] = temp;</span><br><span class="line">            maxHeapify(largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.heap = nums;</span><br><span class="line">        <span class="keyword">this</span>.heapsize = heap.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapsize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        buildMaxHeap(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heap.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = heap[i];</span><br><span class="line">            heap[i] = heap[<span class="number">0</span>];</span><br><span class="line">            heap[<span class="number">0</span>] = temp;</span><br><span class="line"></span><br><span class="line">            heapsize--;</span><br><span class="line">            maxHeapify(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        HeapSort hs =<span class="keyword">new</span> HeapSort();</span><br><span class="line">        hs.heapSort(nums);</span><br><span class="line"></span><br><span class="line">        nums = hs.heap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            mergeSort(nums, left, mid);</span><br><span class="line">            mergeSort(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">            merge(nums, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> r = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= middle &amp;&amp; r &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[r])&#123;</span><br><span class="line">                temp[index++] = nums[l++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = nums[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= middle)&#123;</span><br><span class="line">            temp[index++] = nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt;= right)&#123;</span><br><span class="line">            temp[index++] = nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right)&#123;</span><br><span class="line">            nums[i] = temp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        MergeSort.mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序">冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        BubbleSort.bubbleSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="快速排序">快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之链表问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/09/25/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/09/25/面试算法之链表问题集锦/</id>
    <published>2016-09-25T13:49:35.000Z</published>
    <updated>2016-09-27T02:37:21.000Z</updated>
    <content type="html"><![CDATA[<p>链表操作是面试中很基础也很重要的算法问题，链表问题涉及大量的指针操作，操作很灵活，很考查编程基础。链表问题虽然比较基础，但在高压的面试环境中，要写对链表的问题也不是那么的容易啊：(，博主是有血的教训的。本文我将常见的链表问题总结一下。</p>
<p>下面是本文所用到的节点的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">       val = x;</span><br><span class="line">       next = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="判断链表是否有环">判断链表是否有环</h2><p>使用快慢指针，如果链表有环，慢指针必然会追上慢指针。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="找到单链表环的起始点，如果没有环，返回null">找到单链表环的起始点，如果没有环，返回null</h2><p>同理使用快慢指针，如果慢指针追上了快指针时，将快指针或者慢指针重新指向链表的头结点，然后以相同速度遍历，如果它们再次相遇时即为环的起始点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast )&#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;              </span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转单链表">反转单链表</h2><p>最常见的思路是遍历单链表然后通过前插构建单链表就能构建单链表，但是思路不清晰一时半会也写不出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = newHead;</span><br><span class="line">    newHead = head;</span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实要是写不对上面那个，可以用栈来反转，这个很容易写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack.push(head);</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode curr = dummy;</span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    ListNode temp = stack.pop();</span><br><span class="line">    <span class="comment">//要将原节点切断，不然会形成环</span></span><br><span class="line">    temp.next = <span class="keyword">null</span>;</span><br><span class="line">    curr.next = temp;</span><br><span class="line">    curr = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递归和栈很多时候可以相互转化，而且通过递归实现的代码很简洁，递归写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* recursive solution */</span></span><br><span class="line">    <span class="keyword">return</span> reverseListInt(head, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseListInt</span><span class="params">(ListNode head, ListNode newHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = newHead;</span><br><span class="line">    <span class="keyword">return</span> reverseListInt(next, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转单链表中m到n的之间的节点">反转单链表中m到n的之间的节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//pre用于指向需要反转子链表的头结点的前一个节点</span></span><br><span class="line">  ListNode pre = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    pre = pre.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//start指向需要反转的第一个节点</span></span><br><span class="line">  ListNode start = pre.next;</span><br><span class="line">  ListNode then = start.next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反转m到n之间的节点，只需要将m+1到n之间的节点前插到pre的后面即可</span></span><br><span class="line">  <span class="comment">//所以只需要循环n-m次即可</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++)&#123;</span><br><span class="line">    start.next = then.next;</span><br><span class="line"></span><br><span class="line">    then.next = pre.next;</span><br><span class="line">    pre.next = then;</span><br><span class="line"></span><br><span class="line">    then = start.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表的题目就要多用笔在草稿上多画画</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">//pre用来标记需要反转子链表头节点的前一节点</span></span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) pre = pre.next;</span><br><span class="line">    <span class="comment">//start节点指向需要反转的子链表的头结点</span></span><br><span class="line">    ListNode start = pre.next;</span><br><span class="line">    <span class="comment">//指向将被反转的结点</span></span><br><span class="line">    ListNode then = start.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6, m = 2, n = 4, pre = 1, start = 2, then = 3</span></span><br><span class="line">    <span class="comment">//dummy-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们需要将2-&gt;3-&gt;4有三个节点的子链表反转成dummy-&gt;1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;6</span></span><br><span class="line">    <span class="comment">//我们只需要进行n-m=2次交换：首先把3交互到pre.next的位置变成dum-&gt;1-&gt;3-&gt;2-&gt;4-&gt;5-&gt;6</span></span><br><span class="line">    <span class="comment">//然后将4交互到pre.next的位置变成dummy-&gt;1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++)&#123;</span><br><span class="line">        start.next = then.next;</span><br><span class="line">        then.next = pre.next;</span><br><span class="line">        pre.next = then;</span><br><span class="line">        <span class="comment">//下一个需要反转的节点</span></span><br><span class="line">        then = start.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断链表是否为回文结构">判断链表是否为回文结构</h2><p>判断链表是否为回文，可以反转后一半然后跟前一半相比较即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断回文的一种有效方法就是反转后一半然后跟前一半相比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="comment">//fast != null 和判断fast.next != null的方式比较直接</span></span><br><span class="line">        <span class="comment">//当总节点数为偶数时，当循环结束时，fast处于尾节点的后一节点（即指向null），而slow指向n/2+1的位置，即后一半的开头节点</span></span><br><span class="line">        <span class="comment">//当总结点数为奇数时，fast节点处于尾节点，slow处于中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//奇数情况，</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = reverseList(slow);</span><br><span class="line">        <span class="comment">//总结点数为奇数时，slow指向的后一半为比前一半少1个节点，循环结束条件应该用slow</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow.val != head.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="归并两个有序的链表">归并两个有序的链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode temp = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">            temp.next = l1;</span><br><span class="line">            temp = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp.next = l2;</span><br><span class="line">            temp = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回或者删除链表的倒数第k个节点">返回或者删除链表的倒数第k个节点</h2><p>返回倒数第k个节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">theKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode slow = head, fast = head;</span><br><span class="line">  <span class="keyword">int</span> i = k;</span><br><span class="line">  <span class="keyword">for</span>(;i &gt; <span class="number">0</span> &amp;&amp; fast != <span class="keyword">null</span>; i--)&#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//k大于链表的长度</span></span><br><span class="line">  <span class="keyword">if</span>(i &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除倒数第k个节点，相当于要找到倒数第k-1个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//为了处理特殊情况，比如删除最后一个元素，用一个虚拟头结点</span></span><br><span class="line">      ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">      dummy.next = head;</span><br><span class="line">      ListNode first = dummy,second = dummy;</span><br><span class="line">      <span class="comment">//找出倒数第k-1个节点（参考找出倒数第k个节点的题目）</span></span><br><span class="line">      <span class="comment">//第一个指针先向前走k-2步后指向k-1个节点</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;i++)&#123;</span><br><span class="line">          first = first.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//然后第二个指针跟第一个指针同时前进，当第一个指针指向最后一个元素时，第二个指针指向倒数第n-1个元素</span></span><br><span class="line">      <span class="keyword">while</span>(first.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">          first = first.next;</span><br><span class="line">          second = second.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      second.next = second.next.next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="O(1)时间删除链表节点">O(1)时间删除链表节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此种做法要求删除的节点不能是尾节点</p>
<h2 id="交换单链表两两相邻节点">交换单链表两两相邻节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    ListNode current = dummyHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current.next != <span class="keyword">null</span> &amp;&amp; current.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode first = current.next;</span><br><span class="line">        ListNode second = current.next.next;</span><br><span class="line"></span><br><span class="line">        first.next = second.next;</span><br><span class="line">        current.next = second;</span><br><span class="line">        second.next = first;<span class="comment">//或者是current.next.next = first;</span></span><br><span class="line"></span><br><span class="line">        current = current.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个相交单链表的第一个公共节点">两个相交单链表的第一个公共节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode a = headA, b = headB;</span><br><span class="line">    <span class="comment">//当每一个链表的指针到达链表的尾部时，让指针指向另一链表的头指针，当每一个链表的指针都指向过另</span></span><br><span class="line">    <span class="comment">//一链表的头指针后，他们最终会相遇于公共节点，因为他们走过的路程相等，都等于len(链表A) + len(链表B) - 公共部分的长度</span></span><br><span class="line">    <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">        a = a == <span class="keyword">null</span> ? headB : a.next;</span><br><span class="line">        b = b == <span class="keyword">null</span> ? headA : b.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除单链表中等于某个值的所有节点">删除单链表中等于某个值的所有节点</h2><p>从前往后遍历单链表，current指针指向当前遍历节点，删除节点需要用到前一个节点，所以用pre指向current节点的前一个节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  ListNode pre = dummy, current = head;</span><br><span class="line">  <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(current.val == val)&#123;</span><br><span class="line">      pre.next = current.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除有序单链表中的重复节点I">删除有序单链表中的重复节点I</h2><p>删除重复节点，使每个元素只出现一次，比如给定1-&gt;1-&gt;2-&gt;3-&gt;3，返回1-&gt;2-&gt;3。因为单链表有序，所以重复节点都相邻，我们可以遍历单链表判断当前节点和下一个节点的是否相等，相等删除下一个节点即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.next != <span class="keyword">null</span> &amp;&amp; curr.val == curr.next.val)&#123;</span><br><span class="line">      curr.next = curr.next.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除有序单链表中的重复节点II">删除有序单链表中的重复节点II</h2><p>删除单链表中重复元素的所有节点。比如给定1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5，返回1-&gt;2-&gt;5。使用pre指针指向上一个不重复的元素。当出现重复元素时，找到最右边的重复元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  ListNode pre = dummy;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//出现重复元素时，找到最右边的一个重复元素</span></span><br><span class="line">    <span class="keyword">while</span>(curr.next != <span class="keyword">null</span> &amp;&amp; curr.next.val == curr.val)&#123;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有重复元素时，pre和curr相邻</span></span><br><span class="line">    <span class="keyword">if</span>(pre.next == curr)&#123;</span><br><span class="line">      pre = curr;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//出现重复节点，且curr已经指向了最右边的的重复元素</span></span><br><span class="line">      pre.next = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重新排序单链表">重新排序单链表</h2><p>将原始单链表 L: L0→L1→…→Ln-1→Ln，重新排序为L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>基本思路就是反转单链表的后半部分，然后用两个指针分别指向前半部分单链表的头部(这里用slow)和后半部分的单链表的头部(这里用fast)，然后将slow和fast指向的节点链接起来，在这个过程中要借助单链表的中间节点，终止条件也是slow等于中间节点。</p>
<h2 id="Partition_List">Partition List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">//维护两个临时链表，然后遍历一个原链表，将val小于x的存到第一个临时链表中，</span></span><br><span class="line">   <span class="comment">//其他的存到第二个临时链表中，然后将两个临时链接起来即可</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//维护虚拟头结点</span></span><br><span class="line">       ListNode dummy1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>), dummy2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       ListNode curr1 = dummy1, curr2 = dummy2;</span><br><span class="line">       <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">               curr1.next = head;</span><br><span class="line">               curr1 = head;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               curr2.next = head;</span><br><span class="line">               curr2 = head;</span><br><span class="line">           &#125;</span><br><span class="line">           head = head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2，最后curr2指向5，curr2.next指向2，</span></span><br><span class="line">       <span class="comment">//我们需要将curr2.next置为null，不然会出现circle</span></span><br><span class="line">       curr2.next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//将第一个链表跟第二个链表链接起来</span></span><br><span class="line">       curr1.next = dummy2.next;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> dummy1.next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sort_List">Sort List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将list分为两部分</span></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找链表中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分为两部分，pre为空说明slow前面前面没有元素，前半部分单链表为空</span></span><br><span class="line">        <span class="comment">// if(pre != null) pre.next = null;</span></span><br><span class="line">        <span class="comment">// else head = null;</span></span><br><span class="line">        <span class="comment">//这里因为前面if(head == null || head.next == null) return head;保证了起码有两个元素才会往下运行</span></span><br><span class="line">        <span class="comment">//则保证会进入while循环，则pre一定不会为空(前半部分单链表不可能为空)，写成上面先判空也可以</span></span><br><span class="line">        <span class="comment">//置为空，将链表割断</span></span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode l1 = sortList(head);</span><br><span class="line">        ListNode l2 = sortList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l1 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l2 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l2;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将有序单链表转换为BST">将有序单链表转换为BST</h2><p>将升序单链表转换为高度平衡的BST。思路是找出中间节点为根，然后中间节点左右两部分分别用来递归构造左右子树。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode slow = head;</span><br><span class="line">  ListNode fast = head;</span><br><span class="line">  <span class="comment">//pre指向slow前一节点，记录slow前面是否有节点</span></span><br><span class="line">  ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    pre = slow;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//打断链表</span></span><br><span class="line">  <span class="comment">//pre != null意味着slow前面有节点</span></span><br><span class="line">  <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.next = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//pre</span></span><br><span class="line">  <span class="keyword">else</span> head = <span class="keyword">null</span>;</span><br><span class="line">  TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">  root.left = sortedListToBST(head);</span><br><span class="line">  root.right = sortedListToBST(slow.next);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="计算链表表示的两数之和">计算链表表示的两数之和</h2><p>给定两个链表分别代表两个非负整数。数位以倒序存储，并且每一个节点包含一位数字。将两个数字相加并以链表形式返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode p = l1, q = l2, curr = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(p != <span class="keyword">null</span> || q != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> x = p != <span class="keyword">null</span> ? p.val : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = q != <span class="keyword">null</span> ? q.val : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line"></span><br><span class="line">    carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">    curr = curr.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用插入排序排序链表">使用插入排序排序链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  ListNode pre = dummy;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//每次从头开始在有序部分查找插入位置</span></span><br><span class="line">    pre = dummy;</span><br><span class="line">    <span class="keyword">while</span>(pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt;= curr.val)&#123;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode next = curr.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将curr元素插入到pre和pre.next之间</span></span><br><span class="line">    curr.next = pre.next;</span><br><span class="line">    pre.next = curr;</span><br><span class="line"></span><br><span class="line">    curr = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序单链表">排序单链表</h2><p>要求时间复杂度为O(nlgn)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将链表划分为两部分</span></span><br><span class="line">  ListNode slow = head, fast = head;</span><br><span class="line">  ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//寻找链表中间节点</span></span><br><span class="line">  <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    pre = slow;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//if(pre != null) pre.next = null;</span></span><br><span class="line">  <span class="comment">//else head = null;</span></span><br><span class="line">  <span class="comment">//打断单链表</span></span><br><span class="line">  pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode l1 = sortList(head);</span><br><span class="line">  ListNode l2 = sortList(slow);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">      current.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      current.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">  current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="归并k个有序单链表">归并k个有序单链表</h2><p>利用最小堆进行k路归并<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  Queue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.compare(l1.val, l2.val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ListNode node : lists)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">      pq.offer(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode curr = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">    curr.next = pq.poll();</span><br><span class="line"></span><br><span class="line">    curr = curr.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(curr.next != <span class="keyword">null</span>) pq.offer(curr.next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可使用Merge Two Sorted List的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode curr = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            curr.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curr.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curr.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKListsHelper</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) <span class="keyword">return</span> lists[start];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    ListNode l1 = mergeKListsHelper(lists, start, mid);</span><br><span class="line">    ListNode l2 = mergeKListsHelper(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if(lists == null || lists.length == 0) return null;</span></span><br><span class="line">    <span class="keyword">return</span> mergeKListsHelper(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse_Nodes_in_k-Group">Reverse Nodes in k-Group</h2><p>比如：<br>给定单链表1-&gt;2-&gt;3-&gt;4-&gt;5<br>当k=2时，返回：2-&gt;1-&gt;4-&gt;3-&gt;5<br>当k=3时，返回：3-&gt;2-&gt;1-&gt;4-&gt;5<br>最直接的思路就是k个节点反转，然后再k个节点反转一次，直至不足k个节点。<br>或者可以使用递归的解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//找到第k+1个节点</span></span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; count != k)&#123;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">    curr = reverseKGroup(curr, k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时head为没有反转部分的头结点</span></span><br><span class="line">    <span class="comment">//curr是已经反转部分的头结点</span></span><br><span class="line">    <span class="comment">//我们需要将head为头结点的k个节点反转后，将curr指向的已经反转的部分链接到head反转后的后面</span></span><br><span class="line">    <span class="comment">//举个例子原始链表为1-&gt;2-&gt;3-&gt;4-&gt;5, k = 2</span></span><br><span class="line">    <span class="comment">//此时为1-&gt;2-&gt;4-&gt;3-&gt;5，此时head指向1，curr指向4，我们要变成2-&gt;1-&gt;4-&gt;3-&gt;5</span></span><br><span class="line">    <span class="comment">//k-- &gt; 0</span></span><br><span class="line">    <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">      ListNode temp = head.next;</span><br><span class="line">      <span class="comment">//将head指向的节点前插入到curr指向的链表中</span></span><br><span class="line">      head.next = curr;</span><br><span class="line">      curr = head;</span><br><span class="line"></span><br><span class="line">      head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="深拷贝带有随机指针的链表">深拷贝带有随机指针的链表</h2><p>随机指针可以指向任何节点或者null。链表定义如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> label;</span><br><span class="line">     RandomListNode next, random;</span><br><span class="line">     RandomListNode(<span class="keyword">int</span> x) &#123; <span class="keyword">this</span>.label = x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>简单的方法可以使用HashMap，遍历两遍。第一遍将所有节点加入到HashMap中，key为原节点，value为新节点。<br>第二遍给map中节点的next和random赋值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  RandomListNode node = head;</span><br><span class="line">  <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">    map.put(node, <span class="keyword">new</span> RandomListNode(node.label));</span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  node = head;</span><br><span class="line">  <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">    map.get(node).next = map.get(node.next);</span><br><span class="line">    map.get(node).random = map.get(node.random);</span><br><span class="line"></span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>链表操作是面试中很基础也很重要的算法问题，链表问题涉及大量的指针操作，操作很灵活，很考查编程基础。链表问题虽然比较基础，但在高压的面试环境中，要写对链表的问题也不是那么的容易啊：(，博主是有血的教训的。本文我将常见的链表问题总结一下。</p>
<p>下面是本文所用到的节点的]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试基础问题]]></title>
    <link href="http://blog.noobsky.com/2016/09/24/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.noobsky.com/2016/09/24/面试基础问题/</id>
    <published>2016-09-24T02:26:06.000Z</published>
    <updated>2016-09-24T02:55:53.000Z</updated>
    <content type="html"><![CDATA[<p>进程间通信方式：</p>
<p>管道<br>命名管道<br>信号<br>信号量<br>消息队列<br>共享内存<br>套接字</p>
<p>线程间通信方式<br>锁机制：互斥锁、临界区、<br>信号量<br>信号</p>
<p>进程与线程的区别：<br>进程是程序执行时的实例，而线程是进程的某条执行路径</p>
<p>进程有独立的地址空间，线程共享进程的地址空间和资源，线程有自己的堆栈和局部变量</p>
<p>进程是资源分配的基本单位，而线程是cpu调度的基本单位</p>
<p>进程的切换代价大，线程切换代价小</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>进程间通信方式：</p>
<p>管道<br>命名管道<br>信号<br>信号量<br>消息队列<br>共享内存<br>套接字</p>
<p>线程间通信方式<br>锁机制：互斥锁、临界区、<br>信号量<br>信号</p>
<p>进程与线程的区别：<br>进程是程序执行时的实]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Plus One]]></title>
    <link href="http://blog.noobsky.com/2016/09/17/LeetCode-Plus-One/"/>
    <id>http://blog.noobsky.com/2016/09/17/LeetCode-Plus-One/</id>
    <published>2016-09-17T02:59:15.000Z</published>
    <updated>2016-09-17T03:06:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<h2 id="解题思路及代码">解题思路及代码</h2><p>从数字低位往高位循环，如果某位小于9则该位加1后直接返回。否则该位置为0（该位等于9加1进位）继续下一轮循环。如果从低位往高位循环完后程序没有返回，说明程序一直进位，即为9999……，则原来的digits数组已经存不下，需要申请digits.length + 1长度的数组，然后将下标为0的置为1即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public int[] plusOne(int[] digits) &#123;</span></span><br><span class="line">    <span class="comment">//     if(digits == null || digits.length == 0) return null;</span></span><br><span class="line">    <span class="comment">//     int length = digits.length;</span></span><br><span class="line">    <span class="comment">//     for(int i = length -1; i &gt;= 0; i--)&#123;</span></span><br><span class="line">    <span class="comment">//         //遇到第一位小于9的时，该位+1，然后程序返回</span></span><br><span class="line">    <span class="comment">//         if(digits[i] &lt; 9)&#123;</span></span><br><span class="line">    <span class="comment">//             digits[i]++;</span></span><br><span class="line">    <span class="comment">//             return digits;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         //该位等于9，置为0，进行下一轮循环</span></span><br><span class="line">    <span class="comment">//         digits[i] = 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //程序能走到这里的话，则digits中为99999...加1后digits已经存不下。。。</span></span><br><span class="line">    <span class="comment">//     int[] res = new int[digits.length+1];</span></span><br><span class="line">    <span class="comment">//     //最高位置为1，其他位默认初始为0</span></span><br><span class="line">    <span class="comment">//     res[0] = 1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits)&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="keyword">null</span> || digits.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> length = digits.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] &lt; <span class="number">9</span>)&#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are store]]>
    </summary>
    
      <category term="Array" scheme="http://blog.noobsky.com/tags/Array/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="Math" scheme="http://blog.noobsky.com/tags/Math/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实战Java虚拟机之性能监控工具]]></title>
    <link href="http://blog.noobsky.com/2016/09/16/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
    <id>http://blog.noobsky.com/2016/09/16/实战Java虚拟机之性能监控工具/</id>
    <published>2016-09-16T02:31:15.000Z</published>
    <updated>2016-09-16T04:42:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Linux下的性能监控工具">Linux下的性能监控工具</h2><h3 id="显示系统整体资源使用情况–top命令">显示系统整体资源使用情况–top命令</h3><p>top命令的常用用法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line"> Display dynamic real-time information about running processes.</span><br><span class="line"></span><br><span class="line"> - <span class="operator"><span class="keyword">Start</span> top, all options <span class="keyword">are</span> available <span class="keyword">in</span> the <span class="keyword">interface</span>:</span><br><span class="line">   top</span><br><span class="line"></span><br><span class="line"> - <span class="keyword">Start</span> top sorting processes <span class="keyword">by</span> internal <span class="keyword">memory</span> <span class="keyword">size</span> (<span class="keyword">default</span> <span class="keyword">order</span> - process <span class="keyword">ID</span>):</span><br><span class="line">   top -o mem</span><br><span class="line"></span><br><span class="line"> - <span class="keyword">Start</span> top sorting processes <span class="keyword">first</span> <span class="keyword">by</span> CPU, <span class="keyword">then</span> <span class="keyword">by</span> running <span class="keyword">time</span>:</span><br><span class="line">   top -o cpu -O <span class="keyword">time</span></span><br><span class="line"></span><br><span class="line"> - <span class="keyword">Start</span> top displaying <span class="keyword">only</span> processes owned <span class="keyword">by</span> given <span class="keyword">user</span>:</span><br><span class="line">   top -<span class="keyword">user</span> user_name</span><br><span class="line"></span><br><span class="line"> - <span class="keyword">Get</span> <span class="keyword">help</span> about interactive commands:</span><br><span class="line">   ?</span></span><br></pre></td></tr></table></figure></p>
<p>Mac输出如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Processes: 301 total, 2 running, 10 stuck, 289 sleeping, 1502 threads                             11:09:10</span><br><span class="line"><span class="operator"><span class="keyword">Load</span> <span class="keyword">Avg</span>: <span class="number">1.32</span>, <span class="number">1.64</span>, <span class="number">1.54</span>  CPU <span class="keyword">usage</span>: <span class="number">6.52</span>% <span class="keyword">user</span>, <span class="number">6.28</span>% <span class="keyword">sys</span>, <span class="number">87.19</span>% idle</span><br><span class="line">SharedLibs: <span class="number">138</span><span class="keyword">M</span> resident, <span class="number">23</span><span class="keyword">M</span> <span class="keyword">data</span>, <span class="number">16</span><span class="keyword">M</span> linkedit.</span><br><span class="line">MemRegions: <span class="number">42415</span> total, <span class="number">4174</span><span class="keyword">M</span> resident, <span class="number">160</span><span class="keyword">M</span> <span class="keyword">private</span>, <span class="number">830</span><span class="keyword">M</span> <span class="keyword">shared</span>.</span><br><span class="line">PhysMem: <span class="number">7623</span><span class="keyword">M</span> used (<span class="number">1379</span><span class="keyword">M</span> wired), <span class="number">567</span><span class="keyword">M</span> <span class="keyword">unused</span>.</span><br><span class="line">VM: <span class="number">830</span><span class="keyword">G</span> vsize, <span class="number">465</span><span class="keyword">M</span> framework vsize, <span class="number">0</span>(<span class="number">0</span>) swapins, <span class="number">0</span>(<span class="number">0</span>) swapouts.</span><br><span class="line">Networks: packets: <span class="number">95637</span>/<span class="number">48</span><span class="keyword">M</span> <span class="keyword">in</span>, <span class="number">29925</span>/<span class="number">4994</span><span class="keyword">K</span> <span class="keyword">out</span>. Disks: <span class="number">79110</span>/<span class="number">4258</span><span class="keyword">M</span> <span class="keyword">read</span>, <span class="number">25479</span>/<span class="number">598</span><span class="keyword">M</span> written.</span><br><span class="line"></span><br><span class="line">PID   COMMAND      %CPU <span class="keyword">TIME</span>     #TH   #WQ  #PORT MEM    PURG   CMPR PGRP PPID STATE    BOOSTS</span><br><span class="line"><span class="number">1853</span>  mdworker     <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.92</span> <span class="number">5</span>     <span class="number">3</span>    <span class="number">60</span>-   <span class="number">7816</span><span class="keyword">K</span>- <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1853</span> <span class="number">1</span>    sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1852</span>  mdworker     <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.67</span> <span class="number">5</span>     <span class="number">3</span>    <span class="number">50</span>-   <span class="number">6224</span><span class="keyword">K</span>- <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1852</span> <span class="number">1</span>    sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1851</span>  top          <span class="number">2.9</span>  <span class="number">00</span>:<span class="number">00.93</span> <span class="number">1</span>/<span class="number">1</span>   <span class="number">0</span>    <span class="number">23</span>    <span class="number">2320</span><span class="keyword">K</span>  <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1851</span> <span class="number">693</span>  running  *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1829</span>  Atom Helper  <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">03.52</span> <span class="number">5</span>     <span class="number">0</span>    <span class="number">53</span>    <span class="number">28</span><span class="keyword">M</span>    <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1645</span> <span class="number">1649</span> sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1649</span>  Atom Helper  <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">08.96</span> <span class="number">19</span>    <span class="number">0</span>    <span class="number">129</span>   <span class="number">176</span><span class="keyword">M</span>   <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1645</span> <span class="number">1645</span> sleeping *<span class="number">0</span>[<span class="number">7</span>]</span><br><span class="line"><span class="number">1648</span>  crashpad_han <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.01</span> <span class="number">4</span>     <span class="number">0</span>    <span class="number">28</span>    <span class="number">848</span><span class="keyword">K</span>   <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1647</span> <span class="number">1</span>    sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1646</span>  Atom Helper  <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.48</span> <span class="number">5</span>     <span class="number">0</span>    <span class="number">86</span>    <span class="number">13</span><span class="keyword">M</span>    <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1645</span> <span class="number">1645</span> sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1645</span>  Atom         <span class="number">0.1</span>  <span class="number">00</span>:<span class="number">02.94</span> <span class="number">33</span>    <span class="number">2</span>    <span class="number">347</span>   <span class="number">56</span><span class="keyword">M</span>+   <span class="number">12</span><span class="keyword">K</span>    <span class="number">0</span>B   <span class="number">1645</span> <span class="number">1</span>    sleeping *<span class="number">0</span>[<span class="number">31</span>]</span><br><span class="line"><span class="number">1360</span>  Google Chrom <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">07.10</span> <span class="number">18</span>    <span class="number">0</span>    <span class="number">133</span>   <span class="number">189</span><span class="keyword">M</span>   <span class="number">24</span><span class="keyword">K</span>    <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">2</span>]</span><br><span class="line"><span class="number">1350</span>  Google Chrom <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.33</span> <span class="number">6</span>     <span class="number">0</span>    <span class="number">69</span>    <span class="number">15</span><span class="keyword">M</span>    <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1346</span>  ShadowsocksX <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.45</span> <span class="number">6</span>     <span class="number">2</span>    <span class="number">150</span>   <span class="number">8536</span><span class="keyword">K</span>  <span class="number">4096</span>B  <span class="number">0</span>B   <span class="number">1346</span> <span class="number">1</span>    sleeping *<span class="number">0</span>[<span class="number">108</span>]</span><br><span class="line"><span class="number">1321</span>  com.apple.hi <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.01</span> <span class="number">2</span>     <span class="number">0</span>    <span class="number">34</span>    <span class="number">948</span><span class="keyword">K</span>   <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1321</span> <span class="number">1</span>    sleeping  <span class="number">0</span>[<span class="number">3</span>]</span><br><span class="line"><span class="number">1319</span>  Google Chrom <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">04.21</span> <span class="number">14</span>    <span class="number">0</span>    <span class="number">118</span>   <span class="number">98</span><span class="keyword">M</span>+   <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">2</span>]</span><br><span class="line"><span class="number">1318</span>  systemstatsd <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.06</span> <span class="number">2</span>     <span class="number">1</span>    <span class="number">21</span>    <span class="number">1108</span><span class="keyword">K</span>  <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1318</span> <span class="number">1</span>    sleeping  <span class="number">0</span>[<span class="number">4</span>]</span><br><span class="line"><span class="number">1317</span>  Google Chrom <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">03.80</span> <span class="number">11</span>    <span class="number">0</span>    <span class="number">112</span>   <span class="number">75</span><span class="keyword">M</span>+   <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">2</span>]</span><br><span class="line"><span class="number">1316</span>  Google Chrom <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">03.90</span> <span class="number">13</span>    <span class="number">0</span>    <span class="number">116</span>   <span class="number">100</span><span class="keyword">M</span>+  <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">2</span>]</span><br><span class="line"><span class="number">1315</span>  Google Chrom <span class="number">0.4</span>  <span class="number">00</span>:<span class="number">11.81</span> <span class="number">14</span>    <span class="number">0</span>    <span class="number">117</span>   <span class="number">147</span><span class="keyword">M</span>+  <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">2</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>linux输出如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">top - <span class="number">23</span>:<span class="number">11</span>:<span class="number">30</span> up <span class="number">47</span> min,  <span class="number">2</span> users,  load average: <span class="number">0.04</span>, <span class="number">0.44</span>, <span class="number">0.32</span></span><br><span class="line">Tasks:  <span class="number">68</span> total,   <span class="number">2</span> running,  <span class="number">66</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%Cpu(s):  <span class="number">0.0</span> us,  <span class="number">0.0</span> sy,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">KiB Mem :   <span class="number">500840</span> total,   <span class="number">222072</span> <span class="built_in">free</span>,    <span class="number">51972</span> used,   <span class="number">226796</span> buff/cache</span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> <span class="built_in">free</span>,        <span class="number">0</span> used.   <span class="number">424868</span> avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">41224</span>   <span class="number">3748</span>   <span class="number">2400</span> S  <span class="number">0.0</span>  <span class="number">0.7</span>   <span class="number">0</span>:<span class="number">02.48</span> systemd</span><br><span class="line">    <span class="number">2</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kthreadd</span><br><span class="line">    <span class="number">3</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> ksoftirqd/<span class="number">0</span></span><br><span class="line">    <span class="number">5</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">0</span>:<span class="number">0</span>H</span><br><span class="line">    <span class="number">7</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> migration/<span class="number">0</span></span><br><span class="line">    <span class="number">8</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_bh</span><br><span class="line">    <span class="number">9</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcuob/<span class="number">0</span></span><br><span class="line">   <span class="number">10</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.48</span> rcu_sched</span><br><span class="line">   <span class="number">11</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> R  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.53</span> rcuos/<span class="number">0</span></span><br><span class="line">   <span class="number">12</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.02</span> watchdog/<span class="number">0</span></span><br><span class="line">   <span class="number">13</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> khelper</span><br><span class="line">   <span class="number">14</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kdevtmpfs</span><br><span class="line">   <span class="number">15</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> netns</span><br><span class="line">   <span class="number">16</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> perf</span><br><span class="line">   <span class="number">17</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> writeback</span><br><span class="line">   <span class="number">18</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kintegrityd</span><br><span class="line">   <span class="number">19</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> bioset</span><br><span class="line">   <span class="number">20</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kblockd</span><br></pre></td></tr></table></figure></p>
<p>linux中top命令的输出可以分为两个部分：前半部分是系统统计信息，后半部分是进程信息。</p>
<h3 id="监控内存和CPU–vmstat命令">监控内存和CPU–vmstat命令</h3><p>vmstat也是一款功能比较齐全的性能监测工具。它可以统计CPU、内存使用情况、swap使用情况等信息。还可以指定采样周期和采样次数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]<span class="preprocessor"># vmstat <span class="number">1</span> <span class="number">3</span></span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   <span class="built_in">free</span>   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">2</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">222352</span>  <span class="number">16104</span> <span class="number">210788</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">72</span>    <span class="number">69</span>   <span class="number">93</span>  <span class="number">281</span>  <span class="number">3</span>  <span class="number">1</span> <span class="number">96</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">222336</span>  <span class="number">16104</span> <span class="number">210788</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">40</span>   <span class="number">71</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">222336</span>  <span class="number">16104</span> <span class="number">210788</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">33</span>   <span class="number">64</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="监控IO使用–iostat命令">监控IO使用–iostat命令</h3><p>iostat可以提供详尽的I/O信息，它的基本使用如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="多功能诊断器–pidstat工具">多功能诊断器–pidstat工具</h3><p>pidstat是一个功能强大的性能监测工具，它也是Sysstat组件之一。</p>
<p>如果是Debian / Ubuntu系统，可以使用以下命令安装：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> install sysstat</span><br></pre></td></tr></table></figure></p>
<p>如果是CentOS / Fedora / RHEL系统，可以使用以下命令安装：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> sysstat</span><br></pre></td></tr></table></figure></p>
<p>pidstat强大之处在于，它不仅可以监视进程的性能情况，也可以监视线程的性能情况。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Linux下的性能监控工具">Linux下的性能监控工具</h2><h3 id="显示系统整体资源使用情况–top命令">显示系统整体资源使用情况–top命令</h3><p>top命令的常用用法如下：<br><figure class="highlight sql]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL高可用]]></title>
    <link href="http://blog.noobsky.com/2016/09/12/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>http://blog.noobsky.com/2016/09/12/MySQL高可用/</id>
    <published>2016-09-12T01:48:40.000Z</published>
    <updated>2016-09-21T02:32:24.000Z</updated>
    <content type="html"><![CDATA[<p>lvs+keepalived+MySQL</p>
<p>DRBD + Heartbeat + MySQL</p>
<p>MHA</p>
<p>MMM</p>
<p>NDB</p>
<p>proxy</p>
<p>zookeeper</p>
<p>mysql主从延迟：</p>
<p>半同步复制<br>redis缓存<br>读主库</p>
<p>dubbo:分布式服务框架</p>
<p>cobar：基于MySQL的分布式数据库服务中间件</p>
<p>面向切面的缺点</p>
<p>hash索引和b-tree索引的区别</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>lvs+keepalived+MySQL</p>
<p>DRBD + Heartbeat + MySQL</p>
<p>MHA</p>
<p>MMM</p>
<p>NDB</p>
<p>proxy</p>
<p>zookeeper</p>
<p>mysql主从延迟：</p>]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Element]]></title>
    <link href="http://blog.noobsky.com/2016/09/08/LeetCode-Remove-Element/"/>
    <id>http://blog.noobsky.com/2016/09/08/LeetCode-Remove-Element/</id>
    <published>2016-09-08T02:54:54.000Z</published>
    <updated>2016-09-17T03:08:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example:</strong><br>Given input array nums = [3,2,2,3], val = 3</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p><strong>Hint:</strong></p>
<ol>
<li>Try two pointers.</li>
<li>Did you use the property of “the order of elements can be changed”?</li>
<li>What happens when the elements to remove are rare?</li>
</ol>
<h2 id="解题思路与代码">解题思路与代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//并不需要真正删除元素，我们只需要返回“删除”元素后数组的新长度</span></span><br><span class="line">    <span class="comment">//时间复杂度：O(n),该方法关注于不等于val的元素，如果含有很多不等于val的元素，则浪费很多的移动次数</span></span><br><span class="line">    <span class="comment">//比如[1,2,3,5,4],val为4的时候</span></span><br><span class="line">    <span class="comment">// public int removeElement(int[] nums, int val) &#123;</span></span><br><span class="line">    <span class="comment">//     int begin = 0;</span></span><br><span class="line">    <span class="comment">//     //遍历数组，将所有不等于val元素依次放入原数组中（从index=0的地方依次往后放）</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] != val) nums[begin++] = nums[i];</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return begin;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//上面的解法关注不等于val的元素，同理我们的关注点也可以是等于val的元素</span></span><br><span class="line">    <span class="comment">//我们可以将数组尾部的元素移动到等于val的元素的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                nums[i] = nums[n-<span class="number">1</span>];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>Do not a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="Two Pointers" scheme="http://blog.noobsky.com/tags/Two-Pointers/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Reverse Vowels of a String]]></title>
    <link href="http://blog.noobsky.com/2016/09/08/LeetCode-Reverse-Vowels-of-a-String/"/>
    <id>http://blog.noobsky.com/2016/09/08/LeetCode-Reverse-Vowels-of-a-String/</id>
    <published>2016-09-08T01:59:35.000Z</published>
    <updated>2016-09-08T02:06:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p><strong>Example 1:</strong><br>Given s = “hello”, return “holle”.</p>
<p><strong>Example 2:</strong><br>Given s = “leetcode”, return “leotcede”.</p>
<p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p>
<h2 id="解题思路与代码">解题思路与代码</h2><p>题意是让我们翻转字符串中的元音字母，元音字母有a、e、i、o、u，大小写总共10个。我们使用两个左右指针，左指针从左往右遍历直到找到元音字母，右指针从右往左遍历直到找到元音字母，然后交换左右指针指向的元音字母。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String vowels = <span class="string">"aeiouAEIOU"</span>;</span><br><span class="line">    <span class="comment">// public String reverseVowels(String s) &#123;</span></span><br><span class="line">    <span class="comment">//     if(s == null || s.length() == 0) return s;</span></span><br><span class="line">    <span class="comment">//     char[] chs = s.toCharArray();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int length = chs.length;</span></span><br><span class="line">    <span class="comment">//     int left = 0;</span></span><br><span class="line">    <span class="comment">//     int right = length - 1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     char temp;</span></span><br><span class="line">    <span class="comment">//     while(left &lt; right)&#123;</span></span><br><span class="line">    <span class="comment">//         while(left &lt; right &amp;&amp; !isVowels(chs[left])) left++;</span></span><br><span class="line">    <span class="comment">//         while(left &lt; right &amp;&amp; !isVowels(chs[right])) right--;</span></span><br><span class="line">    <span class="comment">//         temp = chs[left];</span></span><br><span class="line">    <span class="comment">//         chs[left] = chs[right];</span></span><br><span class="line">    <span class="comment">//         chs[right] = temp;</span></span><br><span class="line">    <span class="comment">//         left++;</span></span><br><span class="line">    <span class="comment">//         right--;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return new String(chs);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public boolean isVowels(char c)&#123;</span></span><br><span class="line">    <span class="comment">//     c = Character.toLowerCase(c);</span></span><br><span class="line">    <span class="comment">//     if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') return true;</span></span><br><span class="line">    <span class="comment">//     return false;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = chs.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; vowels.indexOf(chs[left])==-<span class="number">1</span>) left++;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; vowels.indexOf(chs[right])==-<span class="number">1</span>) right--;</span><br><span class="line">            temp = chs[left];</span><br><span class="line">            chs[left] = chs[right];</span><br><span class="line">            chs[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p><strong>Example 1:</]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="String" scheme="http://blog.noobsky.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://blog.noobsky.com/tags/Two-Pointers/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发编程之线程池]]></title>
    <link href="http://blog.noobsky.com/2016/09/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://blog.noobsky.com/2016/09/05/Java并发编程之线程池/</id>
    <published>2016-09-05T07:35:24.000Z</published>
    <updated>2016-09-07T08:38:51.000Z</updated>
    <content type="html"><![CDATA[<p>多线程可以最大限度的发挥多核处理器的计算能力，提高生成系统的吞吐量和性能。但是，若不加控制和管理地随意使用线程，对系统的性能反而会产生不利的影响。在真实的生产环境中，当线程数量过大时，有可能耗尽CPU和内存资源。</p>
<p>首先，虽然与进程相比，线程是一种轻量级的工具，但其创建和关闭依然需要花费时间，如果为每一个小任务都创建一个线程，很有可能出现创建和销毁线程所占用的时间大于该线程真实工作所消耗时间的情况，反而会得不偿失。</p>
<p>其次，线程本身也是要占用内存空间的，大量的线程会抢占宝贵的内存资源，如果处理不当，可能会导致Out of Memory异常。即便没有，大量的线程回收也会给GC带来很大的压力，延长GC的停顿时间。</p>
<p>所以，对线程的使用要适度，在有限范围内，增加线程的数量可以明显提高系统吞吐量，但超出范围，大量线程只会拖垮应用系统。因此，在生产环境中使用线程，必须加以控制和管理。</p>
<p>为了避免系统频繁地创建和销毁线程，我们可以让创建的线程进行复用。就是线程执行完一个任务，并不被销毁，而是可以继续执行其他的任务。Java中可以通过线程池来达到这样的效果。</p>
<h2 id="JDK对线程池的支持">JDK对线程池的支持</h2><p>为了更好的控制多线程，JDK提供了一套Executor框架，帮助开发人员有效地进行线程控制，其本质就是一个线程池。核心成员的UML类图如下：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E5%9B%BE.jpg" alt=""></p>
<p>Executor是顶层接口，里面只有一个方法execute(Runnable command)，返回值为void，参数为Runnable类型，顾名思义，就是用来执行传进去的任务的。而ExecutorService接口继承了Executor接口，并声明了一些方法，包括shutdown、isShutdown、isTerminated、submit、invokeAll、invokeAny等方法。然后抽象类AbstractExecutorService实现了ExecutorService接口。ThreadPoolExecutor继承了抽象类AbstractExecutorService。ThreadPoolExecutor类中有几个非常重要的方法：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">submit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">shutdownNow</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>execute方法实际上是接口Executor中声明的方法，在ThreadPoolExecutor中进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，这个方法可以向线程池提交一个任务，交由线程池去执行。</p>
<p>submit方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，查看源码可以发现，会发现submit内部也是调用execute方法的，只不过它利用了Future来获取任务执行的结果。还有很多其他方法，这里就不一一介绍了。</p>
<p>Executors则扮演着线程池工厂的角色，通过Executors可以取得一个拥有特定功能的线程池。ThreadPoolExecutor类实现了Executor接口，因此通过这个接口，任何Runable的对象都可以被ThreadPoolExecutor线程池调度。</p>
<p>Executors主要提供了以下工厂方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure></p>
<p>以上工厂方法分别返回不同工作特性的线程池。这些线程池工厂方法具体说明如下：</p>
<ul>
<li><p>newFixedThreadPool()方法：该方法返回一个固定线程数量的线程池。该线程池的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>
</li>
<li><p>newSingleThreadExecutor()方法：该方法返回只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行任务中的队列。</p>
</li>
<li><p>newCachedThreadPool()方法：该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池复用。</p>
</li>
<li><p>newSingleThreadScheduledExecutor()方法：该方法返回一个ScheduleExecutorService对象，线程池大小为1。ScheduledExecutorService 接口在ExecutorService接口之上扩展了在给定时间执行某任务的功能，如在某个固定的延时之后执行，或者周期性执行某个任务。</p>
</li>
<li><p>newScheduledThreadPool()方法：该方法也返回一个ScheduleExecutorService对象，但该线程池可以指定线程数量。</p>
</li>
</ul>
<h2 id="深入理解线程池内部实现">深入理解线程池内部实现</h2><p>对于核心的几个线程池，无论是newFixedThreadPool()方法、newSingleThreadExecutor()还是newCachedThreadPool()方法，虽然看起来创建的线程有着完全不同的功能特点，但其内部实现均使用ThreadPoolExecutor来实现的。这三种线程池的实现方式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由以上源码可知，它们都是ThreadPoolExecutor类的封装。我们首先来看一下ThreadPoolExecutor的实现</p>
<h3 id="线程池状态">线程池状态</h3><h3 id="线程池状态-1">线程池状态</h3><p>定义了几个static final变量表示线程池的各个状态：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>先看看文档：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The runState provides the main lifecyle control, taking <span class="keyword">on</span> values:</span><br><span class="line"></span><br><span class="line">RUNNING:  Accept <span class="keyword">new</span> tasks <span class="keyword">and</span> <span class="keyword">process</span> queued tasks</span><br><span class="line">SHUTDOWN: Don<span class="attribute">'t</span> accept <span class="keyword">new</span> tasks, but <span class="keyword">process</span> queued tasks</span><br><span class="line">STOP:     Don<span class="attribute">'t</span> accept <span class="keyword">new</span> tasks, don<span class="attribute">'t</span> <span class="keyword">process</span> queued tasks,<span class="keyword">and</span> interrupt <span class="keyword">in</span>-progress tasks</span><br><span class="line">TIDYING:  <span class="keyword">All</span> tasks have terminated, workerCount <span class="keyword">is</span> zero,the thread transitioning <span class="keyword">to</span> state TIDYING will run the terminated() hook method</span><br><span class="line">TERMINATED: terminated() has completed</span><br></pre></td></tr></table></figure></p>
<p>ThreadPoolExecutor线程池有五个状态，分别为：</p>
<ul>
<li>RUNNING: 可以接受新的任务，也可以处理阻塞队列里的任务</li>
<li>SHUTDOWN: 不接受新的任务，但是可以处理阻塞队列里的任务</li>
<li>STOP: 不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务</li>
<li>TIDYING: 过渡状态，也就是说所有的任务都执行完了，当前线程池已经没有有效线程，此时线程池的状态将会为TIDYING，并且将要调用terminated方法</li>
<li>TERMINATED: 终止状态。terminated方法调用完成以后的方法</li>
</ul>
<p>各状态的相互转换如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RUNNING</span> -&gt; <span class="type">SHUTDOWN</span></span><br><span class="line">    <span class="type">On</span> invocation <span class="keyword">of</span> shutdown(), perhaps implicitly <span class="keyword">in</span> finalize()</span><br><span class="line">(<span class="type">RUNNING</span> <span class="keyword">or</span> <span class="type">SHUTDOWN</span>) -&gt; <span class="type">STOP</span></span><br><span class="line">    <span class="type">On</span> invocation <span class="keyword">of</span> shutdownNow()</span><br><span class="line"><span class="type">SHUTDOWN</span> -&gt; <span class="type">TIDYING</span></span><br><span class="line">    <span class="type">When</span> both queue <span class="keyword">and</span> pool are empty</span><br><span class="line"><span class="type">STOP</span> -&gt; <span class="type">TIDYING</span></span><br><span class="line">    <span class="type">When</span> pool <span class="keyword">is</span> empty</span><br><span class="line"><span class="type">TIDYING</span> -&gt; <span class="type">TERMINATED</span></span><br><span class="line">    <span class="type">When</span> the terminated() hook <span class="keyword">method</span> has completed</span><br></pre></td></tr></table></figure></p>
<p>ThreadPoolExecutor内部还保存着线程池的有效线程个数，状态和线程数在ThreadPoolExecutor内部使用一个原子整形变量保存。那么是如何做到的呢？</p>
<p>java中整型占四个字节，即32位，在ThreadPoolExecutor，整形32位的前三位用来表示线程池的状态，后29位用来表示线程池中有效的线程个数。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前3位表示状态，后29位用来表示线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.<span class="keyword">SIZE</span> - <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>线程池的容量为(1&lt;<29)-1= 00011111111111111111111111111111(二进制，约500="" million)，代码如下：="" <figure="" class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></29)-1=></p>
<p>表示RUNNING状态的代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<p>-1用二进制表示是：11111111111111111111111111111111(这是补码表示，不明白可以补补原码，反码，补码的知识)<br>则 -1 &lt;&lt; 29 = 11111111111111111111111111111111 &lt;&lt; 29 = 11100000000000000000000000000000(前3位为111)</p>
<p>表示SHUTDOWN状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即0 &lt;&lt; 29 = 00000000000000000000000000000000 &lt;&lt; 29 = 00000000000000000000000000000000(前3位为000)</p>
<p>表示STOP状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即 1 &lt;&lt; 29 = 00000000000000000000000000000001 &lt;&lt; 29 = 00100000000000000000000000000000(前3位为001)</p>
<p>表示TIDYING状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即 2 &lt;&lt; 29 = 00000000000000000000000000000010 &lt;&lt; 29 = 01000000000000000000000000000000(前3位为010)</p>
<p>表示TERMINATED状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即 3 &lt;&lt; 29 = 00000000000000000000000000000011 &lt;&lt; 29 = 01100000000000000000000000000000(前3位为011)</p>
<p>所以我们可以通过整数的二进制中后29位来获取线程数，前3位来获取线程的状态：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">//该方法获取状态，CAPACITY的非操作得到的二进制位11100000000000000000000000000000，然后做在一个与操作，相当于直接取前3位的的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//该方法获取线程数，取后29位。CAPACITY常量值为(1&lt;&lt;29)-1= 00011111111111111111111111111111。与CAPACITY相与的话，前三位相与为0，即可得后29位。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 或操作。更新代表线程数量和状态的整形变量。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadPoolExecutor还有一些重要的成员变量：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">private final BlockingQueue<span class="variable">&lt;Runnable&gt;</span> workQueue;//任务阻塞队列，用来存放等待执行的任务</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Lock held on access to workers set and related bookkeeping.</span><br><span class="line"> <span class="keyword">*</span> While we could use a concurrent set of some sort, it turns out</span><br><span class="line"> <span class="keyword">*</span> to be generally preferable to use a lock. Among the reasons is</span><br><span class="line"> <span class="keyword">*</span> that this serializes interruptIdleWorkers, which avoids</span><br><span class="line"> <span class="keyword">*</span> unnecessary interrupt storms, especially during shutdown.</span><br><span class="line"> <span class="keyword">*</span> Otherwise exiting threads would concurrently interrupt those</span><br><span class="line"> <span class="keyword">*</span> that have not yet interrupted. It also simplifies some of the</span><br><span class="line"> <span class="keyword">*</span> associated statistics bookkeeping of largestPoolSize etc. We</span><br><span class="line"> <span class="keyword">*</span> also hold mainLock on shutdown and shutdownNow, for the sake of</span><br><span class="line"> <span class="keyword">*</span> ensuring workers set is stable while separately checking</span><br><span class="line"> <span class="keyword">*</span> permission to interrupt and actually interrupting.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private final ReentrantLock mainLock = new ReentrantLock();//线程池的状态锁，对线程状态（如线程池大小、runState等）的改变都要使用这个锁</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Set containing all worker threads in pool. Accessed only when</span><br><span class="line"> <span class="keyword">*</span> holding mainLock.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private final HashSet<span class="variable">&lt;Worker&gt;</span> workers = new HashSet<span class="variable">&lt;Worker&gt;</span>();//用来存放工作集</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Wait condition to support awaitTermination</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private final Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Tracks largest attained pool size. Accessed only under</span><br><span class="line"> <span class="keyword">*</span> mainLock.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private int largestPoolSize;//用来记录线程池曾出现过的最大线程数</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Counter for completed tasks. Updated only on termination of</span><br><span class="line"> <span class="keyword">*</span> worker threads. Accessed only under mainLock.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private long completedTaskCount;//已完成任务计数器</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> All user control parameters are declared as volatiles so that</span><br><span class="line"> <span class="keyword">*</span> ongoing actions are based on freshest values, but without need</span><br><span class="line"> <span class="keyword">*</span> for locking, since no internal invariants depend on them</span><br><span class="line"> <span class="keyword">*</span> changing synchronously with respect to other actions.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Factory for new threads. All threads are created using this</span><br><span class="line"> <span class="keyword">*</span> factory (via method addWorker).  All callers must be prepared</span><br><span class="line"> <span class="keyword">*</span> for addWorker to fail, which may reflect a system or user's</span><br><span class="line"> <span class="keyword">*</span> policy limiting the number of threads.  Even though it is not</span><br><span class="line"> <span class="keyword">*</span> treated as an error, failure to create threads may result in</span><br><span class="line"> <span class="keyword">*</span> new tasks being rejected or existing ones remaining stuck in</span><br><span class="line"> <span class="keyword">*</span> the queue.</span><br><span class="line"> <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> We go further and preserve pool invariants even in the face of</span><br><span class="line"> <span class="keyword">*</span> errors such as OutOfMemoryError, that might be thrown while</span><br><span class="line"> <span class="keyword">*</span> trying to create threads.  Such errors are rather common due to</span><br><span class="line"> <span class="keyword">*</span> the need to allocate a native stack in Thread<span class="comment">#start, and users</span></span><br><span class="line"> <span class="keyword">*</span> will want to perform clean pool shutdown to clean up.  There</span><br><span class="line"> <span class="keyword">*</span> will likely be enough memory available for the cleanup code to</span><br><span class="line"> <span class="keyword">*</span> complete without encountering yet another OutOfMemoryError.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile ThreadFactory threadFactory;//线程工厂，用来创建线程</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Handler called when saturated or shutdown in execute.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile RejectedExecutionHandler handler;//任务拒绝策略</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Timeout in nanoseconds for idle threads waiting for work.</span><br><span class="line"> <span class="keyword">*</span> Threads use this timeout when there are more than corePoolSize</span><br><span class="line"> <span class="keyword">*</span> present or if allowCoreThreadTimeOut. Otherwise they wait</span><br><span class="line"> <span class="keyword">*</span> forever for new work.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile long keepAliveTime; //闲置线程的存活时间</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> If false (default), core threads stay alive even when idle.</span><br><span class="line"> <span class="keyword">*</span> If true, core threads use keepAliveTime to time out waiting</span><br><span class="line"> <span class="keyword">*</span> for work.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile boolean allowCoreThreadTimeOut;//是否允许为核心线程设置存活时间</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Core pool size is the minimum number of workers to keep alive</span><br><span class="line"> <span class="keyword">*</span> (and not allow to time out etc) unless allowCoreThreadTimeOut</span><br><span class="line"> <span class="keyword">*</span> is set, in which case the minimum is zero.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile int corePoolSize;//核心池的大小，当线程池中的线程数目大于这个参数时，提交的任务会被放进任务阻塞队列中</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Maximum pool size. Note that the actual maximum is internally</span><br><span class="line"> <span class="keyword">*</span> bounded by CAPACITY.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile int maximumPoolSize;//线程池最大能容忍的线程数</span><br></pre></td></tr></table></figure></p>
<h3 id="构造函数">构造函数</h3><p>ThreadPoolExecutor最重要的构造函数：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler <span class="keyword">handler</span>)</span><br></pre></td></tr></table></figure>
<p>函数的参数含义如下：</p>
<ul>
<li>corePoolSize: 指定线程池中的线程数量</li>
<li>maximumPoolSize: 指定了线程池中的最大线程数量</li>
<li>keepAliveTime: 当线程池线程数量超过corePoolSize时，多余的空闲线程的存活时间。即，超过corePoolSize的空闲线程，在多长时间内，会被销毁。</li>
<li>unit: keepAliveTime的单位</li>
<li>workQueue: 任务队列，被提交但尚未被执行的任务。</li>
<li>threadFactory: 线程工厂，用于创建线程，一般用默认的即可。</li>
<li>handler: 拒绝策略。当任务太多来不及处理，如何拒绝任务。</li>
</ul>
<h3 id="任务执行">任务执行</h3><p>在ThreadPoolExecutor类中，最核心的任务执行方法是execute和submit，submit方法也是通过调用execute方法来完成任务的执行。execute方法的源码如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">         * start a new thread with the given command as its first</span><br><span class="line">         * task.  The call to addWorker atomically checks runState and</span><br><span class="line">         * workerCount, and so prevents false alarms that would add</span><br><span class="line">         * threads when it shouldn't, by returning false.</span><br><span class="line">         *</span><br><span class="line">         * 2. If a task can be successfully queued, then we still need</span><br><span class="line">         * to double-check whether we should have added a thread</span><br><span class="line">         * (because existing ones died since last checking) or that</span><br><span class="line">         * the pool shut down since entry into this method. So we</span><br><span class="line">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">         * stopped, or start a new thread if there are none.</span><br><span class="line">         *</span><br><span class="line">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">         * and so reject the task.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<span class="comment">//第1步，线程池中的线程大小小于corePoolSize</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))<span class="comment">//true表示使用corePoolSize,false表示使用maximumPoolSize</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.<span class="keyword">get</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">//第2步，线程池的线程大小大于corePoolSize，而且线程池是RUNNING状态，阻塞队列也没满，加入到阻塞队列中</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.<span class="keyword">get</span>();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<span class="comment">//需要进行第二次判断，防止线程池被关闭了</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">workerCountOf(recheck</span>) </span>== <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">!addWorker(command, <span class="keyword">false</span></span>))<span class="comment">//第3步，使用线程池maximumPoolSize(最大大小)</span></span><br><span class="line">            <span class="title">reject</span>(<span class="params">command</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>由代码中的注释可知，execute方法分三步处理：</p>
<ol>
<li>如果当前正在执行的Worker数量比corePoolSize小，则直接通过addWorker方法创建一个新的Worker执行任务。</li>
<li>如果当前正在执行的Worker数量大于等于corePoolSize。将任务放到阻塞队列里，如果阻塞队列没满并且状态是RUNNING时，直接加入到阻塞队列中，否则跳到第三步。加入到阻塞队列后，还需要再验证一次（加入到聚在队列之后可能另外一个线程关闭了线程池或者刚加入到队列的线程死了）。如果此时线程池不是RUNNING状态，则把刚加入到阻塞队列中的任务remove掉，然后调用reject方法，否则查看Worker数量，如果Worker数量为0，起一个新的Worker去阻塞队列里拿任务执行。</li>
<li>加入阻塞队列失败时，会调用addWorker方法尝试起一个新的Worker去阻塞队列中拿任务并执行任务，如果addWorker调用失败，调用reject方法。</li>
</ol>
<h3 id="任务缓存队列">任务缓存队列</h3><ul>
<li><p>同步队列(SynchronousQueue)：该队列是直接提交的，是一个特殊的BlockingQueue。SynchronousQueue没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除操作都要等待对应的插入操作。如果使用SynchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程，则尝试创建新的线程，如果线程数已经达到最大值，则执行拒绝策略。因此，使用SynchronousQueue队列，通常需要设置很大的maximumPoolSize，否则很容易执行拒绝策略。</p>
</li>
<li><p>ArrayBlockingQueue</p>
</li>
<li><p>LinkedBlockingQueue：是无界任务队列，除非系统资源耗尽，否则无界的任务队列不存在入队失败的情况。当有新的任务到来，系统的线程数小于corePoolSize时，线程池会生成新的线程执行任务，但当系统的线程数达到corePoolSize后，就不会继续增加。若后续仍有新的任务加入，而又没有空闲的线程资源，则任务直接进入队列等待。若任务创建失败和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。</p>
</li>
<li><p>PriorityBlockingQueue：优先任务队列带有执行优先级，可以控制任务执行的先后顺序。ArrayBlockingQueue和LinkedBlockingQueue都是按照先进先出算法处理任务。而PriorityBlockingQueue则可以根据任务自身的优先级顺序先后执行。</p>
</li>
</ul>
<h3 id="任务拒绝策略">任务拒绝策略</h3><ul>
<li>AbortPolicy策略：丢弃任务并抛出RejectedExecutionException异常</li>
<li>CallerRunsPolicy策略：在调用者线程中运行当前被丢弃的任务</li>
<li>DiscardOldestPolicy策略：丢弃最老的任务，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li>
<li>DiscardPolicy策略：丢弃任务，但不抛出异常。</li>
</ul>
<h3 id="线程池的关闭">线程池的关闭</h3><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p>
<ul>
<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
<h3 id="线程工厂">线程工厂</h3><h3 id="扩展线程池">扩展线程池</h3><h3 id="线程池的大小">线程池的大小</h3><h2 id="参考文献">参考文献</h2><p><a href="http://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/" target="_blank" rel="external">Java线程池ThreadPoolExecutor源码分析</a><br><a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="external">Java并发编程：线程池的使用</a><br><a href="http://www.ticmy.com/?p=243" target="_blank" rel="external">hotspot1.7 ThreadPoolExecutor代码解析</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>多线程可以最大限度的发挥多核处理器的计算能力，提高生成系统的吞吐量和性能。但是，若不加控制和管理地随意使用线程，对系统的性能反而会产生不利的影响。在真实的生产环境中，当线程数量过大时，有可能耗尽CPU和内存资源。</p>
<p>首先，虽然与进程相比，线程是一种轻量级的工具，]]>
    </summary>
    
      <category term="Java线程池" scheme="http://blog.noobsky.com/tags/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实战Java虚拟机之锁与并发]]></title>
    <link href="http://blog.noobsky.com/2016/09/05/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E9%94%81%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    <id>http://blog.noobsky.com/2016/09/05/实战Java虚拟机之锁与并发/</id>
    <published>2016-09-05T02:17:39.000Z</published>
    <updated>2016-09-16T09:22:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="对象头和锁">对象头和锁</h2><p>在JVM的实现中每个对象都有一个对象头，用于保存对象的系统信息。对象头中有一个成为Mark Word的部分，它是实现锁的关键。在32位系统中，Mark Word为一个32位的数据，在64位系统中，它占64位。它是一个多功能的数据区，可以存放对象的哈希值、对象年龄、锁的指针等信息。一个对象是否占用锁，占有哪个锁，就记录在这个Mark Word中。</p>
<p>以32位系统为例，普通对象头如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash:<span class="number">25</span> ------------&gt; | age:<span class="number">4</span>   biased_lock:<span class="number">1</span> lock:<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>它表示Mark Word中有25位比特表示对象的哈希值，4位比特表示对象的年龄，1位比特表示是否为偏向锁，2位比特表示锁的信息。</p>
<p>对于偏向锁的对象，它的格式表示如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[JavaThread<span class="keyword">*</span> |<span class="string"> epoch </span>|<span class="string"> age </span>|<span class="string"> 1 </span>|<span class="string"> 01]</span></span><br></pre></td></tr></table></figure></p>
<p>前23位表示持有偏向锁的线程，后续2位比特表示偏向锁的时间戳（epoch），4位比特表示对象年龄，年龄后1位比特固定为1，表示偏向锁，最后两位为01表示可偏向/未锁定。</p>
<p>当对象处于轻量级锁定时，其Mark Word如下（00表示最后2位的值）：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[ptr               | 00]</span> <span class="keyword">locked</span></span><br></pre></td></tr></table></figure></p>
<p>此时，它指向存放在获得锁的线程栈中的该对象真实对象头。</p>
<p>当对象处于重量级锁定时，其Mark Word如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="preprocessor">ptr</span>               | <span class="number">10</span>] <span class="keyword">monitor</span></span><br></pre></td></tr></table></figure></p>
<p>此时，最后2位为10，整个Mark Word表示指向Monitor的指针。</p>
<p>当对象处于普通的未锁定状态时，其格式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Header        | <span class="number">0</span> | <span class="number">01</span>] unlocked</span><br></pre></td></tr></table></figure></p>
<p>前29位表示对象的哈希值、年龄信息。倒数第3位为0，最后两位为01，表示未锁定。可以发现，最后两位的值和偏向状态时是一样的，此时，虚拟机正是通过倒数第3位比特来区分是否为偏向锁。</p>
<h2 id="所在Java虚拟机中的实现和优化">所在Java虚拟机中的实现和优化</h2><h3 id="偏向锁">偏向锁</h3><p>偏向锁是JDK 1.6提出的一种锁优化方式。其核心思想是，如果程序没有竞争，则取消之前已经取得锁的线程同步操作。也就说，若某一锁被线程获取后，便进入偏向模式，当线程再次请求这个锁时，无需再进行相关的同步操作，从而节省了操作时间。如果在此之间有其他线程进行了锁请求，则锁退出偏向模式。在JVM中使用-XX:+UseBiasedLocking可以设置启用偏向锁。</p>
<p>当锁对象处于偏向模式时，对象头会记录获得锁的线程：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[JavaThread<span class="keyword">*</span> |<span class="string"> epoch </span>|<span class="string"> age </span>|<span class="string"> 1 </span>|<span class="string"> 01]</span></span><br></pre></td></tr></table></figure></p>
<p>这样，当线程再次尝试获得锁的时候，通过Mark Word的线程信息就可以判断当前线程是否持有偏向锁。</p>
<p>以下代码展示使用偏向锁带来的性能提升：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jaye.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/16.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Biased</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; numberList = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startnum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">10000000</span>)&#123;</span><br><span class="line">            numberList.add(startnum);</span><br><span class="line">            startnum += <span class="number">2</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(end - begin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用以下参数执行这段程序：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseBiasedLocking</span> -<span class="constant">XX</span><span class="symbol">:BiasedLockingStartupDelay=</span><span class="number">0</span> -client -<span class="constant">Xmx512m</span> -<span class="constant">Xms512m</span></span></span><br></pre></td></tr></table></figure></p>
<p>程序输出结果如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">468</span></span><br></pre></td></tr></table></figure></p>
<p>参数-XX:BiasedLockingStartupDelay=0表示虚拟机启动后，立即启用偏向锁。如不设置该参数，虚拟机默认会在启动后4秒后，才启用偏向锁。</p>
<p>若禁用偏向锁，使用以下参数：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseBiasedLocking</span> -client -<span class="constant">Xmx512m</span> -<span class="constant">Xms512m</span></span></span><br></pre></td></tr></table></figure></p>
<p>程序输出结果如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">743</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，偏向锁在少竞争的情况下，对系统性能有一定帮助。</p>
<p>偏向锁在锁竞争激烈得场合没有太强的优化效果，因为大量的竞争会导致持有锁的线程不停地切换，锁也很难一直保持在偏向模式，此时，使用锁偏向不仅得不到性能的优化，反而有可能降低系统性能。因此在竞争激烈得场合，可以尝试使用-XX:-UseBiasedLocking参数禁用偏向锁。</p>
<h3 id="轻量级锁">轻量级锁</h3><p>如果偏向失败，JVM会让现场申请轻量级锁。轻量级锁在虚拟机内部，使用一个称为BasicObjectLock的对象实现，这个对象内部由一个BasicLock对象和一个持有该锁的Java对象指针组成。BasicObjectLock对象放置在Java栈的栈帧中。在BasicLock对象内部还维护着displaced_header字段，它用于备份对象头部的Mark Word。</p>
<p>当一个线程持有一个对象的锁时，对象头部Mark Word如下所示：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[ptr               | 00]</span> <span class="keyword">locked</span></span><br></pre></td></tr></table></figure></p>
<h3 id="锁膨胀">锁膨胀</h3><p>当轻量级锁失败，虚拟机就会使用重量级锁。在使用重量级锁时，对象的Mark Word如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="preprocessor">ptr</span>               | <span class="number">10</span>] <span class="keyword">monitor</span></span><br></pre></td></tr></table></figure></p>
<p>末尾的2比特标记位被置为10。整个Mark Word表示指向monitor对象的指针。在轻量级锁处理失败后，虚拟机会执行以下操作：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock-&gt;<span class="function">set_displaced_header</span>(markOopDesc<span class="value">::<span class="function">unused_mark</span>());</span></span><br><span class="line">ObjectSynchronizer<span class="value">::<span class="function">inflate</span>(THREAD, <span class="function">obj</span>())-&gt;<span class="function">enter</span>(THREAD);</span></span><br></pre></td></tr></table></figure></p>
<p>第1步是废弃前面的BasicLock备份的对象头信息。第2步则正式启用重量级锁。启用过程分为两步：首先通过inflate()方法进行锁膨胀，其目的是获得对象的ObjectMonitor；然后使用enter()方法尝试进入该锁。</p>
<p>在enter()方法调用中，线程很可能会在操作系统层面被挂起。如果这样，线程间切换和调度的成本就会比较高。</p>
<h3 id="自旋锁">自旋锁</h3><p>上面说到，锁膨胀后进入ObjectMonitor的enter()，线程很可能会在操作系统层面被挂起，这样线程上下文切换的性能损失就比较大。因此在锁膨胀之后，虚拟机会做最后的争取，希望线程可以尽快进入临界区而避免被操作系统挂起。一种较为有效的手段就是使用自旋锁。</p>
<p>自旋锁可以使线程在没有取得锁时，不被挂起，而转而去执行一个空循环（即所谓的自旋），在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。</p>
<p>使用自旋锁后线程挂起的几率相对减少，线程执行的连贯性相对加强。因此，对于那些锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用时间长的并发程序，自旋锁在自旋等待后，往往依然无法获得对应的锁，不仅仅白白浪费CPU时间，最终还免不了被挂起的操作，反而浪费了系统资源。</p>
<p>在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁的等待次数。在JDK1.7中，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁。自旋锁总是会执行，自旋次数也是由虚拟机自行调整。</p>
<h3 id="锁消除">锁消除</h3><h2 id="锁在应用层的优化思路">锁在应用层的优化思路</h2><h3 id="减少锁的持有时间">减少锁的持有时间</h3><p>以下面的代码为例：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  othercode1();</span><br><span class="line">  mutextMethod();</span><br><span class="line">  othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在sync方法中，假设othercode1()和othercode2()方法并不需要同步控制，而且它们两又是重量级的方法，则会花费较长的CPU时间。</p>
<p>一个较为优化的解决方案是，只在必要时进行同步，这样就能明显减少线程持有锁的时间，提高系统的吞吐量。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">syncMethod2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  othercode1();</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    mutextMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="减少锁的粒度">减少锁的粒度</h3><p>典型的使用场景就是ConcurrentHashMap类的实现。</p>
<h3 id="锁分离">锁分离</h3><p>依据应用程序的功能特点，将一个独占锁分成多个锁。一个典型的案例就是LinkedBlockingQueue的实现。</p>
<p>在LinkedBlockingQueue的实现中，take函数和put函数分别实现了从队列中取得数据和往队列中增加数据的功能。虽然两个函数都对当前队列进行了修改，但由于基于链表，所以两个操作分别作用于队列的前端和尾端，从理论上来说，两者并不冲突。如果使用独占锁，则要求在两个操作进行时获取当前队列的独占锁，那么take和put操作就不可能真正并发执行。这样，锁竞争会相对比较激烈，从而影响程序在高并发时的性能。因此，在JDK的实现中，并没有采用这样的方式，取而代之的是两把不同的锁，分离了take和put操作。</p>
<h3 id="锁粗化">锁粗化</h3><h2 id="无锁">无锁</h2><h3 id="理解CAS">理解CAS</h3><h3 id="原子操作">原子操作</h3><h3 id="新宠儿LongAddr">新宠儿LongAddr</h3><h2 id="将随机变为可控：理解Java内存模型">将随机变为可控：理解Java内存模型</h2><h3 id="原子性">原子性</h3><h3 id="有序性">有序性</h3><h3 id="可见性">可见性</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="对象头和锁">对象头和锁</h2><p>在JVM的实现中每个对象都有一个对象头，用于保存对象的系统信息。对象头中有一个成为Mark Word的部分，它是实现锁的关键。在32位系统中，Mark Word为一个32位的数据，在64位系统中，它占64位。它是一个多功能的]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[实战Java虚拟机之Class装载系统]]></title>
    <link href="http://blog.noobsky.com/2016/09/05/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BClass%E8%A3%85%E8%BD%BD%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.noobsky.com/2016/09/05/实战Java虚拟机之Class装载系统/</id>
    <published>2016-09-05T02:03:08.000Z</published>
    <updated>2016-09-16T09:22:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Class文件装载流程">Class文件装载流程</h2><p>装载Class类型可以分为加载、连接、和初始化三个步骤。其中连接又可分为验证、准备和解析3步。</p>
<h3 id="加载">加载</h3><p>加载类时，JVM完成以下工作：</p>
<ul>
<li>通过类的全民，获取类的二进制数据流</li>
<li>解析类的二进制数据流为方法区内的数据结构</li>
<li>创建java.lang.Class类的实例，表示该类型</li>
</ul>
<h3 id="连接">连接</h3><h4 id="验证">验证</h4><p>目的是保证加载的类的字节码是合法、合理并符合规范的。包括：</p>
<ul>
<li>格式检查: 魔数检查，版本检查、长度检查</li>
<li>语义检查：是否继承final、是否有父类、抽象方法是否有实现</li>
<li>字节码验证：跳转指令是否指向正确位置、操作数类型是否合理</li>
<li>符号引用验证：符号引用的直接引用是否存在</li>
</ul>
<h4 id="准备">准备</h4><p>分配内存空间，并设置初始值。<br>jvm为各类型变量默认的初始值如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认初始值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">0L</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">(short)0</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">\u0000</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">reference</td>
<td style="text-align:left">null</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">0f</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">0f</td>
</tr>
</tbody>
</table>
<h4 id="解析">解析</h4><p>将符号引用转为直接引用，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h3 id="初始化">初始化</h3><p>初始化阶段的重要工作是执行类的初始化方法<clinit>。方法<clinit>是由编译器自动生成的，它是由类静态成员的赋值语句以及static语句块合并产生的。</clinit></clinit></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Class文件装载流程">Class文件装载流程</h2><p>装载Class类型可以分为加载、连接、和初始化三个步骤。其中连接又可分为验证、准备和解析3步。</p>
<h3 id="加载">加载</h3><p>加载类时，JVM完成以下工作：</p>
<ul>
<]]>
    </summary>
    
  </entry>
  
</feed>
