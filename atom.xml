<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-05-13T17:16:00.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Number of 1 Bits 和 Counting Bits]]></title>
    <link href="http://blog.noobsky.com/2016/05/14/LeetCode-Number-of-1-Bits-%E5%92%8C-Counting-Bits/"/>
    <id>http://blog.noobsky.com/2016/05/14/LeetCode-Number-of-1-Bits-和-Counting-Bits/</id>
    <published>2016-05-13T17:06:33.000Z</published>
    <updated>2016-05-13T17:16:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Number_of_1_Bits">Number of 1 Bits</h2><h3 id="题目描述">题目描述</h3><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p>
<h4 id="代码一">代码一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// if((n &amp; 1)==1)&#123;</span></span><br><span class="line">        <span class="comment">//     count++;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//更好的写法</span></span><br><span class="line">        count = count + (n &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//注意应该使用无符号右移，如果使用&gt;&gt;遇到负数时会发生死循环</span></span><br><span class="line">        n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码二">代码二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           <span class="comment">//将n最右边为1的比特位置为0</span></span><br><span class="line">           n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码三">代码三</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接调用Integer的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> Integer.<span class="title">bitCount</span><span class="params">(n)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Counting_Bits">Counting Bits</h2><h3 id="题目描述-1">题目描述</h3><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>Follow up:</p>
<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.<br>Hint:</p>
<p>You should make use of what you have produced already.<br>Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.<br>Or does the odd/even status of the number help you in calculating the number of 1s?</p>
<h4 id="代码一-1">代码一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bits[i] = bits[i/2] + i%2;</span></span><br><span class="line"><span class="comment">//i/2相当于将i(i&gt;=0)右移一位，对于奇数(最右边的比特位为1,&amp;1一定为1)来说,少了一个为1的比特位，需要加1（i%2或者i&amp;1），</span></span><br><span class="line"><span class="comment">//对于偶数来说(最右边的比特位为0，&amp;1一定为0)来说，为1的比特位不变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码二-1">代码二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bits[i] = bits[i &amp; (i-1)] + 1;</span></span><br><span class="line"><span class="comment">//i &amp; (i-1)的结果就是讲i最右边为1的比特位置为0，使i的比特位减少1，加上1即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) bits[i] = bits[i &amp; (i-<span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Number_of_1_Bits">Number of 1 Bits</h2><h3 id="题目描述">题目描述</h3><p>Write a function that takes an unsigned integer and returns the num]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Single Number I II III]]></title>
    <link href="http://blog.noobsky.com/2016/05/13/LeetCode-Single-Number-I-II-III/"/>
    <id>http://blog.noobsky.com/2016/05/13/LeetCode-Single-Number-I-II-III/</id>
    <published>2016-05-13T02:30:10.000Z</published>
    <updated>2016-05-13T06:48:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Single_Number_I">Single Number I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用异或的性质，相同的数异或结果为0，一个数跟0异或等于其本身，而且异或满足交换律</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        res = res ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Single_Number_II">Single Number II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果我们将nums数组中所有数的二进制表示中第i比特位求和sum（统计第i比特位为1的个数）</span></span><br><span class="line">   <span class="comment">//如果该sum % 3，那么其结果必为0或1，而且sum % 3的结果一定是那个single number第i比特位（0或1）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">       <span class="keyword">int</span> length = nums.length; </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">           count = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++)&#123;</span><br><span class="line">               <span class="comment">//这里因为外层循环使用了32次限制，所以右移不会像统计某个数中bit为1的数目那样造成死循环（那种情况可以使用无符号右移代替）</span></span><br><span class="line">               <span class="comment">//if(((nums[j] &gt;&gt; i) &amp; 1) == 1) count++;</span></span><br><span class="line">               <span class="comment">//这样写也是可以，这种写法在统计bit为1的数目时也可以避免死循环，但是要注意的是使用!=0,不能使用&gt;0（有负数）</span></span><br><span class="line">               <span class="keyword">if</span>((nums[j] &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) count++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果count % 3 = 1，则这个1肯定是我们所找的那个数贡献，也就是说我们所找的那个数在第i bit为1，</span></span><br><span class="line">           <span class="comment">//左移i位，因为这是第i位上的0或1</span></span><br><span class="line">           res |= ((count % <span class="number">3</span>) &lt;&lt; i);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Single_Number_III">Single Number III</h2><h3 id="题目描述-2">题目描述</h3><p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似Single Number I，我们从头到尾依次异或数组中的每一个数，那么最终得到的结果就是两个只出现一次的数字的异或结果</span></span><br><span class="line">   <span class="comment">//因为其他数字都出现了两次，这些出现两次数字最后的异或结果为0。由于两个出现一次的数字肯定不一样，那么这两个</span></span><br><span class="line">   <span class="comment">//数字的异或结果肯定不为0，也就是说在这两个出现一次的数字的异或结果的二进制表示中至少有一个比特位为1。我们在</span></span><br><span class="line">   <span class="comment">//此异或结果中找到第一个(从低位往高位数，最右边)为1的比特位的位置，记为第N比特位。然后我们以第N位是不是1为标准</span></span><br><span class="line">   <span class="comment">//把原数组中的数字分成两个子数组，第一个子数组的第N位为1，第二个子数组的第N位都为0。则我们把原数组分成两个子数组，</span></span><br><span class="line">   <span class="comment">//每个子数组都包含了一个只出现一次的数字，而其他数字都出现了两次。因为，我们已经把问题转换为了Single Number I</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> xorRes = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//遍历一遍，计算全部数字的异或结果</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) xorRes = xorRes ^ nums[i];</span><br><span class="line">       <span class="comment">//计算异或结果找到第一个为1的比特位的掩码(最右边为1的比特位为1，其余比特位为0)</span></span><br><span class="line">       <span class="comment">//xorRes &amp; (xorRes - 1)的效果是把xorRes第一个（最右边）为1的比特位变为0，该技巧也可以用来统计二进制中比特位为1的个数</span></span><br><span class="line">       <span class="comment">//接着异或自身xorRes即可</span></span><br><span class="line">       <span class="comment">//也可以使用xorRes = xorRes &amp; (-xorRes)。</span></span><br><span class="line">       <span class="keyword">int</span> firstOneBitMask = (xorRes &amp; (xorRes-<span class="number">1</span>)) ^ xorRes;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span>[] res = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>((nums[i] &amp; firstOneBitMask) == <span class="number">0</span>)&#123;</span><br><span class="line">               res[<span class="number">0</span>] = res[<span class="number">0</span>] ^ nums[i];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               res[<span class="number">1</span>] = res[<span class="number">1</span>] ^ nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Single_Number_I">Single Number I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of integers, every element appears twice except for on]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Word Pattern]]></title>
    <link href="http://blog.noobsky.com/2016/05/13/LeetCode-Word-Pattern/"/>
    <id>http://blog.noobsky.com/2016/05/13/LeetCode-Word-Pattern/</id>
    <published>2016-05-12T16:25:27.000Z</published>
    <updated>2016-05-12T16:28:58.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</p>
<p>Examples:<br>pattern = “abba”, str = “dog cat cat dog” should return true.<br>pattern = “abba”, str = “dog cat cat fish” should return false.<br>pattern = “aaaa”, str = “dog cat cat dog” should return false.<br>pattern = “abba”, str = “dog dog dog dog” should return false.<br>Notes:<br>You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.</p>
<h3 id="解法一">解法一</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> wordPattern(<span class="keyword">String</span> pattern, <span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">       <span class="keyword">String</span>[] words = <span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">" "</span>);</span><br><span class="line">       <span class="keyword">if</span>(words.length != pattern.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       Map&lt;Character, Integer&gt; pat = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">       Map&lt;<span class="keyword">String</span>, Integer&gt; wo = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">           <span class="built_in">char</span> temp = pattern.charAt(i);</span><br><span class="line">           <span class="keyword">String</span> tempStr = words[i];</span><br><span class="line">           <span class="comment">//前面异或为真时：一个有映射，一个没有映射，false</span></span><br><span class="line">           <span class="keyword">if</span>(pat.containsKey(temp) ^ wo.containsKey(tempStr) || (pat.containsKey(temp) &amp;&amp; wo.containsKey(tempStr) &amp;&amp; !pat.<span class="built_in">get</span>(temp).equals(wo.<span class="built_in">get</span>(tempStr)))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           pat.put(pattern.charAt(i), i);</span><br><span class="line">           wo.put(words[i], i);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法二">解法二</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的改进版本   </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> wordPattern(String pattern, String <span class="keyword">str</span>)&#123;</span><br><span class="line">    String[] words = <span class="keyword">str</span>.split(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span>(words.length != pattern.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Map <span class="keyword">index</span> = <span class="keyword">new</span> HashMap();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意i为Integer,如果为i时自动装箱会有问题，因为Integer默认缓存-128-127的数，!=比较对象会有问题</span></span><br><span class="line">    <span class="comment">//如果i为Integer，放入同一个对象，能够正确判断</span></span><br><span class="line">    <span class="keyword">for</span>(Integer i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">        <span class="comment">//put函数的返回值存在key时，返回旧的value，不存在key时返回null</span></span><br><span class="line">        <span class="comment">//都还没有索引，即null == null;如果一个有索引，一个没索引（即上面异或为真的情况）!=肯定成立，返回false；</span></span><br><span class="line">        <span class="comment">//如果都存在索引，但是索引的值不同，返回false；</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">index</span>.put(pattern.charAt(i), i) != <span class="keyword">index</span>.put(words[i], i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">        <span class="comment">//put函数的返回值存在key时，返回旧的value，不存在key时返回null</span></span><br><span class="line">        <span class="comment">//都还没有索引，即null == null;如果一个有索引，一个没索引（即上面异或为真的情况）!=肯定成立，返回false；</span></span><br><span class="line">        <span class="comment">//如果都存在索引，但是索引的值不同，返回false；</span></span><br><span class="line">        <span class="comment">// if(index.put(pattern.charAt(i), i) != index.put(words[i], i)) return false;</span></span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(<span class="keyword">index</span>.put(pattern.charAt(i), i),<span class="keyword">index</span>.put(words[i], i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法三">解法三</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map建立pattern到word的映射</span></span><br><span class="line"><span class="comment">//Set保存已经建立映射的word</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> wordPattern(<span class="keyword">String</span> pattern, <span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">    <span class="keyword">String</span>[] words = <span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span>(words.length != pattern.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Character, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">        <span class="built_in">char</span> ch = pattern.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(ch))&#123;</span><br><span class="line">            <span class="comment">//跟前面建立的映射不一样，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.<span class="built_in">get</span>(ch).equals(words[i])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//已经有其他字符映射到了words[i],出现了多对一映射，返回false</span></span><br><span class="line">            <span class="comment">//其实判断是否有其他字符映射到当前的字符也可以不另外使用Set而是直接用HashMap的containsValue来判断</span></span><br><span class="line">            <span class="comment">//但是该方法的时间复杂度为O(n)</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.contains(words[i])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//建立映射</span></span><br><span class="line">            <span class="built_in">map</span>.put(ch, words[i]);</span><br><span class="line">            <span class="comment">//记录已经映射的word</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">set</span>.<span class="built_in">add</span>(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Here follow means a full match, suc]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]包含min函数的栈 Min Stack]]></title>
    <link href="http://blog.noobsky.com/2016/05/12/LeetCode-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88-Min-Stack/"/>
    <id>http://blog.noobsky.com/2016/05/12/LeetCode-包含min函数的栈-Min-Stack/</id>
    <published>2016-05-12T06:35:43.000Z</published>
    <updated>2016-05-12T06:35:43.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]字符串和数字转换相关的几道题Reverse Integer、atoi和Valid Number]]></title>
    <link href="http://blog.noobsky.com/2016/05/12/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%A0%E9%81%93%E9%A2%98Reverse-Integer%E3%80%81atoi%E5%92%8CValid-Number/"/>
    <id>http://blog.noobsky.com/2016/05/12/LeetCode-字符串和数字转换相关的几道题Reverse-Integer、atoi和Valid-Number/</id>
    <published>2016-05-12T02:29:36.000Z</published>
    <updated>2016-05-12T02:29:36.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashSet源码分析]]></title>
    <link href="http://blog.noobsky.com/2016/05/09/HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://blog.noobsky.com/2016/05/09/HashSet源码分析/</id>
    <published>2016-05-09T07:38:48.000Z</published>
    <updated>2016-05-09T07:38:48.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <link href="http://blog.noobsky.com/2016/05/09/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://blog.noobsky.com/2016/05/09/HashMap源码分析/</id>
    <published>2016-05-09T07:38:28.000Z</published>
    <updated>2016-05-09T07:38:28.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tricky知识点与任务列表]]></title>
    <link href="http://blog.noobsky.com/2016/05/06/Tricky%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/"/>
    <id>http://blog.noobsky.com/2016/05/06/Tricky知识点与任务列表/</id>
    <published>2016-05-06T03:09:33.000Z</published>
    <updated>2016-05-10T03:58:17.000Z</updated>
    <content type="html"><![CDATA[<p>n &amp; (n-1)的效果是把该数二进制中最右边的一个1变成0，可以用来统计二进制中1的个数，或者判断二进制中只有一个1（n &amp; (n-1) == 0）<br>return num &gt; 0 &amp;&amp; (num&amp;(num-1)) == 0 &amp;&amp; (num &amp; 0x55555555) != 0;可以用来判断是否是4的指数（//0x55555555 is to get rid of those power of 2 but not power of 4,so that the single 1 bit always appears at the odd position ）<br>return num &gt; 0 &amp;&amp; (num&amp;(num-1)) == 0可以用来判断是否是2的指数</p>
<p>n!尾部含0的个数为n/5 + n/25 + n/125 + n/625 + ……</p>
<p>HashMap的源码<br>TreeMap的源码<br>HashSet的源码<br>Concurrent的源码<br>ArrayList的源码<br>LinkedList的源码<br>。。。</p>
<p>String<br>StringBuffer<br>StringBuilder<br>Integer<br>Arrays<br>Collections<br>Byte</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>n &amp; (n-1)的效果是把该数二进制中最右边的一个1变成0，可以用来统计二进制中1的个数，或者判断二进制中只有一个1（n &amp; (n-1) == 0）<br>return num &gt; 0 &amp;&amp; (num&amp;(num-1)) == ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode对称树]Symmetric Tree]]></title>
    <link href="http://blog.noobsky.com/2016/05/05/LeetCode%E5%AF%B9%E7%A7%B0%E6%A0%91-Symmetric-Tree/"/>
    <id>http://blog.noobsky.com/2016/05/05/LeetCode对称树-Symmetric-Tree/</id>
    <published>2016-05-05T06:33:07.000Z</published>
    <updated>2016-05-05T07:24:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>But the following is not:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>判断一颗二叉树是否是对称的，二叉树是对称的如果它的左子树和右子树是镜像对称的，<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/symtree1.png" alt=""><br>所以问题就是判断两棵树是否镜像对称。当两棵树互为镜像对称时，它们满足以下条件：</p>
<ul>
<li>它们的根的值相等</li>
<li>一棵树的左子树、右子树分别和另一棵树的右子树、左子树是镜像对称的<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/symtree2.png" alt=""><br>这里给出该题的两种解法，分别为递归法和迭代法</li>
</ul>
<h3 id="方法一：递归法">方法一：递归法</h3><p>代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="function"><span class="keyword">return</span> <span class="title">isMirror</span><span class="params">(root.left, root.right)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//判断左右子树是否为镜像</span></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> t1.val == t2.val &amp;&amp; isMirror(t1.left, t2.right) &amp;&amp; isMirror(t1.right, t2.left);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>因为树的每一个节点都需要遍历到，所以算法的时间复杂度为O(n)。递归调用的上界为树的高度，最坏情况下，树退化为线性的链表，高度为O(n)，所以递归调用栈空间复杂度的最坏情况为O(n)。</p>
<h3 id="方法二：迭代法">方法二：迭代法</h3><p>我们也可以利用队列使用迭代的方法来解决该问题。队列中每两个连续的节点都应该相等，而且它们的子树互为镜像对称。初始化时，队列中包含根节点的左右子节点。该算法类似于BFS，稍微做了下修改。每一次循环，从队列中取出两个元素并比较它们的值。然后两个节点的左右孩子以相反的顺序加入队列中。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> isSymmetric(TreeNode root)&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">       <span class="built_in">queue</span><span class="built_in">.</span>offer(root<span class="built_in">.</span>left);</span><br><span class="line">       <span class="built_in">queue</span><span class="built_in">.</span>offer(root<span class="built_in">.</span>right);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">           TreeNode t1 = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">           TreeNode t2 = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(t1 == <span class="built_in">null</span> <span class="subst">&amp;&amp;</span> t2 == <span class="built_in">null</span>) continue;</span><br><span class="line">           <span class="keyword">if</span>(t1 == <span class="built_in">null</span> <span class="subst">||</span> t2 == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(t1<span class="built_in">.</span>val != t2<span class="built_in">.</span>val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="built_in">queue</span><span class="built_in">.</span>offer(t1<span class="built_in">.</span>left);</span><br><span class="line">           <span class="built_in">queue</span><span class="built_in">.</span>offer(t2<span class="built_in">.</span>right);</span><br><span class="line">           <span class="built_in">queue</span><span class="built_in">.</span>offer(t1<span class="built_in">.</span>right);</span><br><span class="line">           <span class="built_in">queue</span><span class="built_in">.</span>offer(t2<span class="built_in">.</span>left);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>因为树的每一个节点都需要遍历到，所以算法的时间复杂度为O(n)。另外还需要额外的空间，最坏情况我们需要将全部节点插入队列中，所以空间复杂度为O(n)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example,]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树的层次遍历]]></title>
    <link href="http://blog.noobsky.com/2016/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>http://blog.noobsky.com/2016/05/05/二叉树的层次遍历/</id>
    <published>2016-05-05T02:28:49.000Z</published>
    <updated>2016-05-05T03:44:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="二叉树的层次遍历">二叉树的层次遍历</h3><p>二叉树的层次遍历是指从上往下，从左往右按层打印树的每个节点。一般可以使用DFS和BFS的方法。<br>首先给出二叉树的代码：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     int <span class="variable"><span class="keyword">val</span>;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode(int x) &#123; <span class="keyword">val</span></span> = x; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用BFS思想的代码如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">    <span class="comment">//对一般的分层遍历稍加改进，就能实现分行打印每一层</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一般的分层遍历都是每次循环从队列头中取出一个元素然后将其左右节点分别入队列，</span></span><br><span class="line">        TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">        res<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">        <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>left);</span><br><span class="line">        <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>right);            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展一">扩展一</h3><p>一般的二叉树的层次遍历所有结点都输出在同一行。如果希望仅仅同层结点输出在同一行，该如何修改代码？我们稍微修改一下上面的二叉树的层次遍历即可，详细见下面代码的注释。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">    <span class="comment">//对一般的分层遍历稍加改进，就能实现分行打印每一层</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">        <span class="comment">//先不急着出队列，记录队列的大小，相当于每层元素的个数</span></span><br><span class="line">        int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//一般的分层遍历都是每次循环从队列头中取出一个元素然后将其左右节点分别入队列，</span></span><br><span class="line">        <span class="comment">//改进后就是每次从队列头中取出levelNumber个元素,</span></span><br><span class="line">        <span class="comment">//然后将每个元素的左右节点分别入队列。</span></span><br><span class="line">        f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">            <span class="comment">//使用peek可以节省一个局部变量</span></span><br><span class="line">            <span class="comment">// if(queue.peek().left != null) queue.add(queue.peek().left);</span></span><br><span class="line">            <span class="comment">// if(queue.peek().right != null) queue.add(queue.peek().right);</span></span><br><span class="line">            <span class="comment">// subList.add(queue.poll().val);</span></span><br><span class="line">            <span class="comment">//使用局部变量,测试发现速度能稍微快一点</span></span><br><span class="line">            TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">            subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">            <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>left);</span><br><span class="line">            <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>right);</span><br><span class="line">        &#125;</span><br><span class="line">        res<span class="built_in">.</span>add(subList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实我们也可以使用DFS的思想，代码如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(level &gt;= res<span class="built_in">.</span>size())&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res<span class="built_in">.</span>get(level)<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level+<span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展二">扩展二</h3><p>前面的讨论都是从上往下、从左往右分层遍历二叉树，那么如果希望自下往上、从左右往右遍历二叉树，该如何修改代码呢？<br>方法很简单，我们只要把扩展一中的结果反转一下就可以了。详见下面的代码。<br>使用BFS思想:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//使用LinkedList，不使用ArrayList，原因见后面</span></span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//将root加入队列中</span></span><br><span class="line">        <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">        <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">            int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">            LinkedList&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> LinkedList();</span><br><span class="line">            f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">                subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>left);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//总是在0索引的位置插入每一层的遍历结果，最后遍历res的时候结果就是反过来的，即从下往上分层遍历</span></span><br><span class="line">            <span class="comment">//这里之所以使用LinkedList的原因是ArrayList的底层是数组，插入元素时需要移动大量的元素，效率低</span></span><br><span class="line">            <span class="comment">//而LinkedList的底层是链表，插入操作非常高效</span></span><br><span class="line">            res<span class="built_in">.</span>add(<span class="number">0</span>,subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用DFS思想：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrderBottom(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res<span class="built_in">.</span>size() &lt;= level)&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="number">0</span>, <span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res<span class="built_in">.</span>get(res<span class="built_in">.</span>size()-<span class="number">1</span><span class="attribute">-level</span>)<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level + <span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="二叉树的层次遍历">二叉树的层次遍历</h3><p>二叉树的层次遍历是指从上往下，从左往右按层打印树的每个节点。一般可以使用DFS和BFS的方法。<br>首先给出二叉树的代码：<br><figure class="highlight kotlin"><table>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Implement Queue using Stacks]]></title>
    <link href="http://blog.noobsky.com/2016/05/04/LeetCode-Implement-Queue-using-Stacks/"/>
    <id>http://blog.noobsky.com/2016/05/04/LeetCode-Implement-Queue-using-Stacks/</id>
    <published>2016-05-04T13:30:27.000Z</published>
    <updated>2016-05-05T03:47:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Implement the following operations of a queue using stacks.</p>
<p>push(x) – Push element x to the back of queue.<br>pop() – Removes the element from in front of queue.<br>peek() – Get the front element.<br>empty() – Return whether the queue is empty.<br>Notes:<br>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.<br>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.<br>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</p>
<p>题意很容易理解，就是利用栈实现队列的功能，我们知道栈是FILO即先进后出，而队列是FIFO即先进先出，我们如何才能利用栈的先进后出实现队列的先进先出呢？答案就是利用两个栈，一个栈是先进后出，两个先进后出的结果就是先进先出就是队列的功能。先把元素压入（push）第一个栈inputStack，然后从第一个栈inputStack中弹栈（pop），接着将弹出的元素压入（push）到第二个栈outputStack中。这样做之后我们先进栈的元素将位于第二个栈outputStack中栈顶，当我们需要从队头取出元素时（pop）时，我们只要在第二个栈outputStack中弹栈（pop）即可。当我们需要向队尾放入元素（push）时，我们向第一个栈inputStack中压入元素（push）即可。这样第一个栈inputStack相当于队尾，第二个栈outputStack相当于队头。</p>
<p>算法思想已经理解，但是实现起来还是有需要注意的地方，下面是我一开始写的代码：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack&lt;Integer&gt; outputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = outputStack.<span class="keyword">pop</span>();</span><br><span class="line">            inputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStack.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">pop</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        outputStack.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> peek() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> inputStack.isEmpty() &amp;&amp; outputStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试之后发现结果不对，比如当我们执行<code>push(1),push(2),peek,push(3),peek</code>后发现输出为1、3，但是正确的输出应该为1。错误的原因如下：开始我们向inputStack压入1、2，然后第一次peek的时候，我们依次从inputStack弹出2、1然后压入outputStack，此时元素是反转过来变成了先进先出，因此我们peek的时候输出1，接着向栈inputStack压入3，最后peek的时候又直接将3压入outpuStack中，这时3和1、2的顺序是错误的。然后我的修改是往inputStack中push元素的时候将outputStack中元素弹出再反压入inputStack中保持元素的顺序，代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack&lt;Integer&gt; outputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = outputStack.<span class="keyword">pop</span>();</span><br><span class="line">            inputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStack.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">pop</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        outputStack.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> peek() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> inputStack.isEmpty() &amp;&amp; outputStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试通过，但是这样写性能太低了，时间复杂度有点大。其实push元素的时候我们不需要将元素反压入inputStack中，而是在pop或者peek时，只在outputStack为空时才将inputStack中的元素弹出然后反压入outputStack中。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack&lt;Integer&gt; outputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        inputStack.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">pop</span>() &#123;</span><br><span class="line">    	<span class="comment">//这段代码跟peek中的重复，可以直接调用peek替代</span></span><br><span class="line">        <span class="keyword">if</span>(outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        outputStack.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> peek() &#123;</span><br><span class="line">        <span class="keyword">if</span>(outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> inputStack.isEmpty() &amp;&amp; outputStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Implement the following operations of a queue using stacks.</p>
<p>push(x) – Push element x to the back of queue.<]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Swap Nodes in Pairs]]></title>
    <link href="http://blog.noobsky.com/2016/05/02/LeetCode-Swap-Nodes-in-Pairs/"/>
    <id>http://blog.noobsky.com/2016/05/02/LeetCode-Swap-Nodes-in-Pairs/</id>
    <published>2016-05-02T05:52:39.000Z</published>
    <updated>2016-05-05T03:46:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
<p>这个题目的思想很简单，但是要想写对代码还是有点繁琐的，稍微不慎可能就蒙圈了。<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode swapPairs(ListNode head)&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">       </span><br><span class="line">       ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       dummy.<span class="keyword">next</span> = head;</span><br><span class="line">       ListNode current = dummy;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>(current.<span class="keyword">next</span> != <span class="literal">null</span> &amp;&amp; current.<span class="keyword">next</span>.<span class="keyword">next</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">           ListNode first = current.<span class="keyword">next</span>;</span><br><span class="line">           ListNode second = current.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">           </span><br><span class="line">           first.<span class="keyword">next</span> = second.<span class="keyword">next</span>;</span><br><span class="line">           current.<span class="keyword">next</span> = second;</span><br><span class="line">           second.<span class="keyword">next</span> = first;//或者是current.<span class="keyword">next</span>.<span class="keyword">next</span> = first;</span><br><span class="line">           </span><br><span class="line">           current = current.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们就以1-&gt;2-&gt;3-&gt;4为例，第一对邻接节点1和2的交换过程示意图如下：<br>初始化，执行<code>ListNode first = current.next; ListNode second = current.next.next;</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes1.png" alt=""></p>
<p>执行<code>first.next = second.next</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes2.png" alt=""></p>
<p>执行<code>current.next = second</code>之后<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes3.png" alt=""></p>
<p>执行<code>second.next = first</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes4.png" alt=""></p>
<p>执行<code>current = current.next.next</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes5.png" alt=""></p>
<p>之后进入下一次循环，过程类似。</p>
<p>其实该题更简洁的方法是使用递归，代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode swapPairs(ListNode head)&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">       </span><br><span class="line">       ListNode temp = head.<span class="keyword">next</span>;</span><br><span class="line">       head.<span class="keyword">next</span> = swapPairs(head.<span class="keyword">next</span>.<span class="keyword">next</span>);</span><br><span class="line">       temp.<span class="keyword">next</span> = head;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock系列]]></title>
    <link href="http://blog.noobsky.com/2016/04/30/Best-Time-to-Buy-and-Sell-Stock/"/>
    <id>http://blog.noobsky.com/2016/04/30/Best-Time-to-Buy-and-Sell-Stock/</id>
    <published>2016-04-30T10:49:01.000Z</published>
    <updated>2016-05-05T03:47:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Best_Time_to_Buy_and_Sell_Stock">Best Time to Buy and Sell Stock</h2><h3 id="题目描述">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>开始我对这个题目不是很理解，存在一些误区，然后看了一个歪果仁的更清楚的说明：<br>If you were only permitted to complete at most one buy and at most one sell during the whole period of days, design an algorithm such that your profit, i.e., sell price minus buy price, is maximized. Note that you can only not sell a stock before you buy one.</p>
<p>For example:</p>
<p>[1,2,3,4] ==&gt; returns 3 (buy at 1 and sell at 4)</p>
<p>[4,3,2,1] ==&gt; returns 0 (don’t buy)</p>
<p>[4,10,25,2,10] ==&gt; returns 21 (buy at 4 and sell at 25)</p>
<p>题目大意是说整个期间你最多只能买一次股票然后只能卖出一次，当然也可以不买股票。设计一个算法计算最大收益。<br>该问题可以使用动态规划解决，设dp[i]是[0,1,2…i]区间的最大利润，则该问题的一维动态规划方程如下：<br>dp[i+1] = max{dp[i], prices[i+1] - minPrices},minPrices是区间[0,1,2…,i]内的最低价格,我们要求解的最大利润 = max{dp[0], dp[1], dp[2], …, dp[n-1]} 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> maxProfit=<span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           <span class="comment">//最大收益</span></span><br><span class="line">           maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">           <span class="comment">//保存最小的price</span></span><br><span class="line">           minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果我们不再从每日的股票价格的角度去看待输入数据，而是考察每日股票价格的变化，第i天的股票价格变化定义为第i天和第i-1的价格差。并将这些价格差看做一个新数组A{prices[1]-prices[0], prices[2]-prices[1], prices[3]-prices[2], …, prices[n-1]-prices[n-2]}，那么问题就转化为寻找新数组A的最大子数组和。最大子数组和也是一个DP问题，详见维基百科<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank" rel="external">Maximum subarray problem</a>和本博客的博文最大子数组和。最大子数组和的Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_subarray</span><span class="params">(A)</span>:</span></span><br><span class="line">    max_ending_here = max_so_far = A[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> A[<span class="number">1</span>:]:</span><br><span class="line">        max_ending_here = max(x, max_ending_here + x)</span><br><span class="line">        max_so_far = max(max_so_far, max_ending_here)</span><br><span class="line">    <span class="keyword">return</span> max_so_far</span><br></pre></td></tr></table></figure>
<p>根据最大子数组和的程序，利用最大子数组和算法解决本股票问题的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxEndingHere = prices[<span class="number">1</span>] - prices[<span class="number">0</span>], maxSoFar = prices[<span class="number">1</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            maxEndingHere = Math.max(prices[i] - prices[i-<span class="number">1</span>], maxEndingHere+prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最大收益为负数，则不买股票，返回0</span></span><br><span class="line">        <span class="keyword">return</span> maxSoFar &gt; <span class="number">0</span> ? maxSoFar : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码可能不够直观，可以使用额外的O(n)的内存空间来存股票价格变化数组，更为直观的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span>[] diffPrices = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length-<span class="number">1</span>];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           diffPrices[i-<span class="number">1</span>] = prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> res = maxSubarray(diffPrices);</span><br><span class="line">       <span class="keyword">return</span> res &gt; <span class="number">0</span> ? res : <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> maxEndingHere = arr[<span class="number">0</span>],maxSoFar = arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">           maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);</span><br><span class="line">           maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxSoFar;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_II">Best Time to Buy and Sell Stock II</h2><h3 id="题目描述-1">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>在上一题的基础上，可以买卖多次股票，但是再买股票时必须把之前的股票卖出去，也就是说手上最多只能有一只股票。可以找到所有价格的递增区间，把这些递增区间的收益全部加起来就是最后的最大收益。代码有以下两种写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码一：</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> length = prices.length;</span><br><span class="line">       <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//注意循环结束条件是i &lt; length-1,如果是i &lt; length在&#123;1，2&#125;会陷入死循环</span></span><br><span class="line">       <span class="keyword">while</span>(i &lt; length - <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">while</span>(i+<span class="number">1</span> &lt; length &amp;&amp; prices[i+<span class="number">1</span>] &gt;= prices[i])&#123;</span><br><span class="line">               profit += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">               i++;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">while</span>(i+<span class="number">1</span> &lt; length &amp;&amp; prices[i+<span class="number">1</span>] &lt; prices[i]) i++;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> profit;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//代码二：</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(prices[i+<span class="number">1</span>] &gt; prices[i]) profit += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> profit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_III">Best Time to Buy and Sell Stock III</h2><h3 id="题目描述-2">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>这一题是最多只能买卖两次股票，求最大收益，同理手上最多只能有一只股票。因为不能连续买入两次股票，所以买卖两次肯定分布在两个不同区间。容易想到的解决办法是，把prices[] 分成两部分prices[0…m] 和 prices[m…length]  ，分别计算在这两部分内做交易的做大收益。在每个区间的问题又回到了I的情况。由于做n次划分，每次划分后求解的时间复杂度为O(n),所以总的时间复杂度为O(n<sup>2</sup>)，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n*n) time limit exceeded</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           maxProfit = Math.max(maxProfit,maxProfitOnce(prices, <span class="number">0</span>, i) + maxProfitOnce(prices, i, prices.length -<span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfitOnce</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> minPrice = prices[start];</span><br><span class="line">       <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">           maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">           minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是由于时间复杂度为O(n<sup>2</sup>)，效率低，运行超时。可以利用动态规划的思想进行改进，保持计算的中间结果，减少重复的计算。那就是第一步扫描，先计算出子序列[0,…,i]中的最大利润，用一个数组保存下来，那么时间是O(n)。计算方法也是利用第一个问题的计算方法。第二步是逆向扫描，计算子序列[i,…,n-1]上的最大利润，这一步同时就能结合上一步的结果计算最终的最大利润了，这一步也是O(n)。 所以最后算法的复杂度就是O(n)的。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] maxProfitFromHead = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        maxProfitFromHead[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">            maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">            maxProfitFromHead[i] = maxProfit;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxPrice = prices[prices.length -<span class="number">1</span>];</span><br><span class="line">        maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> finalMaxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.length -<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            maxPrice = Math.max(prices[i], maxPrice);</span><br><span class="line">            maxProfit = Math.max(maxProfit, maxPrice - prices[i]);</span><br><span class="line">            finalMaxProfit = Math.max(finalMaxProfit, maxProfit + maxProfitFromHead[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> finalMaxProfit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Best_Time_to_Buy_and_Sell_Stock">Best Time to Buy and Sell Stock</h2><h3 id="题目描述">题目描述</h3><p>Say you have an array for which the i]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Happy Number与Floyd判圈算法]]></title>
    <link href="http://blog.noobsky.com/2016/04/30/Happy-Number%E4%B8%8EFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.noobsky.com/2016/04/30/Happy-Number与Floyd判圈算法/</id>
    <published>2016-04-30T04:46:38.000Z</published>
    <updated>2016-05-05T03:46:35.000Z</updated>
    <content type="html"><![CDATA[<p>最近在刷LeetCode的时候，遇到一题为Happy Number的题，该题最容易想到的思路就是利用集合，还有一个很巧妙的解法就是利用Floyd判圈算法来做，下面就来看看。</p>
<h3 id="题目描述">题目描述</h3><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example: 19 is a happy number</p>
<p>1<sup>2</sup> + 9<sup>2</sup> = 82<br>8<sup>2</sup> + 2<sup>2</sup> = 68<br>6<sup>2</sup> + 8<sup>2</sup> = 100<br>1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1</p>
<p>最直接的解法就是利用集合来判断各位的平方和是否已经出现过，如果出现过，则不是Happy Number。代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, digit;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            digit = n % <span class="number">10</span>;</span><br><span class="line">            sum += digit * digit;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">set</span>.add(n))&#123;</span><br><span class="line">            n = digitSquareSum(n);</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去讨论区里发现了一种利用Floyd判圈算法的解法非常巧妙，下面就来介绍一下Floyd判圈算法（Floyd Cycle Detection Algorithm）。</p>
<p>Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)。该算法由美国科学家罗伯特·弗洛伊德发明，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。</p>
<p>Floyd判圈算法的基本思想可以用我们跑步的例子来解释，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。</p>
<p>基于上面的想法，Floyd算法用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果是等价的，只要一个比另一个快就行，从后面的讨论我们可以看出这一点）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没环。详见维基百科<a href="https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare" target="_blank" rel="external">Cycle detection</a></p>
<p>下面从数学的角度来推导一下：<br>乌龟和兔子从起点同时出发，首先假设乌龟每次走一步，兔子每次走两步，则乌龟和兔子最后必定会相遇。<br>借用这张经典的解析图：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/floyd_cycle_detection.jpg" alt=""><br>假设乌龟走的路程为L，兔子走的路程为2L，则有如下等式：<br>1) L = m + p <em> n + k<br>2) 2L = m + q </em> n + k<br>这里的p和q分别为乌龟和兔子在环里走的圈数（q&gt;p）。由1）和2）式可得：<br> 2( m + p <em> n + k ) = m + q </em> n + k<br> =&gt; 2m + 2pn + 2k = m + nq + k<br> =&gt; m + k = (q - 2p)n<br>因此，如果我们能够证明至少有一种k, p, q的值可以使得这个等式成立，我们就证明了假设成立。这里我们只要使p=0，q=m，k=mn-m，上式成立。</p>
<p>下面我们来解决第二个问题，即环的起点在哪里。<br>当乌龟和兔子相遇后，我们让乌龟放回链表起点，兔子留在相遇点，然后他们以相同的速度前进（都是一次一步），则乌龟和兔子将会在在环的起点处相遇。为什么？下面来推导一下。<br>假设让乌龟走m+k步，则乌龟会到达之前跟兔子的相遇点，前面我们已经证明m + k = (q - 2p)n，也就是说m+k是环路长度n的整数倍，同时，兔子绕环路（q-2p）圈后也回到该点（距离环路起点k步处）。我们不是让乌龟走m+k步而是只走m步，则乌龟会到达环路的起点处，而兔子此时还差k步才走完（q-2p）圈环路，而兔子是从离环路起点k步的地方开始走的，所以此时兔子也走到环路起点处。该算法还能用来判断链表中是否有环及找出环的起点，详见()[]。下面是Floyd判圈算法的python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floyd</span><span class="params">(f, x0)</span>:</span></span><br><span class="line">    <span class="comment"># Main phase of algorithm: finding a repetition x_i = x_2i.</span></span><br><span class="line">    <span class="comment"># The hare moves twice as quickly as the tortoise and</span></span><br><span class="line">    <span class="comment"># the distance between them increases by 1 at each step.</span></span><br><span class="line">    <span class="comment"># Eventually they will both be inside the cycle and then,</span></span><br><span class="line">    <span class="comment"># at some point, the distance between them will be</span></span><br><span class="line">    <span class="comment"># divisible by the period λ.</span></span><br><span class="line">    tortoise = f(x0) <span class="comment"># f(x0) is the element/node next to x0.</span></span><br><span class="line">    hare = f(f(x0))</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        tortoise = f(tortoise)</span><br><span class="line">        hare = f(f(hare))</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># At this point the tortoise position, ν, which is also equal</span></span><br><span class="line">    <span class="comment"># to the distance between hare and tortoise, is divisible by</span></span><br><span class="line">    <span class="comment"># the period λ. So hare moving in circle one step at a time, </span></span><br><span class="line">    <span class="comment"># and tortoise (reset to x0) moving towards the circle, will </span></span><br><span class="line">    <span class="comment"># intersect at the beginning of the circle. Because the </span></span><br><span class="line">    <span class="comment"># distance between them is constant at 2ν, a multiple of λ,</span></span><br><span class="line">    <span class="comment"># they will agree as soon as the tortoise reaches index μ.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the position μ of first repetition.    </span></span><br><span class="line">    mu = <span class="number">0</span></span><br><span class="line">    tortoise = x0</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        tortoise = f(tortoise)</span><br><span class="line">        hare = f(hare)   <span class="comment"># Hare and tortoise move at same speed</span></span><br><span class="line">        mu += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Find the length of the shortest cycle starting from x_μ</span></span><br><span class="line">    <span class="comment"># The hare moves one step at a time while tortoise is still.</span></span><br><span class="line">    <span class="comment"># lam is incremented until λ is found.</span></span><br><span class="line">    lam = <span class="number">1</span></span><br><span class="line">    hare = f(tortoise)</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        hare = f(hare)</span><br><span class="line">        lam += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> lam, mu</span><br></pre></td></tr></table></figure>
<p>好了，现在回到Happy Number本身。如果一个数不是Happy Number，则计算该数的各位的平方和时会出现环路，则我们可以利用Floyd判圈算法来做，慢“指针”（乌龟）每次计算一次Number的各位的平方和，快“指针”（兔子）每次计算两次Number的每位的平方和。如果慢指针和快指针相遇（计算的Number的每位平方和相等），则Number不是Happy的。反之最后计算的值都为1，则为Happy Number。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, digit;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            digit = n % <span class="number">10</span>;</span><br><span class="line">            sum += digit * digit;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow=n, fast = n;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = digitSquareSum(slow);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        <span class="keyword">if</span>(slow == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在刷LeetCode的时候，遇到一题为Happy Number的题，该题最容易想到的思路就是利用集合，还有一个很巧妙的解法就是利用Floyd判圈算法来做，下面就来看看。</p>
<h3 id="题目描述">题目描述</h3><p>Write an algorithm t]]>
    </summary>
    
      <category term="Floyd判圈算法" scheme="http://blog.noobsky.com/tags/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[罗马数字和阿拉伯数字的相互转换]]></title>
    <link href="http://blog.noobsky.com/2016/04/28/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E5%92%8C%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
    <id>http://blog.noobsky.com/2016/04/28/罗马数字和阿拉伯数字的相互转换/</id>
    <published>2016-04-28T06:37:29.000Z</published>
    <updated>2016-05-05T03:46:20.000Z</updated>
    <content type="html"><![CDATA[<p>罗马数字基本字符和阿拉伯数字的对应关系</p>
<table>
<thead>
<tr>
<th>Roman Literal</th>
<th>Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
</tbody>
</table>
<h3 id="记数方法">记数方法</h3><ul>
<li>相同的数字连写、所表示的数等于这些数字相加得到的数、如：Ⅲ=3；</li>
<li>小的数字在大的数字的右边、所表示的数等于这些数字相加得到的数、 如：Ⅷ=8、Ⅻ=12；</li>
<li>小的数字、（限于 Ⅰ、X 和 C）在大的数字的左边、所表示的数等于大数减小数得到的数、如：Ⅳ=4、Ⅸ=9；</li>
<li>正常使用时、连写的数字重复不得超过三次；</li>
<li>在一个数的上面画一条横线、表示这个数扩大 1000 倍。</li>
</ul>
<h3 id="组数规则">组数规则</h3><ul>
<li>基本数字 Ⅰ、X 、C 中的任何一个、自身连用构成数目、或者放在大数的右边连用构成数目、都不能超过三个；放在大数的左边只能用一个；</li>
<li>不能把基本数字 V 、L 、D 中的任何一个作为小数放在大数的左边采用相减的方法构成数目；放在大数的右边采用相加的方式构成数目、只能使用一个；</li>
<li>V 和 X 左边的小数字只能用 Ⅰ；</li>
<li>L 和 C 左边的小数字只能用X；</li>
<li>D 和 M 左边的小数字只能用 C。</li>
</ul>
<h3 id="罗马数字转阿拉伯数字">罗马数字转阿拉伯数字</h3><h4 id="题目描述">题目描述</h4><p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<ul>
<li>从左往右遍历转换</li>
</ul>
<p>初始化结果为0，然后从左往右遍历罗马数字，如果某个数比左边一个数小，则把该数加入到结果中；反之（即某个数比左边一个数大），则在结果中两次减去前一个数并加上当前这个数。这里解释一下后者，比如罗马数字IV，开始时遍历到I，然后将结果加1，接着遇到了V，我们知道V的前面出现了一个比V小的的I，所以我们需要从V中减去I，但是我们前面已经加过I，所以我们需要减去两倍的I。下面看一个更复杂的例子：</p>
<table>
<thead>
<tr>
<th>Roman literals from left to right</th>
<th>Accumulated total</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>1000</td>
</tr>
<tr>
<td>MX</td>
<td>1000 + 10 = 1010</td>
</tr>
<tr>
<td>MXC</td>
<td>1010 + (100 - 2 * 10) = 1010 + 80 = 1090</td>
</tr>
<tr>
<td>MXCV</td>
<td>1090 + 5 = 1095</td>
</tr>
<tr>
<td>MXCVI</td>
<td>1095 + 1 = 1096</td>
</tr>
</tbody>
</table>
<p>代码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="built_in">map</span>.get(s.charAt(i));</span><br><span class="line">            sum += (curr &gt; pre) ? (curr - <span class="number">2</span> * pre):curr;</span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>从右往左遍历转换</li>
</ul>
<p>其实更直观的转换方式是从右往左转换，如果某个数大于等于右边的数，则直接加入到结果中；反之，从结果中减去该数。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="built_in">map</span>.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(curr &gt;= pre)&#123;</span><br><span class="line">                sum += curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum -= curr;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="阿拉伯数字转罗马数字">阿拉伯数字转罗马数字</h3><h4 id="题目描述-1">题目描述</h4><p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<p>把所有小数字在前的组合也作为基本数字，对应的数值表如下：</p>
<table>
<thead>
<tr>
<th>Roman Literal</th>
<th>Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>IV</td>
<td>4</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>IX</td>
<td>9</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>XL</td>
<td>40</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>XC</td>
<td>90</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>CD</td>
<td>400</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>CM</td>
<td>900</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> values[] = &#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        String[] symbols = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = num / values[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++)&#123;</span><br><span class="line">                sb.append(symbols[i]);</span><br><span class="line">                num -= values[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>罗马数字基本字符和阿拉伯数字的对应关系</p>
<table>
<thead>
<tr>
<th>Roman Literal</th>
<th>Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>1</td>
</]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximum Depth of Binary Tree二叉树的深度]]></title>
    <link href="http://blog.noobsky.com/2016/04/26/Maximum-Depth-of-Binary-Tree%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://blog.noobsky.com/2016/04/26/Maximum-Depth-of-Binary-Tree二叉树的深度/</id>
    <published>2016-04-26T07:43:33.000Z</published>
    <updated>2016-05-05T03:46:56.000Z</updated>
    <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>最直接的方式是递归方法，树的深度为左右子树深度最大值+1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法是使用广度搜索的方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth2</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">queue</span>.offer(root);</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="built_in">queue</span>.size();</span><br><span class="line">		<span class="comment">//让每一层的节点依次出队列，并把左右子节点加入队列中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">			TreeNode node = <span class="built_in">queue</span>.poll();</span><br><span class="line">			<span class="keyword">if</span>(node.left != null)&#123;</span><br><span class="line">				<span class="built_in">queue</span>.offer(node.left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(node.right != null)&#123;</span><br><span class="line">				<span class="built_in">queue</span>.offer(node.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="问题描述">问题描述</h3><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest pat]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nim Game]]></title>
    <link href="http://blog.noobsky.com/2016/04/26/Nim-Game/"/>
    <id>http://blog.noobsky.com/2016/04/26/Nim-Game/</id>
    <published>2016-04-26T03:03:39.000Z</published>
    <updated>2016-05-05T03:47:01.000Z</updated>
    <content type="html"><![CDATA[<p>今天遇到LeetCode上一道题叫Nim Game，虽然可以用程序解决，但感觉更像是一道数学题，游戏题。</p>
<h3 id="题目描述">题目描述</h3><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
<p><strong>Hint:</strong></p>
<p>If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?</p>
<p>根据题目描述可知，当n==1、2、3时，先手必赢，因为先手都可以一次性把石头移完。<br>当n==4时，先手必输，题目描述中也提到了这个，因为不管先手拿1、2、3个，对手都会拿走剩下的石头<br>当n==5，6，7，先手必赢，先手分别取走1、2、3颗石头，则后手的状态转化为n==4的情况，所以此时后手必输<br>当n==8时，无论先手第一轮拿1、2、3颗石头，下一轮后手都是转化为n==5、6、7的情况，此时先手必输。<br>当n==9,10,11，先手必赢，先手分别取走1、2、3颗石头，则后手的状态转化为n==8的情况，所以此时后手必输<br>……<br>以此类推，我们得出的结论是：<br>当数量是4的倍数时，即n % 4 == 0时，先手必输，否则先手必赢<br>有了上面的结论编写程序就很容易了，如下，但是想到上面的结论不太容易…..<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然想不到上面的数学解法，我们可以通过程序来解决<br>首先来个容易想到的递归解法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//如果不管先手拿1、2、3颗石头，后手都赢，那么先手必输</span></span><br><span class="line">       <span class="keyword">if</span>(canWinNim(n - <span class="number">1</span>) &amp;&amp; canWinNim(n - <span class="number">2</span>) &amp;&amp; canWinNim(n - <span class="number">3</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>递归解法会计算太多的重复值，可以证明程序的运行时间是指数级增长的，在LeetCode上当n==41时程序就已经超时了。<br>我们可以采用带备忘的（memoized）的方法记住已经计算过了的结果，程序如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">canWinNim2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    boolean[] dp = <span class="keyword">new</span> boolean[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = dp[<span class="number">3</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">        dp[i] = !(dp[i-<span class="number">1</span>] &amp;&amp; dp[i-<span class="number">2</span>] &amp;&amp; dp[i-<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这个程序在输入n非常大的时候，内存会超过限制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天遇到LeetCode上一道题叫Nim Game，虽然可以用程序解决，但感觉更像是一道数学题，游戏题。</p>
<h3 id="题目描述">题目描述</h3><p>You are playing the following Nim Game with your frien]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reverse String 反转字符串]]></title>
    <link href="http://blog.noobsky.com/2016/04/26/Reverse-String-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://blog.noobsky.com/2016/04/26/Reverse-String-反转字符串/</id>
    <published>2016-04-26T01:41:43.000Z</published>
    <updated>2016-05-05T03:47:07.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Write a function that takes a string as input and returns the string reversed.</p>
<p><strong>Example:</strong><br>Given s = “hello”, return “olleh”.</p>
<p>首先我想到的思路是将输入字符串转换为char数组，然后将字符反转最后返回字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] temp = s.toCharArray();</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temp.length-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者不借助StringBuffer或StringBuilder的帮忙。<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        char[] <span class="keyword">in</span> = s.toCharArray();</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = <span class="keyword">in</span>.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</span><br><span class="line">			char temp = <span class="keyword">in</span>[<span class="built_in">left</span>];</span><br><span class="line">			<span class="keyword">in</span>[<span class="built_in">left</span>] = <span class="keyword">in</span>[<span class="built_in">right</span>];</span><br><span class="line">			<span class="keyword">in</span>[<span class="built_in">right</span>] = temp;</span><br><span class="line">			<span class="built_in">left</span>++;</span><br><span class="line">			<span class="built_in">right</span>--;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return <span class="keyword">new</span> <span class="built_in">String</span>(<span class="keyword">in</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是其他一些常用解法，使用byte<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        byte[] bytes = s.getBytes();</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = bytes.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</span><br><span class="line">        	byte temp = bytes[<span class="built_in">left</span>];</span><br><span class="line">        	bytes[<span class="built_in">left</span>] = bytes[<span class="built_in">right</span>];</span><br><span class="line">        	bytes[<span class="built_in">right</span>] = temp;</span><br><span class="line">        	<span class="built_in">left</span>++;</span><br><span class="line">        	<span class="built_in">right</span>--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return <span class="keyword">new</span> <span class="built_in">String</span>(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>交互两个变量值最常使用的方法是使用一个临时变量temp，还有一种比较巧妙的方法就是使用异或运算<br>比如交互变量a和b：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> = a<span class="regexp"> ^</span> b;</span><br><span class="line"><span class="title">b</span> = b<span class="regexp"> ^</span> a;</span><br><span class="line"><span class="title">a</span> = b<span class="regexp"> ^</span> a;</span><br></pre></td></tr></table></figure></p>
<p>因为异或有两个特性：</p>
<ul>
<li>一个数异或自身恒等于0，比如6^6恒等于0；</li>
<li>一个数异或0恒等于自身，比如6^0恒等于6。</li>
</ul>
<p>所以不使用临时变量的交互则代码如下：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        byte[] bytes = s.getBytes();</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = bytes.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</span><br><span class="line">        	bytes[<span class="built_in">left</span>] = (byte)(bytes[<span class="built_in">left</span>] ^ bytes[<span class="built_in">right</span>]);</span><br><span class="line">        	bytes[<span class="built_in">right</span>] = (byte)(bytes[<span class="built_in">left</span>] ^ bytes[<span class="built_in">right</span>]);</span><br><span class="line">        	bytes[<span class="built_in">left</span>] = (byte)(bytes[<span class="built_in">left</span>] ^ bytes[<span class="built_in">right</span>]);</span><br><span class="line">        	<span class="built_in">left</span>++;</span><br><span class="line">        	<span class="built_in">right</span>--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return <span class="keyword">new</span> <span class="built_in">String</span>(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实自己不够熟悉StringBuffer或StringBuilder的api，既然想到用它们，就应该想起它们都有reverse方法，所以代码so easy：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String reverseString(String s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer(s).<span class="keyword">reverse</span>().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后也可以使用递归的方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        String leftString = s.substring(<span class="number">0</span>, length &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        String rightString = s.substring(length &gt;&gt; <span class="number">2</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverseString(leftString) + reverseString(rightString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Write a function that takes a string as input and returns the string reversed.</p>
<p><strong>Example:</strong><br]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <link href="http://blog.noobsky.com/2016/04/18/Java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://blog.noobsky.com/2016/04/18/Java序列化/</id>
    <published>2016-04-18T12:53:50.000Z</published>
    <updated>2016-04-18T12:53:50.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java注解]]></title>
    <link href="http://blog.noobsky.com/2016/04/17/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://blog.noobsky.com/2016/04/17/Java注解/</id>
    <published>2016-04-17T03:07:37.000Z</published>
    <updated>2016-04-30T04:32:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="注解（Annotation）的工作方式">注解（Annotation）的工作方式</h3><p>Java5.0提供了一个正式的注解（Annotation）功能：允许开发者定义、使用自己的注解类型。此功能由一个定义注解类型的语法和一个描述注解声明的语法，读取注解的API，一个使用注解修饰的class文件和一个注解处理工具组成。</p>
<p>注解并不直接影响程序代码的语义，但是它工作的方式被看作类似程序的工具或者类库，他会反过来对正在运行的程序语义有所影响。</p>
<p>注解可以从源文件、class文件或者以在运行时反射的多种方式被读取。</p>
<h3 id="Java内置注解">Java内置注解</h3><ul>
<li>@Override注解</li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang</span><br><span class="line">Annotation <span class="keyword">Type</span> <span class="keyword">Override</span></span><br><span class="line">@Target(value=<span class="function"><span class="keyword">METHOD</span>)</span><br><span class="line">@<span class="title">Retention</span><span class="params">(value=SOURCE)</span></span><br><span class="line"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Override</span></span></span><br></pre></td></tr></table></figure>
<p>表示一个方法声明将重写父类中声明的一个方法。如果方法使用此注解类型进行注解但没有重写父类中的方法，则编译器会生成一条错误信息。</p>
<p>@Override注解表示子类要重写父类中对应的方法，它是一个Marker Annotation，用于标识Annotation，Annotation名称本身表示了要给工具程序的信息。<br>@Override注解非常常见，比如：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OverrideTest</span> &#123;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is OverrideTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">        OverrideTest test = <span class="keyword">new</span> OverrideTest();</span><br><span class="line">        System.<span class="keyword">out</span>.println(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>@Deprecated注解</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang</span><br><span class="line">Annotation <span class="keyword">Type</span> Deprecated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Retention(<span class="keyword">value</span>=RUNTIME)</span><br><span class="line">@<span class="type">Target</span>(<span class="keyword">value</span>=&#123;CONSTRUCTOR,FIELD,LOCAL_VARIABLE,METHOD,PACKAGE,<span class="type">PARAMETER</span>,<span class="keyword">TYPE</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> @<span class="keyword">interface</span> Deprecated</span><br></pre></td></tr></table></figure>
<p>用@Deprecated注解的程序元素，是不鼓励程序员使用的，通常是因为它存在危险或存在更好的选择。在使用deprecated的程序元素或在非deprecated代码中重写它，编译器会发出警告。</p>
<p>@Deprecated注解表示某个方法已经不建议使用，即该方法是过时的。Deprecated也是个 Marker annotation。下面是使用@Deprecated注解的例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeprecatedTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Deprecated</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">        DeprecatedTest test = <span class="keyword">new</span> DeprecatedTest();</span><br><span class="line">        test.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>@SuppressWarnings注解</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang</span><br><span class="line">Annotation <span class="keyword">Type</span> SuppressWarnings</span><br><span class="line">@<span class="type">Target</span>(<span class="keyword">value</span>=&#123;<span class="keyword">TYPE</span>,FIELD,METHOD,<span class="type">PARAMETER</span>,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(<span class="keyword">value</span>=SOURCE)</span><br><span class="line"><span class="keyword">public</span> @<span class="keyword">interface</span> SuppressWarnings</span><br></pre></td></tr></table></figure>
<p>表明应该在注解元素（以及包含在该注解元素中的所有程序元素）中取消显示指定的编译器警告。注意，在给定元素中取消显示的警告集是所有包含元素中取消显示的警告的超集。例如，如果注解一个类来取消显示某个警告，同时注解一个方法来取消显示另一个警告，那么将在此方法中同时取消显示这两个警告。<br>根据风格不同，程序员应该始终在最里层的嵌套元素上使用此注解，在那里使用才有效。如果要在特定的方法中取消显示某个警告，则应该注解该方法而不是注解它的类。</p>
<p>@SuppressWarnings注解表示抑制警告。下面是一个使用@SuppressWarnings注解的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SuppressWarningsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;<span class="string">"unchecked"</span>, <span class="string">"deprecation"</span>&#125;)</span><br><span class="line">    public static <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)&#123;</span><br><span class="line">        <span class="built_in">Map</span> map = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        map.put(<span class="string">"hello"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">        System.out.println(map.get(<span class="string">"hello"</span>));</span><br><span class="line">        <span class="built_in">Date</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        System.out.println(date.toLocaleString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>@SafeVarargs注解</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java<span class="class">.lang</span></span><br><span class="line">Annotation Type SafeVarargs</span><br><span class="line">@Documented</span><br><span class="line">@<span class="function"><span class="title">Retention</span><span class="params">(value=RUNTIME)</span></span></span><br><span class="line">@<span class="function"><span class="title">Target</span><span class="params">(value=&#123;CONSTRUCTOR,METHOD&#125;)</span></span></span><br><span class="line">public @interface SafeVarargs</span><br></pre></td></tr></table></figure>
<p>@SafeVarargs是标记注解，只能用于参数长度可变的方法或构造函数，且方法必须声明为static或final，否则会出现编译错误。指示没有发生与可变长度参数相关的不安全动作。如果不安全代码与不能具体化的varargs类型相关，或者与参数化的数组实例相关，那么@SafeVarargs注解用于抑制“未检查不安全代码”警告(本质上，不能具体化的类是泛型类)。@SafeVarargs注解是由JDK 7新增的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SafeVarargsTest &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; a1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        a1.add(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">        a1.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Float&gt; a2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        a2.add(<span class="keyword">new</span> Float(<span class="number">3.0</span>));</span><br><span class="line">        a2.add(<span class="keyword">new</span> Float(<span class="number">4.0</span>));</span><br><span class="line"></span><br><span class="line">        displayElements(a1, a2, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SafeVarargs</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">displayElements</span><span class="params">(T... <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T element : <span class="built_in">array</span>) &#123;</span><br><span class="line">            System.out.println(element.getClass().getName() + <span class="string">":"</span> + element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="自定义注解">自定义注解</h3><p>使用@interface自定义注解时，实际上自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。如果我们定义了一个接口,并且让该接口继承 自 Annotation,那么我们所定义的接口依然还是接口而不是注解;Annotation 本身 是接口而不是注解。可以与 Enum 类比。<br>自定义注解：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Created by Jaye on 16/4/17.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">public <span class="comment">@interface MyAnnotation &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用自定义注解：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Created</span> by <span class="type">Jaye</span> on <span class="number">16</span>/<span class="number">4</span>/<span class="number">17</span>.</span><br><span class="line"> */</span><br><span class="line">public class <span class="type">AnnotationUsage</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="type">MyAnnotation</span></span><br><span class="line">    public <span class="type">void</span> <span class="keyword">method</span>()&#123;</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"usage of annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">AnnotationUsage</span> usage = new <span class="type">AnnotationUsage</span>();</span><br><span class="line">        usage.<span class="keyword">method</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>添加变量</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> @<span class="keyword">interface</span> <span class="title">MyAnnotation</span> &#123;</span><br><span class="line">    <span class="function">String <span class="title">value1</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用自定义注解：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">AnnotationUsage</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="type">MyAnnotation</span>(value1 = <span class="string">"jaye"</span>)</span><br><span class="line">    public <span class="type">void</span> <span class="keyword">method</span>()&#123;</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"usage of annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">AnnotationUsage</span> usage = new <span class="type">AnnotationUsage</span>();</span><br><span class="line">        usage.<span class="keyword">method</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当注解中使用的属性名为value时，对其赋值时可以不指定属性的名称而直接写上属性值接口；除了value意外的变量名都需要使用name=value的方式赋值。</p>
<ul>
<li>使用默认值</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> @<span class="interface"><span class="keyword">interface</span> MyAnnotation </span>&#123;</span><br><span class="line">    <span class="built_in">String</span> value1() <span class="keyword">default</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数组变量</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> @<span class="interface"><span class="keyword">interface</span> MyAnnotation </span>&#123;</span><br><span class="line">    <span class="built_in">String</span>[] value1() <span class="keyword">default</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">AnnotationUsage</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="type">MyAnnotation</span>(value1 = &#123;<span class="string">"jaye"</span>, <span class="string">"poop"</span>&#125;)</span><br><span class="line">    public <span class="type">void</span> <span class="keyword">method</span>()&#123;</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"usage of annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">AnnotationUsage</span> usage = new <span class="type">AnnotationUsage</span>();</span><br><span class="line">        usage.<span class="keyword">method</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多变量使用枚举</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="variable">@interface</span> <span class="constant">MyAnnotation</span> &#123;</span><br><span class="line">    <span class="constant">String</span>[] value1() default <span class="string">"hello"</span>;</span><br><span class="line">    <span class="constant">EnumTest</span> value2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumTest</span>&#123;</span></span><br><span class="line">    <span class="constant">Hello</span>, <span class="constant">World</span>, <span class="constant">Welcome</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">AnnotationUsage</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="type">MyAnnotation</span>(value1 = &#123;<span class="string">"jaye"</span>, <span class="string">"poop"</span>&#125;, value2 = <span class="type">EnumTest</span>.<span class="type">Hello</span>)</span><br><span class="line">    public <span class="type">void</span> <span class="keyword">method</span>()&#123;</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"usage of annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">AnnotationUsage</span> usage = new <span class="type">AnnotationUsage</span>();</span><br><span class="line">        usage.<span class="keyword">method</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置注解的作用范围">设置注解的作用范围</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java<span class="class">.lang</span><span class="class">.annotation</span></span><br><span class="line">Annotation Type Retention</span><br><span class="line">@Documented</span><br><span class="line">@<span class="function"><span class="title">Retention</span><span class="params">(value=RUNTIME)</span></span></span><br><span class="line">@<span class="function"><span class="title">Target</span><span class="params">(value=ANNOTATION_TYPE)</span></span></span><br><span class="line">public @interface Retention</span><br></pre></td></tr></table></figure>
<p>声明注解类型的注解需要保留多久。如果注解类型声明中没有Retention注解，则保留策略默认为RetentionPolicy.CLASS。只有元注释类型直接用于注释时，Target 元注释才有效。如果元注释类型用作另一种注释类型的成员，则无效。<br>注解保留策略。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span></span></span><br><span class="line">extends <span class="constant">Enum</span>&lt;<span class="constant">RetentionPolicy</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>此枚举类型的常量描述保留注解的不同策略。它们与 Retention 元注释类型一起使用，以指定保留多长的注解。</p>
<p><strong>CLASS:</strong> 编译器将注解类型记录在class文件中，但运行时VM不保留注解<br><strong>RUNTIME:</strong> 编译器把注解类型记录在class文件中，而且运行时VM将保留注解，因此可以利用反射机制读取。<br><strong>SOURCE:</strong> 编译器将丢弃注解</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.annotation.Retention;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">MyAnnotation2</span> </span>&#123;</span><br><span class="line">    String hello() <span class="keyword">default</span> <span class="string">"hellojaye"</span>;</span><br><span class="line">    String world();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用反射读取RUNTIME保留策略的注解信息">使用反射读取RUNTIME保留策略的注解信息</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect</span><br><span class="line"><span class="keyword">Interface</span> AnnotatedElement</span><br><span class="line"></span><br><span class="line">All Known Implementing Classes:</span><br><span class="line">AccessibleObject, <span class="keyword">Class</span>, <span class="function"><span class="keyword">Constructor</span>, <span class="title">Field</span>, <span class="title">Method</span>, <span class="title">Package</span></span></span><br></pre></td></tr></table></figure>
<p>表示目前正在此 VM 中运行的程序的一个已注解元素。该接口允许通过反射机制读取注解。由此接口中的方法返回的所有注解都是不可变并且可序列化的。调用者可以修改已赋值数组枚举成员的访问器返回的数组；这不会对其他调用者返回的数组产生任何影响。<br>如果此接口中的方法返回的注解（直接或间接地）包含一个已赋值的 Class 成员，该成员引用了一个在此 VM 中不可访问的类，则试图通过在返回的注解上调用相关的类返回的方法来读取该类，将导致一个 TypeNotPresentException。</p>
<p>类似地，如果注释中的枚举常量不再以枚举类型存在，那么试图读取一个已赋值的枚举成员将导致一个 EnumConstantNotPresentException。</p>
<p>最后，读取其定义已经引起不兼容性的成员将导致 AnnotationTypeMismatchException 或 IncompleteAnnotationException。<br>自定义注解：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.annotation.Retention;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">MyAnnotation2</span> </span>&#123;</span><br><span class="line">    String hello() <span class="keyword">default</span> <span class="string">"hellojaye"</span>;</span><br><span class="line">    String world();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用自定义注解：<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">@MyAnnotation2</span>(hello = <span class="string">"beijing"</span>, world = <span class="string">"haidian"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@MyAnnotation2</span>(hello = <span class="string">"poop"</span>, world = <span class="string">"jaye"</span>)</span><br><span class="line">    <span class="keyword">@Deprecated</span></span><br><span class="line">    <span class="keyword">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> output()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"output something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用反射获取注解信息：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.<span class="type">Annotation</span>;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="type">Method</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * <span class="type">Created</span> by <span class="type">Jaye</span> on <span class="number">16</span>/<span class="number">4</span>/<span class="number">17</span>.</span><br><span class="line"> */</span><br><span class="line">public class <span class="type">MyReflection</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) throws <span class="type">Exception</span>&#123;</span><br><span class="line">        <span class="type">MyTest</span> myTest = new <span class="type">MyTest</span>();</span><br><span class="line">        //获取<span class="type">MyTest2</span>的<span class="type">Class</span>实例</span><br><span class="line">        <span class="type">Class</span>&lt;<span class="type">MyTest</span>&gt; cls = <span class="type">MyTest</span>.class;</span><br><span class="line">        //获取待处理方法的<span class="type">Method</span>实例</span><br><span class="line">        <span class="type">Method</span> <span class="keyword">method</span> = cls.getMethod(<span class="string">"output"</span>, new <span class="type">Class</span>[]&#123;&#125;);</span><br><span class="line">        //判断该方法是否包含<span class="type">MyAnnotation2</span>注解</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">method</span>.isAnnotationPresent(<span class="type">MyAnnotation2</span>.class))&#123;</span><br><span class="line">            //执行方法</span><br><span class="line">            <span class="keyword">method</span>.invoke(myTest, new <span class="type">Object</span>[]&#123;&#125;);</span><br><span class="line">            //获取方法的<span class="type">MyAnnotation2</span>的注解实例</span><br><span class="line">            <span class="type">MyAnnotation2</span> myAnnotation2 = <span class="keyword">method</span>.getAnnotation(<span class="type">MyAnnotation2</span>.class);</span><br><span class="line">            <span class="type">String</span> hello = myAnnotation2.hello();</span><br><span class="line">            <span class="type">String</span> world = myAnnotation2.world();</span><br><span class="line"></span><br><span class="line">            <span class="type">System</span>.<span class="keyword">out</span>.println(hello + <span class="string">","</span> + world);</span><br><span class="line">            //获取方法上的所有注解</span><br><span class="line">            <span class="type">Annotation</span>[] annotations = <span class="keyword">method</span>.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">Annotation</span> annotation : annotations)&#123;</span><br><span class="line">                <span class="type">System</span>.<span class="keyword">out</span>.println(annotation.annotationType().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序输出：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output something</span><br><span class="line">poop,jaye</span><br><span class="line">com<span class="class">.jaye</span><span class="class">.annotation</span><span class="class">.MyAnnotation2</span></span><br><span class="line">java<span class="class">.lang</span><span class="class">.Deprecated</span></span><br></pre></td></tr></table></figure></p>
<h3 id="限定注解的使用">限定注解的使用</h3><p>限定注解对象使用@Target<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ava<span class="class">.lang</span><span class="class">.annotation</span></span><br><span class="line">Annotation Type Target</span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@<span class="function"><span class="title">Retention</span><span class="params">(value=RUNTIME)</span></span></span><br><span class="line">@<span class="function"><span class="title">Target</span><span class="params">(value=ANNOTATION_TYPE)</span></span></span><br><span class="line">public @interface Target</span><br></pre></td></tr></table></figure></p>
<p>指示注解类型所适用的程序元素的种类。如果注解类型声明中不存在 Target 元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注解，则编译器强制实施指定的使用限制。 例如，此元注解指示该声明类型是其自身，即元注解类型。它只能用在注解类型声明上：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span></span></span><br><span class="line">extends <span class="constant">Enum</span>&lt;<span class="constant">ElementType</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>程序元素类型。此枚举类型的常量提供了 Java 程序中声明的元素的简单分类。<br>这些常量与 Target 元注解类型一起使用，以指定在什么情况下使用注解类型是合法的。枚举常量如下：</p>
<p><strong>ANNOTATION_TYPE:</strong> 注解类型声明<br><strong>CONSTRUCTOR:</strong> 构造方法声明<br><strong>FIELD:</strong> 字段声明（包括枚举常量）<br><strong>LOCAL_VARIABLE:</strong> 局部变量声明<br><strong>METHOD:</strong> 方法声明<br><strong>PACKAGE:</strong> 包声明<br><strong>PARAMETER:</strong> 参数声明<br><strong>TYPE:</strong> 类、接口（包括注释类型）或枚举声明</p>
<p>例子如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Created by Jaye on 16/4/17.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@Target(ElementType.METHOD)</span></span><br><span class="line">public <span class="comment">@interface MyTarget &#123;</span></span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在帮助文档中加入注解">在帮助文档中加入注解</h3><p>要想在制作JavaDoc文件的同时将注解信息加入到API文件中，可以使用java.lang.annotation.Documented。<br>在自定义注解中声明构建注解文档：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.annotation.Documented;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line">@Documented</span><br><span class="line"><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">DocumentedAnnotation</span> </span>&#123;</span><br><span class="line">    String hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">DocumentedTest</span></span><br><span class="line">&#123;</span><br><span class="line">	@<span class="type">DocumentedAnnotation</span>(hello = <span class="string">"welcome"</span>)</span><br><span class="line">	public <span class="type">void</span> <span class="keyword">method</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"hello world"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在注解中使用继承：">在注解中使用继承：</h3><p>默认情况下注解并不会被继承到子类中，可以在自定义注解时加上java.lang.annotation.Inherited注解声明使用继承。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java<span class="class">.lang</span><span class="class">.annotation</span></span><br><span class="line">Annotation Type Inherited</span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@<span class="function"><span class="title">Retention</span><span class="params">(value=RUNTIME)</span></span></span><br><span class="line">@<span class="function"><span class="title">Target</span><span class="params">(value=ANNOTATION_TYPE)</span></span></span><br><span class="line">public @interface Inherited</span><br></pre></td></tr></table></figure></p>
<p>表示注解类型被自动继承。如果在注解类型声明中存在 Inherited 元注释，并且用户在某一类声明中查询该注解类型，同时该类声明中没有此类型的注解，则将在该类的父类中自动查询该注解类型。此过程会重复进行，直到找到此类型的注解或到达了该类层次结构的顶层 (Object) 为止。如果没有父类具有该类型的注解，则查询将指示当前类没有这样的注解。<br>注意，如果使用注解类型注解类以外的任何事物，此元注解类型都是无效的。还要注意，此元注解仅促成从父类继承注解；对已实现接口的注解无效。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="注解（Annotation）的工作方式">注解（Annotation）的工作方式</h3><p>Java5.0提供了一个正式的注解（Annotation）功能：允许开发者定义、使用自己的注解类型。此功能由一个定义注解类型的语法和一个描述注解声明的语法，读取注解的A]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="注解" scheme="http://blog.noobsky.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/categories/Java/"/>
    
  </entry>
  
</feed>
