<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-06-17T01:21:55.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximal Square And Maximal Rectangle]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Maximal-Square-And-Maximal-Rectangle/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Maximal-Square-And-Maximal-Rectangle/</id>
    <published>2016-06-16T13:30:34.000Z</published>
    <updated>2016-06-17T01:21:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return its area.</p>
<p>For example, given the following matrix:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Return 4.</p>
<h2 id="代码">代码</h2><p>使用动态规划方法，状态转移方程如下。</p>
<p>dp[i][j]表示在点matrix[i][j]最大的正方形的边长：</p>
<p>边界情况：<br>dp[i][j] = matrix[i][j], i=0 or j = 0</p>
<p>非边界(i &gt; 0, j &gt; 0)：<br>if matrix[i][j] == 0: dp[i][j] = 0, i &gt; 0, j &gt; 0<br>if matrix[i][j] == 1: 那么dp[i][j]由左边、上方、左上方的dp决定<br>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</p>
<p>根据上面的状态转移方程，我们不难得出以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//dp[i][j]表示在点matrix[i][j]最大的正方形的边长</span></span><br><span class="line">    <span class="comment">//边界：dp[i][j] = matrix[i][j], i=0 or j = 0</span></span><br><span class="line">    <span class="comment">//if matrix[i][j] == 0: dp[i][j] = 0, i &gt; 0, j &gt; 0</span></span><br><span class="line">    <span class="comment">//if matrix[i][j] == 1: 那么dp[i][j]由左边、上方、左上方的dp决定</span></span><br><span class="line">    <span class="comment">//dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="comment">//i == 0 || j == 0是边界情况</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//可以不写，java默认初始化为0</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新最长边长</span></span><br><span class="line">                maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码更简洁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//其实几个if-else也可以合并起来，代码更简洁一些，想不到也没关系，上面的代码可读性更好</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return its area.<]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Summary Ranges And Missing Ranges]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Summary-Ranges-And-Missing-Ranges/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Summary-Ranges-And-Missing-Ranges/</id>
    <published>2016-06-16T11:13:28.000Z</published>
    <updated>2016-06-16T12:37:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”].</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//找到每一个连续期间</span></span><br><span class="line">    <span class="comment">//使用for循环遍历数组，对每一个元素不断与右边的元素相比较，如果相差为1则还是同一个连续区间，</span></span><br><span class="line">    <span class="comment">//下标i++，直到与右边元素之差不唯一则找到了一个连续区间</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; summaryRanges(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span> &lt; nums.length &amp;&amp; nums[i+<span class="number">1</span>] - nums[i] == <span class="number">1</span>) i++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i] != temp)&#123;</span><br><span class="line">                res.add(temp + <span class="string">"-&gt;"</span> + nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(temp+<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目描述-1">题目描述</h2><p>Given a sorted integer array where the range of elements are [0, 99] inclusive, return its missing ranges.<br>For example, given [0, 1, 3, 50, 75], return [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”]</p>
<p>You should be able to extend the above cases not only for the range [0,99], but any arbitrary range [start, end].</p>
<h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; getMissingRanges(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        List&lt;String&gt; ranges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> prev = start - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = (i == nums.length) ? end + <span class="number">1</span> : nums[i];</span><br><span class="line">            <span class="keyword">if</span>(curr - prev &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ranges.add(getRange(prev + <span class="number">1</span>, curr - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ranges;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getRange</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from == to ? String.valueOf(from) : from + <span class="string">"-&gt;"</span> + to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given [0,1,]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Coin Change]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Coin-Change/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Coin-Change/</id>
    <published>2016-06-16T09:47:26.000Z</published>
    <updated>2016-06-16T11:01:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p><strong> Example 1: </strong><br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>
<p><strong> Example 2: </strong><br>coins = [2], amount = 3<br>return -1.</p>
<p><strong> Note: </strong><br>You may assume that you have an infinite number of each kind of coin.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//dp[i]表示组合成总额为i需要的最少的硬币数量</span></span><br><span class="line">    <span class="comment">//dp[i] = min(dp[i-coins[j]] + 1), coins[j] &lt;= i, 0 &lt;= j &lt; coins.length</span></span><br><span class="line">    <span class="comment">//返回dp[i]即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化为最大值为amount+1，总额为amount至多需要硬币amount个硬币</span></span><br><span class="line">        <span class="comment">//不能初始化为Integer.MAX_VALUE，因为状态转移方程有dp[i] + 1，会溢出:( </span></span><br><span class="line">        <span class="comment">//Arrays.fill(dp, Integer.MAX_VALUE);</span></span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= amount; i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = 0; j &lt; coins.length; j++)&#123;</span></span><br><span class="line">        <span class="comment">//         if(coins[j] &lt;= i)&#123;</span></span><br><span class="line">        <span class="comment">//             dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin: coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt;= amount; i++)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法时间复杂度为O(n*amount)，空间复杂度为O(amount)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sqrt(x)]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Sqrt-x/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Sqrt-x/</id>
    <published>2016-06-16T06:43:38.000Z</published>
    <updated>2016-06-16T06:50:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
<h2 id="代码">代码</h2><p>使用二分搜索，方法简单写对也不容易啊:)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">    <span class="comment">//0到x甚至x/2中二分搜索吧</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//除法能防止溢出，mid*mid&gt;x会溢出</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x/mid) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//除法是有取整的，需要注意</span></span><br><span class="line">                <span class="keyword">if</span> (mid + <span class="number">1</span> &gt; x/(mid + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种写法</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> mySqrt(<span class="built_in">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) return x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span>, <span class="built_in">right</span> = x;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (<span class="built_in">right</span> - <span class="built_in">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">mid</span> &lt;= x/<span class="built_in">mid</span>)&#123;</span><br><span class="line">                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">right</span> = <span class="built_in">mid</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return <span class="built_in">left</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
<h2 id="代码">代码</h2><p>使用二分搜索，方法简单写对]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Count Complete Tree Nodes]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Count-Complete-Tree-Nodes/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Count-Complete-Tree-Nodes/</id>
    <published>2016-06-16T05:32:03.000Z</published>
    <updated>2016-06-16T06:10:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a complete binary tree, count the number of nodes.</p>
<p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<h2 id="代码">代码</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//树的通用做法超时啦:)</span></span><br><span class="line">    <span class="comment">// public int countNodes(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return 0;</span></span><br><span class="line">    <span class="comment">//     return 1 + countNodes(root.left) + countNodes(root.right);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们可以改进一下，因为完全二叉树除了最后一层节点都是满，最后一层的节点都集中在最左边</span></span><br><span class="line">    <span class="comment">//我们利用完全二叉树的性质对上面的程序进行优化，如果该（子）树是满二叉树，</span></span><br><span class="line">    <span class="comment">//这里满二叉树是指的最后一层的节点也是满，我们就不递归直接利用公式进行计算,满二叉树的节点个数为2的height次方-1</span></span><br><span class="line">    <span class="comment">//否则才进行递归递归计算</span></span><br><span class="line">    <span class="comment">//（满二叉树的正式定义不是这样的。）</span></span><br><span class="line">    <span class="comment">//时间复杂度也是O(n)</span></span><br><span class="line">    <span class="keyword">public</span> int countNodes(<span class="type">TreeNode</span> root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">left</span> = root, <span class="keyword">right</span> = root;</span><br><span class="line">        int height = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">right</span> != null)&#123;</span><br><span class="line">            <span class="keyword">left</span> = <span class="keyword">left</span>.<span class="keyword">left</span>;</span><br><span class="line">            <span class="keyword">right</span> = <span class="keyword">right</span>.<span class="keyword">right</span>;</span><br><span class="line">            height++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span> == null) <span class="comment">//如果当right == null时，left == null，说明二叉树是满的</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; height) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//不是满二叉树，递归计算</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.<span class="keyword">left</span>) + countNodes(root.<span class="keyword">right</span>);</span><br><span class="line">        <span class="comment">//其实可以改为</span></span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//求完全二叉树的层数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">level</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> root == null ? <span class="number">0</span> : level(root.left) + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> level = level(root);</span><br><span class="line">         <span class="keyword">if</span>(level == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//右子树比整棵树少一层说明左子树和右子树有相同的层数，并且左子树是层数为level-1的满二叉树</span></span><br><span class="line">         <span class="comment">//右子树不一定（最后的节点在右子树上），</span></span><br><span class="line">         <span class="comment">//则利用公式计算左子树的节点数为2的(level-1)次方-1再加上根节点的话就是2的(level-1)次方</span></span><br><span class="line">         <span class="comment">//如果右子树不是比整棵树少一层说明，则最后的节点在左子树上，右子树是层数为level-2的满二叉树</span></span><br><span class="line">         <span class="comment">//则右子树的节点数为2的(level-2)次方-1加上根节点就是2的(level-2)次方</span></span><br><span class="line">         <span class="keyword">return</span> level(root.right) == level - <span class="number">1</span> ? (<span class="number">1</span> &lt;&lt; (level - <span class="number">1</span>)) + countNodes(root.right)</span><br><span class="line">                : (<span class="number">1</span> &lt;&lt; (level - <span class="number">2</span>)) + countNodes(root.left);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用的是统计层数来判断左右子树是否有相同层数，我们也可以用数的高度来求，也是类似的，这里顺便提一下树的高度的定义为：</p>
<p>Height of node:<br>The height of a node is the number of edges on the longest path between that node and a leaf.<br>Height of tree:<br>The height of a tree is the height of its root node.</p>
<p>所以只有一个节点的树的高度为0，但是层数为1。用高度来统计的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == null ? -<span class="number">1</span> : <span class="number">1</span> + height(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = height(root);</span><br><span class="line">        <span class="keyword">return</span> h &lt; <span class="number">0</span> ? <span class="number">0</span> :</span><br><span class="line">               height(root.right) == h-<span class="number">1</span> ? (<span class="number">1</span> &lt;&lt; h) + countNodes(root.right)</span><br><span class="line">                                         : (<span class="number">1</span> &lt;&lt; h-<span class="number">1</span>) + countNodes(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a complete binary tree, count the number of nodes.</p>
<p>Definition of a complete binary tree from Wikipedi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Word Break]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Word-Break/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Word-Break/</id>
    <published>2016-06-16T01:17:42.000Z</published>
    <updated>2016-06-16T02:06:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p>
<p>Return true because “leetcode” can be segmented as “leet code”.</p>
<h2 id="代码">代码</h2><p>直接递归发，超时:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || wordDict.contains(s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wordBreak(s.substring(<span class="number">0</span>, i), wordDict) &amp;&amp; wordBreak(s.substring(i, s.length()), wordDict))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用dp解决，dp[i]表示s[0]到s[i-1]中的子字符串能用字典中的词表示, 0&lt;= i &lt;= s.length()，dp[i] = dp[j] + wordDict.contains(s.substring(j, i)), 0&lt;= j &lt; i。最后返回dp[s.length()]即可。代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//dp[i]表示s[0]到s[i-1]中的子字符串能用字典中的词表示, 0&lt;= i &lt;= s.length()</span></span><br><span class="line">    <span class="comment">//dp[i] = dp[j] + wordDict.contains(s.substring(j, i)), 0&lt;= j &lt; i</span></span><br><span class="line">    <span class="comment">//返回dp[s.length()]即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        boolean[] dp = <span class="keyword">new</span> boolean[s.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; wordDict.contains(s.substring(j, i)))&#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence o]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Repeated DNA Sequences]]></title>
    <link href="http://blog.noobsky.com/2016/06/15/LeetCode-Repeated-DNA-Sequences/"/>
    <id>http://blog.noobsky.com/2016/06/15/LeetCode-Repeated-DNA-Sequences/</id>
    <published>2016-06-15T13:44:51.000Z</published>
    <updated>2016-06-15T15:45:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>
<p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>
<p>For example,</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">Given</span> <span class="atom">s</span> = <span class="string">"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"</span>,</span><br><span class="line"></span><br><span class="line"><span class="name">Return</span>:</span><br><span class="line">[<span class="string">"AAAAACCCCC"</span>, <span class="string">"CCCCCAAAAA"</span>].</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2><p>这里只有四种不同的字符，A、C、G、T，所以只需2 bits就能表示，而且题目让我们找出长度为10的重复序列(substrings)。10*2 = 20 &lt; 32，所以我们只需一个int类型就能代表这些长度为10的子字符串。然后我们用朴素的字符串匹配算法，将字符串表示为整数，然后利用集合来排重。这里要求找大于一次的子字符串，我们使用两个集合，当子字符串不能加入第一个集合说明该子字符串出现了大于等于2次，然后加入第二个集合排重。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// 这里只有四种不同的字符，A、C、G、T，所以只需2 bits就能表示，而且题目让我们找出长度为10的重复序列(substrings)</span></span><br><span class="line">    <span class="comment">// 10*2 = 20 &lt; 32，所以我们只需一个int类型就能代表这些长度为10的子字符串。然后我们用朴素的字符串匹配算法，将字符串</span></span><br><span class="line">    <span class="comment">// 表示为整数，然后利用集合来排重。这里要求找大于一次的子字符串，我们使用两个集合，当子字符串不能加入第一个集合说明</span></span><br><span class="line">    <span class="comment">// 该子字符串出现了大于等于2次，然后加入第二个集合排重。</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; findRepeatedDnaSequences(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null &amp;&amp; s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        Set&lt;Integer&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; doubleWords = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//字母对应的二进制表示 00, 01, 10,11</span></span><br><span class="line">        <span class="keyword">char</span>[] <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">'A'</span> - <span class="string">'A'</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">'C'</span> - <span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">'G'</span> - <span class="string">'A'</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">'T'</span> - <span class="string">'A'</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//使用朴素的字符串匹配算法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//将每个长度为10的子字符串用一个整数来表示</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; i+<span class="number">10</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//每次左移两比特位，对应一个字符</span></span><br><span class="line">                temp &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">                temp |= <span class="built_in">map</span>[s.charAt(j) - <span class="string">'A'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不能加入第一个集合，说明这个子字符串出现了大于一次，符合条件，</span></span><br><span class="line">            <span class="comment">//然后使用第二个集合来排重，看这个符合条件的子字符串是否已经加入过结果集中了</span></span><br><span class="line">            <span class="comment">//还挺tricky的:)</span></span><br><span class="line">            <span class="keyword">if</span>(!words.add(temp) &amp;&amp; doubleWords.add(temp))&#123;</span><br><span class="line">                res.add(s.substring(i, i+<span class="number">10</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When stud]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Minimum Size Subarray Sum]]></title>
    <link href="http://blog.noobsky.com/2016/06/15/LeetCode-Minimum-Size-Subarray-Sum/"/>
    <id>http://blog.noobsky.com/2016/06/15/LeetCode-Minimum-Size-Subarray-Sum/</id>
    <published>2016-06-15T11:41:36.000Z</published>
    <updated>2016-06-15T12:33:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>For example, given the array [2,3,1,2,4,3] and s = 7,<br>the subarray [4,3] has the minimal length under the problem constraint.</p>
<p><strong> More practice: </strong><br>If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</p>
<h2 id="代码">代码</h2><p>维护两个索引指针left和right，初始时两个指针指向数组首元素(下标0)，然后right往右移动，并将right指针遇到的元素求sum。当sum &gt;= s时，也就是找到了子数组和大于等于s的子数组，更新最小的子数组长度minLen,然后从sum中减去left指针指向的数组元素，接着left指针往右移动，只要sum还大于等于s，继续减去left指向元素，更新最小的子数组长度，直到sum &lt; s时内层while结束，ringt指针继续往右移动进行下一次循环。每执行一次外层while循环，其实是找到里以nums[right]结尾的且子数组和大于等于s的所以子数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// 维护两个索引指针left和right，初始时两个指针指向数组首元素(下标0)，然后right往右移动，并将right指针遇到的元素求sum</span></span><br><span class="line">    <span class="comment">// 当sum &gt;= s时，也就是找到了子数组和大于等于s的子数组，更新最小的子数组长度minLen,</span></span><br><span class="line">    <span class="comment">// 然后从sum中减去left指针指向的数组元素，接着left指针往右移动，只要sum还大于等于s，继续减去left指向元素</span></span><br><span class="line">    <span class="comment">// 则更新最小的子数组长度，直到sum &lt; s时内层while结束，ringt指针继续往右移动进行下一次循环</span></span><br><span class="line">    <span class="comment">// 每执行一次外层while循环，其实是找到里以nums[right]结尾的且子数组和大于等于s的所以子数组。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始时left和right指向数组首元素</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//该循环不会让left大于right，因为当left==right - 1时sum为0，题目说了s为正数</span></span><br><span class="line">        <span class="comment">//不用加left&lt;=right-1</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.length)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            right++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//出现了子数组和大于等于s的子数组</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">                <span class="comment">//跟新minLen</span></span><br><span class="line">                minLen = Math.min(minLen, right - left);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法right从左往右遍历一遍，left指针也从左往右遍历一遍，所以时间复杂度为O(2n) = O(n)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Majority Element I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/15/LeetCode-Majority-Element-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/15/LeetCode-Majority-Element-I-II/</id>
    <published>2016-06-15T08:00:45.000Z</published>
    <updated>2016-06-15T11:52:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Majority_Element_I">Majority Element I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and <font color="red">the majority element always exist in the array</font>.</p>
<h3 id="代码">代码</h3><p>比较常规的解法有使用HashMap计数，可以在线性时间解决，但是需要额外的内存，如果有内存限制则改方法不可取；也可以使用排序的方法，排序后出现次数超过一半的元素肯定在中间，直接返回即可。还可以使用位操作，建立一个大小为32的数组，将原数组每个数字的每位为1的数量存入这个数组。因为majorit element的数量超过一半，那么1的数量大于一半的一定是majori element的1，0的数量大于一半的，也一定是majori elemen的0。如此还原出那个majori elemen。该题最好的解法是使用摩尔投票算法，关于该算法详见维基百科<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm" target="_blank" rel="external">Boyer–Moore majority vote algorithm</a>。算法的主要思想是使用变量candidate表示当前候选众数和计数器count，从头遍历数组，如果当前数组元素与candidate相等，计算器count++。如果不相等且count等于0，将candidate置为当前元素且设置count为1；否则count–。</p>
<p>使用摩尔投票算法代码如下：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> majorityElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//自己的想法</span></span><br><span class="line">        <span class="comment">// if(nums == null || nums.length == 0) return -1;</span></span><br><span class="line">        <span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">        <span class="comment">// return nums[nums.length/2];</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>, candidate = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">count</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">count</span>++;</span><br><span class="line">                candidate = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate)&#123;</span><br><span class="line">                <span class="keyword">count</span>++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">count</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用摩尔投票算法选出的候选元素不一定是出现次数超过一半的元素，比如数组[1, 2, 3, 4, 5]返回5，我们应该在遍历一遍数组确认候选元素是否真的是出现次数超过一半的元素。但是题目中已经假设majority element肯定存在了，就不用检查了。</p>
<h2 id="Majority_Element_II">Majority Element II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.</p>
<p><strong> Hint: </strong></p>
<p>How many majority elements could it possibly have?</p>
<h3 id="代码-1">代码</h3><p>出现次数超过⌊ n/3 ⌋的元素小于等于2，我们稍微修改一下上面的摩尔投票算法，维护两个candidate和count，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//超过n/3的元素个数少于等于2</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; majorityElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> candidate1 = nums[<span class="number">0</span>], candidate2 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//这种写法当测试用例为[8,8,7,7,7]时不能通过</span></span><br><span class="line">            <span class="comment">// if(count1 == 0)&#123;</span></span><br><span class="line">            <span class="comment">//     candidate1 = nums[i];</span></span><br><span class="line">            <span class="comment">//     count1 = 1;</span></span><br><span class="line">            <span class="comment">// &#125;else if(count2 == 0)&#123;</span></span><br><span class="line">            <span class="comment">//     candidate2 = nums[i];</span></span><br><span class="line">            <span class="comment">//     count2 = 1;</span></span><br><span class="line">            <span class="comment">// &#125;else if(nums[i] == candidate1)&#123;</span></span><br><span class="line">            <span class="comment">//     count1++;</span></span><br><span class="line">            <span class="comment">// &#125;else if(nums[i] == candidate2)&#123;</span></span><br><span class="line">            <span class="comment">//     count2++;</span></span><br><span class="line">            <span class="comment">// &#125;else&#123;</span></span><br><span class="line">            <span class="comment">//     count1--;</span></span><br><span class="line">            <span class="comment">//     count2--;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count1 == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate1 = nums[i];</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count2 == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate2 = nums[i];</span><br><span class="line">                count2 = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count1 &gt; nums.length / <span class="number">3</span>) res.add(candidate1);</span><br><span class="line">        <span class="keyword">if</span>(count2 &gt; nums.length / <span class="number">3</span>) res.add(candidate2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是如果几个if-else写成如下形式不能AC：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(count1 == <span class="number">0</span>)&#123;</span><br><span class="line">	candidate1 = nums[i];</span><br><span class="line">	count1 = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(count2 == <span class="number">0</span>)&#123;</span><br><span class="line">	candidate2 = nums[i];</span><br><span class="line">	count2 = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">	count1++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">	count2++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	count1--;</span><br><span class="line">	count2--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当测试用例为[8, 8, 7, 7, 7]，正确答案为[8, 7]，但是程序只返回[7]。第一次循环时，因count1 == 0，则candidate1 = 8，count1 = 1；第二次循环时， 因count2 = 0，则candidate2 = 8，count2 = 1；第三次循环时，nums[2] == 7，count1–后为0，count2–后为0，第四、五次循环分别把candidate1和candidate2设置为7，所以最后统计时只有7。</p>
<h2 id="参考文献">参考文献</h2><p><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm" target="_blank" rel="external">Boyer–Moore majority vote algorithm</a><br><a href="http://www.geeksforgeeks.org/majority-element/" target="_blank" rel="external">Majority Element</a><br><a href="http://www.cs.utexas.edu/users/misra/scannedPdf.dir/FindRepeatedElements.pdf" target="_blank" rel="external">Finding Repeated Elements</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Majority_Element_I">Majority Element I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of size n, find the majority element. The majori]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Gas Station]]></title>
    <link href="http://blog.noobsky.com/2016/06/15/LeetCode-Gas-Station/"/>
    <id>http://blog.noobsky.com/2016/06/15/LeetCode-Gas-Station/</id>
    <published>2016-06-15T00:48:25.000Z</published>
    <updated>2016-06-15T05:06:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with <font color="red">an unlimited gas tank</font> and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p><strong> Note: </strong><br>The solution is guaranteed to be unique.</p>
<h2 id="代码">代码</h2><p>由题意我们可以得到两个性质：</p>
<ul>
<li>如果从station A出发不能到达 station B，那么A和B之间的任意station都不能到达B。（B是A第一个不能到达的station）</li>
<li>如果全部station的gas总和大于cost的总和，那么一定存在一个solution。</li>
</ul>
<p>第一个性质的简单证明：<br>假设C为A和B之间任一的加油站，我们要证明C也不能到达B。因为A不能到达B，所以A和B之间全部station的gas的总和小于cost的总和。从A出发，当到达C的时候（B是A第一个不能到达的station，A能到C），剩下的gas &gt;= 0，仍然不能到达B。因为从A到C带来了额外的gas然后从C出发都不能到达B，所以直接从C出发更不可能到达B。</p>
<p>第二个性质的证明直接从网上找的英文证明：）</p>
<ul>
<li><p>If there is only one gas station, it’s true.</p>
</li>
<li><p>If there are two gas stations a and b, and gas(a) cannot afford cost(a), i.e., gas(a) &lt; cost(a), then gas(b) must be greater than cost(b), i.e., gas(b) &gt; cost(b), since gas(a) + gas(b) &gt; cost(a) + cost(b); so there must be a way too.</p>
</li>
<li><p>If there are three gas stations a, b, and c, where gas(a) &lt; cost(a), i.e., we cannot travel from a to b directly, then:</p>
<ul>
<li><p>either if gas(b) &lt; cost(b), i.e., we cannot travel from b to c directly, then cost(c) &gt; cost(c), so we can start at c and travel to a; since gas(b) &lt; cost(b), gas(c) + gas(a) must be greater than cost(c) + cost(a), so we can continue traveling from a to b. Key Point: this can be considered as there is one station at c’ with gas(c’) = gas(c) + gas(a) and the cost from c’ to b is cost(c’) = cost(c) + cost(a), and the problem reduces to a problem with two stations. This in turn becomes the problem with two stations above.</p>
</li>
<li><p>or if gas(b) &gt;= cost(b), we can travel from b to c directly. Similar to the case above, this problem can reduce to a problem with two stations b’ and a, where gas(b’) = gas(b) + gas(c) and cost(b’) = cost(b) + cost(c). Since gas(a) &lt; cost(a), gas(b’) must be greater than cost(b’), so it’s solved too.</p>
</li>
</ul>
</li>
<li><p>For problems with more stations, we can reduce them in a similar way. In fact, as seen above for the example of three stations, the problem of two stations can also reduce to the initial problem with one station.</p>
</li>
</ul>
<p>根据以上性质可得以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sumGas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sumCost = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录开始station</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tank = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; i++)&#123;</span><br><span class="line">            sumGas += gas[i];</span><br><span class="line">            sumCost += cost[i];</span><br><span class="line">            </span><br><span class="line">            tank += gas[i] - cost[i];</span><br><span class="line">            <span class="comment">//tank小于0说明不能到达i，从下一个station i+1开始</span></span><br><span class="line">            <span class="keyword">if</span>(tank &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">                tank = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sumGas &gt;= sumCost ? start : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Duplicates from Sorted List I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Remove-Duplicates-from-Sorted-List-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Remove-Duplicates-from-Sorted-List-I-II/</id>
    <published>2016-06-14T11:35:31.000Z</published>
    <updated>2016-06-14T15:18:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Remove_Duplicates_from_Sorted_List_I">Remove Duplicates from Sorted List I</h2><h3 id="题目描述">题目描述</h3><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
<h3 id="代码">代码</h3><ul>
<li>迭代</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	 <span class="comment">//迭代</span></span><br><span class="line">    <span class="comment">//链表有序，相同元素相邻，遍历单链表，如果当前节点和下一个节点的值相等删除下一个节点</span></span><br><span class="line">    <span class="comment">//否则跳到下一个节点继续处理</span></span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前节点和下一个节点的值相等，删除下一个节点，让当前节点的next指向下下个节点</span></span><br><span class="line">            <span class="keyword">if</span>(curr.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; curr.<span class="keyword">next</span>.val == curr.val)&#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = curr.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归</li>
</ul>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        //加上判断head.<span class="keyword">next</span> == <span class="literal">null</span>判断能够保证递归返回的给head.<span class="keyword">next</span>的节点不为空</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        head.<span class="keyword">next</span> = deleteDuplicates(head.<span class="keyword">next</span>);</span><br><span class="line">        //head.<span class="keyword">next</span>不会为空</span><br><span class="line">        <span class="keyword">return</span> head.val == head.<span class="keyword">next</span>.val ? head.<span class="keyword">next</span> : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove_Duplicates_from_Sorted_List_II">Remove Duplicates from Sorted List II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
<h3 id="代码-1">代码</h3><ul>
<li>递归</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; head.<span class="keyword">next</span>.val == head.val)&#123;</span><br><span class="line">            <span class="comment">//删除所有值相等的节点</span></span><br><span class="line">            <span class="keyword">while</span>(head.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; head.<span class="keyword">next</span>.val == head.val)&#123;</span><br><span class="line">                head = head.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时head是最后一个跟前面删除节点值相等的节点，不保留,其next节点才是distinc节点</span></span><br><span class="line">            <span class="comment">//所以递归处理head.next</span></span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(head.<span class="keyword">next</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//此时head节点没有出现重复，保留</span></span><br><span class="line">            head.<span class="keyword">next</span> = deleteDuplicates(head.<span class="keyword">next</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//迭代</span></span><br><span class="line">    <span class="comment">//使用一个前驱指针pre指向上一个不重复的元素</span></span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.<span class="keyword">next</span> = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//出现重复元素，让curr指向最右边的重复元素</span></span><br><span class="line">            <span class="keyword">while</span>(curr.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; curr.<span class="keyword">next</span>.val == curr.val)&#123;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//目前没有出现重复节点，curr指向的是一个distinc numbers的节点</span></span><br><span class="line">            <span class="comment">//更新不重复节点pre为curr</span></span><br><span class="line">            <span class="comment">//没有出现重复节点是pre和curr相邻</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pre.<span class="keyword">next</span> == curr)&#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//出现了重复值的节点，curr指向最右边的重复节点，删除重复节点，pre.next = curr.next;</span></span><br><span class="line">                pre.<span class="keyword">next</span> = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Remove_Duplicates_from_Sorted_List_I">Remove Duplicates from Sorted List I</h2><h3 id="题目描述">题目描述</h3><p>Given a sorted linked list,]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Palindrome Partitioning I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Palindrome-Partitioning-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Palindrome-Partitioning-I-II/</id>
    <published>2016-06-14T11:20:32.000Z</published>
    <updated>2016-06-14T11:33:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Palindrome_Partitioning_I">Palindrome Partitioning I</h2><h3 id="题目描述">题目描述</h3><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">"aa"</span>,<span class="string">"b"</span>],</span><br><span class="line">  [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; partition(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backTrack(s, <span class="number">0</span>, curr, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">void</span> backTrack(<span class="built_in">String</span> s, <span class="built_in">int</span> start, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; curr, <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = start; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//[0, 0]是回文时然后检查[0,1]然后[0,2]</span></span><br><span class="line">            <span class="comment">//检查[0,0],递归检查子字符串。</span></span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s, start, i))&#123;</span><br><span class="line">                curr.add(s.substring(start, i+<span class="number">1</span>));</span><br><span class="line">                backTrack(s, i+<span class="number">1</span>, curr, res);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断一个字符串是否为回文字符串</span></span><br><span class="line">    public boolean isPalindrome(<span class="built_in">String</span> s, <span class="built_in">int</span> left, <span class="built_in">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Palindrome_Partitioning_II">Palindrome Partitioning II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut.</p>
<h3 id="代码-1">代码</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Palindrome_Partitioning_I">Palindrome Partitioning I</h2><h3 id="题目描述">题目描述</h3><p>Given a string s, partition s such that every sub]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Pow(x,n)]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Pow-x-n/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Pow-x-n/</id>
    <published>2016-06-14T06:42:09.000Z</published>
    <updated>2016-06-14T06:46:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>mplement pow(x, n).</p>
<h2 id="代码">代码</h2><ul>
<li>递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            <span class="comment">//n = -n在n = Integer.MIN_VALUE时会溢出，而且溢出n的值为Integer.MIN_VALUE，也就是说n没变，手动修改</span></span><br><span class="line">            <span class="comment">//如果不知道溢出后刚好n没变，就用if else</span></span><br><span class="line">            <span class="keyword">if</span>(n == Integer.MIN_VALUE)&#123;</span><br><span class="line">                n = Integer.MAX_VALUE;</span><br><span class="line">                x = x * x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span> ? myPow(x * x, n / <span class="number">2</span>) : <span class="function">x * <span class="title">myPow</span><span class="params">(x * x, n / <span class="number">2</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// if(n &lt; 0)&#123;</span></span><br><span class="line">        <span class="comment">//     if(n == Integer.MIN_VALUE)&#123;</span></span><br><span class="line">        <span class="comment">//         x = 1 / x;</span></span><br><span class="line">        <span class="comment">//         x = x * x;</span></span><br><span class="line">        <span class="comment">//         n = Integer.MAX_VALUE;</span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//         n = -n;</span></span><br><span class="line">        <span class="comment">//         x = 1/x;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            <span class="comment">//n = -n在n = Integer.MIN_VALUE时会溢出，而且溢出n的值为Integer.MIN_VALUE，也就是说n没变，手动修改</span></span><br><span class="line">            <span class="comment">//如果不知道溢出后刚好n没变，就用if else</span></span><br><span class="line">            <span class="keyword">if</span>(n == Integer.MIN_VALUE)&#123;</span><br><span class="line">                n = Integer.MAX_VALUE;</span><br><span class="line">                x = x * x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>) ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>mplement pow(x, n).</p>
<h2 id="代码">代码</h2><ul>
<li>递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td cla]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Group Anagrams]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Group-Anagrams/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Group-Anagrams/</id>
    <published>2016-06-14T04:14:16.000Z</published>
    <updated>2016-06-14T04:51:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>, <span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong> Note: </strong> All inputs will be in lower-case.</p>
<h2 id="代码">代码</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">//同字母异序词排序后就是同一个词，所以可以用HashMap，key为排序后的词，value为对应的同字母异序词</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; groupAnagrams(<span class="keyword">String</span>[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">String</span>&gt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Map&lt;<span class="keyword">String</span>, List&lt;<span class="keyword">String</span>&gt;&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//Arrays.sort(strs);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">str</span>: strs)&#123;</span><br><span class="line">            <span class="comment">//直接转换为char数组用Arrays.sort排序，更简单:)</span></span><br><span class="line">            <span class="built_in">char</span>[] temp = <span class="built_in">str</span>.toCharArray();</span><br><span class="line">            Arrays.<span class="built_in">sort</span>(temp);</span><br><span class="line">            <span class="keyword">String</span> keyStr = <span class="keyword">String</span>.valueOf(temp);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.containsKey(keyStr)) <span class="built_in">map</span>.put(keyStr, <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;());</span><br><span class="line">            <span class="built_in">map</span>.<span class="built_in">get</span>(keyStr).<span class="built_in">add</span>(<span class="built_in">str</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">String</span>&gt;&gt;(<span class="built_in">map</span>.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”,]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Number of Islands I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Number-of-Islands-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Number-of-Islands-I-II/</id>
    <published>2016-06-14T02:45:10.000Z</published>
    <updated>2016-06-14T03:19:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Number_of_Islands_I">Number of Islands I</h2><h3 id="题目描述">题目描述</h3><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong> Example 1: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00000</span></span><br></pre></td></tr></table></figure>
<p>Answer: 1</p>
<p><strong> Example 2: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br></pre></td></tr></table></figure>
<p>Answer: 3</p>
<p>给定一个由字符‘1’（陆地）和‘0’（水域）组成的二维网格地图，计算岛屿的个数。岛屿被水域环绕，由竖直或者水平方向邻接的陆地构成。你可以假设网格地图的四条边都被水域包围。</p>
<p>遍历矩阵的每一个点，如果为1（陆地），则岛屿数加1，然后将与该陆地邻接的陆地（1）置为0，因为这些陆地属于同一个岛屿。其实该题就是找出里面不相邻的只包含1的块的个数。</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == null || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">//DFS标记周围节点</span></span><br><span class="line">                    DFSMarking(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS标记周围节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSMarking</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] != <span class="string">'1'</span> ) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        DFSMarking(grid, i-<span class="number">1</span>, j);</span><br><span class="line">        DFSMarking(grid, i+<span class="number">1</span>, j);</span><br><span class="line">        DFSMarking(grid, i, j-<span class="number">1</span>);</span><br><span class="line">        DFSMarking(grid, i, j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Number_of_Islands_II">Number of Islands II</h2><h3 id="题目描述-1">题目描述</h3><h3 id="代码-1">代码</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Number_of_Islands_I">Number of Islands I</h2><h3 id="题目描述">题目描述</h3><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count th]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Jump Game I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Jump-Game-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Jump-Game-I-II/</id>
    <published>2016-06-14T01:21:57.000Z</published>
    <updated>2016-06-14T02:30:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Jump_Game_I">Jump Game I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br>A = [2,3,1,1,4], return true.</p>
<p>A = [3,2,1,0,4], return false.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//贪心</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//记录能到达的最大Index，i在后边需要用到，定义在for循环外边</span></span><br><span class="line">        <span class="keyword">int</span> maxReach = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意不要漏了i &lt;= maxReach，如果maxReach &lt; i，即最大能达到的下标比当前的index还小，则肯定不能到达数组的最后index</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length &amp;&amp; i &lt;= maxReach; i++)&#123;</span><br><span class="line">            <span class="comment">//更新能到达的最大Index</span></span><br><span class="line">            maxReach = Math.max(maxReach, i + nums[i]);</span><br><span class="line">            <span class="comment">//可以优化一下，已经能到达last Index，提前终止for循环</span></span><br><span class="line">            <span class="keyword">if</span>(maxReach &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//return i == nums.length;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Jump_Game_II">Jump Game II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>For example:<br>Given array A = [2,3,1,1,4]</p>
<p>The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)</p>
<p><strong> Note: </strong><br>You can assume that you can always reach the last index.</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//number of jumps</span></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前能达到的最大Index</span></span><br><span class="line">        <span class="keyword">int</span> maxReach = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> nextMaxReach = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//终止条件是i &lt; nums.length - 1,比如只有一个元素[0]，则step = 0，不用进入循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span> &amp;&amp; i &lt;= maxReach; i++)&#123;</span><br><span class="line">            nextMaxReach = Math.max(nextMaxReach, i + nums[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i == maxReach)&#123;</span><br><span class="line">                step++;</span><br><span class="line">                maxReach = nextMaxReach;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不能到达last index，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> maxReach &gt;= nums.length - <span class="number">1</span> ? step : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Jump_Game_I">Jump Game I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of non-negative integers, you are initially positioned at the ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Flatten Nested List Iterator]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Flatten-Nested-List-Iterator/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Flatten-Nested-List-Iterator/</id>
    <published>2016-06-14T00:54:28.000Z</published>
    <updated>2016-06-14T00:56:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a nested list of integers, implement an iterator to flatten it.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p><strong> Example 1: </strong><br>Given the list [[1,1],2,[1,1]],</p>
<p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</p>
<p><strong> Example 2: </strong><br>Given the list [1,[4,[6]]],</p>
<p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * // This is the interface that allows for creating nested lists.</span><br><span class="line"> * // You should not implement it, or speculate about its implementation</span><br><span class="line"> * public interface NestedInteger &#123;</span><br><span class="line"> *</span><br><span class="line"> *     // @return true if this NestedInteger holds a single integer, rather than a nested list.</span><br><span class="line"> *     public boolean isInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // @return the single integer that this NestedInteger holds, if it holds a single integer</span><br><span class="line"> *     // Return null if this NestedInteger holds a nested list</span><br><span class="line"> *     public Integer getInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // @return the nested list that this NestedInteger holds, if it holds a nested list</span><br><span class="line"> *     // Return null if this NestedInteger holds a single integer</span><br><span class="line"> *     public List&lt;NestedInteger&gt; getList();</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">//使用栈，在构造函数中将List&lt;NestedInteger&gt;中的元素从后往前push到栈中，因为栈先进后出，pop时可以从前往后访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NestedIterator implements Iterator&lt;Integer&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;NestedInteger&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nestedList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(nestedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.pop().getInteger();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//stack为空时返回false，不为空时进入while循环，在循环中判断栈顶元素是单一的Integer，还是nested list</span></span><br><span class="line">    <span class="comment">//如果是单一的Integer元素，返回true，如果是nested list将nested list中的Integer从后往前push到栈中</span></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> boolean <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty())&#123;</span><br><span class="line">            NestedInteger curr = <span class="built_in">stack</span>.peek();</span><br><span class="line">            <span class="comment">//栈顶元素是单一的Integer元素，返回true</span></span><br><span class="line">            <span class="keyword">if</span>(curr.isInteger())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = curr.getList().size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(curr.getList().get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your NestedIterator object will be instantiated and called as such:</span><br><span class="line"> * NestedIterator i = new NestedIterator(nestedList);</span><br><span class="line"> * while (i.hasNext()) v[f()] = i.next();</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a nested list of integers, implement an iterator to flatten it.</p>
<p>Each element is either an integer, or]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Construct Binary Tree from Preorder/Postorder and Inorder Traversal]]></title>
    <link href="http://blog.noobsky.com/2016/06/13/LeetCode-Construct-Binary-Tree-from-Preorder-Postorder-and-Inorder-Traversal/"/>
    <id>http://blog.noobsky.com/2016/06/13/LeetCode-Construct-Binary-Tree-from-Preorder-Postorder-and-Inorder-Traversal/</id>
    <published>2016-06-13T15:29:51.000Z</published>
    <updated>2016-06-13T16:10:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal">Construct Binary Tree from Preorder and Inorder Traversal</h2><h3 id="题目描述">题目描述</h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong> Note: </strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>preorder[0]一定是树的根，然后在inorder中找到preorder[0],将inorder分成了两部分，前半部分是preorder[0]的左子树，右半部分是preorder[0]的右子树，然后在子数组中递归处理。</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == null || inorder == null || preorder.length != inorder.length) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//preorder[0]一定是树的根，然后在inorder中找到preorder[0],将inorder分成了两部分，前半部分是preorder[0]</span></span><br><span class="line">    <span class="comment">//的左子树，右半部分是preorder[0]的右子树，然后在子数组中递归处理。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preorder.length - <span class="number">1</span> || inStart &gt; inEnd) <span class="keyword">return</span> null;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出preorder[preStart]在inorder中的下标</span></span><br><span class="line">        <span class="comment">//题目中假设没有重复元素</span></span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == preorder[preStart])&#123;</span><br><span class="line">                inIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.left = helper(preStart + <span class="number">1</span>, inStart, inIndex - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">        <span class="comment">//右子树根节点的索引：preStart + inIndex - inStart + 1，稍微举个例子算算就可以了</span></span><br><span class="line">        root.right = helper(preStart + inIndex - inStart + <span class="number">1</span>, inIndex + <span class="number">1</span>, inEnd, preorder, inorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法每次都要到inorder中线性搜索root节点的index，如果我们构造的的二叉树是平衡的，那么时间复杂度为O(nlgn)。如果构造的树退化为单链表（每个节点只有左/右节点），那么久需要O(n)的时间复杂度。我们可以使用HashMap缓存inorder中值和对应的index，将时间复杂度降到O(n)。修改后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == null || inorder == null || preorder.length != inorder.length) <span class="keyword">return</span> null;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, inorder, <span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//preorder[0]一定是树的根，然后在inorder中找到preorder[0],将inorder分成了两部分，前半部分是preorder[0]</span></span><br><span class="line">    <span class="comment">//的左子树，右半部分是preorder[0]的右子树，然后在子数组中递归处理。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, Map&lt;Integer, Integer&gt; <span class="built_in">map</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preorder.length - <span class="number">1</span> || inStart &gt; inEnd) <span class="keyword">return</span> null;</span><br><span class="line">    </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出preorder[preStart]在inorder中的下标</span></span><br><span class="line">        <span class="comment">//题目中假设没有重复元素</span></span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="built_in">map</span>.get(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        root.left = helper(preStart + <span class="number">1</span>, inStart, inIndex - <span class="number">1</span>, preorder, inorder, <span class="built_in">map</span>);</span><br><span class="line">        <span class="comment">//右子树根节点的索引：preStart + inIndex - inStart + 1，稍微举个例子算算就可以了</span></span><br><span class="line">        root.right = helper(preStart + inIndex - inStart + <span class="number">1</span>, inIndex + <span class="number">1</span>, inEnd, preorder, inorder, <span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal">Construct Binary Tree from Inorder and Postorder Traversal</h2><h3 id="题目描述-1">题目描述</h3><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><strong> Note: </strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>postorder[postorder.length - 1]为树的根节点,然后在inorder中找到postorder[postorder.length - 1]的索引,将inorder分成两部分，分别为左右子树，然后递归处理。</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(inorder == null || postorder == null || inorder.length != postorder.length) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">return</span> helper(postorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//postorder[postorder.length - 1]为树的根节点,然后在inorder中找到postorder[postorder.length - 1]的索引</span></span><br><span class="line">    <span class="comment">//将inorder分成两部分，分别为左右子树，递归处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> postEnd, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postEnd &lt; <span class="number">0</span> || inStart &gt; inEnd) <span class="keyword">return</span> null;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postEnd]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == postorder[postEnd])&#123;</span><br><span class="line">                inIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.left = helper(postEnd - (inEnd - inIndex) - <span class="number">1</span> ,inStart,inIndex - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">        root.right = helper(postEnd - <span class="number">1</span>, inIndex+<span class="number">1</span>, inEnd, inorder, postorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="http://articles.leetcode.com/construct-binary-tree-from-inorder-and-preorder-postorder-traversal" target="_blank" rel="external">Construct Binary Tree From Inorder and Preorder/Postorder Traversal</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal">Construct Binary Tree from Preorder and Inorder Traversal</h2><h3 id="题目描]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Lowest Common Ancestor of a Binary Search Tree or Search Tree]]></title>
    <link href="http://blog.noobsky.com/2016/06/13/LeetCode-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-or-Search-Tree/"/>
    <id>http://blog.noobsky.com/2016/06/13/LeetCode-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-or-Search-Tree/</id>
    <published>2016-06-13T08:09:00.000Z</published>
    <updated>2016-06-13T12:16:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Lowest_Common_Ancestor_of_a_Binary_Search_Tree">Lowest Common Ancestor of a Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    /              \</span><br><span class="line"> ___2__          ___8__</span><br><span class="line">/      \        /      \</span><br><span class="line"><span class="number">0</span>      _4       <span class="number">7</span>       <span class="number">9</span></span><br><span class="line">      /  \</span><br><span class="line">      <span class="number">3</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
<p>根据BST树的性质，可知，在遍历树的时候，如果当前节点的值都大于p和q节点的值，则p和q在当前节点的左子树中，则它们的LCA也在左子树；如果当前节点的值都小于p和q两个节点的值，则p和q在当前节点的右子树，在右子树中查找LCA。如果不是以上情况，则当前节点就是p和q的LCA。</p>
<h3 id="代码">代码</h3><ul>
<li>递归法</li>
</ul>
<p>时间复杂度O(h)，空间复杂度O(h)递归栈空间</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//p和q分居root的两边，lca为root</span></span><br><span class="line">        <span class="comment">//等价于</span></span><br><span class="line">        <span class="keyword">if</span>((root.<span class="keyword">val</span> - p.<span class="keyword">val</span>)*(root.<span class="keyword">val</span> - q.<span class="keyword">val</span>) &lt;= <span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//if((p.val &lt;= root.val &amp;&amp; root.val &lt;= q.val) || (q.val &lt;= root.val &amp;&amp; root.val &lt;= p.val)) return root;</span></span><br><span class="line">        <span class="comment">//p和q分居root的一边（左或右子树里）</span></span><br><span class="line">        root = p.<span class="keyword">val</span> &lt; root.<span class="keyword">val</span> ? root.left : root.right;</span><br><span class="line">        <span class="comment">//尾递归可以改写为迭代的形式</span></span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root, p,q);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>更clean的code：</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    return (root<span class="string">.val</span> - p<span class="string">.val)</span> * (root<span class="string">.val</span> - q<span class="string">.val)</span> &lt; 1 ? root :</span><br><span class="line">           lowestCommonAncestor(p<span class="string">.val</span> &lt; root<span class="string">.val</span> ? root<span class="string">.left</span> : root<span class="string">.right</span>, p, q);</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>一般我写下面朴实的写法：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//root.val大于p.val和q.val，则p和q在左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="keyword">val</span> &gt; p.<span class="keyword">val</span> &amp;&amp; root.<span class="keyword">val</span> &gt; q.<span class="keyword">val</span>) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="comment">//在右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.<span class="keyword">val</span> &lt; p.<span class="keyword">val</span> &amp;&amp; root.<span class="keyword">val</span> &lt; q.<span class="keyword">val</span>) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>迭代法</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾递归可以改写为迭代的形式</span></span><br><span class="line"><span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)&#123;</span><br><span class="line">    <span class="comment">//p、q各分居root同一侧：(p.val - root.val) * (root.val - q.val) &gt; 0表达式不对比如【2，1，3】分居两侧也大于0</span></span><br><span class="line">    <span class="comment">//正确的表达式为(root.val-p.val)*(root.val-q.val) &gt; 0</span></span><br><span class="line">    <span class="keyword">while</span>((root.<span class="keyword">val</span>-p.<span class="keyword">val</span>)*(root.<span class="keyword">val</span>-q.<span class="keyword">val</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        root = p.<span class="keyword">val</span> &lt; root.<span class="keyword">val</span> ? root.left : root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分居两侧时lca为root</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// while ((root.val - p.val) * (root.val - q.val) &gt; 0)</span></span><br><span class="line">    <span class="comment">//     root = p.val &lt; root.val ? root.left : root.right;</span></span><br><span class="line">    <span class="comment">//return root;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lowest_Common_Ancestor_of_a_Search_Tree">Lowest Common Ancestor of a Search Tree</h2><h3 id="题目描述-1">题目描述</h3><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line"><span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></span><br><span class="line">      /  \</span><br><span class="line">      <span class="number">7</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<p>可以利用深度优先搜索，从叶子节点向上，标记子树中出现目标节点的情况。如果子树中有目标节点，则通过返回该目标节点标记该子树有那个目标节点，如果没有，标记为null。如果左子树、右子树都有标记，说明p和q两个目标节点正好有一个在左子树中有一个在右子树中，则LCA就是当前节点。如果只有一个子树（左或右）有标记，则说明p和q都在这子树上，而且p或者q就是该子树的根节点，则p或者q就是LCA。</p>
<h3 id="代码-1">代码</h3><ul>
<li>递归法</li>
</ul>
<p>时间复杂度O(n)，空间复杂度O(h)栈空间<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> lowestCommonAncestor(<span class="type">TreeNode</span> root, <span class="type">TreeNode</span> p, <span class="type">TreeNode</span> q) &#123;</span><br><span class="line">        <span class="comment">//发现目标(p或q)节点就通过返回该目标节点标记该子树发现了某个目标节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == null || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">left</span> = lowestCommonAncestor(root.<span class="keyword">left</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">right</span> = lowestCommonAncestor(root.<span class="keyword">right</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//都不为空，说明p和q两个目标节点正好有一个在左子树中有一个在右子树中，则LCA为root</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span> != null &amp;&amp; <span class="keyword">right</span>  != null) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//如果left(或者right)不为空，而且left为p或者q节点，如果在left(left为p或者q)的子树中查找p和q的LCA，则必定是left</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span> != null ? <span class="keyword">left</span> : <span class="keyword">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法假设两个节点都在二叉树里，这里的题目也说了给定二叉树里的两个节点。如果这点不能保证，也就是一个节点在二叉树而另一个不在，那么该方法返回那个出现在二叉树中的节点，但是正确的做法是返回null。我们可以扩展上面的方法使得也能够正确处理这种情况，使用两个boolean变量v1和v2，如果p在二叉树中，则设置v1为true；如果q在二叉树中，设置v2为true。修改后的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> boolean v1, v2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> lowestCommonAncestor(<span class="type">TreeNode</span> root, <span class="type">TreeNode</span> p, <span class="type">TreeNode</span> q) &#123;</span><br><span class="line">        v1 = <span class="literal">false</span>;</span><br><span class="line">        v2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="type">LCA</span> = lowestCommonAncestorHelper(root, p, q);</span><br><span class="line">        <span class="keyword">if</span>(v1 &amp;&amp; v2) <span class="keyword">return</span> <span class="type">LCA</span>;</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> lowestCommonAncestorHelper(<span class="type">TreeNode</span> root, <span class="type">TreeNode</span> p, <span class="type">TreeNode</span> q) &#123;</span><br><span class="line">        <span class="comment">//发现目标(p或q)节点就通过返回该目标节点标记该子树发现了某个目标节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root == p)&#123;</span><br><span class="line">            v1 = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//注意！！！不能直接返回，如果直接返回，比如树为[2, 2], p = 2(root节点), q = 2(root.left节点)</span></span><br><span class="line">            <span class="comment">//会判断错误，因为只把v1设置为true之后就直接返回，但是v2也应该为true，应该在递归后加入代码：</span></span><br><span class="line">            <span class="comment">//if(root == p || root == q) return root;才能正确处理。</span></span><br><span class="line">            <span class="comment">//return root;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == q)&#123;</span><br><span class="line">            v2 = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//return root;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">left</span> = lowestCommonAncestorHelper(root.<span class="keyword">left</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">right</span> = lowestCommonAncestorHelper(root.<span class="keyword">right</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在这里判断返回才能正确处理类似树为[2, 2], p = 2(root节点), q = 2(root.left节点)的情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//都不为空，说明p和q两个目标节点正好有一个在左子树中有一个在右子树中，则LCA为root</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span> != null &amp;&amp; <span class="keyword">right</span>  != null) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//如果left(或者right)不为空，而且left为p或者q节点，如果在left(left为p或者q)的子树中查找p和q的LCA，则必定是left</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span> != null ? <span class="keyword">left</span> : <span class="keyword">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代法</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        Map<span class="tag">&lt;TreeNode, TreeNode&gt;</span> parent = new HashMap<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        Deque<span class="tag">&lt;TreeNode&gt;</span> stack = new ArrayDeque<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        parent.put(root, null);</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        while (!parent.containsKey(p) || !parent.containsKey(q)) &#123;</span><br><span class="line">            TreeNode <span class="keyword">node</span><span class="identifier"> </span><span class="title">= stack</span>.pop();</span><br><span class="line">            if (<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span> != null) &#123;</span><br><span class="line">                parent.put(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>, <span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">                stack</span>.push(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            if (<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span> != null) &#123;</span><br><span class="line">                parent.put(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>, <span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">                stack</span>.push(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Set<span class="tag">&lt;TreeNode&gt;</span> ancestors = new HashSet<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            ancestors.add(p);</span><br><span class="line">            p = parent.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        while (!ancestors.contains(q))</span><br><span class="line">            q = parent.get(q);</span><br><span class="line">        return q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/" target="_blank" rel="external">Lowest Common Ancestor in a Binary Search Tree</a><br><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/" target="_blank" rel="external">Lowest Common Ancestor in a Binary Tree</a><br><a href="https://segmentfault.com/a/1190000003509399" target="_blank" rel="external">Lowest Common Ancestor of a Binary Tree 最小公共祖先</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Lowest_Common_Ancestor_of_a_Binary_Search_Tree">Lowest Common Ancestor of a Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]3Sum And 3Sum Closest And 4Sum]]></title>
    <link href="http://blog.noobsky.com/2016/06/13/LeetCode-3Sum-And-3Sum-Closest/"/>
    <id>http://blog.noobsky.com/2016/06/13/LeetCode-3Sum-And-3Sum-Closest/</id>
    <published>2016-06-13T06:46:13.000Z</published>
    <updated>2016-06-16T13:11:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="3Sum">3Sum</h2><h3 id="题目描述">题目描述</h3><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong> Note: </strong>The solution set must not contain duplicate triplets.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For example, given <span class="built_in">array</span> S = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">A solution <span class="built_in">set</span> is:</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这个题目跟3Sum Closest的思路都类似。首先排序，然后使用三个索引指针。</p>
<p>开始时：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">^  ^                                               ^</span><br><span class="line">|  |                                               |</span><br><span class="line">|  +- <span class="keyword">second</span>                                     <span class="keyword">third</span></span><br><span class="line">+-<span class="keyword">first</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>nums[first]+nums[second]+nums[third]</code>小于target，我们需要增大sum。所以讲second索引指针往右移动。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">^    ^                                             ^</span><br><span class="line">|    |                                             |</span><br><span class="line">|    +- <span class="keyword">second</span>                                   <span class="keyword">third</span></span><br><span class="line">+-<span class="keyword">first</span></span><br></pre></td></tr></table></figure>
<p>如果sum大于target，则我们需要减小sum。所以将third索引指针往前移动。如果sum等于target，那么我们返回sum或者加入到结果集中。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">^    ^                                          ^</span><br><span class="line">|    |                                          |</span><br><span class="line">|    +- <span class="keyword">second</span>                                <span class="keyword">third</span></span><br><span class="line">+-<span class="keyword">first</span></span><br></pre></td></tr></table></figure>
<p>当second和third相遇时，这一回合结束。将first往右移动开始下一回合，并且重置second和third。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">  ^    ^                                           ^</span><br><span class="line">  |    |                                           |</span><br><span class="line">  |    +- <span class="keyword">second</span>                                 <span class="keyword">third</span></span><br><span class="line">  +-<span class="keyword">first</span></span><br></pre></td></tr></table></figure></p>
<p>在这个过程中能得到满足条件的Sum或者Closest。最后三个索引指针聚集在数组末端。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">                                         ^    ^    ^</span><br><span class="line">                                         |    |    `- <span class="keyword">third</span></span><br><span class="line">                                         |    +- <span class="keyword">second</span></span><br><span class="line">                                         +-<span class="keyword">first</span></span><br></pre></td></tr></table></figure></p>
<h3 id="代码">代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; res = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//先排序，后面更好处理</span></span><br><span class="line">        <span class="type">Arrays</span>.<span class="built_in">sort</span>(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; nums.length -<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//进行nums[i] != nums[i-1]判断去除重复的结果，就不用利用集合去重了</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> ||(i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="comment">//先固定第一个数nums[i]，然后在数组的剩下部分查找两元素之和等于-nums[i]的组合</span></span><br><span class="line">                int sum = -nums[i];</span><br><span class="line">                <span class="comment">//使用两个索引指针，一头一尾进行扫荡</span></span><br><span class="line">                int <span class="keyword">left</span> = i+<span class="number">1</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] == sum)&#123;</span><br><span class="line">                        <span class="comment">//找到一种组合，加入结果集中</span></span><br><span class="line">                        res.add(<span class="type">Arrays</span>.asList(nums[i], nums[<span class="keyword">left</span>], nums[<span class="keyword">right</span>]));</span><br><span class="line">                        <span class="comment">//跳过重复元素</span></span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>+<span class="number">1</span>] == nums[<span class="keyword">left</span>]) <span class="keyword">left</span>++;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>-<span class="number">1</span>] == nums[<span class="keyword">right</span>]) <span class="keyword">right</span>--;</span><br><span class="line">                        <span class="keyword">left</span>++;</span><br><span class="line">                        <span class="keyword">right</span>--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] &lt; sum) <span class="keyword">left</span>++;<span class="comment">//数组有序，小于sum时，增大左边数才有可能相等</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">right</span>--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3Sum_Closest">3Sum Closest</h2><h3 id="题目描述-1">题目描述</h3><p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, given <span class="built_in">array</span> S = &#123;-<span class="number">1</span> <span class="number">2</span> <span class="number">1</span> -<span class="number">4</span>&#125;, and target = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is <span class="number">2.</span> (-<span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>
<h3 id="代码-1">代码</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Solution</span> &#123;</span><br><span class="line">    public <span class="type">int</span> threeSumClosest(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        //如果nums.length&lt;<span class="number">3</span>,如何处理，随时沟通:)</span><br><span class="line">        </span><br><span class="line">        //排序，然后我们就能慢慢逼近target</span><br><span class="line">        <span class="type">Arrays</span>.sort(nums);</span><br><span class="line">        </span><br><span class="line">        //初始化结果，找三个数，nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[nums.length - <span class="number">1</span>]</span><br><span class="line">        <span class="type">int</span> <span class="literal">result</span> = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]; </span><br><span class="line">        //<span class="type">int</span> <span class="literal">result</span> = nums[<span class="number">0</span>] + nums[<span class="number">1</span>]+nums[nums.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(<span class="type">Math</span>.abs(<span class="literal">result</span> - target) &gt; <span class="type">Math</span>.abs(sum - target))&#123;</span><br><span class="line">                    <span class="literal">result</span> = sum;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="literal">result</span> == target) <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                //sum &gt; target ? right-- : left++;</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target) left++;</span><br><span class="line">                <span class="keyword">else</span> right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4Sum">4Sum</h2><h3 id="题目描述-2">题目描述</h3><p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note: The solution set must not contain duplicate quadruplets.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">For example, given <span class="built_in">array</span> S = [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>], and target = <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">A solution <span class="built_in">set</span> is:</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [-<span class="number">2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码-2">代码</h3><p>其实可以利用3Sum的方法，外面加一层循环，然后3Sum的target变成target3Sum = target - nums[j]。 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; res = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//先排序，后面更好处理</span></span><br><span class="line">        <span class="type">Arrays</span>.<span class="built_in">sort</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; nums.length - <span class="number">3</span>; j++)&#123;</span><br><span class="line">            int target3Sum = target - nums[j];</span><br><span class="line">            <span class="comment">//排重</span></span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span> || j &gt; <span class="number">0</span> &amp;&amp; nums[j] != nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(int i = j+<span class="number">1</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">                    <span class="comment">//进行nums[i] != nums[i-1]判断去除重复的结果，就不用利用集合去重了</span></span><br><span class="line">                    <span class="keyword">if</span>(i == j+<span class="number">1</span> ||(i &gt; j+<span class="number">1</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                        <span class="comment">//先固定第一个数nums[i]，然后在数组的剩下部分查找两元素之和等于-nums[i]的组合</span></span><br><span class="line">                        int sum = target3Sum-nums[i];</span><br><span class="line">                        <span class="comment">//使用两个索引指针，一头一尾进行扫荡</span></span><br><span class="line">                        int <span class="keyword">left</span> = i+<span class="number">1</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] == sum)&#123;</span><br><span class="line">                                <span class="comment">//找到一种组合，加入结果集中</span></span><br><span class="line">                                res.add(<span class="type">Arrays</span>.asList(nums[j], nums[i], nums[<span class="keyword">left</span>], nums[<span class="keyword">right</span>]));</span><br><span class="line">                                <span class="comment">//跳过重复元素</span></span><br><span class="line">                                <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>+<span class="number">1</span>] == nums[<span class="keyword">left</span>]) <span class="keyword">left</span>++;</span><br><span class="line">                                <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>-<span class="number">1</span>] == nums[<span class="keyword">right</span>]) <span class="keyword">right</span>--;</span><br><span class="line">                                <span class="keyword">left</span>++;</span><br><span class="line">                                <span class="keyword">right</span>--;</span><br><span class="line">                            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] &lt; sum) <span class="keyword">left</span>++;<span class="comment">//数组有序，小于sum时，增大左边数才有可能相等</span></span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">right</span>--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="3Sum">3Sum</h2><h3 id="题目描述">题目描述</h3><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Fi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
