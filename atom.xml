<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-09-28T01:57:11.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[面试算法之动态规划问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/09/28/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/09/28/面试算法之动态规划问题集锦/</id>
    <published>2016-09-28T01:57:10.000Z</published>
    <updated>2016-09-28T01:57:11.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法]]></title>
    <link href="http://blog.noobsky.com/2016/09/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.noobsky.com/2016/09/26/排序算法/</id>
    <published>2016-09-25T17:54:40.000Z</published>
    <updated>2016-09-25T17:57:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="快速排序">快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int i = left-1;</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, right);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            quickSort(nums, left, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//int[] nums = &#123;1,2,3,4,5,6&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> QuickSort().quickSort(nums,<span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            System.out.println(num + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapsize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left(i);</span><br><span class="line">        <span class="keyword">int</span> r = right(i);</span><br><span class="line">        <span class="keyword">int</span> largest = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l &lt; heapsize &amp;&amp; heap[l] &gt; heap[largest])</span><br><span class="line">            largest = l;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; heapsize &amp;&amp; heap[r] &gt; heap[largest])</span><br><span class="line">            largest = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(largest != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = heap[i];</span><br><span class="line">            heap[i] = heap[largest];</span><br><span class="line">            heap[largest] = temp;</span><br><span class="line">            maxHeapify(largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.heap = nums;</span><br><span class="line">        <span class="keyword">this</span>.heapsize = heap.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapsize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        buildMaxHeap(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heap.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = heap[i];</span><br><span class="line">            heap[i] = heap[<span class="number">0</span>];</span><br><span class="line">            heap[<span class="number">0</span>] = temp;</span><br><span class="line"></span><br><span class="line">            heapsize--;</span><br><span class="line">            maxHeapify(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        HeapSort hs =<span class="keyword">new</span> HeapSort();</span><br><span class="line">        hs.heapSort(nums);</span><br><span class="line"></span><br><span class="line">        nums = hs.heap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            mergeSort(nums, left, mid);</span><br><span class="line">            mergeSort(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">            merge(nums, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> r = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= middle &amp;&amp; r &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[r])&#123;</span><br><span class="line">                temp[index++] = nums[l++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = nums[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= middle)&#123;</span><br><span class="line">            temp[index++] = nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt;= right)&#123;</span><br><span class="line">            temp[index++] = nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right)&#123;</span><br><span class="line">            nums[i] = temp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        MergeSort.mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序">冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        BubbleSort.bubbleSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="快速排序">快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之链表问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/09/25/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/09/25/面试算法之链表问题集锦/</id>
    <published>2016-09-25T13:49:35.000Z</published>
    <updated>2016-09-27T02:37:21.000Z</updated>
    <content type="html"><![CDATA[<p>链表操作是面试中很基础也很重要的算法问题，链表问题涉及大量的指针操作，操作很灵活，很考查编程基础。链表问题虽然比较基础，但在高压的面试环境中，要写对链表的问题也不是那么的容易啊：(，博主是有血的教训的。本文我将常见的链表问题总结一下。</p>
<p>下面是本文所用到的节点的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">       val = x;</span><br><span class="line">       next = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="判断链表是否有环">判断链表是否有环</h2><p>使用快慢指针，如果链表有环，慢指针必然会追上慢指针。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="找到单链表环的起始点，如果没有环，返回null">找到单链表环的起始点，如果没有环，返回null</h2><p>同理使用快慢指针，如果慢指针追上了快指针时，将快指针或者慢指针重新指向链表的头结点，然后以相同速度遍历，如果它们再次相遇时即为环的起始点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast )&#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;              </span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转单链表">反转单链表</h2><p>最常见的思路是遍历单链表然后通过前插构建单链表就能构建单链表，但是思路不清晰一时半会也写不出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = newHead;</span><br><span class="line">    newHead = head;</span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实要是写不对上面那个，可以用栈来反转，这个很容易写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack.push(head);</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode curr = dummy;</span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    ListNode temp = stack.pop();</span><br><span class="line">    <span class="comment">//要将原节点切断，不然会形成环</span></span><br><span class="line">    temp.next = <span class="keyword">null</span>;</span><br><span class="line">    curr.next = temp;</span><br><span class="line">    curr = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递归和栈很多时候可以相互转化，而且通过递归实现的代码很简洁，递归写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* recursive solution */</span></span><br><span class="line">    <span class="keyword">return</span> reverseListInt(head, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseListInt</span><span class="params">(ListNode head, ListNode newHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = newHead;</span><br><span class="line">    <span class="keyword">return</span> reverseListInt(next, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转单链表中m到n的之间的节点">反转单链表中m到n的之间的节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//pre用于指向需要反转子链表的头结点的前一个节点</span></span><br><span class="line">  ListNode pre = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    pre = pre.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//start指向需要反转的第一个节点</span></span><br><span class="line">  ListNode start = pre.next;</span><br><span class="line">  ListNode then = start.next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反转m到n之间的节点，只需要将m+1到n之间的节点前插到pre的后面即可</span></span><br><span class="line">  <span class="comment">//所以只需要循环n-m次即可</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++)&#123;</span><br><span class="line">    start.next = then.next;</span><br><span class="line"></span><br><span class="line">    then.next = pre.next;</span><br><span class="line">    pre.next = then;</span><br><span class="line"></span><br><span class="line">    then = start.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表的题目就要多用笔在草稿上多画画</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">//pre用来标记需要反转子链表头节点的前一节点</span></span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) pre = pre.next;</span><br><span class="line">    <span class="comment">//start节点指向需要反转的子链表的头结点</span></span><br><span class="line">    ListNode start = pre.next;</span><br><span class="line">    <span class="comment">//指向将被反转的结点</span></span><br><span class="line">    ListNode then = start.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6, m = 2, n = 4, pre = 1, start = 2, then = 3</span></span><br><span class="line">    <span class="comment">//dummy-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们需要将2-&gt;3-&gt;4有三个节点的子链表反转成dummy-&gt;1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;6</span></span><br><span class="line">    <span class="comment">//我们只需要进行n-m=2次交换：首先把3交互到pre.next的位置变成dum-&gt;1-&gt;3-&gt;2-&gt;4-&gt;5-&gt;6</span></span><br><span class="line">    <span class="comment">//然后将4交互到pre.next的位置变成dummy-&gt;1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++)&#123;</span><br><span class="line">        start.next = then.next;</span><br><span class="line">        then.next = pre.next;</span><br><span class="line">        pre.next = then;</span><br><span class="line">        <span class="comment">//下一个需要反转的节点</span></span><br><span class="line">        then = start.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断链表是否为回文结构">判断链表是否为回文结构</h2><p>判断链表是否为回文，可以反转后一半然后跟前一半相比较即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断回文的一种有效方法就是反转后一半然后跟前一半相比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="comment">//fast != null 和判断fast.next != null的方式比较直接</span></span><br><span class="line">        <span class="comment">//当总节点数为偶数时，当循环结束时，fast处于尾节点的后一节点（即指向null），而slow指向n/2+1的位置，即后一半的开头节点</span></span><br><span class="line">        <span class="comment">//当总结点数为奇数时，fast节点处于尾节点，slow处于中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//奇数情况，</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = reverseList(slow);</span><br><span class="line">        <span class="comment">//总结点数为奇数时，slow指向的后一半为比前一半少1个节点，循环结束条件应该用slow</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow.val != head.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="归并两个有序的链表">归并两个有序的链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode temp = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">            temp.next = l1;</span><br><span class="line">            temp = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp.next = l2;</span><br><span class="line">            temp = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回或者删除链表的倒数第k个节点">返回或者删除链表的倒数第k个节点</h2><p>返回倒数第k个节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">theKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode slow = head, fast = head;</span><br><span class="line">  <span class="keyword">int</span> i = k;</span><br><span class="line">  <span class="keyword">for</span>(;i &gt; <span class="number">0</span> &amp;&amp; fast != <span class="keyword">null</span>; i--)&#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//k大于链表的长度</span></span><br><span class="line">  <span class="keyword">if</span>(i &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除倒数第k个节点，相当于要找到倒数第k-1个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//为了处理特殊情况，比如删除最后一个元素，用一个虚拟头结点</span></span><br><span class="line">      ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">      dummy.next = head;</span><br><span class="line">      ListNode first = dummy,second = dummy;</span><br><span class="line">      <span class="comment">//找出倒数第k-1个节点（参考找出倒数第k个节点的题目）</span></span><br><span class="line">      <span class="comment">//第一个指针先向前走k-2步后指向k-1个节点</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;i++)&#123;</span><br><span class="line">          first = first.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//然后第二个指针跟第一个指针同时前进，当第一个指针指向最后一个元素时，第二个指针指向倒数第n-1个元素</span></span><br><span class="line">      <span class="keyword">while</span>(first.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">          first = first.next;</span><br><span class="line">          second = second.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      second.next = second.next.next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="O(1)时间删除链表节点">O(1)时间删除链表节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此种做法要求删除的节点不能是尾节点</p>
<h2 id="交换单链表两两相邻节点">交换单链表两两相邻节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    ListNode current = dummyHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current.next != <span class="keyword">null</span> &amp;&amp; current.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode first = current.next;</span><br><span class="line">        ListNode second = current.next.next;</span><br><span class="line"></span><br><span class="line">        first.next = second.next;</span><br><span class="line">        current.next = second;</span><br><span class="line">        second.next = first;<span class="comment">//或者是current.next.next = first;</span></span><br><span class="line"></span><br><span class="line">        current = current.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个相交单链表的第一个公共节点">两个相交单链表的第一个公共节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode a = headA, b = headB;</span><br><span class="line">    <span class="comment">//当每一个链表的指针到达链表的尾部时，让指针指向另一链表的头指针，当每一个链表的指针都指向过另</span></span><br><span class="line">    <span class="comment">//一链表的头指针后，他们最终会相遇于公共节点，因为他们走过的路程相等，都等于len(链表A) + len(链表B) - 公共部分的长度</span></span><br><span class="line">    <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">        a = a == <span class="keyword">null</span> ? headB : a.next;</span><br><span class="line">        b = b == <span class="keyword">null</span> ? headA : b.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除单链表中等于某个值的所有节点">删除单链表中等于某个值的所有节点</h2><p>从前往后遍历单链表，current指针指向当前遍历节点，删除节点需要用到前一个节点，所以用pre指向current节点的前一个节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  ListNode pre = dummy, current = head;</span><br><span class="line">  <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(current.val == val)&#123;</span><br><span class="line">      pre.next = current.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除有序单链表中的重复节点I">删除有序单链表中的重复节点I</h2><p>删除重复节点，使每个元素只出现一次，比如给定1-&gt;1-&gt;2-&gt;3-&gt;3，返回1-&gt;2-&gt;3。因为单链表有序，所以重复节点都相邻，我们可以遍历单链表判断当前节点和下一个节点的是否相等，相等删除下一个节点即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.next != <span class="keyword">null</span> &amp;&amp; curr.val == curr.next.val)&#123;</span><br><span class="line">      curr.next = curr.next.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除有序单链表中的重复节点II">删除有序单链表中的重复节点II</h2><p>删除单链表中重复元素的所有节点。比如给定1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5，返回1-&gt;2-&gt;5。使用pre指针指向上一个不重复的元素。当出现重复元素时，找到最右边的重复元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  ListNode pre = dummy;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//出现重复元素时，找到最右边的一个重复元素</span></span><br><span class="line">    <span class="keyword">while</span>(curr.next != <span class="keyword">null</span> &amp;&amp; curr.next.val == curr.val)&#123;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有重复元素时，pre和curr相邻</span></span><br><span class="line">    <span class="keyword">if</span>(pre.next == curr)&#123;</span><br><span class="line">      pre = curr;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//出现重复节点，且curr已经指向了最右边的的重复元素</span></span><br><span class="line">      pre.next = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重新排序单链表">重新排序单链表</h2><p>将原始单链表 L: L0→L1→…→Ln-1→Ln，重新排序为L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>基本思路就是反转单链表的后半部分，然后用两个指针分别指向前半部分单链表的头部(这里用slow)和后半部分的单链表的头部(这里用fast)，然后将slow和fast指向的节点链接起来，在这个过程中要借助单链表的中间节点，终止条件也是slow等于中间节点。</p>
<h2 id="Partition_List">Partition List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">//维护两个临时链表，然后遍历一个原链表，将val小于x的存到第一个临时链表中，</span></span><br><span class="line">   <span class="comment">//其他的存到第二个临时链表中，然后将两个临时链接起来即可</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//维护虚拟头结点</span></span><br><span class="line">       ListNode dummy1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>), dummy2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       ListNode curr1 = dummy1, curr2 = dummy2;</span><br><span class="line">       <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">               curr1.next = head;</span><br><span class="line">               curr1 = head;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               curr2.next = head;</span><br><span class="line">               curr2 = head;</span><br><span class="line">           &#125;</span><br><span class="line">           head = head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2，最后curr2指向5，curr2.next指向2，</span></span><br><span class="line">       <span class="comment">//我们需要将curr2.next置为null，不然会出现circle</span></span><br><span class="line">       curr2.next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//将第一个链表跟第二个链表链接起来</span></span><br><span class="line">       curr1.next = dummy2.next;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> dummy1.next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sort_List">Sort List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将list分为两部分</span></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找链表中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分为两部分，pre为空说明slow前面前面没有元素，前半部分单链表为空</span></span><br><span class="line">        <span class="comment">// if(pre != null) pre.next = null;</span></span><br><span class="line">        <span class="comment">// else head = null;</span></span><br><span class="line">        <span class="comment">//这里因为前面if(head == null || head.next == null) return head;保证了起码有两个元素才会往下运行</span></span><br><span class="line">        <span class="comment">//则保证会进入while循环，则pre一定不会为空(前半部分单链表不可能为空)，写成上面先判空也可以</span></span><br><span class="line">        <span class="comment">//置为空，将链表割断</span></span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode l1 = sortList(head);</span><br><span class="line">        ListNode l2 = sortList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l1 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l2 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l2;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将有序单链表转换为BST">将有序单链表转换为BST</h2><p>将升序单链表转换为高度平衡的BST。思路是找出中间节点为根，然后中间节点左右两部分分别用来递归构造左右子树。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode slow = head;</span><br><span class="line">  ListNode fast = head;</span><br><span class="line">  <span class="comment">//pre指向slow前一节点，记录slow前面是否有节点</span></span><br><span class="line">  ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    pre = slow;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//打断链表</span></span><br><span class="line">  <span class="comment">//pre != null意味着slow前面有节点</span></span><br><span class="line">  <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.next = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//pre</span></span><br><span class="line">  <span class="keyword">else</span> head = <span class="keyword">null</span>;</span><br><span class="line">  TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">  root.left = sortedListToBST(head);</span><br><span class="line">  root.right = sortedListToBST(slow.next);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="计算链表表示的两数之和">计算链表表示的两数之和</h2><p>给定两个链表分别代表两个非负整数。数位以倒序存储，并且每一个节点包含一位数字。将两个数字相加并以链表形式返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode p = l1, q = l2, curr = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(p != <span class="keyword">null</span> || q != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> x = p != <span class="keyword">null</span> ? p.val : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = q != <span class="keyword">null</span> ? q.val : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line"></span><br><span class="line">    carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">    curr = curr.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用插入排序排序链表">使用插入排序排序链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  ListNode pre = dummy;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//每次从头开始在有序部分查找插入位置</span></span><br><span class="line">    pre = dummy;</span><br><span class="line">    <span class="keyword">while</span>(pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt;= curr.val)&#123;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode next = curr.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将curr元素插入到pre和pre.next之间</span></span><br><span class="line">    curr.next = pre.next;</span><br><span class="line">    pre.next = curr;</span><br><span class="line"></span><br><span class="line">    curr = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序单链表">排序单链表</h2><p>要求时间复杂度为O(nlgn)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将链表划分为两部分</span></span><br><span class="line">  ListNode slow = head, fast = head;</span><br><span class="line">  ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//寻找链表中间节点</span></span><br><span class="line">  <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    pre = slow;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//if(pre != null) pre.next = null;</span></span><br><span class="line">  <span class="comment">//else head = null;</span></span><br><span class="line">  <span class="comment">//打断单链表</span></span><br><span class="line">  pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode l1 = sortList(head);</span><br><span class="line">  ListNode l2 = sortList(slow);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">      current.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      current.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">  current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="归并k个有序单链表">归并k个有序单链表</h2><p>利用最小堆进行k路归并<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  Queue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.compare(l1.val, l2.val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ListNode node : lists)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">      pq.offer(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode curr = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">    curr.next = pq.poll();</span><br><span class="line"></span><br><span class="line">    curr = curr.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(curr.next != <span class="keyword">null</span>) pq.offer(curr.next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可使用Merge Two Sorted List的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode curr = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            curr.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curr.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curr.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKListsHelper</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) <span class="keyword">return</span> lists[start];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    ListNode l1 = mergeKListsHelper(lists, start, mid);</span><br><span class="line">    ListNode l2 = mergeKListsHelper(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if(lists == null || lists.length == 0) return null;</span></span><br><span class="line">    <span class="keyword">return</span> mergeKListsHelper(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse_Nodes_in_k-Group">Reverse Nodes in k-Group</h2><p>比如：<br>给定单链表1-&gt;2-&gt;3-&gt;4-&gt;5<br>当k=2时，返回：2-&gt;1-&gt;4-&gt;3-&gt;5<br>当k=3时，返回：3-&gt;2-&gt;1-&gt;4-&gt;5<br>最直接的思路就是k个节点反转，然后再k个节点反转一次，直至不足k个节点。<br>或者可以使用递归的解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//找到第k+1个节点</span></span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; count != k)&#123;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">    curr = reverseKGroup(curr, k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时head为没有反转部分的头结点</span></span><br><span class="line">    <span class="comment">//curr是已经反转部分的头结点</span></span><br><span class="line">    <span class="comment">//我们需要将head为头结点的k个节点反转后，将curr指向的已经反转的部分链接到head反转后的后面</span></span><br><span class="line">    <span class="comment">//举个例子原始链表为1-&gt;2-&gt;3-&gt;4-&gt;5, k = 2</span></span><br><span class="line">    <span class="comment">//此时为1-&gt;2-&gt;4-&gt;3-&gt;5，此时head指向1，curr指向4，我们要变成2-&gt;1-&gt;4-&gt;3-&gt;5</span></span><br><span class="line">    <span class="comment">//k-- &gt; 0</span></span><br><span class="line">    <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">      ListNode temp = head.next;</span><br><span class="line">      <span class="comment">//将head指向的节点前插入到curr指向的链表中</span></span><br><span class="line">      head.next = curr;</span><br><span class="line">      curr = head;</span><br><span class="line"></span><br><span class="line">      head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="深拷贝带有随机指针的链表">深拷贝带有随机指针的链表</h2><p>随机指针可以指向任何节点或者null。链表定义如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> label;</span><br><span class="line">     RandomListNode next, random;</span><br><span class="line">     RandomListNode(<span class="keyword">int</span> x) &#123; <span class="keyword">this</span>.label = x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>简单的方法可以使用HashMap，遍历两遍。第一遍将所有节点加入到HashMap中，key为原节点，value为新节点。<br>第二遍给map中节点的next和random赋值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  RandomListNode node = head;</span><br><span class="line">  <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">    map.put(node, <span class="keyword">new</span> RandomListNode(node.label));</span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  node = head;</span><br><span class="line">  <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">    map.get(node).next = map.get(node.next);</span><br><span class="line">    map.get(node).random = map.get(node.random);</span><br><span class="line"></span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>链表操作是面试中很基础也很重要的算法问题，链表问题涉及大量的指针操作，操作很灵活，很考查编程基础。链表问题虽然比较基础，但在高压的面试环境中，要写对链表的问题也不是那么的容易啊：(，博主是有血的教训的。本文我将常见的链表问题总结一下。</p>
<p>下面是本文所用到的节点的]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试基础问题]]></title>
    <link href="http://blog.noobsky.com/2016/09/24/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.noobsky.com/2016/09/24/面试基础问题/</id>
    <published>2016-09-24T02:26:06.000Z</published>
    <updated>2016-09-24T02:55:53.000Z</updated>
    <content type="html"><![CDATA[<p>进程间通信方式：</p>
<p>管道<br>命名管道<br>信号<br>信号量<br>消息队列<br>共享内存<br>套接字</p>
<p>线程间通信方式<br>锁机制：互斥锁、临界区、<br>信号量<br>信号</p>
<p>进程与线程的区别：<br>进程是程序执行时的实例，而线程是进程的某条执行路径</p>
<p>进程有独立的地址空间，线程共享进程的地址空间和资源，线程有自己的堆栈和局部变量</p>
<p>进程是资源分配的基本单位，而线程是cpu调度的基本单位</p>
<p>进程的切换代价大，线程切换代价小</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>进程间通信方式：</p>
<p>管道<br>命名管道<br>信号<br>信号量<br>消息队列<br>共享内存<br>套接字</p>
<p>线程间通信方式<br>锁机制：互斥锁、临界区、<br>信号量<br>信号</p>
<p>进程与线程的区别：<br>进程是程序执行时的实]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Plus One]]></title>
    <link href="http://blog.noobsky.com/2016/09/17/LeetCode-Plus-One/"/>
    <id>http://blog.noobsky.com/2016/09/17/LeetCode-Plus-One/</id>
    <published>2016-09-17T02:59:15.000Z</published>
    <updated>2016-09-17T03:06:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<h2 id="解题思路及代码">解题思路及代码</h2><p>从数字低位往高位循环，如果某位小于9则该位加1后直接返回。否则该位置为0（该位等于9加1进位）继续下一轮循环。如果从低位往高位循环完后程序没有返回，说明程序一直进位，即为9999……，则原来的digits数组已经存不下，需要申请digits.length + 1长度的数组，然后将下标为0的置为1即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public int[] plusOne(int[] digits) &#123;</span></span><br><span class="line">    <span class="comment">//     if(digits == null || digits.length == 0) return null;</span></span><br><span class="line">    <span class="comment">//     int length = digits.length;</span></span><br><span class="line">    <span class="comment">//     for(int i = length -1; i &gt;= 0; i--)&#123;</span></span><br><span class="line">    <span class="comment">//         //遇到第一位小于9的时，该位+1，然后程序返回</span></span><br><span class="line">    <span class="comment">//         if(digits[i] &lt; 9)&#123;</span></span><br><span class="line">    <span class="comment">//             digits[i]++;</span></span><br><span class="line">    <span class="comment">//             return digits;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         //该位等于9，置为0，进行下一轮循环</span></span><br><span class="line">    <span class="comment">//         digits[i] = 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //程序能走到这里的话，则digits中为99999...加1后digits已经存不下。。。</span></span><br><span class="line">    <span class="comment">//     int[] res = new int[digits.length+1];</span></span><br><span class="line">    <span class="comment">//     //最高位置为1，其他位默认初始为0</span></span><br><span class="line">    <span class="comment">//     res[0] = 1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits)&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="keyword">null</span> || digits.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> length = digits.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] &lt; <span class="number">9</span>)&#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are store]]>
    </summary>
    
      <category term="Array" scheme="http://blog.noobsky.com/tags/Array/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="Math" scheme="http://blog.noobsky.com/tags/Math/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实战Java虚拟机之性能监控工具]]></title>
    <link href="http://blog.noobsky.com/2016/09/16/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
    <id>http://blog.noobsky.com/2016/09/16/实战Java虚拟机之性能监控工具/</id>
    <published>2016-09-16T02:31:15.000Z</published>
    <updated>2016-09-16T04:42:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Linux下的性能监控工具">Linux下的性能监控工具</h2><h3 id="显示系统整体资源使用情况–top命令">显示系统整体资源使用情况–top命令</h3><p>top命令的常用用法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line"> Display dynamic real-time information about running processes.</span><br><span class="line"></span><br><span class="line"> - <span class="operator"><span class="keyword">Start</span> top, all options <span class="keyword">are</span> available <span class="keyword">in</span> the <span class="keyword">interface</span>:</span><br><span class="line">   top</span><br><span class="line"></span><br><span class="line"> - <span class="keyword">Start</span> top sorting processes <span class="keyword">by</span> internal <span class="keyword">memory</span> <span class="keyword">size</span> (<span class="keyword">default</span> <span class="keyword">order</span> - process <span class="keyword">ID</span>):</span><br><span class="line">   top -o mem</span><br><span class="line"></span><br><span class="line"> - <span class="keyword">Start</span> top sorting processes <span class="keyword">first</span> <span class="keyword">by</span> CPU, <span class="keyword">then</span> <span class="keyword">by</span> running <span class="keyword">time</span>:</span><br><span class="line">   top -o cpu -O <span class="keyword">time</span></span><br><span class="line"></span><br><span class="line"> - <span class="keyword">Start</span> top displaying <span class="keyword">only</span> processes owned <span class="keyword">by</span> given <span class="keyword">user</span>:</span><br><span class="line">   top -<span class="keyword">user</span> user_name</span><br><span class="line"></span><br><span class="line"> - <span class="keyword">Get</span> <span class="keyword">help</span> about interactive commands:</span><br><span class="line">   ?</span></span><br></pre></td></tr></table></figure></p>
<p>Mac输出如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Processes: 301 total, 2 running, 10 stuck, 289 sleeping, 1502 threads                             11:09:10</span><br><span class="line"><span class="operator"><span class="keyword">Load</span> <span class="keyword">Avg</span>: <span class="number">1.32</span>, <span class="number">1.64</span>, <span class="number">1.54</span>  CPU <span class="keyword">usage</span>: <span class="number">6.52</span>% <span class="keyword">user</span>, <span class="number">6.28</span>% <span class="keyword">sys</span>, <span class="number">87.19</span>% idle</span><br><span class="line">SharedLibs: <span class="number">138</span><span class="keyword">M</span> resident, <span class="number">23</span><span class="keyword">M</span> <span class="keyword">data</span>, <span class="number">16</span><span class="keyword">M</span> linkedit.</span><br><span class="line">MemRegions: <span class="number">42415</span> total, <span class="number">4174</span><span class="keyword">M</span> resident, <span class="number">160</span><span class="keyword">M</span> <span class="keyword">private</span>, <span class="number">830</span><span class="keyword">M</span> <span class="keyword">shared</span>.</span><br><span class="line">PhysMem: <span class="number">7623</span><span class="keyword">M</span> used (<span class="number">1379</span><span class="keyword">M</span> wired), <span class="number">567</span><span class="keyword">M</span> <span class="keyword">unused</span>.</span><br><span class="line">VM: <span class="number">830</span><span class="keyword">G</span> vsize, <span class="number">465</span><span class="keyword">M</span> framework vsize, <span class="number">0</span>(<span class="number">0</span>) swapins, <span class="number">0</span>(<span class="number">0</span>) swapouts.</span><br><span class="line">Networks: packets: <span class="number">95637</span>/<span class="number">48</span><span class="keyword">M</span> <span class="keyword">in</span>, <span class="number">29925</span>/<span class="number">4994</span><span class="keyword">K</span> <span class="keyword">out</span>. Disks: <span class="number">79110</span>/<span class="number">4258</span><span class="keyword">M</span> <span class="keyword">read</span>, <span class="number">25479</span>/<span class="number">598</span><span class="keyword">M</span> written.</span><br><span class="line"></span><br><span class="line">PID   COMMAND      %CPU <span class="keyword">TIME</span>     #TH   #WQ  #PORT MEM    PURG   CMPR PGRP PPID STATE    BOOSTS</span><br><span class="line"><span class="number">1853</span>  mdworker     <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.92</span> <span class="number">5</span>     <span class="number">3</span>    <span class="number">60</span>-   <span class="number">7816</span><span class="keyword">K</span>- <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1853</span> <span class="number">1</span>    sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1852</span>  mdworker     <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.67</span> <span class="number">5</span>     <span class="number">3</span>    <span class="number">50</span>-   <span class="number">6224</span><span class="keyword">K</span>- <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1852</span> <span class="number">1</span>    sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1851</span>  top          <span class="number">2.9</span>  <span class="number">00</span>:<span class="number">00.93</span> <span class="number">1</span>/<span class="number">1</span>   <span class="number">0</span>    <span class="number">23</span>    <span class="number">2320</span><span class="keyword">K</span>  <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1851</span> <span class="number">693</span>  running  *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1829</span>  Atom Helper  <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">03.52</span> <span class="number">5</span>     <span class="number">0</span>    <span class="number">53</span>    <span class="number">28</span><span class="keyword">M</span>    <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1645</span> <span class="number">1649</span> sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1649</span>  Atom Helper  <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">08.96</span> <span class="number">19</span>    <span class="number">0</span>    <span class="number">129</span>   <span class="number">176</span><span class="keyword">M</span>   <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1645</span> <span class="number">1645</span> sleeping *<span class="number">0</span>[<span class="number">7</span>]</span><br><span class="line"><span class="number">1648</span>  crashpad_han <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.01</span> <span class="number">4</span>     <span class="number">0</span>    <span class="number">28</span>    <span class="number">848</span><span class="keyword">K</span>   <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1647</span> <span class="number">1</span>    sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1646</span>  Atom Helper  <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.48</span> <span class="number">5</span>     <span class="number">0</span>    <span class="number">86</span>    <span class="number">13</span><span class="keyword">M</span>    <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1645</span> <span class="number">1645</span> sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1645</span>  Atom         <span class="number">0.1</span>  <span class="number">00</span>:<span class="number">02.94</span> <span class="number">33</span>    <span class="number">2</span>    <span class="number">347</span>   <span class="number">56</span><span class="keyword">M</span>+   <span class="number">12</span><span class="keyword">K</span>    <span class="number">0</span>B   <span class="number">1645</span> <span class="number">1</span>    sleeping *<span class="number">0</span>[<span class="number">31</span>]</span><br><span class="line"><span class="number">1360</span>  Google Chrom <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">07.10</span> <span class="number">18</span>    <span class="number">0</span>    <span class="number">133</span>   <span class="number">189</span><span class="keyword">M</span>   <span class="number">24</span><span class="keyword">K</span>    <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">2</span>]</span><br><span class="line"><span class="number">1350</span>  Google Chrom <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.33</span> <span class="number">6</span>     <span class="number">0</span>    <span class="number">69</span>    <span class="number">15</span><span class="keyword">M</span>    <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">1346</span>  ShadowsocksX <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.45</span> <span class="number">6</span>     <span class="number">2</span>    <span class="number">150</span>   <span class="number">8536</span><span class="keyword">K</span>  <span class="number">4096</span>B  <span class="number">0</span>B   <span class="number">1346</span> <span class="number">1</span>    sleeping *<span class="number">0</span>[<span class="number">108</span>]</span><br><span class="line"><span class="number">1321</span>  com.apple.hi <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.01</span> <span class="number">2</span>     <span class="number">0</span>    <span class="number">34</span>    <span class="number">948</span><span class="keyword">K</span>   <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1321</span> <span class="number">1</span>    sleeping  <span class="number">0</span>[<span class="number">3</span>]</span><br><span class="line"><span class="number">1319</span>  Google Chrom <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">04.21</span> <span class="number">14</span>    <span class="number">0</span>    <span class="number">118</span>   <span class="number">98</span><span class="keyword">M</span>+   <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">2</span>]</span><br><span class="line"><span class="number">1318</span>  systemstatsd <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">00.06</span> <span class="number">2</span>     <span class="number">1</span>    <span class="number">21</span>    <span class="number">1108</span><span class="keyword">K</span>  <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">1318</span> <span class="number">1</span>    sleeping  <span class="number">0</span>[<span class="number">4</span>]</span><br><span class="line"><span class="number">1317</span>  Google Chrom <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">03.80</span> <span class="number">11</span>    <span class="number">0</span>    <span class="number">112</span>   <span class="number">75</span><span class="keyword">M</span>+   <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">2</span>]</span><br><span class="line"><span class="number">1316</span>  Google Chrom <span class="number">0.0</span>  <span class="number">00</span>:<span class="number">03.90</span> <span class="number">13</span>    <span class="number">0</span>    <span class="number">116</span>   <span class="number">100</span><span class="keyword">M</span>+  <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">2</span>]</span><br><span class="line"><span class="number">1315</span>  Google Chrom <span class="number">0.4</span>  <span class="number">00</span>:<span class="number">11.81</span> <span class="number">14</span>    <span class="number">0</span>    <span class="number">117</span>   <span class="number">147</span><span class="keyword">M</span>+  <span class="number">0</span>B     <span class="number">0</span>B   <span class="number">268</span>  <span class="number">268</span>  sleeping *<span class="number">0</span>[<span class="number">2</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>linux输出如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">top - <span class="number">23</span>:<span class="number">11</span>:<span class="number">30</span> up <span class="number">47</span> min,  <span class="number">2</span> users,  load average: <span class="number">0.04</span>, <span class="number">0.44</span>, <span class="number">0.32</span></span><br><span class="line">Tasks:  <span class="number">68</span> total,   <span class="number">2</span> running,  <span class="number">66</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%Cpu(s):  <span class="number">0.0</span> us,  <span class="number">0.0</span> sy,  <span class="number">0.0</span> ni,<span class="number">100.0</span> id,  <span class="number">0.0</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">KiB Mem :   <span class="number">500840</span> total,   <span class="number">222072</span> <span class="built_in">free</span>,    <span class="number">51972</span> used,   <span class="number">226796</span> buff/cache</span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> <span class="built_in">free</span>,        <span class="number">0</span> used.   <span class="number">424868</span> avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">41224</span>   <span class="number">3748</span>   <span class="number">2400</span> S  <span class="number">0.0</span>  <span class="number">0.7</span>   <span class="number">0</span>:<span class="number">02.48</span> systemd</span><br><span class="line">    <span class="number">2</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kthreadd</span><br><span class="line">    <span class="number">3</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> ksoftirqd/<span class="number">0</span></span><br><span class="line">    <span class="number">5</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">0</span>:<span class="number">0</span>H</span><br><span class="line">    <span class="number">7</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> migration/<span class="number">0</span></span><br><span class="line">    <span class="number">8</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_bh</span><br><span class="line">    <span class="number">9</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcuob/<span class="number">0</span></span><br><span class="line">   <span class="number">10</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.48</span> rcu_sched</span><br><span class="line">   <span class="number">11</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> R  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.53</span> rcuos/<span class="number">0</span></span><br><span class="line">   <span class="number">12</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.02</span> watchdog/<span class="number">0</span></span><br><span class="line">   <span class="number">13</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> khelper</span><br><span class="line">   <span class="number">14</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kdevtmpfs</span><br><span class="line">   <span class="number">15</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> netns</span><br><span class="line">   <span class="number">16</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> perf</span><br><span class="line">   <span class="number">17</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> writeback</span><br><span class="line">   <span class="number">18</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kintegrityd</span><br><span class="line">   <span class="number">19</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> bioset</span><br><span class="line">   <span class="number">20</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kblockd</span><br></pre></td></tr></table></figure></p>
<p>linux中top命令的输出可以分为两个部分：前半部分是系统统计信息，后半部分是进程信息。</p>
<h3 id="监控内存和CPU–vmstat命令">监控内存和CPU–vmstat命令</h3><p>vmstat也是一款功能比较齐全的性能监测工具。它可以统计CPU、内存使用情况、swap使用情况等信息。还可以指定采样周期和采样次数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]<span class="preprocessor"># vmstat <span class="number">1</span> <span class="number">3</span></span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   <span class="built_in">free</span>   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">2</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">222352</span>  <span class="number">16104</span> <span class="number">210788</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">72</span>    <span class="number">69</span>   <span class="number">93</span>  <span class="number">281</span>  <span class="number">3</span>  <span class="number">1</span> <span class="number">96</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">222336</span>  <span class="number">16104</span> <span class="number">210788</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">40</span>   <span class="number">71</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>      <span class="number">0</span> <span class="number">222336</span>  <span class="number">16104</span> <span class="number">210788</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">33</span>   <span class="number">64</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">100</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="监控IO使用–iostat命令">监控IO使用–iostat命令</h3><p>iostat可以提供详尽的I/O信息，它的基本使用如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="多功能诊断器–pidstat工具">多功能诊断器–pidstat工具</h3><p>pidstat是一个功能强大的性能监测工具，它也是Sysstat组件之一。</p>
<p>如果是Debian / Ubuntu系统，可以使用以下命令安装：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> install sysstat</span><br></pre></td></tr></table></figure></p>
<p>如果是CentOS / Fedora / RHEL系统，可以使用以下命令安装：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> sysstat</span><br></pre></td></tr></table></figure></p>
<p>pidstat强大之处在于，它不仅可以监视进程的性能情况，也可以监视线程的性能情况。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Linux下的性能监控工具">Linux下的性能监控工具</h2><h3 id="显示系统整体资源使用情况–top命令">显示系统整体资源使用情况–top命令</h3><p>top命令的常用用法如下：<br><figure class="highlight sql]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL高可用]]></title>
    <link href="http://blog.noobsky.com/2016/09/12/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>http://blog.noobsky.com/2016/09/12/MySQL高可用/</id>
    <published>2016-09-12T01:48:40.000Z</published>
    <updated>2016-09-21T02:32:24.000Z</updated>
    <content type="html"><![CDATA[<p>lvs+keepalived+MySQL</p>
<p>DRBD + Heartbeat + MySQL</p>
<p>MHA</p>
<p>MMM</p>
<p>NDB</p>
<p>proxy</p>
<p>zookeeper</p>
<p>mysql主从延迟：</p>
<p>半同步复制<br>redis缓存<br>读主库</p>
<p>dubbo:分布式服务框架</p>
<p>cobar：基于MySQL的分布式数据库服务中间件</p>
<p>面向切面的缺点</p>
<p>hash索引和b-tree索引的区别</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>lvs+keepalived+MySQL</p>
<p>DRBD + Heartbeat + MySQL</p>
<p>MHA</p>
<p>MMM</p>
<p>NDB</p>
<p>proxy</p>
<p>zookeeper</p>
<p>mysql主从延迟：</p>]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Element]]></title>
    <link href="http://blog.noobsky.com/2016/09/08/LeetCode-Remove-Element/"/>
    <id>http://blog.noobsky.com/2016/09/08/LeetCode-Remove-Element/</id>
    <published>2016-09-08T02:54:54.000Z</published>
    <updated>2016-09-17T03:08:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example:</strong><br>Given input array nums = [3,2,2,3], val = 3</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p><strong>Hint:</strong></p>
<ol>
<li>Try two pointers.</li>
<li>Did you use the property of “the order of elements can be changed”?</li>
<li>What happens when the elements to remove are rare?</li>
</ol>
<h2 id="解题思路与代码">解题思路与代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//并不需要真正删除元素，我们只需要返回“删除”元素后数组的新长度</span></span><br><span class="line">    <span class="comment">//时间复杂度：O(n),该方法关注于不等于val的元素，如果含有很多不等于val的元素，则浪费很多的移动次数</span></span><br><span class="line">    <span class="comment">//比如[1,2,3,5,4],val为4的时候</span></span><br><span class="line">    <span class="comment">// public int removeElement(int[] nums, int val) &#123;</span></span><br><span class="line">    <span class="comment">//     int begin = 0;</span></span><br><span class="line">    <span class="comment">//     //遍历数组，将所有不等于val元素依次放入原数组中（从index=0的地方依次往后放）</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] != val) nums[begin++] = nums[i];</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return begin;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//上面的解法关注不等于val的元素，同理我们的关注点也可以是等于val的元素</span></span><br><span class="line">    <span class="comment">//我们可以将数组尾部的元素移动到等于val的元素的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                nums[i] = nums[n-<span class="number">1</span>];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>Do not a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="Two Pointers" scheme="http://blog.noobsky.com/tags/Two-Pointers/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Reverse Vowels of a String]]></title>
    <link href="http://blog.noobsky.com/2016/09/08/LeetCode-Reverse-Vowels-of-a-String/"/>
    <id>http://blog.noobsky.com/2016/09/08/LeetCode-Reverse-Vowels-of-a-String/</id>
    <published>2016-09-08T01:59:35.000Z</published>
    <updated>2016-09-08T02:06:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p><strong>Example 1:</strong><br>Given s = “hello”, return “holle”.</p>
<p><strong>Example 2:</strong><br>Given s = “leetcode”, return “leotcede”.</p>
<p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p>
<h2 id="解题思路与代码">解题思路与代码</h2><p>题意是让我们翻转字符串中的元音字母，元音字母有a、e、i、o、u，大小写总共10个。我们使用两个左右指针，左指针从左往右遍历直到找到元音字母，右指针从右往左遍历直到找到元音字母，然后交换左右指针指向的元音字母。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String vowels = <span class="string">"aeiouAEIOU"</span>;</span><br><span class="line">    <span class="comment">// public String reverseVowels(String s) &#123;</span></span><br><span class="line">    <span class="comment">//     if(s == null || s.length() == 0) return s;</span></span><br><span class="line">    <span class="comment">//     char[] chs = s.toCharArray();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int length = chs.length;</span></span><br><span class="line">    <span class="comment">//     int left = 0;</span></span><br><span class="line">    <span class="comment">//     int right = length - 1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     char temp;</span></span><br><span class="line">    <span class="comment">//     while(left &lt; right)&#123;</span></span><br><span class="line">    <span class="comment">//         while(left &lt; right &amp;&amp; !isVowels(chs[left])) left++;</span></span><br><span class="line">    <span class="comment">//         while(left &lt; right &amp;&amp; !isVowels(chs[right])) right--;</span></span><br><span class="line">    <span class="comment">//         temp = chs[left];</span></span><br><span class="line">    <span class="comment">//         chs[left] = chs[right];</span></span><br><span class="line">    <span class="comment">//         chs[right] = temp;</span></span><br><span class="line">    <span class="comment">//         left++;</span></span><br><span class="line">    <span class="comment">//         right--;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return new String(chs);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public boolean isVowels(char c)&#123;</span></span><br><span class="line">    <span class="comment">//     c = Character.toLowerCase(c);</span></span><br><span class="line">    <span class="comment">//     if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') return true;</span></span><br><span class="line">    <span class="comment">//     return false;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = chs.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; vowels.indexOf(chs[left])==-<span class="number">1</span>) left++;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; vowels.indexOf(chs[right])==-<span class="number">1</span>) right--;</span><br><span class="line">            temp = chs[left];</span><br><span class="line">            chs[left] = chs[right];</span><br><span class="line">            chs[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p><strong>Example 1:</]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="String" scheme="http://blog.noobsky.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://blog.noobsky.com/tags/Two-Pointers/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发编程之线程池]]></title>
    <link href="http://blog.noobsky.com/2016/09/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://blog.noobsky.com/2016/09/05/Java并发编程之线程池/</id>
    <published>2016-09-05T07:35:24.000Z</published>
    <updated>2016-09-07T08:38:51.000Z</updated>
    <content type="html"><![CDATA[<p>多线程可以最大限度的发挥多核处理器的计算能力，提高生成系统的吞吐量和性能。但是，若不加控制和管理地随意使用线程，对系统的性能反而会产生不利的影响。在真实的生产环境中，当线程数量过大时，有可能耗尽CPU和内存资源。</p>
<p>首先，虽然与进程相比，线程是一种轻量级的工具，但其创建和关闭依然需要花费时间，如果为每一个小任务都创建一个线程，很有可能出现创建和销毁线程所占用的时间大于该线程真实工作所消耗时间的情况，反而会得不偿失。</p>
<p>其次，线程本身也是要占用内存空间的，大量的线程会抢占宝贵的内存资源，如果处理不当，可能会导致Out of Memory异常。即便没有，大量的线程回收也会给GC带来很大的压力，延长GC的停顿时间。</p>
<p>所以，对线程的使用要适度，在有限范围内，增加线程的数量可以明显提高系统吞吐量，但超出范围，大量线程只会拖垮应用系统。因此，在生产环境中使用线程，必须加以控制和管理。</p>
<p>为了避免系统频繁地创建和销毁线程，我们可以让创建的线程进行复用。就是线程执行完一个任务，并不被销毁，而是可以继续执行其他的任务。Java中可以通过线程池来达到这样的效果。</p>
<h2 id="JDK对线程池的支持">JDK对线程池的支持</h2><p>为了更好的控制多线程，JDK提供了一套Executor框架，帮助开发人员有效地进行线程控制，其本质就是一个线程池。核心成员的UML类图如下：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E5%9B%BE.jpg" alt=""></p>
<p>Executor是顶层接口，里面只有一个方法execute(Runnable command)，返回值为void，参数为Runnable类型，顾名思义，就是用来执行传进去的任务的。而ExecutorService接口继承了Executor接口，并声明了一些方法，包括shutdown、isShutdown、isTerminated、submit、invokeAll、invokeAny等方法。然后抽象类AbstractExecutorService实现了ExecutorService接口。ThreadPoolExecutor继承了抽象类AbstractExecutorService。ThreadPoolExecutor类中有几个非常重要的方法：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">submit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">shutdownNow</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>execute方法实际上是接口Executor中声明的方法，在ThreadPoolExecutor中进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，这个方法可以向线程池提交一个任务，交由线程池去执行。</p>
<p>submit方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，查看源码可以发现，会发现submit内部也是调用execute方法的，只不过它利用了Future来获取任务执行的结果。还有很多其他方法，这里就不一一介绍了。</p>
<p>Executors则扮演着线程池工厂的角色，通过Executors可以取得一个拥有特定功能的线程池。ThreadPoolExecutor类实现了Executor接口，因此通过这个接口，任何Runable的对象都可以被ThreadPoolExecutor线程池调度。</p>
<p>Executors主要提供了以下工厂方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure></p>
<p>以上工厂方法分别返回不同工作特性的线程池。这些线程池工厂方法具体说明如下：</p>
<ul>
<li><p>newFixedThreadPool()方法：该方法返回一个固定线程数量的线程池。该线程池的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>
</li>
<li><p>newSingleThreadExecutor()方法：该方法返回只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行任务中的队列。</p>
</li>
<li><p>newCachedThreadPool()方法：该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池复用。</p>
</li>
<li><p>newSingleThreadScheduledExecutor()方法：该方法返回一个ScheduleExecutorService对象，线程池大小为1。ScheduledExecutorService 接口在ExecutorService接口之上扩展了在给定时间执行某任务的功能，如在某个固定的延时之后执行，或者周期性执行某个任务。</p>
</li>
<li><p>newScheduledThreadPool()方法：该方法也返回一个ScheduleExecutorService对象，但该线程池可以指定线程数量。</p>
</li>
</ul>
<h2 id="深入理解线程池内部实现">深入理解线程池内部实现</h2><p>对于核心的几个线程池，无论是newFixedThreadPool()方法、newSingleThreadExecutor()还是newCachedThreadPool()方法，虽然看起来创建的线程有着完全不同的功能特点，但其内部实现均使用ThreadPoolExecutor来实现的。这三种线程池的实现方式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由以上源码可知，它们都是ThreadPoolExecutor类的封装。我们首先来看一下ThreadPoolExecutor的实现</p>
<h3 id="线程池状态">线程池状态</h3><h3 id="线程池状态-1">线程池状态</h3><p>定义了几个static final变量表示线程池的各个状态：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>先看看文档：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The runState provides the main lifecyle control, taking <span class="keyword">on</span> values:</span><br><span class="line"></span><br><span class="line">RUNNING:  Accept <span class="keyword">new</span> tasks <span class="keyword">and</span> <span class="keyword">process</span> queued tasks</span><br><span class="line">SHUTDOWN: Don<span class="attribute">'t</span> accept <span class="keyword">new</span> tasks, but <span class="keyword">process</span> queued tasks</span><br><span class="line">STOP:     Don<span class="attribute">'t</span> accept <span class="keyword">new</span> tasks, don<span class="attribute">'t</span> <span class="keyword">process</span> queued tasks,<span class="keyword">and</span> interrupt <span class="keyword">in</span>-progress tasks</span><br><span class="line">TIDYING:  <span class="keyword">All</span> tasks have terminated, workerCount <span class="keyword">is</span> zero,the thread transitioning <span class="keyword">to</span> state TIDYING will run the terminated() hook method</span><br><span class="line">TERMINATED: terminated() has completed</span><br></pre></td></tr></table></figure></p>
<p>ThreadPoolExecutor线程池有五个状态，分别为：</p>
<ul>
<li>RUNNING: 可以接受新的任务，也可以处理阻塞队列里的任务</li>
<li>SHUTDOWN: 不接受新的任务，但是可以处理阻塞队列里的任务</li>
<li>STOP: 不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务</li>
<li>TIDYING: 过渡状态，也就是说所有的任务都执行完了，当前线程池已经没有有效线程，此时线程池的状态将会为TIDYING，并且将要调用terminated方法</li>
<li>TERMINATED: 终止状态。terminated方法调用完成以后的方法</li>
</ul>
<p>各状态的相互转换如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RUNNING</span> -&gt; <span class="type">SHUTDOWN</span></span><br><span class="line">    <span class="type">On</span> invocation <span class="keyword">of</span> shutdown(), perhaps implicitly <span class="keyword">in</span> finalize()</span><br><span class="line">(<span class="type">RUNNING</span> <span class="keyword">or</span> <span class="type">SHUTDOWN</span>) -&gt; <span class="type">STOP</span></span><br><span class="line">    <span class="type">On</span> invocation <span class="keyword">of</span> shutdownNow()</span><br><span class="line"><span class="type">SHUTDOWN</span> -&gt; <span class="type">TIDYING</span></span><br><span class="line">    <span class="type">When</span> both queue <span class="keyword">and</span> pool are empty</span><br><span class="line"><span class="type">STOP</span> -&gt; <span class="type">TIDYING</span></span><br><span class="line">    <span class="type">When</span> pool <span class="keyword">is</span> empty</span><br><span class="line"><span class="type">TIDYING</span> -&gt; <span class="type">TERMINATED</span></span><br><span class="line">    <span class="type">When</span> the terminated() hook <span class="keyword">method</span> has completed</span><br></pre></td></tr></table></figure></p>
<p>ThreadPoolExecutor内部还保存着线程池的有效线程个数，状态和线程数在ThreadPoolExecutor内部使用一个原子整形变量保存。那么是如何做到的呢？</p>
<p>java中整型占四个字节，即32位，在ThreadPoolExecutor，整形32位的前三位用来表示线程池的状态，后29位用来表示线程池中有效的线程个数。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前3位表示状态，后29位用来表示线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.<span class="keyword">SIZE</span> - <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>线程池的容量为(1&lt;<29)-1= 00011111111111111111111111111111(二进制，约500="" million)，代码如下：="" <figure="" class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></29)-1=></p>
<p>表示RUNNING状态的代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<p>-1用二进制表示是：11111111111111111111111111111111(这是补码表示，不明白可以补补原码，反码，补码的知识)<br>则 -1 &lt;&lt; 29 = 11111111111111111111111111111111 &lt;&lt; 29 = 11100000000000000000000000000000(前3位为111)</p>
<p>表示SHUTDOWN状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即0 &lt;&lt; 29 = 00000000000000000000000000000000 &lt;&lt; 29 = 00000000000000000000000000000000(前3位为000)</p>
<p>表示STOP状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即 1 &lt;&lt; 29 = 00000000000000000000000000000001 &lt;&lt; 29 = 00100000000000000000000000000000(前3位为001)</p>
<p>表示TIDYING状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即 2 &lt;&lt; 29 = 00000000000000000000000000000010 &lt;&lt; 29 = 01000000000000000000000000000000(前3位为010)</p>
<p>表示TERMINATED状态的代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>即 3 &lt;&lt; 29 = 00000000000000000000000000000011 &lt;&lt; 29 = 01100000000000000000000000000000(前3位为011)</p>
<p>所以我们可以通过整数的二进制中后29位来获取线程数，前3位来获取线程的状态：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">//该方法获取状态，CAPACITY的非操作得到的二进制位11100000000000000000000000000000，然后做在一个与操作，相当于直接取前3位的的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//该方法获取线程数，取后29位。CAPACITY常量值为(1&lt;&lt;29)-1= 00011111111111111111111111111111。与CAPACITY相与的话，前三位相与为0，即可得后29位。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 或操作。更新代表线程数量和状态的整形变量。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadPoolExecutor还有一些重要的成员变量：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">private final BlockingQueue<span class="variable">&lt;Runnable&gt;</span> workQueue;//任务阻塞队列，用来存放等待执行的任务</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Lock held on access to workers set and related bookkeeping.</span><br><span class="line"> <span class="keyword">*</span> While we could use a concurrent set of some sort, it turns out</span><br><span class="line"> <span class="keyword">*</span> to be generally preferable to use a lock. Among the reasons is</span><br><span class="line"> <span class="keyword">*</span> that this serializes interruptIdleWorkers, which avoids</span><br><span class="line"> <span class="keyword">*</span> unnecessary interrupt storms, especially during shutdown.</span><br><span class="line"> <span class="keyword">*</span> Otherwise exiting threads would concurrently interrupt those</span><br><span class="line"> <span class="keyword">*</span> that have not yet interrupted. It also simplifies some of the</span><br><span class="line"> <span class="keyword">*</span> associated statistics bookkeeping of largestPoolSize etc. We</span><br><span class="line"> <span class="keyword">*</span> also hold mainLock on shutdown and shutdownNow, for the sake of</span><br><span class="line"> <span class="keyword">*</span> ensuring workers set is stable while separately checking</span><br><span class="line"> <span class="keyword">*</span> permission to interrupt and actually interrupting.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private final ReentrantLock mainLock = new ReentrantLock();//线程池的状态锁，对线程状态（如线程池大小、runState等）的改变都要使用这个锁</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Set containing all worker threads in pool. Accessed only when</span><br><span class="line"> <span class="keyword">*</span> holding mainLock.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private final HashSet<span class="variable">&lt;Worker&gt;</span> workers = new HashSet<span class="variable">&lt;Worker&gt;</span>();//用来存放工作集</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Wait condition to support awaitTermination</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private final Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Tracks largest attained pool size. Accessed only under</span><br><span class="line"> <span class="keyword">*</span> mainLock.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private int largestPoolSize;//用来记录线程池曾出现过的最大线程数</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Counter for completed tasks. Updated only on termination of</span><br><span class="line"> <span class="keyword">*</span> worker threads. Accessed only under mainLock.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private long completedTaskCount;//已完成任务计数器</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> All user control parameters are declared as volatiles so that</span><br><span class="line"> <span class="keyword">*</span> ongoing actions are based on freshest values, but without need</span><br><span class="line"> <span class="keyword">*</span> for locking, since no internal invariants depend on them</span><br><span class="line"> <span class="keyword">*</span> changing synchronously with respect to other actions.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Factory for new threads. All threads are created using this</span><br><span class="line"> <span class="keyword">*</span> factory (via method addWorker).  All callers must be prepared</span><br><span class="line"> <span class="keyword">*</span> for addWorker to fail, which may reflect a system or user's</span><br><span class="line"> <span class="keyword">*</span> policy limiting the number of threads.  Even though it is not</span><br><span class="line"> <span class="keyword">*</span> treated as an error, failure to create threads may result in</span><br><span class="line"> <span class="keyword">*</span> new tasks being rejected or existing ones remaining stuck in</span><br><span class="line"> <span class="keyword">*</span> the queue.</span><br><span class="line"> <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> We go further and preserve pool invariants even in the face of</span><br><span class="line"> <span class="keyword">*</span> errors such as OutOfMemoryError, that might be thrown while</span><br><span class="line"> <span class="keyword">*</span> trying to create threads.  Such errors are rather common due to</span><br><span class="line"> <span class="keyword">*</span> the need to allocate a native stack in Thread<span class="comment">#start, and users</span></span><br><span class="line"> <span class="keyword">*</span> will want to perform clean pool shutdown to clean up.  There</span><br><span class="line"> <span class="keyword">*</span> will likely be enough memory available for the cleanup code to</span><br><span class="line"> <span class="keyword">*</span> complete without encountering yet another OutOfMemoryError.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile ThreadFactory threadFactory;//线程工厂，用来创建线程</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Handler called when saturated or shutdown in execute.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile RejectedExecutionHandler handler;//任务拒绝策略</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Timeout in nanoseconds for idle threads waiting for work.</span><br><span class="line"> <span class="keyword">*</span> Threads use this timeout when there are more than corePoolSize</span><br><span class="line"> <span class="keyword">*</span> present or if allowCoreThreadTimeOut. Otherwise they wait</span><br><span class="line"> <span class="keyword">*</span> forever for new work.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile long keepAliveTime; //闲置线程的存活时间</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> If false (default), core threads stay alive even when idle.</span><br><span class="line"> <span class="keyword">*</span> If true, core threads use keepAliveTime to time out waiting</span><br><span class="line"> <span class="keyword">*</span> for work.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile boolean allowCoreThreadTimeOut;//是否允许为核心线程设置存活时间</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Core pool size is the minimum number of workers to keep alive</span><br><span class="line"> <span class="keyword">*</span> (and not allow to time out etc) unless allowCoreThreadTimeOut</span><br><span class="line"> <span class="keyword">*</span> is set, in which case the minimum is zero.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile int corePoolSize;//核心池的大小，当线程池中的线程数目大于这个参数时，提交的任务会被放进任务阻塞队列中</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Maximum pool size. Note that the actual maximum is internally</span><br><span class="line"> <span class="keyword">*</span> bounded by CAPACITY.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">private volatile int maximumPoolSize;//线程池最大能容忍的线程数</span><br></pre></td></tr></table></figure></p>
<h3 id="构造函数">构造函数</h3><p>ThreadPoolExecutor最重要的构造函数：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler <span class="keyword">handler</span>)</span><br></pre></td></tr></table></figure>
<p>函数的参数含义如下：</p>
<ul>
<li>corePoolSize: 指定线程池中的线程数量</li>
<li>maximumPoolSize: 指定了线程池中的最大线程数量</li>
<li>keepAliveTime: 当线程池线程数量超过corePoolSize时，多余的空闲线程的存活时间。即，超过corePoolSize的空闲线程，在多长时间内，会被销毁。</li>
<li>unit: keepAliveTime的单位</li>
<li>workQueue: 任务队列，被提交但尚未被执行的任务。</li>
<li>threadFactory: 线程工厂，用于创建线程，一般用默认的即可。</li>
<li>handler: 拒绝策略。当任务太多来不及处理，如何拒绝任务。</li>
</ul>
<h3 id="任务执行">任务执行</h3><p>在ThreadPoolExecutor类中，最核心的任务执行方法是execute和submit，submit方法也是通过调用execute方法来完成任务的执行。execute方法的源码如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">         * start a new thread with the given command as its first</span><br><span class="line">         * task.  The call to addWorker atomically checks runState and</span><br><span class="line">         * workerCount, and so prevents false alarms that would add</span><br><span class="line">         * threads when it shouldn't, by returning false.</span><br><span class="line">         *</span><br><span class="line">         * 2. If a task can be successfully queued, then we still need</span><br><span class="line">         * to double-check whether we should have added a thread</span><br><span class="line">         * (because existing ones died since last checking) or that</span><br><span class="line">         * the pool shut down since entry into this method. So we</span><br><span class="line">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">         * stopped, or start a new thread if there are none.</span><br><span class="line">         *</span><br><span class="line">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">         * and so reject the task.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<span class="comment">//第1步，线程池中的线程大小小于corePoolSize</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))<span class="comment">//true表示使用corePoolSize,false表示使用maximumPoolSize</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.<span class="keyword">get</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">//第2步，线程池的线程大小大于corePoolSize，而且线程池是RUNNING状态，阻塞队列也没满，加入到阻塞队列中</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.<span class="keyword">get</span>();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<span class="comment">//需要进行第二次判断，防止线程池被关闭了</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">workerCountOf(recheck</span>) </span>== <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">!addWorker(command, <span class="keyword">false</span></span>))<span class="comment">//第3步，使用线程池maximumPoolSize(最大大小)</span></span><br><span class="line">            <span class="title">reject</span>(<span class="params">command</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>由代码中的注释可知，execute方法分三步处理：</p>
<ol>
<li>如果当前正在执行的Worker数量比corePoolSize小，则直接通过addWorker方法创建一个新的Worker执行任务。</li>
<li>如果当前正在执行的Worker数量大于等于corePoolSize。将任务放到阻塞队列里，如果阻塞队列没满并且状态是RUNNING时，直接加入到阻塞队列中，否则跳到第三步。加入到阻塞队列后，还需要再验证一次（加入到聚在队列之后可能另外一个线程关闭了线程池或者刚加入到队列的线程死了）。如果此时线程池不是RUNNING状态，则把刚加入到阻塞队列中的任务remove掉，然后调用reject方法，否则查看Worker数量，如果Worker数量为0，起一个新的Worker去阻塞队列里拿任务执行。</li>
<li>加入阻塞队列失败时，会调用addWorker方法尝试起一个新的Worker去阻塞队列中拿任务并执行任务，如果addWorker调用失败，调用reject方法。</li>
</ol>
<h3 id="任务缓存队列">任务缓存队列</h3><ul>
<li><p>同步队列(SynchronousQueue)：该队列是直接提交的，是一个特殊的BlockingQueue。SynchronousQueue没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除操作都要等待对应的插入操作。如果使用SynchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程，则尝试创建新的线程，如果线程数已经达到最大值，则执行拒绝策略。因此，使用SynchronousQueue队列，通常需要设置很大的maximumPoolSize，否则很容易执行拒绝策略。</p>
</li>
<li><p>ArrayBlockingQueue</p>
</li>
<li><p>LinkedBlockingQueue：是无界任务队列，除非系统资源耗尽，否则无界的任务队列不存在入队失败的情况。当有新的任务到来，系统的线程数小于corePoolSize时，线程池会生成新的线程执行任务，但当系统的线程数达到corePoolSize后，就不会继续增加。若后续仍有新的任务加入，而又没有空闲的线程资源，则任务直接进入队列等待。若任务创建失败和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。</p>
</li>
<li><p>PriorityBlockingQueue：优先任务队列带有执行优先级，可以控制任务执行的先后顺序。ArrayBlockingQueue和LinkedBlockingQueue都是按照先进先出算法处理任务。而PriorityBlockingQueue则可以根据任务自身的优先级顺序先后执行。</p>
</li>
</ul>
<h3 id="任务拒绝策略">任务拒绝策略</h3><ul>
<li>AbortPolicy策略：丢弃任务并抛出RejectedExecutionException异常</li>
<li>CallerRunsPolicy策略：在调用者线程中运行当前被丢弃的任务</li>
<li>DiscardOldestPolicy策略：丢弃最老的任务，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li>
<li>DiscardPolicy策略：丢弃任务，但不抛出异常。</li>
</ul>
<h3 id="线程池的关闭">线程池的关闭</h3><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p>
<ul>
<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
<h3 id="线程工厂">线程工厂</h3><h3 id="扩展线程池">扩展线程池</h3><h3 id="线程池的大小">线程池的大小</h3><h2 id="参考文献">参考文献</h2><p><a href="http://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/" target="_blank" rel="external">Java线程池ThreadPoolExecutor源码分析</a><br><a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="external">Java并发编程：线程池的使用</a><br><a href="http://www.ticmy.com/?p=243" target="_blank" rel="external">hotspot1.7 ThreadPoolExecutor代码解析</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>多线程可以最大限度的发挥多核处理器的计算能力，提高生成系统的吞吐量和性能。但是，若不加控制和管理地随意使用线程，对系统的性能反而会产生不利的影响。在真实的生产环境中，当线程数量过大时，有可能耗尽CPU和内存资源。</p>
<p>首先，虽然与进程相比，线程是一种轻量级的工具，]]>
    </summary>
    
      <category term="Java线程池" scheme="http://blog.noobsky.com/tags/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实战Java虚拟机之锁与并发]]></title>
    <link href="http://blog.noobsky.com/2016/09/05/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E9%94%81%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    <id>http://blog.noobsky.com/2016/09/05/实战Java虚拟机之锁与并发/</id>
    <published>2016-09-05T02:17:39.000Z</published>
    <updated>2016-09-16T09:22:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="对象头和锁">对象头和锁</h2><p>在JVM的实现中每个对象都有一个对象头，用于保存对象的系统信息。对象头中有一个成为Mark Word的部分，它是实现锁的关键。在32位系统中，Mark Word为一个32位的数据，在64位系统中，它占64位。它是一个多功能的数据区，可以存放对象的哈希值、对象年龄、锁的指针等信息。一个对象是否占用锁，占有哪个锁，就记录在这个Mark Word中。</p>
<p>以32位系统为例，普通对象头如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash:<span class="number">25</span> ------------&gt; | age:<span class="number">4</span>   biased_lock:<span class="number">1</span> lock:<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>它表示Mark Word中有25位比特表示对象的哈希值，4位比特表示对象的年龄，1位比特表示是否为偏向锁，2位比特表示锁的信息。</p>
<p>对于偏向锁的对象，它的格式表示如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[JavaThread<span class="keyword">*</span> |<span class="string"> epoch </span>|<span class="string"> age </span>|<span class="string"> 1 </span>|<span class="string"> 01]</span></span><br></pre></td></tr></table></figure></p>
<p>前23位表示持有偏向锁的线程，后续2位比特表示偏向锁的时间戳（epoch），4位比特表示对象年龄，年龄后1位比特固定为1，表示偏向锁，最后两位为01表示可偏向/未锁定。</p>
<p>当对象处于轻量级锁定时，其Mark Word如下（00表示最后2位的值）：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[ptr               | 00]</span> <span class="keyword">locked</span></span><br></pre></td></tr></table></figure></p>
<p>此时，它指向存放在获得锁的线程栈中的该对象真实对象头。</p>
<p>当对象处于重量级锁定时，其Mark Word如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="preprocessor">ptr</span>               | <span class="number">10</span>] <span class="keyword">monitor</span></span><br></pre></td></tr></table></figure></p>
<p>此时，最后2位为10，整个Mark Word表示指向Monitor的指针。</p>
<p>当对象处于普通的未锁定状态时，其格式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Header        | <span class="number">0</span> | <span class="number">01</span>] unlocked</span><br></pre></td></tr></table></figure></p>
<p>前29位表示对象的哈希值、年龄信息。倒数第3位为0，最后两位为01，表示未锁定。可以发现，最后两位的值和偏向状态时是一样的，此时，虚拟机正是通过倒数第3位比特来区分是否为偏向锁。</p>
<h2 id="所在Java虚拟机中的实现和优化">所在Java虚拟机中的实现和优化</h2><h3 id="偏向锁">偏向锁</h3><p>偏向锁是JDK 1.6提出的一种锁优化方式。其核心思想是，如果程序没有竞争，则取消之前已经取得锁的线程同步操作。也就说，若某一锁被线程获取后，便进入偏向模式，当线程再次请求这个锁时，无需再进行相关的同步操作，从而节省了操作时间。如果在此之间有其他线程进行了锁请求，则锁退出偏向模式。在JVM中使用-XX:+UseBiasedLocking可以设置启用偏向锁。</p>
<p>当锁对象处于偏向模式时，对象头会记录获得锁的线程：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[JavaThread<span class="keyword">*</span> |<span class="string"> epoch </span>|<span class="string"> age </span>|<span class="string"> 1 </span>|<span class="string"> 01]</span></span><br></pre></td></tr></table></figure></p>
<p>这样，当线程再次尝试获得锁的时候，通过Mark Word的线程信息就可以判断当前线程是否持有偏向锁。</p>
<p>以下代码展示使用偏向锁带来的性能提升：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jaye.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/16.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Biased</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; numberList = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startnum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">10000000</span>)&#123;</span><br><span class="line">            numberList.add(startnum);</span><br><span class="line">            startnum += <span class="number">2</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(end - begin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用以下参数执行这段程序：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseBiasedLocking</span> -<span class="constant">XX</span><span class="symbol">:BiasedLockingStartupDelay=</span><span class="number">0</span> -client -<span class="constant">Xmx512m</span> -<span class="constant">Xms512m</span></span></span><br></pre></td></tr></table></figure></p>
<p>程序输出结果如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">468</span></span><br></pre></td></tr></table></figure></p>
<p>参数-XX:BiasedLockingStartupDelay=0表示虚拟机启动后，立即启用偏向锁。如不设置该参数，虚拟机默认会在启动后4秒后，才启用偏向锁。</p>
<p>若禁用偏向锁，使用以下参数：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseBiasedLocking</span> -client -<span class="constant">Xmx512m</span> -<span class="constant">Xms512m</span></span></span><br></pre></td></tr></table></figure></p>
<p>程序输出结果如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">743</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，偏向锁在少竞争的情况下，对系统性能有一定帮助。</p>
<p>偏向锁在锁竞争激烈得场合没有太强的优化效果，因为大量的竞争会导致持有锁的线程不停地切换，锁也很难一直保持在偏向模式，此时，使用锁偏向不仅得不到性能的优化，反而有可能降低系统性能。因此在竞争激烈得场合，可以尝试使用-XX:-UseBiasedLocking参数禁用偏向锁。</p>
<h3 id="轻量级锁">轻量级锁</h3><p>如果偏向失败，JVM会让现场申请轻量级锁。轻量级锁在虚拟机内部，使用一个称为BasicObjectLock的对象实现，这个对象内部由一个BasicLock对象和一个持有该锁的Java对象指针组成。BasicObjectLock对象放置在Java栈的栈帧中。在BasicLock对象内部还维护着displaced_header字段，它用于备份对象头部的Mark Word。</p>
<p>当一个线程持有一个对象的锁时，对象头部Mark Word如下所示：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[ptr               | 00]</span> <span class="keyword">locked</span></span><br></pre></td></tr></table></figure></p>
<h3 id="锁膨胀">锁膨胀</h3><p>当轻量级锁失败，虚拟机就会使用重量级锁。在使用重量级锁时，对象的Mark Word如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="preprocessor">ptr</span>               | <span class="number">10</span>] <span class="keyword">monitor</span></span><br></pre></td></tr></table></figure></p>
<p>末尾的2比特标记位被置为10。整个Mark Word表示指向monitor对象的指针。在轻量级锁处理失败后，虚拟机会执行以下操作：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock-&gt;<span class="function">set_displaced_header</span>(markOopDesc<span class="value">::<span class="function">unused_mark</span>());</span></span><br><span class="line">ObjectSynchronizer<span class="value">::<span class="function">inflate</span>(THREAD, <span class="function">obj</span>())-&gt;<span class="function">enter</span>(THREAD);</span></span><br></pre></td></tr></table></figure></p>
<p>第1步是废弃前面的BasicLock备份的对象头信息。第2步则正式启用重量级锁。启用过程分为两步：首先通过inflate()方法进行锁膨胀，其目的是获得对象的ObjectMonitor；然后使用enter()方法尝试进入该锁。</p>
<p>在enter()方法调用中，线程很可能会在操作系统层面被挂起。如果这样，线程间切换和调度的成本就会比较高。</p>
<h3 id="自旋锁">自旋锁</h3><p>上面说到，锁膨胀后进入ObjectMonitor的enter()，线程很可能会在操作系统层面被挂起，这样线程上下文切换的性能损失就比较大。因此在锁膨胀之后，虚拟机会做最后的争取，希望线程可以尽快进入临界区而避免被操作系统挂起。一种较为有效的手段就是使用自旋锁。</p>
<p>自旋锁可以使线程在没有取得锁时，不被挂起，而转而去执行一个空循环（即所谓的自旋），在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。</p>
<p>使用自旋锁后线程挂起的几率相对减少，线程执行的连贯性相对加强。因此，对于那些锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用时间长的并发程序，自旋锁在自旋等待后，往往依然无法获得对应的锁，不仅仅白白浪费CPU时间，最终还免不了被挂起的操作，反而浪费了系统资源。</p>
<p>在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁的等待次数。在JDK1.7中，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁。自旋锁总是会执行，自旋次数也是由虚拟机自行调整。</p>
<h3 id="锁消除">锁消除</h3><h2 id="锁在应用层的优化思路">锁在应用层的优化思路</h2><h3 id="减少锁的持有时间">减少锁的持有时间</h3><p>以下面的代码为例：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  othercode1();</span><br><span class="line">  mutextMethod();</span><br><span class="line">  othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在sync方法中，假设othercode1()和othercode2()方法并不需要同步控制，而且它们两又是重量级的方法，则会花费较长的CPU时间。</p>
<p>一个较为优化的解决方案是，只在必要时进行同步，这样就能明显减少线程持有锁的时间，提高系统的吞吐量。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">syncMethod2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  othercode1();</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    mutextMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="减少锁的粒度">减少锁的粒度</h3><p>典型的使用场景就是ConcurrentHashMap类的实现。</p>
<h3 id="锁分离">锁分离</h3><p>依据应用程序的功能特点，将一个独占锁分成多个锁。一个典型的案例就是LinkedBlockingQueue的实现。</p>
<p>在LinkedBlockingQueue的实现中，take函数和put函数分别实现了从队列中取得数据和往队列中增加数据的功能。虽然两个函数都对当前队列进行了修改，但由于基于链表，所以两个操作分别作用于队列的前端和尾端，从理论上来说，两者并不冲突。如果使用独占锁，则要求在两个操作进行时获取当前队列的独占锁，那么take和put操作就不可能真正并发执行。这样，锁竞争会相对比较激烈，从而影响程序在高并发时的性能。因此，在JDK的实现中，并没有采用这样的方式，取而代之的是两把不同的锁，分离了take和put操作。</p>
<h3 id="锁粗化">锁粗化</h3><h2 id="无锁">无锁</h2><h3 id="理解CAS">理解CAS</h3><h3 id="原子操作">原子操作</h3><h3 id="新宠儿LongAddr">新宠儿LongAddr</h3><h2 id="将随机变为可控：理解Java内存模型">将随机变为可控：理解Java内存模型</h2><h3 id="原子性">原子性</h3><h3 id="有序性">有序性</h3><h3 id="可见性">可见性</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="对象头和锁">对象头和锁</h2><p>在JVM的实现中每个对象都有一个对象头，用于保存对象的系统信息。对象头中有一个成为Mark Word的部分，它是实现锁的关键。在32位系统中，Mark Word为一个32位的数据，在64位系统中，它占64位。它是一个多功能的]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[实战Java虚拟机之Class装载系统]]></title>
    <link href="http://blog.noobsky.com/2016/09/05/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BClass%E8%A3%85%E8%BD%BD%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blog.noobsky.com/2016/09/05/实战Java虚拟机之Class装载系统/</id>
    <published>2016-09-05T02:03:08.000Z</published>
    <updated>2016-09-16T09:22:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Class文件装载流程">Class文件装载流程</h2><p>装载Class类型可以分为加载、连接、和初始化三个步骤。其中连接又可分为验证、准备和解析3步。</p>
<h3 id="加载">加载</h3><p>加载类时，JVM完成以下工作：</p>
<ul>
<li>通过类的全民，获取类的二进制数据流</li>
<li>解析类的二进制数据流为方法区内的数据结构</li>
<li>创建java.lang.Class类的实例，表示该类型</li>
</ul>
<h3 id="连接">连接</h3><h4 id="验证">验证</h4><p>目的是保证加载的类的字节码是合法、合理并符合规范的。包括：</p>
<ul>
<li>格式检查: 魔数检查，版本检查、长度检查</li>
<li>语义检查：是否继承final、是否有父类、抽象方法是否有实现</li>
<li>字节码验证：跳转指令是否指向正确位置、操作数类型是否合理</li>
<li>符号引用验证：符号引用的直接引用是否存在</li>
</ul>
<h4 id="准备">准备</h4><p>分配内存空间，并设置初始值。<br>jvm为各类型变量默认的初始值如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">默认初始值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">0L</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">(short)0</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">\u0000</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">reference</td>
<td style="text-align:left">null</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">0f</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">0f</td>
</tr>
</tbody>
</table>
<h4 id="解析">解析</h4><p>将符号引用转为直接引用，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h3 id="初始化">初始化</h3><p>初始化阶段的重要工作是执行类的初始化方法<clinit>。方法<clinit>是由编译器自动生成的，它是由类静态成员的赋值语句以及static语句块合并产生的。</clinit></clinit></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Class文件装载流程">Class文件装载流程</h2><p>装载Class类型可以分为加载、连接、和初始化三个步骤。其中连接又可分为验证、准备和解析3步。</p>
<h3 id="加载">加载</h3><p>加载类时，JVM完成以下工作：</p>
<ul>
<]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Climbing Stairs]]></title>
    <link href="http://blog.noobsky.com/2016/09/04/LeetCode-Climbing-Stairs/"/>
    <id>http://blog.noobsky.com/2016/09/04/LeetCode-Climbing-Stairs/</id>
    <published>2016-09-04T12:15:03.000Z</published>
    <updated>2016-09-04T12:16:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<h2 id="解题思路与代码">解题思路与代码</h2><p>该题本质上是斐波那契数列，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//超时</span></span><br><span class="line">    <span class="comment">// public int climbStairs(int n) &#123;</span></span><br><span class="line">    <span class="comment">//     if(n == 1) return 1;</span></span><br><span class="line">    <span class="comment">//     if(n == 2) return 2;</span></span><br><span class="line">    <span class="comment">//     return climbStairs(n-1) + climbStairs(n-2);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int climbStairs(int n)&#123;</span></span><br><span class="line">    <span class="comment">//     if(n &lt;= 0) return 0;</span></span><br><span class="line">    <span class="comment">//     if(n == 1) return 1;</span></span><br><span class="line">    <span class="comment">//     if(n == 2) return 2;</span></span><br><span class="line">    <span class="comment">//   int[] res = new int[n+1];</span></span><br><span class="line">    <span class="comment">//   res[1] = 1;</span></span><br><span class="line">    <span class="comment">//   res[2] = 2;</span></span><br><span class="line">    <span class="comment">//   for(int i = 3;i &lt;= n;i++)&#123;</span></span><br><span class="line">    <span class="comment">//       res[i] = res[i-2] + res[i-1];</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">//     return res[n];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//前一级阶梯不同路径数</span></span><br><span class="line">        <span class="keyword">int</span> oneStep = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//前两级阶梯的不同路径数</span></span><br><span class="line">        <span class="keyword">int</span> twoStep = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> allWays = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n; i++)&#123;</span><br><span class="line">            allWays = oneStep + twoStep;</span><br><span class="line">            twoStep = oneStep;</span><br><span class="line">            oneStep = allWays;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allWays;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 ]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://blog.noobsky.com/tags/Dynamic-Programming/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Power of Two]]></title>
    <link href="http://blog.noobsky.com/2016/09/04/LeetCode-Power-of-Two/"/>
    <id>http://blog.noobsky.com/2016/09/04/LeetCode-Power-of-Two/</id>
    <published>2016-09-04T11:58:56.000Z</published>
    <updated>2016-09-04T12:03:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an integer, write a function to determine if it is a power of two.</p>
<h2 id="解题思路与代码">解题思路与代码</h2><p>一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是0。根据分析可知，把一个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变成0。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二进制中只有一位是1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &amp; (n-<span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an integer, write a function to determine if it is a power of two.</p>
<h2 id="解题思路与代码">解题思路与代码</h2><p>一个整数如]]>
    </summary>
    
      <category term="Bit Manipulation" scheme="http://blog.noobsky.com/tags/Bit-Manipulation/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="Math" scheme="http://blog.noobsky.com/tags/Math/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实战Java虚拟机之垃圾收集器和内存分配]]></title>
    <link href="http://blog.noobsky.com/2016/09/04/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://blog.noobsky.com/2016/09/04/实战Java虚拟机之垃圾收集器和内存分配/</id>
    <published>2016-09-04T08:44:31.000Z</published>
    <updated>2016-09-04T08:49:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="串行回收器">串行回收器</h2><h3 id="新生代串行回收器">新生代串行回收器</h3><p>串行回收器的主要特点：</p>
<ul>
<li>仅仅使用单线程进行垃圾回收</li>
<li>独占式的垃圾回收</li>
</ul>
<p>使用-XX:+UseSerialGC参数可以指定使用新生代串行收集器和老年代串行收集器。当虚拟机在Client模式下运行时，它是默认的垃圾收集器。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="串行回收器">串行回收器</h2><h3 id="新生代串行回收器">新生代串行回收器</h3><p>串行回收器的主要特点：</p>
<ul>
<li>仅仅使用单线程进行垃圾回收</li>
<li>独占式的垃圾回收</li>
</ul>
<p>使用-XX:+Use]]>
    </summary>
    
      <category term="垃圾收集器" scheme="http://blog.noobsky.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
      <category term="JVM" scheme="http://blog.noobsky.com/categories/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实战Java虚拟机之垃圾回收概念与算法]]></title>
    <link href="http://blog.noobsky.com/2016/09/04/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.noobsky.com/2016/09/04/实战Java虚拟机之垃圾回收概念与算法/</id>
    <published>2016-09-04T08:43:55.000Z</published>
    <updated>2016-09-04T08:43:55.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[实战Java虚拟机之常用Java虚拟机参数]]></title>
    <link href="http://blog.noobsky.com/2016/09/04/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%B8%B8%E7%94%A8Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0/"/>
    <id>http://blog.noobsky.com/2016/09/04/实战Java虚拟机之常用Java虚拟机参数/</id>
    <published>2016-09-04T07:03:42.000Z</published>
    <updated>2016-09-04T08:41:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="掌握跟踪调试参数">掌握跟踪调试参数</h2><h3 id="虚拟机日志">虚拟机日志</h3><p>最简单的一个GC参数为-XX:+PrintGC，使用这个参数启动Java虚拟机后，遇到GC，会打印GC日志。</p>
<p>如果需要更加详细的信息，则可以使用-XX:+PrintGCDetails参数。</p>
<p>如果需要更全面的堆信息，还可以使用参数-XX:+PrintHeapAtGC。它会在GC前后分别打印堆的信息。</p>
<p>如果需要分析分析GC发生的时间，还可以使用-XX:+PrintGCTimeStamps参数，该参数会在每次GC发生时，额外输出GC发生的时间，该输出时间为虚拟机启动后的时间偏移量。</p>
<p>GC会引起应用的停顿。使用参数-XX:+PrintGCApplicationConcurrentTime可以打印应用程序的执行时间。使用参数-XX:+PrintGCApplicationStoppedTime可以打印应用程序由于GC而产生的停顿时间。</p>
<p>如果要跟踪系统内的软引用、弱引用、虚引用和Finallize队列，则可以使用-XX:+PrintReferenceGC。</p>
<p>默认情况，GC日志在控制台输出，不便于后序的分析和问题的定位。为此，虚拟机允许将GC以日志文件的形式输出，可以使用-Xloggc指定。比如使用-Xloggc:log/gc.log启动虚拟机，可以在当前目录下的log文件夹下的gc.log文件中记录所有的GC日志。</p>
<h3 id="类加载/卸载的跟踪">类加载/卸载的跟踪</h3><p>可以使用-verbose:class跟踪类的加载和卸载，也可以单独使用参数-XX:+TraceClassLoading跟踪类的加载，使用-XX:+TraceClassUnloading跟踪类的卸载。</p>
<p>JVM还允许研发人员在运行时打印、查看系统中类的分布情况，只要在系统启动时加上-XX:+PrintClassHistogram参数，然后在Java的控制台中按下Ctrl+Break组合键，控制台上就会显示当前的类信息柱状图。</p>
<h3 id="系统参数查看">系统参数查看</h3><p>参数-XX:+PrintVMOptions可以在程序运行时，打印虚拟机接收的命令行显示参数。</p>
<p>参数-XX:+PrintCommandLineFlags可以打印传递给虚拟机的显示和隐式参数，隐式参数未必是通过命令行直接给出，可能是虚拟机启动时自行设置的。</p>
<p>另外一个有用的参数是-XX:+PrintFlagsFinal，它会打印所有的系统参数的值。</p>
<h2 id="学习堆的配置参数">学习堆的配置参数</h2><h3 id="最大堆和初始堆的设置">最大堆和初始堆的设置</h3><p>使用参数-Xms指定堆的初始空间，使用-Xmx指定最大堆空间。在实际工作中，可以直接将初始堆-Xms与最大堆-Xmx设置相等。这样的好处是可以减少程序运行时进行的垃圾回收次数，从而提高程序的性能。</p>
<h3 id="新生代的设置">新生代的设置</h3><p>参数-Xmn可以用于设置新生代的大小。新生代一般设置为整个队空间的1/3到1/4左右。</p>
<p>参数-XX:SurvivorRatio用来设置设置新生代中eden空间和from/to空间的比例关系。它的含义如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:SurvivorRatio=eden/from=eden/to</span></span></span><br></pre></td></tr></table></figure></p>
<p>除了可以使用-Xmn指定新生代的绝对大小外，还可以使用参数-XX:NewRatio来设置新生代和老生代的比例。它的含义如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:NewRatio=</span>老年代/新生代</span></span><br></pre></td></tr></table></figure></p>
<p>下图显示了几个重要的堆参数的含义：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/%E5%A0%86%E7%9A%84%E5%88%86%E9%85%8D%E5%8F%82%E6%95%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt=""></p>
<h3 id="堆溢出处理">堆溢出处理</h3><p>Java虚拟机提供了参数-XX:+HeapDumpOnOutOfMemoryError，使用该参数可以在内存溢出时导出整个堆信息。和它配合使用的还有-XX:HeapDumpPath，可以指明导出堆的存放路径。</p>
<h2 id="非堆内存的参数配置">非堆内存的参数配置</h2><h3 id="方法区配置">方法区配置</h3><p>方法区主要存放类的元信息。在JDK 1.6和JDK 1.7等版本中，可以使用-XX:PermSize和-XX:MaxPermSize配置永久区大小。前者表示初始的永久区大小，后者表示最大永久区。</p>
<h3 id="栈配置">栈配置</h3><p>-Xss参数指定线程的栈大小。</p>
<h3 id="直接内存配置">直接内存配置</h3><p>最大可用直接内存可以使用参数-XX:MaxDirectMemorySize设置，如不设置，默认值为最大堆空间，即-Xmx。</p>
<h2 id="虚拟机的工作模式">虚拟机的工作模式</h2><p>JVM支持Client和Server两种运行模式。使用参数-client可以指定使用Client模式，使用参数-server可以指定使用Server模式。</p>
<p>与Client模式相比，Server模式的启动比较慢，因为Server模式会尝试收集更多的系统性能信息，使用更复杂的优化算法对程序进行优化。因此，当系统完全启动并进入运行稳定期后，Server模式的执行速度会远远快于Client模式。所以对于后台长期运行的系统，使用-server参数启动对系统的整体性能可以有不小的帮助。但对于用户界面程序，运行时间不长，又追求启动速度，Client模式也是不错的选择。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="掌握跟踪调试参数">掌握跟踪调试参数</h2><h3 id="虚拟机日志">虚拟机日志</h3><p>最简单的一个GC参数为-XX:+PrintGC，使用这个参数启动Java虚拟机后，遇到GC，会打印GC日志。</p>
<p>如果需要更加详细的信息，则可以使用-X]]>
    </summary>
    
      <category term="JVM参数" scheme="http://blog.noobsky.com/tags/JVM%E5%8F%82%E6%95%B0/"/>
    
      <category term="JVM" scheme="http://blog.noobsky.com/categories/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实战Java虚拟机之认识Java虚拟机的基本结构]]></title>
    <link href="http://blog.noobsky.com/2016/09/04/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E8%AE%A4%E8%AF%86Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.noobsky.com/2016/09/04/实战Java虚拟机之认识Java虚拟机的基本结构/</id>
    <published>2016-09-04T03:40:33.000Z</published>
    <updated>2016-09-04T07:03:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Java虚拟机基本结构">Java虚拟机基本结构</h2><p>Java虚拟机基本结构如下所示：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<ul>
<li><p>类加载子系统负责从文件系统或者网络中加载Class信息，加载的类信息存放在方法区的内存空间。除了类信息外，方法区中还存放运行时常量池信息，包括字符串和数字常量</p>
</li>
<li><p>Java堆在虚拟机启动时建立，是Java最主要的内存工作区域。几乎所有对象实例都存放在Java堆中。堆空间是所有线程共享的。</p>
</li>
<li><p>Java的NIO库允许Java程序使用直接内存。直接内存是在Java堆外的、直接向系统申请的内存区间。速度由于Java堆，读写频繁可以考虑使用直接内存。直接内存的大小不直接受限于Xmx指定的最大堆大小，但仍然受限于系统内存。</p>
</li>
<li><p>垃圾回收系统是JVM的重要组成部分，垃圾回收器可以对方法区、Java堆和直接内存进行回收。其中，Java堆是垃圾收集器的工作重点。</p>
</li>
<li><p>每一个Java虚拟机栈线程都有一个私有的Java栈。Java栈中保存帧信息，Java栈中保存局部变量、方法参数，同时和Java方法调用、返回密切相关。</p>
</li>
<li><p>本地方法栈和Java栈非常类似，最大的不同在于Java栈用于Java方法的调用，而本地方法栈则用于本地方法调用。</p>
</li>
<li><p>PC寄存器也是线程私有。PC寄存器指向当前正在被执行的指令。但如果是本地方法，则PC的值为undefined。</p>
</li>
</ul>
<h2 id="Java堆">Java堆</h2><h2 id="函数调用：出入Java栈">函数调用：出入Java栈</h2><p>在java栈中保存的主要内容为栈帧。一个栈帧中，至少包含局部变量表、操作数栈和帧数据。Java虚拟机提供了参数-Xss来指定线程的最大栈空间。</p>
<ul>
<li>局部变量表用于保存函数的参数以及局部变量。函数调用结束后，随着函数栈帧的销毁，局部变量表也会随之销毁。</li>
<li>操作数栈主要用于保存计算过程的中间结果，同时作为计算过程变量临时的存储空间。</li>
<li>帧数据区保存访问常量池的指针和异常处理表</li>
</ul>
<h3 id="栈上分配">栈上分配</h3><p>JVM提供的一项优化技术，基本思想为：对于那些线程私有的对象（指不可能被其他线程访问的对象），可以将它们打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统的性能。</p>
<p>栈上分配的一个技术基础是进行逃逸分析。逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。如下代码显示了一个逃逸对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> User u;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  u = <span class="keyword">new</span> User();</span><br><span class="line">  u.id = <span class="number">5</span>;</span><br><span class="line">  u.name = <span class="string">"Jaye"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对象User u是类的成员变量，该字段有可能被任何线程访问，因此属于逃逸对象。以下代码显示了一个非逃逸对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  User u = <span class="keyword">new</span> User();</span><br><span class="line">  u.id = <span class="number">5</span>;</span><br><span class="line">  u.name = <span class="string">"Jaye"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的User以局部变量的形式存在，并且该对象并没有被alloc函数返回，或者出现了任何形式的公开，因此，它并未发生逃逸，所以这种情况，虚拟机就有可能将User分配在栈上，而不是堆上。</p>
<h2 id="方法区">方法区</h2><p>和Java堆一样，方法区是一块所有线程共享的内存区域。它用于保存系统的类信息，比如类的字段、方法、常量池等。</p>
<p>在JDK 1.6、JDK 1.7中，方法区可以理解为永久区（Perm）。永久区可以使用参数-XX:PermSize和-XX:MaxPermSize指定，默认情况下，-XX:MaxPermSize为64MB。</p>
<p>在JDK 1.8中，永久区已经被彻底移除。取而代之的是元数据区，元数据区大小可以使用参数-XX:MaxMetaspaceSize指定，这是一块堆外的直接内存。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Java虚拟机基本结构">Java虚拟机基本结构</h2><p>Java虚拟机基本结构如下所示：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%]]>
    </summary>
    
      <category term="JVM基本结构" scheme="http://blog.noobsky.com/tags/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    
      <category term="JVM" scheme="http://blog.noobsky.com/categories/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RST包]]></title>
    <link href="http://blog.noobsky.com/2016/09/04/RST%E5%8C%85/"/>
    <id>http://blog.noobsky.com/2016/09/04/RST包/</id>
    <published>2016-09-04T01:48:50.000Z</published>
    <updated>2016-09-04T01:50:29.000Z</updated>
    <content type="html"><![CDATA[<p>A,B两台机器都正常工作,B机器未监听任何端口.如果A机器向B机器80端口发送SYN包,会收到何种类型的回包?</p>
<p>因为B机器未监听任何端口,A又向B的80端口发送了数据包,所以B不会建立连接,会异常结束建立连接,会发送RST包,如果是正常结束的话就会发送FIN包,RST是TCP连接中 出现差错产生的,RST置1可以用来拒绝一个非法的报文段或拒绝打开一个连接。</p>
<p>rst是复位报文 几种TCP链接中出现rst的情况 1.端口未打开 2，请求超时 3，提前关闭 4,在一个已关闭的socket上出现数据</p>
<p>1 端口未打开<br>服务器程序端口未打开而客户端来连接。这种情况是最为常见和好理解的一种了。去 telnet 一个未打开的 TCP 的端口可能会出现这种错误。这个和操作系统的实现有关。在某些情况下，操作系统也会完全不理会这些发到未打开端口请求 。<br>比如在下面这种情况下，主机 241 向主机 114 发送一个 SYN 请求，表示想要连接主机 114 的 40000 端口，但是主机 114 上根本没有打开 40000 这个端口，于是就向主机 241 发送了一个 RST 。这种情况很常见。特别是服务器程序 core dump 之后重启之前连续出现 RST 的情况会经常发生 。</p>
<p>当然在某些操作系统的主机上，未必是这样的表现。比如向一台 WINDOWS7 的主机发送一个连接不存在的端口的请求，这台主机就不会回应 。<br>2 请求超时<br>曾经遇到过这样一个情况 : 一个客户端连接服务器， connect 返回 -1 并且 error=EINPROGRESS 。 直接 telnet 发现网络连接没有问题。 ping 没有出现丢包。用抓包工具查看，客户端是在收到服务器发出的 SYN 之后就莫名其妙的发送了 RST 。<br>比如像下面这样 ：</p>
<p>有 89 、 27 两台主机。主机 89 向主机 27 发送了一个 SYN ，表示希望连接 8888 端口，主机 27 回应了主机 89 一个 SYN 表示可以连接。但是主机 27 却很不友好，莫名其妙的发送了一个 RST 表示我不想连接你了 。<br>后来经过排查发现，在主机 89 上的程序在建立了 socket 之后，用 setsockopt 的 SO_RCVTIMEO 选项设置了 recv 的超时时间为 100ms 。而我们看上面的抓包结果表示，从主机 89 发出 SYN 到接收 SYN 的时间多达 110ms 。（从 15:01:27.799961 到 15:01:27.961886 ， 小数点之后的单位是微秒）。因此主机 89 上的程序认为接收超时，所以发送了 RST 拒绝进一步发送数据 。<br>3 提前关闭<br>关于 TCP ，我想我们在教科书里都读到过一句话， ‘TCP 是一种可靠的连接 ‘ 。 而这可靠有这样一种含义，那就是操作系统接收到的来自 TCP 连接中的每一个字节，我都会让应用程序接收到。如果应用程序不接收怎么办？你猜对了， RST 。<br>4 在一个已关闭的 socket 上收到数据<br>如果某个 socket 已经关闭，但依然收到数据也会产生 RST 。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>A,B两台机器都正常工作,B机器未监听任何端口.如果A机器向B机器80端口发送SYN包,会收到何种类型的回包?</p>
<p>因为B机器未监听任何端口,A又向B的80端口发送了数据包,所以B不会建立连接,会异常结束建立连接,会发送RST包,如果是正常结束的话就会发送FIN包]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Guess Number Higher or Lower I II]]></title>
    <link href="http://blog.noobsky.com/2016/09/01/LeetCode-Guess-Number-Higher-or-Lower-I-II/"/>
    <id>http://blog.noobsky.com/2016/09/01/LeetCode-Guess-Number-Higher-or-Lower-I-II/</id>
    <published>2016-09-01T08:16:08.000Z</published>
    <updated>2016-09-02T02:31:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Guess_Number_Higher_or_Lower_I">Guess Number Higher or Lower I</h2><h3 id="题目描述">题目描述</h3><p>We are playing the Guess Game. The game is as follows:</p>
<p>I pick a number from 1 to n. You have to guess which number I picked.</p>
<p>Every time you guess wrong, I’ll tell you whether the number is higher or lower.</p>
<p>You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> lower</span><br><span class="line"> <span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> higher</span><br><span class="line"> <span class="number">0</span> : Congrats! You got <span class="keyword">it</span>!</span><br></pre></td></tr></table></figure></p>
<p><strong>Example:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span>, I pick <span class="number">6.</span></span><br><span class="line"></span><br><span class="line">Return <span class="number">6.</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路与代码">解题思路与代码</h3><p>二分查找，要注意的是：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> lower</span><br><span class="line"><span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> higher</span><br><span class="line"><span class="number">0</span> : Congrats! You got <span class="keyword">it</span>!</span><br></pre></td></tr></table></figure></p>
<p>指的是：Here “My” means the number which is given for you to guess not the number you put into guess(int num).<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The guess API is defined in the parent class GuessGame.</span><br><span class="line">   @param num, your guess</span><br><span class="line">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span><br><span class="line">      int guess(int num); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(guess(mid) == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(guess(mid) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 1 : My number is higher,这里的My number是指要你猜的那个数</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Guess_Number_Higher_or_Lower_II">Guess Number Higher or Lower II</h2><h3 id="题目描述-1">题目描述</h3><p>We are playing the Guess Game. The game is as follows:</p>
<p>I pick a number from 1 to n. You have to guess which number I picked.</p>
<p>Every time you guess wrong, I’ll tell you whether the number I picked is higher or lower.</p>
<p>However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.</p>
<p>Example:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span>, I pick <span class="number">8.</span></span><br><span class="line"></span><br><span class="line">First <span class="command">round</span>:  You guess <span class="number">5</span>, I <span class="keyword">tell</span> you <span class="keyword">that</span> <span class="keyword">it</span>'s higher. You pay $<span class="number">5.</span></span><br><span class="line">Second <span class="command">round</span>: You guess <span class="number">7</span>, I <span class="keyword">tell</span> you <span class="keyword">that</span> <span class="keyword">it</span>'s higher. You pay $<span class="number">7.</span></span><br><span class="line">Third <span class="command">round</span>:  You guess <span class="number">9</span>, I <span class="keyword">tell</span> you <span class="keyword">that</span> <span class="keyword">it</span>'s lower. You pay $<span class="number">9.</span></span><br><span class="line"></span><br><span class="line">Game <span class="keyword">over</span>. <span class="number">8</span> <span class="keyword">is</span> <span class="keyword">the</span> <span class="type">number</span> I picked.</span><br><span class="line"></span><br><span class="line">You <span class="keyword">end</span> up paying $<span class="number">5</span> + $<span class="number">7</span> + $<span class="number">9</span> = $<span class="number">21.</span></span><br><span class="line">Given a particular n ≥ <span class="number">1</span>, find out how much money you need <span class="keyword">to</span> have <span class="keyword">to</span> guarantee a win.</span><br></pre></td></tr></table></figure></p>
<p>Hint:</p>
<ol>
<li>The best strategy to play the game is to minimize the maximum loss you could possibly face. Another strategy is to minimize the expected loss. Here, we are interested in the first scenario.</li>
<li>Take a small example (n = 3). What do you end up paying in the worst case?</li>
<li>Check out <a href="https://en.wikipedia.org/wiki/Minimax" target="_blank" rel="external">this article</a> if you’re still stuck.</li>
<li>The purely recursive implementation of minimax would be worthless for even a small n. You MUST use dynamic programming.</li>
<li>As a follow-up, how would you modify your code to solve the problem of minimizing the expected loss, instead of the worst-case loss?</li>
</ol>
<h3 id="解题思路与代码-1">解题思路与代码</h3><p>这题要求我们在猜测数字（设为y，1~n任意一个数）未知的情况下，要我们在最坏情况下我们支付最少的钱。即要考虑所有y的情况。</p>
<p>Definition of dp[i][j]: minimum number of money to guarantee win for subproblem [i, j].</p>
<p>Target: dp[1][n]</p>
<p>Corner case: dp[i][i] = 0 (because the only element must be correct)</p>
<p>Equation: we can choose k (i&lt;=k&lt;=j) as our guess, and pay price k. After our guess, the problem is divided into two subproblems. Notice we do not need to pay the money for both subproblems. We only need to pay the worst case (because the system will tell us which side we should go) to guarantee win. So dp[i][j] = min (i&lt;=k&lt;=j) { k + max(dp[i][k-1], dp[k+1][j]) }</p>
<p>假设我们选择了猜测数字为k（1&lt;= k &lt;= n &amp;&amp; k != y），然后将该问题划分为两个子问题[1, k-1]和[k+1, n]。 假如我们已经解决了[1,k-1] 和 [k+1,n]计算问题，我们将其表示为solve(L,k-1) 和solve(k+1,n)，那么我们应该选择max(solve(L,k-1),solve(k+1,n)) 这样就是求最坏情况下的损失。总的损失就是 f(k) = k + max(solve(L,k-1),solve(k+1,n))。那么将k从1~n进行遍历，取使得 f(k) 达到最小，来确定最坏情况下最小的损失，也就是我们初始应该选择哪个数。</p>
<p>根据以上思路我们可以写出带备忘录的top-down的递归写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> solve(dp, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//top-down，效率不高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[][] dp, <span class="keyword">int</span> left , <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[left][right] != <span class="number">0</span>) <span class="keyword">return</span> dp[left][right];</span><br><span class="line"></span><br><span class="line">        dp[left][right] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            dp[left][right] = Math.min(dp[left][right], i + Math.max(solve(dp, left, i-<span class="number">1</span>), solve(dp, i+<span class="number">1</span>, right)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>top-down方法，效率不高，可以改写为bottom-up:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bottom-up</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int len = 1; len &lt; n; len++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int i = 1; i &lt;= n-len; i++)&#123;</span></span><br><span class="line">        <span class="comment">//         int j = i + len;</span></span><br><span class="line">        <span class="comment">//         int min = Integer.MAX_VALUE;</span></span><br><span class="line">        <span class="comment">//         for(int k = i; k &lt; j; k++)&#123;</span></span><br><span class="line">        <span class="comment">//             int temp = k + Math.max(dp[i][k-1], dp[k+1][j]);</span></span><br><span class="line">        <span class="comment">//             min = Math.min(min, temp);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         dp[i][j] = min;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n-len; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; j; k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], k + Math.max(dp[i][k-<span class="number">1</span>], dp[k+<span class="number">1</span>][j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Guess_Number_Higher_or_Lower_I">Guess Number Higher or Lower I</h2><h3 id="题目描述">题目描述</h3><p>We are playing the Guess Game. The game]]>
    </summary>
    
      <category term="Binary Search" scheme="http://blog.noobsky.com/tags/Binary-Search/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
