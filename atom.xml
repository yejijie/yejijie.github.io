<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-06-18T03:11:26.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Reorder List]]></title>
    <link href="http://blog.noobsky.com/2016/06/18/LeetCode-Reorder-List/"/>
    <id>http://blog.noobsky.com/2016/06/18/LeetCode-Reorder-List/</id>
    <published>2016-06-18T03:08:51.000Z</published>
    <updated>2016-06-18T03:11:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
<h2 id="代码">代码</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//基本思路就是反转单链表的后半部分</span></span><br><span class="line">    <span class="comment">//然后用两个指针分别指向前半部分单链表的头部(这里用slow)和后半部分的单链表的头部(这里用fast)</span></span><br><span class="line">    <span class="comment">//然后将slow和fast指向的节点链接起来，在这个过程中要借助单链表的中间节点，终止条件也是slow等于中间节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> reorderList(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//利用快慢指针，找出链表的中点</span></span><br><span class="line">        <span class="comment">//利用快慢指针找链表的中点有两种写法，只在循环条件不同</span></span><br><span class="line">        <span class="comment">//1. 循环条件为：fast.next != null &amp;&amp; fast.next.next != null</span></span><br><span class="line">        <span class="comment">//2. 循环条件为：fast != null &amp;&amp; fast.next != null</span></span><br><span class="line">        <span class="comment">//这两种写法在链表的节点数为奇数时效果是一样的，偶数时有点不一样：</span></span><br><span class="line">        <span class="comment">//循环结束时，第一种写法的slow指针指向两个中间节点偏左的节点，fast指向倒数第二个节点</span></span><br><span class="line">        <span class="comment">//第二种写法的slow指针指向两个中间节点偏右的中间节点，fast指向null节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//反转后半部分，即中间节点之后的节点，可以参考Reverse list II</span></span><br><span class="line">        ListNode middle = slow;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指向需要反转的子链表的头结点,start节点的next的节点就是需要被反转的节点</span></span><br><span class="line">        ListNode start = slow.<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">//反转后半部分链表就是把每个需要反转的节点交换链接到middle.next中</span></span><br><span class="line">        <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 to 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4</span></span><br><span class="line">        <span class="keyword">while</span>(start.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前需要反转的节点，把该节点链接到middle后面</span></span><br><span class="line">            ListNode <span class="keyword">reverse</span> = start.<span class="keyword">next</span>;</span><br><span class="line">            start.<span class="keyword">next</span> = <span class="keyword">reverse</span>.<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">reverse</span>.<span class="keyword">next</span> = middle.<span class="keyword">next</span>;</span><br><span class="line">            middle.<span class="keyword">next</span> = <span class="keyword">reverse</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//reorder</span></span><br><span class="line">        slow = head;</span><br><span class="line">        fast = middle.<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">//每次循环将slow和fast指向的节点链接起来</span></span><br><span class="line">        <span class="keyword">while</span>(slow != middle)&#123;</span><br><span class="line">            middle.<span class="keyword">next</span> = fast.<span class="keyword">next</span>;</span><br><span class="line">            fast.<span class="keyword">next</span> = slow.<span class="keyword">next</span>;</span><br><span class="line">            slow.<span class="keyword">next</span> = fast;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//slow，fast指向下一个节点</span></span><br><span class="line">            slow = fast.<span class="keyword">next</span>;</span><br><span class="line">            fast = middle.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this i]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Rotate List]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Rotate-List/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Rotate-List/</id>
    <published>2016-06-17T13:37:17.000Z</published>
    <updated>2016-06-17T13:39:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,<br>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
<h2 id="代码">代码</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//k可能大于链表的长度length，所以我们需要知道链表的长度来取模得到正确的k</span></span><br><span class="line">    <span class="comment">//我们只需要将末尾k%length个节点移到链表的头部，这些节点处于第(length-k%length)th个节点之后</span></span><br><span class="line">    <span class="comment">//所以我们需要两个指针分别指向链表最后一个节点和第(length-k%length)th个节点</span></span><br><span class="line">    <span class="keyword">public</span> ListNode rotateRight(ListNode head, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.<span class="keyword">next</span> = head;</span><br><span class="line">        ListNode fast = dummy, slow = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="comment">//统计链表长度，顺便让fast指向最后一个节点</span></span><br><span class="line">        <span class="keyword">for</span>( length = <span class="number">0</span>; fast.<span class="keyword">next</span> != <span class="keyword">null</span>; length++)&#123;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让slow指针指向第length - k % length 个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = length - k % length; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//rotate</span></span><br><span class="line">        <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL，k = 2，fast指向5，slow指向3</span></span><br><span class="line">        </span><br><span class="line">        fast.<span class="keyword">next</span> = dummy.<span class="keyword">next</span>;</span><br><span class="line">        dummy.<span class="keyword">next</span> = slow.<span class="keyword">next</span>;</span><br><span class="line">        slow.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given 1-&g]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Word Search I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Word-Search-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Word-Search-I-II/</id>
    <published>2016-06-17T11:16:23.000Z</published>
    <updated>2016-06-17T12:42:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Word_Search_I">Word Search I</h2><h3 id="题目描述">题目描述</h3><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,</p>
<p>Given board =</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  ['A','B','C','E'],</span><br><span class="line">  ['S','F','C','S'],</span><br><span class="line">  ['A','D','E','E']</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == null || word.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(board == null || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfsSearch(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dfs搜索是否存在该word</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">dfsSearch</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == word.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word.charAt(index)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标记为已经访问过，这里用字符要保证输入不会出现*字符</span></span><br><span class="line">        <span class="comment">//如果面试的时候可以跟面试官沟通用个不会出现的字符:)</span></span><br><span class="line">        <span class="comment">//还有不能保证的话的可以使用一个布尔数组标记是否访问过</span></span><br><span class="line">        <span class="comment">//这里还有一种很tricky的处理的方法，就是用异或</span></span><br><span class="line">        <span class="comment">//这里假设只会出现ASCII字符，当然面试时可以跟面试官沟通，也就是0~255，那么可以用256</span></span><br><span class="line">        <span class="comment">//java中char是两个字节的0~65535，注意用的2的16次方65536会溢出，需要用int</span></span><br><span class="line">        <span class="comment">//board[i][j] ^= 256;</span></span><br><span class="line">        board[i][j] = <span class="string">'*'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上下左右搜索下标index+1下的字符</span></span><br><span class="line">        boolean exist = dfsSearch(board, word, i-<span class="number">1</span>, j, index + <span class="number">1</span>)</span><br><span class="line">                        || dfsSearch(board, word, i, j-<span class="number">1</span>, index + <span class="number">1</span>)</span><br><span class="line">                        || dfsSearch(board, word, i, j+<span class="number">1</span>, index + <span class="number">1</span>)</span><br><span class="line">                        || dfsSearch(board, word, i+<span class="number">1</span>, j, index + <span class="number">1</span>);</span><br><span class="line">                        </span><br><span class="line">        <span class="comment">//回复board[i][j]，为下一次搜索准备</span></span><br><span class="line">        board[i][j] = word.charAt(index);</span><br><span class="line">        <span class="comment">//再次异或就恢复原始值，异或的性质</span></span><br><span class="line">        <span class="comment">//board[i][j] ^= 256;</span></span><br><span class="line">        <span class="keyword">return</span> exist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Word_Search_I">Word Search I</h2><h3 id="题目描述">题目描述</h3><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Letter Combinations of a Phone Number]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Letter-Combinations-of-a-Phone-Number/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Letter-Combinations-of-a-Phone-Number/</id>
    <published>2016-06-17T07:49:44.000Z</published>
    <updated>2016-06-17T11:22:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:Digit</span> <span class="built_in">string</span> <span class="string">"23"</span></span><br><span class="line">Outpu<span class="variable">t:</span> [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>
<p><strong> Note: </strong><br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<h2 id="代码">代码</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用队列的先进先出性质，根据字符串的长度来区别字符串</span></span><br><span class="line">    <span class="comment">//首先将空字符串加入res中，然后进入for循环，循环次数由digits的长度决定</span></span><br><span class="line">    <span class="comment">//当队列头部的字符串的长度跟循环次数i的下标相等，说明这个字符串还是上次放入队列中的，</span></span><br><span class="line">    <span class="comment">//取出该元素并与当前digits对应的字符分别组合，然后依次加入队列中</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; letterCombinations(<span class="keyword">String</span> digits) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用队列</span></span><br><span class="line">        LinkedList&lt;<span class="keyword">String</span>&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//将数字和可能的字母对应起来</span></span><br><span class="line">        <span class="keyword">String</span>[] <span class="built_in">map</span>= &#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//先加入空字符串</span></span><br><span class="line">        res.offer(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; digits.length(); i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> mapIndex = Character.getNumericValue(digits.charAt(i));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//挺tricky的！！！</span></span><br><span class="line">            <span class="keyword">while</span>(res.peek().length() == i)&#123;</span><br><span class="line">                <span class="comment">//取出头部元素，依次跟digits对应的字符组合，再加入队列中</span></span><br><span class="line">                <span class="keyword">String</span> last = res.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">char</span> ch: <span class="built_in">map</span>[mapIndex].toCharArray())&#123;</span><br><span class="line">                    res.offer(last + ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Longest Palindromic Substring]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Longest-Palindromic-Substring/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Longest-Palindromic-Substring/</id>
    <published>2016-06-17T04:20:13.000Z</published>
    <updated>2016-06-17T04:32:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
<h2 id="代码">代码</h2><p>我们可以从回文的中心不但向两边扩展回文字符串，并更新最长的回文字符串长度和开始位置。设字符串S的长度为n，则回文字符串的中心最多只有2n-1个，中心可以是n个字符和，或者两个字符的之间为中心，这样的情况有n-1，所以总共有2n-1个可能的回文中心位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//start为最长回文子字符串的开始下标，maxLen为最长长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start, maxLen;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            extendPalindromic(s, i, i);<span class="comment">//回文字符串长度为奇数，以某个字符为中心</span></span><br><span class="line">            extendPalindromic(s, i, i+<span class="number">1</span>);<span class="comment">//回文字符串长度为偶数，以两个字符为中心</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从中间不断的向两边找可能的回文字符串，并更新最长回文长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendPalindromic</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//left、right下标字符相等，继续扩展</span></span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(maxLen &lt; right - left - <span class="number">1</span>)&#123;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            maxLen = right - left - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Add Two Numbers]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Add-Two-Numbers/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Add-Two-Numbers/</id>
    <published>2016-06-17T03:36:33.000Z</published>
    <updated>2016-06-17T03:38:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>
<h2 id="代码">代码</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        ListNode p = l1, q = l2, curr = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//可以用||把为空的一方的加数置为0就可以</span></span><br><span class="line">        <span class="comment">//用&amp;&amp;也可以，后面再将不空链接到尾部就行了</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> || q != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = p != <span class="keyword">null</span> ? p.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = q != <span class="keyword">null</span> ? q.val : <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">sum</span> = x + y + carry;</span><br><span class="line">            carry = <span class="keyword">sum</span> / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(<span class="keyword">sum</span> % <span class="number">10</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">            <span class="keyword">if</span>(q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and e]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Restore IP Addresses]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Restore-IP-Addresses/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Restore-IP-Addresses/</id>
    <published>2016-06-17T02:53:13.000Z</published>
    <updated>2016-06-17T02:58:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given a <span class="type">string</span> containing only digits, restore <span class="keyword">it</span> <span class="keyword">by</span> <span class="keyword">returning</span> all possible valid IP address combinations.</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">Given <span class="string">"25525511135"</span>,</span><br><span class="line"><span class="command"></span><br><span class="line">return</span> [<span class="string">"255.255.11.135"</span>, <span class="string">"255.255.111.35"</span>]. (Order <span class="keyword">does</span> <span class="keyword">not</span> matter)</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//简单高效的方法</span></span><br><span class="line">    <span class="comment">//基本思想就是将字符串切割三次将字符串分成四部分，每部分至少一个字符，至多三个字符，而且必须小于255</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="comment">//三个for循环切割三次</span></span><br><span class="line">        <span class="comment">//至少一个字符，最多三个字符，对应substring(0, 1)，substring(0, 3),而且至少给后面留下三个字符</span></span><br><span class="line">        <span class="comment">//所以i &lt; len - 2,后面至少还有len - 3， len - 2， len - 1三个字符</span></span><br><span class="line">        <span class="comment">//这里i应该是小于4，i可以等于3但是substring(0, 3)是不包括下标3的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span> &amp;&amp; i &lt; length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//至少一个字符substring(i, i+1)...substring(i, i+3)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; i+<span class="number">4</span> &amp;&amp; j &lt; length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>; k &lt; j+<span class="number">4</span> &amp;&amp; k &lt; length; k++)&#123;</span><br><span class="line">                String s1 = s.substring(<span class="number">0</span>, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, length);</span><br><span class="line">                    <span class="keyword">if</span>(isValid(s1) &amp;&amp; isValid(s2) &amp;&amp; isValid(s3) &amp;&amp; isValid(s4))&#123;</span><br><span class="line">                        res.add(s1 + <span class="string">"."</span> + s2 + <span class="string">"."</span> + s3 + <span class="string">"."</span> + s4);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里不能压缩ip地址，比如01，不能压缩成，001不能压缩成1,00压缩成0</span></span><br><span class="line">        <span class="comment">//所以需要 (s.charAt(0) == '0' &amp;&amp; s.length() &gt; 1)的条件</span></span><br><span class="line">        <span class="comment">//如果去掉：</span></span><br><span class="line">        <span class="comment">//Input:"010010"</span></span><br><span class="line">        <span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//["0.1.0.010","0.1.00.10","0.1.001.0","0.10.0.10","0.10.01.0","0.100.1.0","01.0.0.10","01.0.01.0","01.00.1.0","010.0.1.0"]</span></span><br><span class="line">        <span class="comment">//Expected:["0.10.0.10","0.100.1.0"]</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; <span class="number">3</span> || s.length() == <span class="number">0</span> || (s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; s.length() &gt; <span class="number">1</span>) || Integer.parseInt(s) &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先贴上DFS的代码吧</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">    List&lt;String&gt; solutions = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    restoreIp(s, solutions, <span class="number">0</span>, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> solutions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restoreIp</span><span class="params">(String ip, List&lt;String&gt; solutions, <span class="keyword">int</span> idx, String restored, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">4</span> &amp;&amp; idx == ip.length()) solutions.add(restored);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx+i &gt; ip.length()) <span class="keyword">break</span>;</span><br><span class="line">        String s = ip.substring(idx,idx+i);</span><br><span class="line">        <span class="keyword">if</span> ((s.startsWith(<span class="string">"0"</span>) &amp;&amp; s.length()&gt;<span class="number">1</span>) || (i==<span class="number">3</span> &amp;&amp; Integer.parseInt(s) &gt;= <span class="number">256</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        restoreIp(ip, solutions, idx+i, restored+s+(count==<span class="number">3</span>?<span class="string">""</span> : <span class="string">"."</span>), count+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximal Square And Maximal Rectangle]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Maximal-Square-And-Maximal-Rectangle/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Maximal-Square-And-Maximal-Rectangle/</id>
    <published>2016-06-16T13:30:34.000Z</published>
    <updated>2016-06-17T02:53:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return its area.</p>
<p>For example, given the following matrix:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Return 4.</p>
<h2 id="代码">代码</h2><p>使用动态规划方法，状态转移方程如下。</p>
<p>dp[i][j]表示在点matrix[i][j]最大的正方形的边长：</p>
<p>边界情况：<br>dp[i][j] = matrix[i][j], i=0 or j = 0</p>
<p>非边界(i &gt; 0, j &gt; 0)：<br>if matrix[i][j] == 0: dp[i][j] = 0, i &gt; 0, j &gt; 0<br>if matrix[i][j] == 1: 那么dp[i][j]由左边、上方、左上方的dp决定<br>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</p>
<p>根据上面的状态转移方程，我们不难得出以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//dp[i][j]表示在点matrix[i][j]最大的正方形的边长</span></span><br><span class="line">    <span class="comment">//边界：dp[i][j] = matrix[i][j], i=0 or j = 0</span></span><br><span class="line">    <span class="comment">//if matrix[i][j] == 0: dp[i][j] = 0, i &gt; 0, j &gt; 0</span></span><br><span class="line">    <span class="comment">//if matrix[i][j] == 1: 那么dp[i][j]由左边、上方、左上方的dp决定</span></span><br><span class="line">    <span class="comment">//dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="comment">//i == 0 || j == 0是边界情况</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//可以不写，java默认初始化为0</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新最长边长</span></span><br><span class="line">                maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码更简洁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//其实几个if-else也可以合并起来，代码更简洁一些，想不到也没关系，上面的代码可读性更好</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return its area.<]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Summary Ranges And Missing Ranges]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Summary-Ranges-And-Missing-Ranges/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Summary-Ranges-And-Missing-Ranges/</id>
    <published>2016-06-16T11:13:28.000Z</published>
    <updated>2016-06-16T12:37:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”].</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//找到每一个连续期间</span></span><br><span class="line">    <span class="comment">//使用for循环遍历数组，对每一个元素不断与右边的元素相比较，如果相差为1则还是同一个连续区间，</span></span><br><span class="line">    <span class="comment">//下标i++，直到与右边元素之差不唯一则找到了一个连续区间</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; summaryRanges(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span> &lt; nums.length &amp;&amp; nums[i+<span class="number">1</span>] - nums[i] == <span class="number">1</span>) i++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i] != temp)&#123;</span><br><span class="line">                res.add(temp + <span class="string">"-&gt;"</span> + nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(temp+<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目描述-1">题目描述</h2><p>Given a sorted integer array where the range of elements are [0, 99] inclusive, return its missing ranges.<br>For example, given [0, 1, 3, 50, 75], return [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”]</p>
<p>You should be able to extend the above cases not only for the range [0,99], but any arbitrary range [start, end].</p>
<h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; getMissingRanges(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        List&lt;String&gt; ranges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> prev = start - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = (i == nums.length) ? end + <span class="number">1</span> : nums[i];</span><br><span class="line">            <span class="keyword">if</span>(curr - prev &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ranges.add(getRange(prev + <span class="number">1</span>, curr - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ranges;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getRange</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from == to ? String.valueOf(from) : from + <span class="string">"-&gt;"</span> + to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given [0,1,]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Coin Change]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Coin-Change/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Coin-Change/</id>
    <published>2016-06-16T09:47:26.000Z</published>
    <updated>2016-06-16T11:01:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p><strong> Example 1: </strong><br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>
<p><strong> Example 2: </strong><br>coins = [2], amount = 3<br>return -1.</p>
<p><strong> Note: </strong><br>You may assume that you have an infinite number of each kind of coin.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//dp[i]表示组合成总额为i需要的最少的硬币数量</span></span><br><span class="line">    <span class="comment">//dp[i] = min(dp[i-coins[j]] + 1), coins[j] &lt;= i, 0 &lt;= j &lt; coins.length</span></span><br><span class="line">    <span class="comment">//返回dp[i]即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化为最大值为amount+1，总额为amount至多需要硬币amount个硬币</span></span><br><span class="line">        <span class="comment">//不能初始化为Integer.MAX_VALUE，因为状态转移方程有dp[i] + 1，会溢出:( </span></span><br><span class="line">        <span class="comment">//Arrays.fill(dp, Integer.MAX_VALUE);</span></span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= amount; i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = 0; j &lt; coins.length; j++)&#123;</span></span><br><span class="line">        <span class="comment">//         if(coins[j] &lt;= i)&#123;</span></span><br><span class="line">        <span class="comment">//             dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin: coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt;= amount; i++)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法时间复杂度为O(n*amount)，空间复杂度为O(amount)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sqrt(x)]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Sqrt-x/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Sqrt-x/</id>
    <published>2016-06-16T06:43:38.000Z</published>
    <updated>2016-06-16T06:50:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
<h2 id="代码">代码</h2><p>使用二分搜索，方法简单写对也不容易啊:)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">    <span class="comment">//0到x甚至x/2中二分搜索吧</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//除法能防止溢出，mid*mid&gt;x会溢出</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x/mid) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//除法是有取整的，需要注意</span></span><br><span class="line">                <span class="keyword">if</span> (mid + <span class="number">1</span> &gt; x/(mid + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种写法</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> mySqrt(<span class="built_in">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) return x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">1</span>, <span class="built_in">right</span> = x;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (<span class="built_in">right</span> - <span class="built_in">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">mid</span> &lt;= x/<span class="built_in">mid</span>)&#123;</span><br><span class="line">                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">right</span> = <span class="built_in">mid</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return <span class="built_in">left</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
<h2 id="代码">代码</h2><p>使用二分搜索，方法简单写对]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Count Complete Tree Nodes]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Count-Complete-Tree-Nodes/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Count-Complete-Tree-Nodes/</id>
    <published>2016-06-16T05:32:03.000Z</published>
    <updated>2016-06-16T06:10:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a complete binary tree, count the number of nodes.</p>
<p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<h2 id="代码">代码</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//树的通用做法超时啦:)</span></span><br><span class="line">    <span class="comment">// public int countNodes(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return 0;</span></span><br><span class="line">    <span class="comment">//     return 1 + countNodes(root.left) + countNodes(root.right);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们可以改进一下，因为完全二叉树除了最后一层节点都是满，最后一层的节点都集中在最左边</span></span><br><span class="line">    <span class="comment">//我们利用完全二叉树的性质对上面的程序进行优化，如果该（子）树是满二叉树，</span></span><br><span class="line">    <span class="comment">//这里满二叉树是指的最后一层的节点也是满，我们就不递归直接利用公式进行计算,满二叉树的节点个数为2的height次方-1</span></span><br><span class="line">    <span class="comment">//否则才进行递归递归计算</span></span><br><span class="line">    <span class="comment">//（满二叉树的正式定义不是这样的。）</span></span><br><span class="line">    <span class="comment">//时间复杂度也是O(n)</span></span><br><span class="line">    <span class="keyword">public</span> int countNodes(<span class="type">TreeNode</span> root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">left</span> = root, <span class="keyword">right</span> = root;</span><br><span class="line">        int height = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">right</span> != null)&#123;</span><br><span class="line">            <span class="keyword">left</span> = <span class="keyword">left</span>.<span class="keyword">left</span>;</span><br><span class="line">            <span class="keyword">right</span> = <span class="keyword">right</span>.<span class="keyword">right</span>;</span><br><span class="line">            height++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span> == null) <span class="comment">//如果当right == null时，left == null，说明二叉树是满的</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; height) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//不是满二叉树，递归计算</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.<span class="keyword">left</span>) + countNodes(root.<span class="keyword">right</span>);</span><br><span class="line">        <span class="comment">//其实可以改为</span></span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//求完全二叉树的层数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">level</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> root == null ? <span class="number">0</span> : level(root.left) + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> level = level(root);</span><br><span class="line">         <span class="keyword">if</span>(level == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//右子树比整棵树少一层说明左子树和右子树有相同的层数，并且左子树是层数为level-1的满二叉树</span></span><br><span class="line">         <span class="comment">//右子树不一定（最后的节点在右子树上），</span></span><br><span class="line">         <span class="comment">//则利用公式计算左子树的节点数为2的(level-1)次方-1再加上根节点的话就是2的(level-1)次方</span></span><br><span class="line">         <span class="comment">//如果右子树不是比整棵树少一层说明，则最后的节点在左子树上，右子树是层数为level-2的满二叉树</span></span><br><span class="line">         <span class="comment">//则右子树的节点数为2的(level-2)次方-1加上根节点就是2的(level-2)次方</span></span><br><span class="line">         <span class="keyword">return</span> level(root.right) == level - <span class="number">1</span> ? (<span class="number">1</span> &lt;&lt; (level - <span class="number">1</span>)) + countNodes(root.right)</span><br><span class="line">                : (<span class="number">1</span> &lt;&lt; (level - <span class="number">2</span>)) + countNodes(root.left);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用的是统计层数来判断左右子树是否有相同层数，我们也可以用数的高度来求，也是类似的，这里顺便提一下树的高度的定义为：</p>
<p>Height of node:<br>The height of a node is the number of edges on the longest path between that node and a leaf.<br>Height of tree:<br>The height of a tree is the height of its root node.</p>
<p>所以只有一个节点的树的高度为0，但是层数为1。用高度来统计的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == null ? -<span class="number">1</span> : <span class="number">1</span> + height(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = height(root);</span><br><span class="line">        <span class="keyword">return</span> h &lt; <span class="number">0</span> ? <span class="number">0</span> :</span><br><span class="line">               height(root.right) == h-<span class="number">1</span> ? (<span class="number">1</span> &lt;&lt; h) + countNodes(root.right)</span><br><span class="line">                                         : (<span class="number">1</span> &lt;&lt; h-<span class="number">1</span>) + countNodes(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a complete binary tree, count the number of nodes.</p>
<p>Definition of a complete binary tree from Wikipedi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Word Break]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Word-Break/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Word-Break/</id>
    <published>2016-06-16T01:17:42.000Z</published>
    <updated>2016-06-16T02:06:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p>
<p>Return true because “leetcode” can be segmented as “leet code”.</p>
<h2 id="代码">代码</h2><p>直接递归发，超时:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || wordDict.contains(s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wordBreak(s.substring(<span class="number">0</span>, i), wordDict) &amp;&amp; wordBreak(s.substring(i, s.length()), wordDict))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用dp解决，dp[i]表示s[0]到s[i-1]中的子字符串能用字典中的词表示, 0&lt;= i &lt;= s.length()，dp[i] = dp[j] + wordDict.contains(s.substring(j, i)), 0&lt;= j &lt; i。最后返回dp[s.length()]即可。代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//dp[i]表示s[0]到s[i-1]中的子字符串能用字典中的词表示, 0&lt;= i &lt;= s.length()</span></span><br><span class="line">    <span class="comment">//dp[i] = dp[j] + wordDict.contains(s.substring(j, i)), 0&lt;= j &lt; i</span></span><br><span class="line">    <span class="comment">//返回dp[s.length()]即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        boolean[] dp = <span class="keyword">new</span> boolean[s.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; wordDict.contains(s.substring(j, i)))&#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence o]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Repeated DNA Sequences]]></title>
    <link href="http://blog.noobsky.com/2016/06/15/LeetCode-Repeated-DNA-Sequences/"/>
    <id>http://blog.noobsky.com/2016/06/15/LeetCode-Repeated-DNA-Sequences/</id>
    <published>2016-06-15T13:44:51.000Z</published>
    <updated>2016-06-15T15:45:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>
<p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>
<p>For example,</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">Given</span> <span class="atom">s</span> = <span class="string">"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"</span>,</span><br><span class="line"></span><br><span class="line"><span class="name">Return</span>:</span><br><span class="line">[<span class="string">"AAAAACCCCC"</span>, <span class="string">"CCCCCAAAAA"</span>].</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2><p>这里只有四种不同的字符，A、C、G、T，所以只需2 bits就能表示，而且题目让我们找出长度为10的重复序列(substrings)。10*2 = 20 &lt; 32，所以我们只需一个int类型就能代表这些长度为10的子字符串。然后我们用朴素的字符串匹配算法，将字符串表示为整数，然后利用集合来排重。这里要求找大于一次的子字符串，我们使用两个集合，当子字符串不能加入第一个集合说明该子字符串出现了大于等于2次，然后加入第二个集合排重。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// 这里只有四种不同的字符，A、C、G、T，所以只需2 bits就能表示，而且题目让我们找出长度为10的重复序列(substrings)</span></span><br><span class="line">    <span class="comment">// 10*2 = 20 &lt; 32，所以我们只需一个int类型就能代表这些长度为10的子字符串。然后我们用朴素的字符串匹配算法，将字符串</span></span><br><span class="line">    <span class="comment">// 表示为整数，然后利用集合来排重。这里要求找大于一次的子字符串，我们使用两个集合，当子字符串不能加入第一个集合说明</span></span><br><span class="line">    <span class="comment">// 该子字符串出现了大于等于2次，然后加入第二个集合排重。</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; findRepeatedDnaSequences(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null &amp;&amp; s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        Set&lt;Integer&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; doubleWords = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//字母对应的二进制表示 00, 01, 10,11</span></span><br><span class="line">        <span class="keyword">char</span>[] <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">'A'</span> - <span class="string">'A'</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">'C'</span> - <span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">'G'</span> - <span class="string">'A'</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="string">'T'</span> - <span class="string">'A'</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//使用朴素的字符串匹配算法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//将每个长度为10的子字符串用一个整数来表示</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; i+<span class="number">10</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//每次左移两比特位，对应一个字符</span></span><br><span class="line">                temp &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">                temp |= <span class="built_in">map</span>[s.charAt(j) - <span class="string">'A'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不能加入第一个集合，说明这个子字符串出现了大于一次，符合条件，</span></span><br><span class="line">            <span class="comment">//然后使用第二个集合来排重，看这个符合条件的子字符串是否已经加入过结果集中了</span></span><br><span class="line">            <span class="comment">//还挺tricky的:)</span></span><br><span class="line">            <span class="keyword">if</span>(!words.add(temp) &amp;&amp; doubleWords.add(temp))&#123;</span><br><span class="line">                res.add(s.substring(i, i+<span class="number">10</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When stud]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Minimum Size Subarray Sum]]></title>
    <link href="http://blog.noobsky.com/2016/06/15/LeetCode-Minimum-Size-Subarray-Sum/"/>
    <id>http://blog.noobsky.com/2016/06/15/LeetCode-Minimum-Size-Subarray-Sum/</id>
    <published>2016-06-15T11:41:36.000Z</published>
    <updated>2016-06-15T12:33:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>For example, given the array [2,3,1,2,4,3] and s = 7,<br>the subarray [4,3] has the minimal length under the problem constraint.</p>
<p><strong> More practice: </strong><br>If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</p>
<h2 id="代码">代码</h2><p>维护两个索引指针left和right，初始时两个指针指向数组首元素(下标0)，然后right往右移动，并将right指针遇到的元素求sum。当sum &gt;= s时，也就是找到了子数组和大于等于s的子数组，更新最小的子数组长度minLen,然后从sum中减去left指针指向的数组元素，接着left指针往右移动，只要sum还大于等于s，继续减去left指向元素，更新最小的子数组长度，直到sum &lt; s时内层while结束，ringt指针继续往右移动进行下一次循环。每执行一次外层while循环，其实是找到里以nums[right]结尾的且子数组和大于等于s的所以子数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// 维护两个索引指针left和right，初始时两个指针指向数组首元素(下标0)，然后right往右移动，并将right指针遇到的元素求sum</span></span><br><span class="line">    <span class="comment">// 当sum &gt;= s时，也就是找到了子数组和大于等于s的子数组，更新最小的子数组长度minLen,</span></span><br><span class="line">    <span class="comment">// 然后从sum中减去left指针指向的数组元素，接着left指针往右移动，只要sum还大于等于s，继续减去left指向元素</span></span><br><span class="line">    <span class="comment">// 则更新最小的子数组长度，直到sum &lt; s时内层while结束，ringt指针继续往右移动进行下一次循环</span></span><br><span class="line">    <span class="comment">// 每执行一次外层while循环，其实是找到里以nums[right]结尾的且子数组和大于等于s的所以子数组。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始时left和right指向数组首元素</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//该循环不会让left大于right，因为当left==right - 1时sum为0，题目说了s为正数</span></span><br><span class="line">        <span class="comment">//不用加left&lt;=right-1</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.length)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            right++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//出现了子数组和大于等于s的子数组</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">                <span class="comment">//跟新minLen</span></span><br><span class="line">                minLen = Math.min(minLen, right - left);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法right从左往右遍历一遍，left指针也从左往右遍历一遍，所以时间复杂度为O(2n) = O(n)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Majority Element I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/15/LeetCode-Majority-Element-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/15/LeetCode-Majority-Element-I-II/</id>
    <published>2016-06-15T08:00:45.000Z</published>
    <updated>2016-06-15T11:52:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Majority_Element_I">Majority Element I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and <font color="red">the majority element always exist in the array</font>.</p>
<h3 id="代码">代码</h3><p>比较常规的解法有使用HashMap计数，可以在线性时间解决，但是需要额外的内存，如果有内存限制则改方法不可取；也可以使用排序的方法，排序后出现次数超过一半的元素肯定在中间，直接返回即可。还可以使用位操作，建立一个大小为32的数组，将原数组每个数字的每位为1的数量存入这个数组。因为majorit element的数量超过一半，那么1的数量大于一半的一定是majori element的1，0的数量大于一半的，也一定是majori elemen的0。如此还原出那个majori elemen。该题最好的解法是使用摩尔投票算法，关于该算法详见维基百科<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm" target="_blank" rel="external">Boyer–Moore majority vote algorithm</a>。算法的主要思想是使用变量candidate表示当前候选众数和计数器count，从头遍历数组，如果当前数组元素与candidate相等，计算器count++。如果不相等且count等于0，将candidate置为当前元素且设置count为1；否则count–。</p>
<p>使用摩尔投票算法代码如下：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> majorityElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//自己的想法</span></span><br><span class="line">        <span class="comment">// if(nums == null || nums.length == 0) return -1;</span></span><br><span class="line">        <span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">        <span class="comment">// return nums[nums.length/2];</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>, candidate = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">count</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">count</span>++;</span><br><span class="line">                candidate = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate)&#123;</span><br><span class="line">                <span class="keyword">count</span>++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">count</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用摩尔投票算法选出的候选元素不一定是出现次数超过一半的元素，比如数组[1, 2, 3, 4, 5]返回5，我们应该在遍历一遍数组确认候选元素是否真的是出现次数超过一半的元素。但是题目中已经假设majority element肯定存在了，就不用检查了。</p>
<h2 id="Majority_Element_II">Majority Element II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.</p>
<p><strong> Hint: </strong></p>
<p>How many majority elements could it possibly have?</p>
<h3 id="代码-1">代码</h3><p>出现次数超过⌊ n/3 ⌋的元素小于等于2，我们稍微修改一下上面的摩尔投票算法，维护两个candidate和count，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//超过n/3的元素个数少于等于2</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; majorityElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> candidate1 = nums[<span class="number">0</span>], candidate2 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//这种写法当测试用例为[8,8,7,7,7]时不能通过</span></span><br><span class="line">            <span class="comment">// if(count1 == 0)&#123;</span></span><br><span class="line">            <span class="comment">//     candidate1 = nums[i];</span></span><br><span class="line">            <span class="comment">//     count1 = 1;</span></span><br><span class="line">            <span class="comment">// &#125;else if(count2 == 0)&#123;</span></span><br><span class="line">            <span class="comment">//     candidate2 = nums[i];</span></span><br><span class="line">            <span class="comment">//     count2 = 1;</span></span><br><span class="line">            <span class="comment">// &#125;else if(nums[i] == candidate1)&#123;</span></span><br><span class="line">            <span class="comment">//     count1++;</span></span><br><span class="line">            <span class="comment">// &#125;else if(nums[i] == candidate2)&#123;</span></span><br><span class="line">            <span class="comment">//     count2++;</span></span><br><span class="line">            <span class="comment">// &#125;else&#123;</span></span><br><span class="line">            <span class="comment">//     count1--;</span></span><br><span class="line">            <span class="comment">//     count2--;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count1 == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate1 = nums[i];</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count2 == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate2 = nums[i];</span><br><span class="line">                count2 = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count1 &gt; nums.length / <span class="number">3</span>) res.add(candidate1);</span><br><span class="line">        <span class="keyword">if</span>(count2 &gt; nums.length / <span class="number">3</span>) res.add(candidate2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是如果几个if-else写成如下形式不能AC：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(count1 == <span class="number">0</span>)&#123;</span><br><span class="line">	candidate1 = nums[i];</span><br><span class="line">	count1 = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(count2 == <span class="number">0</span>)&#123;</span><br><span class="line">	candidate2 = nums[i];</span><br><span class="line">	count2 = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">	count1++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">	count2++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	count1--;</span><br><span class="line">	count2--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当测试用例为[8, 8, 7, 7, 7]，正确答案为[8, 7]，但是程序只返回[7]。第一次循环时，因count1 == 0，则candidate1 = 8，count1 = 1；第二次循环时， 因count2 = 0，则candidate2 = 8，count2 = 1；第三次循环时，nums[2] == 7，count1–后为0，count2–后为0，第四、五次循环分别把candidate1和candidate2设置为7，所以最后统计时只有7。</p>
<h2 id="参考文献">参考文献</h2><p><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm" target="_blank" rel="external">Boyer–Moore majority vote algorithm</a><br><a href="http://www.geeksforgeeks.org/majority-element/" target="_blank" rel="external">Majority Element</a><br><a href="http://www.cs.utexas.edu/users/misra/scannedPdf.dir/FindRepeatedElements.pdf" target="_blank" rel="external">Finding Repeated Elements</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Majority_Element_I">Majority Element I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of size n, find the majority element. The majori]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Gas Station]]></title>
    <link href="http://blog.noobsky.com/2016/06/15/LeetCode-Gas-Station/"/>
    <id>http://blog.noobsky.com/2016/06/15/LeetCode-Gas-Station/</id>
    <published>2016-06-15T00:48:25.000Z</published>
    <updated>2016-06-15T05:06:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with <font color="red">an unlimited gas tank</font> and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p><strong> Note: </strong><br>The solution is guaranteed to be unique.</p>
<h2 id="代码">代码</h2><p>由题意我们可以得到两个性质：</p>
<ul>
<li>如果从station A出发不能到达 station B，那么A和B之间的任意station都不能到达B。（B是A第一个不能到达的station）</li>
<li>如果全部station的gas总和大于cost的总和，那么一定存在一个solution。</li>
</ul>
<p>第一个性质的简单证明：<br>假设C为A和B之间任一的加油站，我们要证明C也不能到达B。因为A不能到达B，所以A和B之间全部station的gas的总和小于cost的总和。从A出发，当到达C的时候（B是A第一个不能到达的station，A能到C），剩下的gas &gt;= 0，仍然不能到达B。因为从A到C带来了额外的gas然后从C出发都不能到达B，所以直接从C出发更不可能到达B。</p>
<p>第二个性质的证明直接从网上找的英文证明：）</p>
<ul>
<li><p>If there is only one gas station, it’s true.</p>
</li>
<li><p>If there are two gas stations a and b, and gas(a) cannot afford cost(a), i.e., gas(a) &lt; cost(a), then gas(b) must be greater than cost(b), i.e., gas(b) &gt; cost(b), since gas(a) + gas(b) &gt; cost(a) + cost(b); so there must be a way too.</p>
</li>
<li><p>If there are three gas stations a, b, and c, where gas(a) &lt; cost(a), i.e., we cannot travel from a to b directly, then:</p>
<ul>
<li><p>either if gas(b) &lt; cost(b), i.e., we cannot travel from b to c directly, then cost(c) &gt; cost(c), so we can start at c and travel to a; since gas(b) &lt; cost(b), gas(c) + gas(a) must be greater than cost(c) + cost(a), so we can continue traveling from a to b. Key Point: this can be considered as there is one station at c’ with gas(c’) = gas(c) + gas(a) and the cost from c’ to b is cost(c’) = cost(c) + cost(a), and the problem reduces to a problem with two stations. This in turn becomes the problem with two stations above.</p>
</li>
<li><p>or if gas(b) &gt;= cost(b), we can travel from b to c directly. Similar to the case above, this problem can reduce to a problem with two stations b’ and a, where gas(b’) = gas(b) + gas(c) and cost(b’) = cost(b) + cost(c). Since gas(a) &lt; cost(a), gas(b’) must be greater than cost(b’), so it’s solved too.</p>
</li>
</ul>
</li>
<li><p>For problems with more stations, we can reduce them in a similar way. In fact, as seen above for the example of three stations, the problem of two stations can also reduce to the initial problem with one station.</p>
</li>
</ul>
<p>根据以上性质可得以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sumGas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sumCost = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录开始station</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tank = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; i++)&#123;</span><br><span class="line">            sumGas += gas[i];</span><br><span class="line">            sumCost += cost[i];</span><br><span class="line">            </span><br><span class="line">            tank += gas[i] - cost[i];</span><br><span class="line">            <span class="comment">//tank小于0说明不能到达i，从下一个station i+1开始</span></span><br><span class="line">            <span class="keyword">if</span>(tank &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">                tank = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sumGas &gt;= sumCost ? start : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Duplicates from Sorted List I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Remove-Duplicates-from-Sorted-List-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Remove-Duplicates-from-Sorted-List-I-II/</id>
    <published>2016-06-14T11:35:31.000Z</published>
    <updated>2016-06-14T15:18:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Remove_Duplicates_from_Sorted_List_I">Remove Duplicates from Sorted List I</h2><h3 id="题目描述">题目描述</h3><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
<h3 id="代码">代码</h3><ul>
<li>迭代</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	 <span class="comment">//迭代</span></span><br><span class="line">    <span class="comment">//链表有序，相同元素相邻，遍历单链表，如果当前节点和下一个节点的值相等删除下一个节点</span></span><br><span class="line">    <span class="comment">//否则跳到下一个节点继续处理</span></span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前节点和下一个节点的值相等，删除下一个节点，让当前节点的next指向下下个节点</span></span><br><span class="line">            <span class="keyword">if</span>(curr.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; curr.<span class="keyword">next</span>.val == curr.val)&#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = curr.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归</li>
</ul>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        //加上判断head.<span class="keyword">next</span> == <span class="literal">null</span>判断能够保证递归返回的给head.<span class="keyword">next</span>的节点不为空</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        head.<span class="keyword">next</span> = deleteDuplicates(head.<span class="keyword">next</span>);</span><br><span class="line">        //head.<span class="keyword">next</span>不会为空</span><br><span class="line">        <span class="keyword">return</span> head.val == head.<span class="keyword">next</span>.val ? head.<span class="keyword">next</span> : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove_Duplicates_from_Sorted_List_II">Remove Duplicates from Sorted List II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
<h3 id="代码-1">代码</h3><ul>
<li>递归</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; head.<span class="keyword">next</span>.val == head.val)&#123;</span><br><span class="line">            <span class="comment">//删除所有值相等的节点</span></span><br><span class="line">            <span class="keyword">while</span>(head.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; head.<span class="keyword">next</span>.val == head.val)&#123;</span><br><span class="line">                head = head.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时head是最后一个跟前面删除节点值相等的节点，不保留,其next节点才是distinc节点</span></span><br><span class="line">            <span class="comment">//所以递归处理head.next</span></span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(head.<span class="keyword">next</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//此时head节点没有出现重复，保留</span></span><br><span class="line">            head.<span class="keyword">next</span> = deleteDuplicates(head.<span class="keyword">next</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//迭代</span></span><br><span class="line">    <span class="comment">//使用一个前驱指针pre指向上一个不重复的元素</span></span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.<span class="keyword">next</span> = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//出现重复元素，让curr指向最右边的重复元素</span></span><br><span class="line">            <span class="keyword">while</span>(curr.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; curr.<span class="keyword">next</span>.val == curr.val)&#123;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//目前没有出现重复节点，curr指向的是一个distinc numbers的节点</span></span><br><span class="line">            <span class="comment">//更新不重复节点pre为curr</span></span><br><span class="line">            <span class="comment">//没有出现重复节点是pre和curr相邻</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pre.<span class="keyword">next</span> == curr)&#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//出现了重复值的节点，curr指向最右边的重复节点，删除重复节点，pre.next = curr.next;</span></span><br><span class="line">                pre.<span class="keyword">next</span> = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Remove_Duplicates_from_Sorted_List_I">Remove Duplicates from Sorted List I</h2><h3 id="题目描述">题目描述</h3><p>Given a sorted linked list,]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Palindrome Partitioning I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Palindrome-Partitioning-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Palindrome-Partitioning-I-II/</id>
    <published>2016-06-14T11:20:32.000Z</published>
    <updated>2016-06-14T11:33:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Palindrome_Partitioning_I">Palindrome Partitioning I</h2><h3 id="题目描述">题目描述</h3><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">"aa"</span>,<span class="string">"b"</span>],</span><br><span class="line">  [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; partition(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backTrack(s, <span class="number">0</span>, curr, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">void</span> backTrack(<span class="built_in">String</span> s, <span class="built_in">int</span> start, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; curr, <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = start; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//[0, 0]是回文时然后检查[0,1]然后[0,2]</span></span><br><span class="line">            <span class="comment">//检查[0,0],递归检查子字符串。</span></span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s, start, i))&#123;</span><br><span class="line">                curr.add(s.substring(start, i+<span class="number">1</span>));</span><br><span class="line">                backTrack(s, i+<span class="number">1</span>, curr, res);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断一个字符串是否为回文字符串</span></span><br><span class="line">    public boolean isPalindrome(<span class="built_in">String</span> s, <span class="built_in">int</span> left, <span class="built_in">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Palindrome_Partitioning_II">Palindrome Partitioning II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut.</p>
<h3 id="代码-1">代码</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Palindrome_Partitioning_I">Palindrome Partitioning I</h2><h3 id="题目描述">题目描述</h3><p>Given a string s, partition s such that every sub]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Pow(x,n)]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Pow-x-n/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Pow-x-n/</id>
    <published>2016-06-14T06:42:09.000Z</published>
    <updated>2016-06-14T06:46:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>mplement pow(x, n).</p>
<h2 id="代码">代码</h2><ul>
<li>递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            <span class="comment">//n = -n在n = Integer.MIN_VALUE时会溢出，而且溢出n的值为Integer.MIN_VALUE，也就是说n没变，手动修改</span></span><br><span class="line">            <span class="comment">//如果不知道溢出后刚好n没变，就用if else</span></span><br><span class="line">            <span class="keyword">if</span>(n == Integer.MIN_VALUE)&#123;</span><br><span class="line">                n = Integer.MAX_VALUE;</span><br><span class="line">                x = x * x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span> ? myPow(x * x, n / <span class="number">2</span>) : <span class="function">x * <span class="title">myPow</span><span class="params">(x * x, n / <span class="number">2</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// if(n &lt; 0)&#123;</span></span><br><span class="line">        <span class="comment">//     if(n == Integer.MIN_VALUE)&#123;</span></span><br><span class="line">        <span class="comment">//         x = 1 / x;</span></span><br><span class="line">        <span class="comment">//         x = x * x;</span></span><br><span class="line">        <span class="comment">//         n = Integer.MAX_VALUE;</span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//         n = -n;</span></span><br><span class="line">        <span class="comment">//         x = 1/x;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            <span class="comment">//n = -n在n = Integer.MIN_VALUE时会溢出，而且溢出n的值为Integer.MIN_VALUE，也就是说n没变，手动修改</span></span><br><span class="line">            <span class="comment">//如果不知道溢出后刚好n没变，就用if else</span></span><br><span class="line">            <span class="keyword">if</span>(n == Integer.MIN_VALUE)&#123;</span><br><span class="line">                n = Integer.MAX_VALUE;</span><br><span class="line">                x = x * x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>) ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>mplement pow(x, n).</p>
<h2 id="代码">代码</h2><ul>
<li>递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td cla]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
