<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-06-05T01:43:27.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Combination Sum I II III]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Combination-Sum-I-II-III/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Combination-Sum-I-II-III/</id>
    <published>2016-06-04T12:23:07.000Z</published>
    <updated>2016-06-05T01:43:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Combination_Sum_I">Combination Sum I</h2><h3 id="题目描述">题目描述</h3><p>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>The same repeated number may be chosen from C unlimited number of times.</p>
<p>Note:</p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</li>
<li>The solution set must not contain duplicate combinations.</li>
<li>For example, given candidate set 2,3,6,7 and target 7,<br>A solution set is:<br>[7]<br>[2, 2, 3]</li>
</ul>
<h3 id="代码">代码</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(candidates, <span class="keyword">target</span>, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">target</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; <span class="keyword">target</span> &gt;= candidates[i]; i++)&#123;</span><br><span class="line">                curr.add(candidates[i]);</span><br><span class="line">                <span class="comment">//元素可以重复利用，所以start为i</span></span><br><span class="line">                helper(candidates, <span class="keyword">target</span> - candidates[i], res, curr, i);</span><br><span class="line">                <span class="comment">//回溯，删除curr中最后一个元素</span></span><br><span class="line">                curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(<span class="keyword">target</span> == <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">            <span class="comment">//找到一个序列</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Combination_Sum_II">Combination Sum II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>Each number in C may only be used once in the combination.</p>
<p>Note:</p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>For example, given candidate set 10,1,2,7,6,1,5 and target 8,<br>A solution set is:<br>[1, 7]<br>[1, 2, 5]<br>[2, 6]<br>[1, 1, 6] </p>
<h3 id="代码-1">代码</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(candidates, <span class="keyword">target</span>, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">target</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">target</span> &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; <span class="keyword">target</span> &gt;= candidates[i]; i++)&#123;</span><br><span class="line">            <span class="comment">//i==start || candidates[i]!=candidates[i-1]避免重复结果</span></span><br><span class="line">            <span class="comment">//等价于（i&gt;start&amp;&amp;candidates[i]==candidates[i-1] continue</span></span><br><span class="line">            <span class="comment">//i大于start意味着candidates[i-1]已经从curr被remove，所以如果candidates[i]==candidates[i-1]</span></span><br><span class="line">            <span class="comment">//则我们不应该将candidates[i]加入curr中</span></span><br><span class="line">            <span class="keyword">if</span>(i==start || candidates[i]!=candidates[i-<span class="number">1</span>])&#123;</span><br><span class="line">                curr.add(candidates[i]);</span><br><span class="line">                <span class="comment">//candidates的每个元素智能使用一次,所以下一次递归时为i+1</span></span><br><span class="line">                helper(candidates, <span class="keyword">target</span>-candidates[i], res, curr, i+<span class="number">1</span>);</span><br><span class="line">                curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Combination_Sum_III">Combination Sum III</h2><h3 id="题目描述-2">题目描述</h3><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Ensure that numbers within the set are sorted in ascending order.</p>
<p>Example 1:</p>
<p>Input: k = 3, n = 7</p>
<p>Output:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<p>Input: k = 3, n = 9</p>
<p>Output:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>], [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(k, n, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> need, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(need == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//需要寻找从i开始的need个数，所以需要满足target &gt;= i+(i+1)+...+(i+need-1) = i*need+need*(need-1)/2</span></span><br><span class="line">        <span class="comment">//即i开始的need个数最小和为i+(i+1)+...+(i+need-1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i != <span class="number">10</span> &amp;&amp; target &gt;= i * need + need * (need - <span class="number">1</span>) / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            curr.add(i);</span><br><span class="line">            helper(need-<span class="number">1</span>, target-i, res, curr, i+<span class="number">1</span>);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Combination_Sum_I">Combination Sum I</h2><h3 id="题目描述">题目描述</h3><p>Given a set of candidate numbers (C) and a target number (T), fin]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Find Minimum in Rotated Sorted Array I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Find-Minimum-in-Rotated-Sorted-Array-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Find-Minimum-in-Rotated-Sorted-Array-I-II/</id>
    <published>2016-06-04T07:07:07.000Z</published>
    <updated>2016-06-04T08:49:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Find_Minimum_in_Rotated_Sorted_Array_I">Find Minimum in Rotated Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<h3 id="代码如下">代码如下</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="keyword">public</span> int findMin(int[] nums) &#123;</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>])&#123;<span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">                <span class="keyword">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="keyword">right</span>])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                <span class="keyword">right</span> = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="keyword">left</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Find_Minimum_in_Rotated_Sorted_Array_II">Find Minimum in Rotated Sorted Array II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for “Find Minimum in Rotated Sorted Array”:<br>What if duplicates are allowed?</p>
<p>Would this affect the run-time complexity? How and why?<br>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<h3 id="代码">代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="comment">//nums[mid] &gt; nums[right],nums[left:mid]有序，搜索右边</span></span><br><span class="line">    <span class="comment">//nums[mid] &lt; nums[right],nums[mid:right]有序，搜索左边</span></span><br><span class="line">    <span class="comment">//nums[mid] = nums[right],有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">    <span class="comment">//但可以肯定排除nums[right],即使min = A[right],排除A[right]并没有使min丢失</span></span><br><span class="line">    <span class="keyword">public</span> int findMin(int[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span>+(<span class="keyword">right</span> - <span class="keyword">left</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="keyword">right</span>])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                <span class="keyword">right</span> = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">                <span class="keyword">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="keyword">left</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Find_Minimum_in_Rotated_Sorted_Array_I">Find Minimum in Rotated Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Suppose a sorted array ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Populating Next Right Pointers in Each Node I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Populating-Next-Right-Pointers-in-Each-Node/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Populating-Next-Right-Pointers-in-Each-Node/</id>
    <published>2016-06-04T05:28:55.000Z</published>
    <updated>2016-06-04T06:38:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Populating_Next_Right_Pointers_in_Each_Node_I">Populating Next Right Pointers in Each Node I</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">struct</span> TreeLinkNode &#123;</span><br><span class="line">      <span class="title">TreeLinkNode</span> *left;</span><br><span class="line">      <span class="title">TreeLinkNode</span> *right;</span><br><span class="line">      <span class="title">TreeLinkNode</span> *next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<ul>
<li>You may only use constant extra space.</li>
<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
<p>For example,<br>Given the following perfect binary tree,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>After calling your function, the tree should look like:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span> -&gt; <span class="literal">NULL</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">NULL</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span> -&gt; <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p>
<h3 id="代码如下">代码如下</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree with next pointer.</span><br><span class="line"> * public class TreeLinkNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeLinkNode left, right, next;</span><br><span class="line"> *     TreeLinkNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//思路比较直接，直接迭代法遍历,分层处理</span></span><br><span class="line">    <span class="comment">//注意，所有节点的next都初始化为null</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> connect(TreeLinkNode root)&#123;</span><br><span class="line"></span><br><span class="line">		TreeLinkNode levelStart = root;</span><br><span class="line">		TreeLinkNode curr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(levelStart != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//从每一层的第一个节点开始处理</span></span><br><span class="line">			curr = levelStart;</span><br><span class="line">			<span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(curr.left != <span class="keyword">null</span>) curr.left.<span class="keyword">next</span> = curr.right;</span><br><span class="line">				<span class="keyword">if</span>(curr.right != <span class="keyword">null</span> &amp;&amp; curr.<span class="keyword">next</span> != <span class="keyword">null</span>) curr.right.<span class="keyword">next</span> = curr.<span class="keyword">next</span>.left;</span><br><span class="line">				curr = curr.<span class="keyword">next</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//换到下一层第一个节点</span></span><br><span class="line">			levelStart = levelStart.left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Populating_Next_Right_Pointers_in_Each_Node_II">Populating Next Right Pointers in Each Node II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for problem “Populating Next Right Pointers in Each Node”.</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note:</p>
<ul>
<li>You may only use constant extra space.<br>For example,<br>Given the following binary tree,<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"> / \    \</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>    <span class="number">7</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>After calling your function, the tree should look like:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span> -&gt; <span class="literal">NULL</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">NULL</span></span><br><span class="line"> / \    \</span><br><span class="line"><span class="number">4</span>-&gt; <span class="number">5</span> -&gt; <span class="number">7</span> -&gt; <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p>
<h3 id="代码">代码</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree with <span class="built_in">next</span> pointer.</span><br><span class="line"> * public class TreeLinkNode &#123;</span><br><span class="line"> *     <span class="typename">int</span> val;</span><br><span class="line"> *     TreeLinkNode left, right, <span class="built_in">next</span>;</span><br><span class="line"> *     TreeLinkNode(<span class="typename">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void connect(TreeLinkNode root)&#123;</span><br><span class="line">        TreeLinkNode levelStart = root;<span class="comment">//下一层的最左边节点</span></span><br><span class="line">        TreeLinkNode <span class="built_in">prev</span> = <span class="built_in">null</span>; <span class="comment">//下一层的前一节点</span></span><br><span class="line">        TreeLinkNode curr = <span class="built_in">null</span>;<span class="comment">//当前节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(levelStart != <span class="built_in">null</span>)&#123;</span><br><span class="line">            curr = levelStart;</span><br><span class="line">            <span class="built_in">prev</span> = <span class="built_in">null</span>;</span><br><span class="line">            <span class="comment">//不能缺少，少了会超时（只有根节点的情况），&#123;0&#125;死循环</span></span><br><span class="line">            levelStart = <span class="built_in">null</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(curr != <span class="built_in">null</span>)&#123;</span><br><span class="line">                <span class="comment">//不为空，进行处理</span></span><br><span class="line">                if(curr.left != <span class="built_in">null</span>)&#123;</span><br><span class="line">                    if(<span class="built_in">prev</span> != <span class="built_in">null</span>)</span><br><span class="line">                        <span class="built_in">prev</span>.<span class="built_in">next</span> = curr.left;</span><br><span class="line">                    else</span><br><span class="line">                        levelStart = curr.left;<span class="comment">//没有prev节点的话，则新的levelStart为curr.left</span></span><br><span class="line">                    <span class="comment">//处理完之后，curr.left成为prev节点</span></span><br><span class="line">                    <span class="built_in">prev</span> = curr.left;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if(curr.right != <span class="built_in">null</span>)&#123;</span><br><span class="line">                    if(<span class="built_in">prev</span> != <span class="built_in">null</span>)</span><br><span class="line">                        <span class="built_in">prev</span>.<span class="built_in">next</span> = curr.right;</span><br><span class="line">                    else</span><br><span class="line">                        levelStart = curr.right;</span><br><span class="line">                    <span class="comment">//处理完之后，curr.left成为prev节点</span></span><br><span class="line">                    <span class="built_in">prev</span> = curr.right;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr.<span class="built_in">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Populating_Next_Right_Pointers_in_Each_Node_I">Populating Next Right Pointers in Each Node I</h2><h3 id="题目描述">题目描述</h3><p>Given a b]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Unique Paths I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Unique-Paths-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Unique-Paths-I-II/</id>
    <published>2016-06-04T02:38:02.000Z</published>
    <updated>2016-06-04T04:03:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Unique_Paths">Unique Paths</h2><h3 id="题目描述">题目描述</h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="http://7xonwi.com1.z0.glb.clouddn.com/robot_maze.png" alt=""><br>Above is a 3 x 7 grid. How many possible unique paths are there?</p>
<p>Note: m and n will be at most 100.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//a[m][n] = a[m-1][n]+a[m][n-1]</span></span><br><span class="line">    <span class="comment">// public int uniquePaths(int m, int n) &#123;</span></span><br><span class="line">    <span class="comment">//     if(m &lt;= 0 || n &lt;= 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int[][] grid = new int[m][n];</span></span><br><span class="line">    <span class="comment">//     //第一排和第一列都为1</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; m; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         grid[i][0] = 1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     for(int j = 0; j &lt; n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//         grid[0][j] = 1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt; m; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 1; j &lt; n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             grid[i][j] = grid[i-1][j]+grid[i][j-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return grid[m-1][n-1];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a[m][n] = a[m-1][n]+a[m][n-1]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                grid[i][j] = (i == <span class="number">0</span> || j == <span class="number">0</span>) ? <span class="number">1</span> : grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Unique_Paths_II">Unique Paths II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p>For example,<br>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> grid[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) grid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">0</span> : grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) grid[<span class="number">0</span>][j] = (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) ? <span class="number">0</span> : grid[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                grid[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也可以但是不够好理解</span></span><br><span class="line">    <span class="comment">// public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span></span><br><span class="line">    <span class="comment">//     int m = obstacleGrid.length;</span></span><br><span class="line">    <span class="comment">//     if(m == 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int n = obstacleGrid[0].length;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int grid[][] = new int[m+1][n+1];</span></span><br><span class="line">    <span class="comment">//     grid[0][1] = 1;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt;= m; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 1; j &lt;= n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             grid[i][j] = obstacleGrid[i-1][j-1] == 1 ? 0 : grid[i-1][j]+grid[i][j-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return grid[m][n];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Unique_Paths">Unique Paths</h2><h3 id="题目描述">题目描述</h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ i]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Gray Code]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Gray-Code/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Gray-Code/</id>
    <published>2016-06-04T00:59:16.000Z</published>
    <updated>2016-06-04T01:55:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> - <span class="number">0</span></span><br><span class="line"><span class="number">01</span> - <span class="number">1</span></span><br><span class="line"><span class="number">11</span> - <span class="number">3</span></span><br><span class="line"><span class="number">10</span> - <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Note:<br>For a given n, a gray code sequence is not uniquely defined.</p>
<p>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Int    Grey Code    Binary</span><br><span class="line"> <span class="number">0</span>  　　  <span class="number">000</span>        <span class="number">000</span></span><br><span class="line"> <span class="number">1</span>  　　  <span class="number">001</span>        <span class="number">001</span></span><br><span class="line"> <span class="number">2</span>   　 　<span class="number">011</span>        <span class="number">010</span></span><br><span class="line"> <span class="number">3</span>   　 　<span class="number">010</span>        <span class="number">011</span></span><br><span class="line"> <span class="number">4</span>   　 　<span class="number">110</span>        <span class="number">100</span></span><br><span class="line"> <span class="number">5</span>   　 　<span class="number">111</span>        <span class="number">101</span></span><br><span class="line"> <span class="number">6</span>   　 　<span class="number">101</span>        <span class="number">110</span></span><br><span class="line"> <span class="number">7</span>   　　 <span class="number">100</span>        <span class="number">111</span></span><br></pre></td></tr></table></figure>
<h2 id="解法一">解法一</h2><p>利用格雷码和二进制数的相互转换，G(i)=(i/2)^i<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//G(i)=(i/2)^i</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; grayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            res.add(i ^ (i&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二">解法二</h2><p>格雷码有镜射排列的性质，即n位元的格雷码可以从n-1位元的格雷码以上下镜射后加上新位元的方式快速得到，如下图所示<br><img src="https://upload.wikimedia.org/wikipedia/commons/c/c1/Binary-reflected_Gray_code_construction.svg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//镜面排列</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; grayCode(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        res.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> highBit = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                res.add(res.get(j)+highBit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-ne]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Generate Parentheses]]></title>
    <link href="http://blog.noobsky.com/2016/06/03/LeetCode-Generate-Parentheses/"/>
    <id>http://blog.noobsky.com/2016/06/03/LeetCode-Generate-Parentheses/</id>
    <published>2016-06-03T12:00:58.000Z</published>
    <updated>2016-06-03T12:24:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:</p>
<p>“((()))”, “(()())”, “(())()”, “()(())”, “()()()”</p>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(n,n,<span class="string">""</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="comment">//在每次递归函数中记录左括号和右括号剩余的数量，然后有两种选择，一种是放一个左括号，一种放一个右括号</span></span><br><span class="line">    <span class="comment">//有一些否定条件，比如右括号的数量不能比左括号少，左右括号的数量要大于0</span></span><br><span class="line">    <span class="comment">//正常的递归终止条件是左右括号的数量都为0</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// public void helper(int left, int right, String item, List&lt;String&gt; res)&#123;</span></span><br><span class="line">    <span class="comment">//     //右括号的数量比左括号少，递归终止</span></span><br><span class="line">    <span class="comment">//     if(right &lt; left) return;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(right == 0 &amp;&amp; left == 0) res.add(item);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(left &gt; 0) helper(left-1, right, item+"(", res);</span></span><br><span class="line">    <span class="comment">//     if(right &gt; 0) helper(left, right-1, item+")", res);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//right不能比左括号少，且right &gt; 0,即条件为right &gt; left</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String item, List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//右括号的数量比左括号少，递归终止</span></span><br><span class="line">        <span class="comment">//if(right &lt; left) return;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">0</span> &amp;&amp; left == <span class="number">0</span>) res.add(item);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>) helper(left-<span class="number">1</span>, right, item+<span class="string">"("</span>, res);</span><br><span class="line">        <span class="comment">//右括号比左括号多时才能往下递归，比如n=3，当递归到helper(1,1,"()()",res),"()()"+")"显然是不可行的</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; left) helper(left, right-<span class="number">1</span>, item+<span class="string">")"</span>, res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]House Robber I II III]]></title>
    <link href="http://blog.noobsky.com/2016/06/03/LeetCode-House-Robber-I-II-III/"/>
    <id>http://blog.noobsky.com/2016/06/03/LeetCode-House-Robber-I-II-III/</id>
    <published>2016-06-03T06:25:53.000Z</published>
    <updated>2016-06-03T08:51:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="House_Robber_I">House Robber I</h2><h3 id="题目描述">题目描述</h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<h3 id="解题思路及代码">解题思路及代码</h3><p>dp解法，第i家要么不抢要么抢，dp[i] = max(dp[i-1],dp[i-2]+nums[i])，dp数组可以省略</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//dp[i] = max(dp[i-1],dp[i-2]+nums[i])</span></span><br><span class="line">    <span class="comment">//自己想的，O(n),但是需要O(n)的内存空间</span></span><br><span class="line">    <span class="comment">// public int rob(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(nums.length == 1) return nums[0];</span></span><br><span class="line">    <span class="comment">//     int[] dp = new int[nums.length];</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     dp[0] = nums[0];</span></span><br><span class="line">    <span class="comment">//     dp[1] = Math.max(nums[0], nums[1]);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     for(int i = 2; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return dp[nums.length - 1];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ifRobedPrevious = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ifDontRobedPrevious = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前house要么抢要么不抢</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//当前house抢能获得的money，则前一house不能抢，</span></span><br><span class="line">            <span class="keyword">int</span> currentRobed = ifDontRobedPrevious + nums[i];</span><br><span class="line">            <span class="comment">//当前house不抢能获得的money，则为前一house抢或者不抢，取最大值</span></span><br><span class="line">            <span class="keyword">int</span> currentNotRobed = Math.max(ifRobedPrevious, ifDontRobedPrevious);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对于下一次循环来说相当于前一house抢</span></span><br><span class="line">            ifRobedPrevious = currentRobed;</span><br><span class="line">            <span class="comment">//对于下一次循环来说相当于前一house不抢</span></span><br><span class="line">            ifDontRobedPrevious = currentNotRobed;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(ifRobedPrevious, ifDontRobedPrevious);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="House_Robber_II">House Robber II</h2><h3 id="题目描述-1">题目描述</h3><p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<h3 id="解题思路及代码-1">解题思路及代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//房子首尾相连形成了一个圈，所以i间房子和i+1间房子只能有一间抢，或者两者都不抢</span></span><br><span class="line">    <span class="comment">//如果假设第i间不抢，则我们可以打断该圈，比如1-&gt;2-&gt;3-&gt;1则变成了2-&gt;3如果1不抢，</span></span><br><span class="line">    <span class="comment">//我们假设第i间房子不抢，剩下的房子组成的连续序列用House Robber的方法求解出最大值max1</span></span><br><span class="line">    <span class="comment">//然后假设第i+1间房子不抢，剩下的房子组成的连续序列用House Robber的方法求解出最大值max2，max1和max2的较大者即为所求</span></span><br><span class="line">    <span class="comment">//为了编程简单，我们选择i=n，i+1=0，也就是说我们把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后比较两个值取</span></span><br><span class="line">    <span class="comment">//取其中的最大值即为所求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(robHelper(nums, <span class="number">0</span>, nums.length-<span class="number">2</span>), robHelper(nums, <span class="number">1</span>, nums.length-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robHelper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> robedPrevious = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dontRobedPrevious = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> currentRobed = dontRobedPrevious + nums[i];</span><br><span class="line">            <span class="keyword">int</span> currentDontRobed = Math.max(robedPrevious, dontRobedPrevious);</span><br><span class="line">            </span><br><span class="line">            robedPrevious = currentRobed;</span><br><span class="line">            dontRobedPrevious = currentDontRobed;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(robedPrevious, dontRobedPrevious);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="House_Robber_III">House Robber III</h2><h3 id="题目描述-2">题目描述</h3><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>
<p><em>Example 1:</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> \   \ </span><br><span class="line">  <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.<br><em>Example 2:</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"> / \   \ </span><br><span class="line"><span class="number">1</span>   <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>
<h3 id="解题思路及代码-2">解题思路及代码</h3><ul>
<li>方法一</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//最优子结构：如果从想从当前二叉树中抢到最大的money，那么从子二叉树也是应该抢到最多的money</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    <span class="comment">//递归解法，会有很多重复子问题，效率低</span></span><br><span class="line">    <span class="comment">//max(抢root，不抢root) 即max(rob(root),rob(root.left)+rob(root.right))</span></span><br><span class="line">    <span class="keyword">public</span> int rob(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">      <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">      int val = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span>(root.<span class="keyword">left</span> != null)&#123;</span><br><span class="line">          val += rob(root.<span class="keyword">left</span>.<span class="keyword">left</span>)+rob(root.<span class="keyword">left</span>.<span class="keyword">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span>(root.<span class="keyword">right</span> != null)&#123;</span><br><span class="line">          val += rob(root.<span class="keyword">right</span>.<span class="keyword">left</span>)+rob(root.<span class="keyword">right</span>.<span class="keyword">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">return</span> <span class="type">Math</span>.<span class="built_in">max</span>(val+root.val, rob(root.<span class="keyword">left</span>)+rob(root.<span class="keyword">right</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//最优子结构：如果从想从当前二叉树中抢到最大的money，那么从子二叉树也是应该抢到最多的money</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="comment">//直接递归有很多重复子问题，可以利用带备忘的递归，使用HashMap记录访问过的子树的结果</span></span><br><span class="line">    <span class="keyword">public</span> int rob(<span class="type">TreeNode</span> root)&#123;</span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">TreeNode</span>, <span class="type">Integer</span>&gt; <span class="built_in">map</span> = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> robHelper(root, <span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> int robHelper(<span class="type">TreeNode</span> root, <span class="type">Map</span>&lt;<span class="type">TreeNode</span>, <span class="type">Integer</span>&gt; <span class="built_in">map</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果map中存在root对应的值，则不需要递归，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(root)) <span class="keyword">return</span> <span class="built_in">map</span>.<span class="keyword">get</span>(root);</span><br><span class="line">        </span><br><span class="line">        int val = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.<span class="keyword">left</span> != null)&#123;</span><br><span class="line">            val += robHelper(root.<span class="keyword">left</span>.<span class="keyword">left</span>, <span class="built_in">map</span>)+robHelper(root.<span class="keyword">left</span>.<span class="keyword">right</span>, <span class="built_in">map</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.<span class="keyword">right</span> != null)&#123;</span><br><span class="line">            val += robHelper(root.<span class="keyword">right</span>.<span class="keyword">left</span>, <span class="built_in">map</span>)+robHelper(root.<span class="keyword">right</span>.<span class="keyword">right</span>,<span class="built_in">map</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        val = <span class="type">Math</span>.<span class="built_in">max</span>(val+root.val, robHelper(root.<span class="keyword">left</span>, <span class="built_in">map</span>)+robHelper(root.<span class="keyword">right</span>,<span class="built_in">map</span>));</span><br><span class="line">        <span class="comment">//将root对应的max money存入map中</span></span><br><span class="line">        <span class="built_in">map</span>.put(root, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法三</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//最优子结构：如果从想从当前二叉树中抢到最大的money，那么从子二叉树也是应该抢到最多的money</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//方法三</span></span><br><span class="line">    <span class="comment">//重新定义rob(root)函数，返回值为含有两个元素的数组，第一个元素代表不抢root获得的最大money，</span></span><br><span class="line">    <span class="comment">//第二个元素代表抢root获得的最大money</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = robHelper(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] robHelper(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] left = robHelper(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = robHelper(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//不抢root，则left可抢其子root也可不抢其子root,right同理</span></span><br><span class="line">        res[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//抢root,则left和right不能抢其子root</span></span><br><span class="line">        res[<span class="number">1</span>] = root.val +  left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="House_Robber_I">House Robber I</h2><h3 id="题目描述">题目描述</h3><p>You are a professional robber planning to rob houses along a street. Ea]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://blog.noobsky.com/tags/Dynamic-Programming/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Convert Sorted Array/List to Binary Search Tree]]></title>
    <link href="http://blog.noobsky.com/2016/06/02/LeetCode-Convert-Sorted-Array-List-to-Binary-Search-Tree/"/>
    <id>http://blog.noobsky.com/2016/06/02/LeetCode-Convert-Sorted-Array-List-to-Binary-Search-Tree/</id>
    <published>2016-06-02T07:01:58.000Z</published>
    <updated>2016-06-02T15:16:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Convert_Sorted_Array_to_Binary_Search_Tree">Convert Sorted Array to Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="解题思路与代码">解题思路与代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意判断是否为start&gt;end,不然会发生数组越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="comment">//取中间节点作为树的root，可以保证是height balanced的BST</span></span><br><span class="line">        <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, start, mid-<span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Convert_Sorted_List_to_Binary_Search_Tree">Convert Sorted List to Binary Search Tree</h2><h3 id="题目描述-1">题目描述</h3><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="解题思路与代码-1">解题思路与代码</h3><p>方法一：O(nlogn) runtime, O(logn) stack space<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//类似Convert Sorted Array to BST，找出中间节点</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(nlgn),找中间节点为O(n),需要找lgn次</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="comment">//pre指向slow前一节点，记录slow前面是否有节点</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//找出单链表的中间节点,循环结束后slow指向单链表的中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pre != null意味着slow前面有节点，pre.next = null,head则为单链表的前半部分</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//pre == null 意味着slow前面没有节点</span></span><br><span class="line">        <span class="keyword">else</span> head = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        <span class="comment">//head指向单链表前半部分的头结点</span></span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        <span class="comment">//slow.next指向单链表后半部分的头结点</span></span><br><span class="line">        root.right = sortedListToBST(slow.<span class="keyword">next</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二：O(n) runtime, O(logn) stack space, Bottom-up recursion<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="keyword">list</span>;</span><br><span class="line">    <span class="comment">//感觉不好理解</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode sortedListToBST(ListNode head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">list</span> = head;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,size-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode helper(<span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        TreeNode left = helper(start, mid-<span class="number">1</span>);</span><br><span class="line">        TreeNode <span class="keyword">parent</span> = <span class="keyword">new</span> TreeNode(<span class="keyword">list</span>.val);</span><br><span class="line">        <span class="keyword">parent</span>.left = left;</span><br><span class="line">        <span class="keyword">list</span> = <span class="keyword">list</span>.next;</span><br><span class="line">        <span class="keyword">parent</span>.right = helper(mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Convert_Sorted_Array_to_Binary_Search_Tree">Convert Sorted Array to Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given an array ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="Tree" scheme="http://blog.noobsky.com/tags/Tree/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Unique Binary Search Trees I II]]></title>
    <link href="http://blog.noobsky.com/2016/05/31/LeetCode-Unique-Binary-Search-Trees/"/>
    <id>http://blog.noobsky.com/2016/05/31/LeetCode-Unique-Binary-Search-Trees/</id>
    <published>2016-05-31T07:18:22.000Z</published>
    <updated>2016-06-03T09:57:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Unique_Binary_Search_Trees_I">Unique Binary Search Trees I</h2><h3 id="题目描述">题目描述</h3><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>      <span class="number">2</span></span><br><span class="line"> /     /       \                 \</span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                 <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路">解题思路</h3><p>G(n): 序列长度为n的不同BST的数量<br>F(i, n): 1&lt;= i &lt;= n为根节点，序列为1到n的不同BST的数量<br>则G(n) = F(1,n) + F(2,n) + F(3,n) + …… + F(n,n)<br>F(i, n) = G(i-1)*G(n-i)<br>G(n) = G(0)(n-1) + G(1)G(n-2) + G(2)G(n-3)+……+G(n-1)G(0)</p>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] G = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">				G[i] += G[j-<span class="number">1</span>]*G[i-j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> G[n];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique_Binary_Search_Trees_II">Unique Binary Search Trees II</h2><h3 id="题目描述-1">题目描述</h3><p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For example,<br>Given n = 3, your program should return all 5 unique BST’s shown below.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>      <span class="number">2</span></span><br><span class="line"> /     /       \                 \</span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                 <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>代码如下：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode <span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode <span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; generateTrees(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) return <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        return genTreeList(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; genTreeList(<span class="built_in">int</span> start, <span class="built_in">int</span> <span class="keyword">end</span>)&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start &gt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            res.add(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = start; i &lt;= <span class="keyword">end</span>; i++)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftList = genTreeList(start, i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightList = genTreeList(i+<span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(TreeNode <span class="built_in">left</span> : leftList)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode <span class="built_in">right</span>: rightList)&#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.<span class="built_in">left</span> = <span class="built_in">left</span>;</span><br><span class="line">                    root.<span class="built_in">right</span> = <span class="built_in">right</span>;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Unique_Binary_Search_Trees_I">Unique Binary Search Trees I</h2><h3 id="题目描述">题目描述</h3><p>Given n, how many structurally unique BST’s]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Kth Smallest Element in a BST]]></title>
    <link href="http://blog.noobsky.com/2016/05/28/LeetCode-Kth-Smallest-Element-in-a-BST/"/>
    <id>http://blog.noobsky.com/2016/05/28/LeetCode-Kth-Smallest-Element-in-a-BST/</id>
    <published>2016-05-28T15:19:28.000Z</published>
    <updated>2016-05-31T07:19:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<p>Hint:</p>
<p>1.Try to utilize the property of a BST.<br>2.What if you could modify the BST node’s structure?<br>3.The optimal runtime complexity is O(height of BST).</p>
<p>代码如下：<br>方法一：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二叉搜索树，左儿子比根节点小，右儿子比根节点大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> kthSmallest(TreeNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//统计左子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = countNodes(root.left);</span><br><span class="line">        <span class="comment">//左子树的节点个数大于等于k，说明第k小的元素在左子树中，递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.left, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第k个元素在右子树中，相当于在右子树中寻找第k-count-1小的元素</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">count</span> &lt; k-<span class="number">1</span>) <span class="keyword">return</span> kthSmallest(root.right, k - <span class="keyword">count</span> -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//count = k-1,说明左子树有k-1个节点，跟该节点即为第k小的元素</span></span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计节点个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> countNodes(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">//使用中序遍历法，因为中序遍历二叉树是有序的</span></span><br><span class="line">    <span class="comment">//使用递归中序遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        count = k;</span><br><span class="line">        dfsHelper(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left != null) dfsHelper(root.left);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            number = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != null) dfsHelper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用迭代法中序遍历</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        <span class="keyword">while</span>(curr != null || !<span class="built_in">stack</span>.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr != null)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = <span class="built_in">stack</span>.pop();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> curr.val;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>Note:<br>Y]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Odd Even Linked List]]></title>
    <link href="http://blog.noobsky.com/2016/05/28/LeetCode-Odd-Even-Linked-List/"/>
    <id>http://blog.noobsky.com/2016/05/28/LeetCode-Odd-Even-Linked-List/</id>
    <published>2016-05-28T09:37:55.000Z</published>
    <updated>2016-05-28T09:39:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>Example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,<br>return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.</p>
<p>Note:<br>The relative order inside both the even and odd groups should remain as it was in the input.<br>The first node is considered odd, the second node even and so on …</p>
<p>代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//最直观的做法就是将奇数节点放到一个链表，偶数节点放到另一个链接，然后将偶数节点的链表链接到奇数链表的尾部即可</span></span><br><span class="line">    <span class="keyword">public</span> ListNode oddEvenList(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//odd奇数,even偶数节点，evenHead</span></span><br><span class="line">        ListNode odd = head, even = head.<span class="keyword">next</span>, evenHead = even;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(even != <span class="keyword">null</span> &amp;&amp; even.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            odd.<span class="keyword">next</span> = even.<span class="keyword">next</span>;</span><br><span class="line">            odd = odd.<span class="keyword">next</span>;</span><br><span class="line">            </span><br><span class="line">            even.<span class="keyword">next</span> = odd.<span class="keyword">next</span>;</span><br><span class="line">            even = even.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        odd.<span class="keyword">next</span> = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talki]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximum Product of Word Lengths]]></title>
    <link href="http://blog.noobsky.com/2016/05/28/LeetCode-Maximum-Product-of-Word-Lengths/"/>
    <id>http://blog.noobsky.com/2016/05/28/LeetCode-Maximum-Product-of-Word-Lengths/</id>
    <published>2016-05-28T08:20:16.000Z</published>
    <updated>2016-05-28T09:38:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.</p>
<p>Example 1:<br>Given [“abcw”, “baz”, “foo”, “bar”, “xtfn”, “abcdef”]<br>Return 16<br>The two words can be “abcw”, “xtfn”.</p>
<p>Example 2:<br>Given [“a”, “ab”, “abc”, “d”, “cd”, “bcd”, “abcd”]<br>Return 4<br>The two words can be “ab”, “cd”.</p>
<p>Example 3:<br>Given [“a”, “aa”, “aaa”, “aaaa”]<br>Return 0<br>No such pair of words.</p>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//使用一个int来记录一个字符串中出现的字符，题目说只包含26个小写字母，一个int有32比特位，足够表示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words == null || words.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = words.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">//使用masks[i]记录words[i]含有的字符信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历words[i]的每个字符，masks[i]的最低比特位表示words[i]是否含有字符a(1表示含有</span></span><br><span class="line">            <span class="comment">//，0表示不含)，最高位表示是否含有字符z</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch: words[i].toCharArray())&#123;</span><br><span class="line">                masks[i] |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxProduct = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">                <span class="comment">//(masks[i] &amp; masks[j]) == 0表示两个word没有相同的字符</span></span><br><span class="line">                <span class="keyword">if</span>((masks[i] &amp; masks[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    maxProduct = Math.max(maxProduct, words[i].length()*words[j].length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者优化一下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个int来记录一个字符串中出现的字符，题目说只包含26个小写字母，一个int有32比特位，足够表示</span></span><br><span class="line"><span class="comment">//我们还可以先对words数组按字符串长度排序，后面就可以进行剪枝优化,排序为O(nlgn)，不影响O(n*n)的时间复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(words == null || words.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对words数组按字符串长度排序</span></span><br><span class="line">    Arrays.sort(words, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b.length() - a.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> length = words.length;</span><br><span class="line">    <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="comment">//使用masks[i]记录words[i]含有的字符信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="comment">//遍历words[i]的每个字符，masks[i]的最低比特位表示words[i]是否含有字符a(1表示含有</span></span><br><span class="line">        <span class="comment">//，0表示不含)，最高位表示是否含有字符z</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch: words[i].toCharArray())&#123;</span><br><span class="line">            masks[i] |= <span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxProduct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="comment">//words[i].length() * words[i].length()是words[i]最大可能的maxProduct</span></span><br><span class="line">        <span class="keyword">if</span>(words[i].length() * words[i].length() &lt; maxProduct) <span class="keyword">break</span>; <span class="comment">//剪枝优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">            <span class="comment">//(masks[i] &amp; masks[j]) == 0表示两个word没有相同的字符</span></span><br><span class="line">            <span class="keyword">if</span>((masks[i] &amp; masks[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                maxProduct = Math.max(maxProduct, words[i].length()*words[j].length());</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//剪枝，越前面的字符串求到的maxProduct越大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxProduct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Integer Break]]></title>
    <link href="http://blog.noobsky.com/2016/05/28/LeetCode-Integer-Break/"/>
    <id>http://blog.noobsky.com/2016/05/28/LeetCode-Integer-Break/</id>
    <published>2016-05-28T04:36:50.000Z</published>
    <updated>2016-05-28T04:43:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.</p>
<p>For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p>
<p>Note: you may assume that n is not less than 2.</p>
<p>Hint:</p>
<p>There is a simple O(n) solution to this problem.<br>You may check the breaking results of n ranging from 7 to 10 to discover the regularities.</p>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//2 = 1+1,1</span></span><br><span class="line">    <span class="comment">//3 = 1+2,2</span></span><br><span class="line">    <span class="comment">//4 = 2+2,4</span></span><br><span class="line">    <span class="comment">//5 = 2+3,6</span></span><br><span class="line">    <span class="comment">//6 = 3+3,9</span></span><br><span class="line">    <span class="comment">//7 = 3+4,12</span></span><br><span class="line">    <span class="comment">//8 = 2+3+3,18</span></span><br><span class="line">    <span class="comment">//9 = 3+3+3,27</span></span><br><span class="line">    <span class="comment">//10 = 3+3+2+2,36</span></span><br><span class="line">    <span class="comment">//11 = 3*3*3*2</span></span><br><span class="line">    <span class="comment">//12 = 3*3*3*3</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            product *= <span class="number">3</span>;</span><br><span class="line">            n = n -<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        product *= n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[n] = max(max(i,dp[i])*max(n-i,dp[n-i])),i = <span class="number">1.</span>.n/<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j,dp[j])*Math.max(i-j,dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of th]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Missing Number]]></title>
    <link href="http://blog.noobsky.com/2016/05/28/LeetCode-Missing-Number/"/>
    <id>http://blog.noobsky.com/2016/05/28/LeetCode-Missing-Number/</id>
    <published>2016-05-28T03:34:43.000Z</published>
    <updated>2016-05-28T03:56:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>For example,<br>Given nums = [0, 1, 3] return 2.</p>
<p>Note:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<p>这道题给我们n个数字，是0到n之间的数但是有一个数字去掉了，让我们寻找这个数字，要求线性的时间复杂度和常数级的空间复杂度。</p>
<p>代码如下：<br>方法一：排序</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没说是按顺序来排的</span></span><br><span class="line">    <span class="comment">//最直观的方法：Arrays.sort时间复杂度为O(nlgn)</span></span><br><span class="line">    <span class="keyword">public</span> int missingNumber(int[] nums) &#123;</span><br><span class="line">        <span class="comment">//先排序就可以了</span></span><br><span class="line">        <span class="type">Arrays</span>.<span class="built_in">sort</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != nums[i]) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int missingNumber(int[] nums) &#123; <span class="comment">//binary search</span></span><br><span class="line">    	<span class="type">Arrays</span>.<span class="built_in">sort</span>(nums);</span><br><span class="line">    	int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length, mid= (<span class="keyword">left</span> + <span class="keyword">right</span>)/<span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="keyword">left</span>&lt;<span class="keyword">right</span>)&#123;</span><br><span class="line">        	mid = (<span class="keyword">left</span> + <span class="keyword">right</span>)/<span class="number">2</span>;</span><br><span class="line">        	<span class="keyword">if</span>(nums[mid]&gt;mid) <span class="keyword">right</span> = mid;</span><br><span class="line">        	<span class="keyword">else</span> <span class="keyword">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">left</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：异或</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//可以利用异或，异或有交换性质，除了一个missing number以外，每一个number都会存在一个下标跟这个number相等</span><br><span class="line">    //相等的数异或为<span class="number">0</span>，一个数跟<span class="number">0</span>异或为自己本身，所以我们只要遍历一遍数组，每次异或下标i和nums[i]</span><br><span class="line">    //[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]:<span class="number">0</span>^<span class="number">0</span>^<span class="number">1</span>^<span class="number">1</span>^<span class="number">2</span>^<span class="number">3</span></span><br><span class="line">    //<span class="number">2</span>^<span class="number">3</span> = <span class="number">10</span>^<span class="number">11</span> = <span class="number">1</span> 如何转换为最终结果<span class="number">2</span>，答案是再异或上nums.length,<span class="number">01</span>^<span class="number">11</span> = <span class="number">10</span> = <span class="number">2</span></span><br><span class="line">    //如果这种想法正确的话，我们很容易猜到最后要异或上数组的长度，比如特例[<span class="number">0</span>,<span class="number">1</span>],返回<span class="number">2</span>，就是<span class="number">0</span>异或nums.length</span><br><span class="line">    //如果不用这种特例来猜也是可以说明的</span><br><span class="line">    //分两种情况：第一种情况是数组所有的元素都有相应的下边对应，那么missing number为nums.length,而数组里的数异或为<span class="number">0</span>，则返回</span><br><span class="line">    //<span class="number">0</span> ^ nums.length = nums.length</span><br><span class="line">    //第二种情况是数组里不是所有的元素都有相应的下边对应，也就是missing number为nums中的某一个元素，这种情况下nums.length</span><br><span class="line">    //必为数组中的一个元素，比如[<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>]，假设下边i没有元素对应，则此时相当于i^nums.length^nums.length = i</span><br><span class="line">    public <span class="type">int</span> missingNumber(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="literal">result</span> = <span class="literal">result</span> ^ i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span> ^ nums.length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法三：求和</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> missingNumber(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">sum</span> = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">sum</span> += i - nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Bulb Swithcher]]></title>
    <link href="http://blog.noobsky.com/2016/05/27/LeetCode-Bulb-Swithcher/"/>
    <id>http://blog.noobsky.com/2016/05/27/LeetCode-Bulb-Swithcher/</id>
    <published>2016-05-27T12:09:31.000Z</published>
    <updated>2016-05-28T03:35:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.</p>
<p>Example:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given n = <span class="number">3.</span> </span><br><span class="line"></span><br><span class="line">At <span class="keyword">first</span>, <span class="operator">the</span> <span class="constant">three</span> bulbs are [off, off, off].</span><br><span class="line">After <span class="keyword">first</span> <span class="built_in">round</span>, <span class="operator">the</span> <span class="constant">three</span> bulbs are [<span class="command"><span class="keyword">on</span>, <span class="title">on</span>, <span class="title">on</span>].</span></span><br><span class="line">After <span class="keyword">second</span> <span class="built_in">round</span>, <span class="operator">the</span> <span class="constant">three</span> bulbs are [<span class="command"><span class="keyword">on</span>, <span class="title">off</span>, <span class="title">on</span>].</span></span><br><span class="line">After <span class="keyword">third</span> <span class="built_in">round</span>, <span class="operator">the</span> <span class="constant">three</span> bulbs are [<span class="command"><span class="keyword">on</span>, <span class="title">off</span>, <span class="title">off</span>]. </span></span><br><span class="line"></span><br><span class="line">So you should <span class="constant">return</span> <span class="number">1</span>, because there is only <span class="constant">one</span> bulb is <span class="command"><span class="keyword">on</span>.</span></span><br></pre></td></tr></table></figure></p>
<h2 id="题目大意">题目大意</h2><p>给定n个灯泡，初始的时候灯都是灭的，让你进行开关灯。第一轮的时候把1的倍数反转（原来关的就开，原来开的就关），第二轮把2的倍数反转，以此类推，第n轮是把n的倍数反转。</p>
<h2 id="解题思路">解题思路</h2><p>由题意可知，每当灯泡会发生状态改变时，也就是toggle时，是因为它是某个数的整数倍。<br>对于第1个灯泡：1*1，会改变1次状态（第一轮是1的倍数），即off -&gt; on<br>对于第2个灯泡：1*2，2*1，会改变两次状态（第一轮是1的倍数，第二轮是2的倍数），即off -&gt; on -&gt; off<br>对于第3个灯泡：1*3，3*1，会改变两次状态（第一轮是1的倍数，第三轮是3的倍数），即off -&gt; on -&gt; off<br>对于第4个灯泡：1*4，2*2，4*1，会改变三次状态（第一轮是1的倍数，第二轮是2的倍数，第四轮是4的倍数），即off -&gt; on -&gt; off -&gt; on<br>……</p>
<p>我们可以发现，没当我们找到一个数的整数倍时，总会存在另外一个对称的整数倍，例如1*3，还会有3*1。唯一例外的就是平方数，例如4=2*2，只会有一个整数倍。<br>对于某位置上的灯泡，如果出现了偶数个整数倍时，最终的该灯泡都会还原为初始的off状态；如果出现了奇数个整数倍时，最终的该位置的灯泡的状态为on。由上面的推导可知，只有在平方数位置上的灯泡，比如，1、4、9位置上的灯泡会出现奇数个整数倍，最终的该位置的灯泡状态为on，也就是说，最终为on的灯泡的数目由小于或等于n的平方数决定，所以问题等价于求1到n之间完全平方数的个数。所以代码就很简单了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.<span class="built_in">sqrt</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. O]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java单例模式]]></title>
    <link href="http://blog.noobsky.com/2016/05/17/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.noobsky.com/2016/05/17/Java单例模式/</id>
    <published>2016-05-17T14:29:05.000Z</published>
    <updated>2016-05-17T16:44:14.000Z</updated>
    <content type="html"><![CDATA[<p>单例模式应该是设计模式中最容易理解，也是最容易手写代码，但这并不意味着简单，想要写对、用对单例模式还是需要费一番脑筋的。因为其中的坑不少，它也常作为面试题来考。本文对Java中常见的单例模式写法做一个总结。</p>
<h2 id="饿汉式">饿汉式</h2><p>饿汉式就是在类第一次加载到内存中就进行初始化</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>声明成static，类加载时就初始化</li>
<li>final意味着该实例不能重新生成，确保只有一个实例存在</li>
<li>private构造函数表明这个类不能调用构造方法生成其他实例</li>
<li>既然这个类不能调用构造方法形成实例，那么我们需要一个静态的方法getInstance()让其获得一个实例</li>
</ul>
<p>这种方法的好处是编写简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。但是这种方法无法做到延迟创建对象。但是我们很多时候都希望对象可以尽可能地延迟加载，从而减小负载，所以就需要下面的懒汉式。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//去掉final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法使用懒加载模式，由私有构造器和一个共有静态方法构成，在工厂方法中对singleton进行null判断，如果是null就new一个出来，最后返回singleton对象。这种方法可以实现延迟加载，但是有一个致命弱点：线程不安全。在单线程下可以正常工作，如果有多条线程同时调用getSingleton()方法时，很大可能导致重复创建对象。比如第一个线程进行singleton == null后还没执行后面的new，第二个线程也进行singleton == null判断时也为true，此时两个线程都会new出一个不同实例。</p>
<h2 id="线程安全的懒汉式">线程安全的懒汉式</h2><p>为了解决上面线程不安全的问题，最简单的方法就是把getSingleton方法设置为synchronize（同步）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//去掉final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做虽然是线程安全的，能解决多实例问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了同步代码块和双重检验锁。</p>
<h2 id="兼顾线程安全和效率">兼顾线程安全和效率</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="built_in">Singleton</span> &#123;</span><br><span class="line">    private <span class="keyword">static</span> <span class="built_in">Singleton</span> <span class="built_in">singleton</span> = <span class="literal">null</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    private <span class="built_in">Singleton</span>()&#123;&#125;<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">Singleton</span> getSingleton()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">singleton</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized (<span class="built_in">Singleton</span>.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">singleton</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="built_in">singleton</span> = new <span class="built_in">Singleton</span>()<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">singleton</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法被称为“双重检查锁”，顾名思义，就是在getSingleton方法中，进行两次null检查。</p>
<ul>
<li>第一null检查，如果实例创建了，就没必要进行同步了直接返回</li>
<li>如果没创建，就开始线程同步</li>
<li>第二个null检查，如果被同步的线程中，有一个线程创建了对象，那么其他线程就不需要创建了<br>第一次null检查极大提升了并发度，去掉第一次null检查跟上面的线程安全的懒汉式效果差不多。第二次null检查也是必须的，如果去掉，如下：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果有多个线程同时通过(singleton== null)的条件检查（因为他们并行运行），虽然我们的synchronized方法会帮助我们同步所有的线程，让我们并行线程变成串行的一个一个去new，同样会出现很多实例。</p>
<p>双重检查锁的代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面3件事情。</p>
<ol>
<li>给singleton分配内存</li>
<li>调用Singleton的构造函数来初始化成员变量，形成实例</li>
<li>将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）<br>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时instance已经是非 null了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。我们只需要将 instance 变量声明成 volatile 就可以了。<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>有些人认为使用volatile的原因是可见性，也就是可以保证线程在本地不会存有singleton的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完1-2-3 之后或者1-3-2之后，不存在执行到1-3然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>但是需要注意的是volatile的禁止指令重排优化这条语义知道JDK1.5才能正确使用。所以在JDK1.5之前双重检查锁的形式的单例模式是无法保证线程安全的。</p>
<p>为了个延迟加载，搞出来这么多问题，我们还是使用前面的饿汉式吧：）。</p>
<h2 id="静态内部类法">静态内部类法</h2><p>《Effective Java》中推荐使用静态内部类的方式实现单例模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这种方式，仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>
<h2 id="高大上的枚举Enum">高大上的枚举Enum</h2><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Jaye <span class="keyword">on</span> <span class="number">16</span>/<span class="number">5</span>/<span class="number">18</span>.</span><br><span class="line"> */</span><br><span class="line">public <span class="class"><span class="keyword">enum</span>  <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>居然用枚举！！看上去好牛逼，通过Singleton.INSTANCE来访问，这比调用getInstance()方法简单多了。</p>
<p>默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>单例模式应该是设计模式中最容易理解，也是最容易手写代码，但这并不意味着简单，想要写对、用对单例模式还是需要费一番脑筋的。因为其中的坑不少，它也常作为面试题来考。本文对Java中常见的单例模式写法做一个总结。</p>
<h2 id="饿汉式">饿汉式</h2><p>饿汉式就是]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出Node.js读书笔记]]></title>
    <link href="http://blog.noobsky.com/2016/05/16/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.noobsky.com/2016/05/16/深入浅出Node-js读书笔记/</id>
    <published>2016-05-16T03:34:25.000Z</published>
    <updated>2016-05-16T08:13:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Node简介">Node简介</h2><h3 id="Node诞生历程">Node诞生历程</h3><ul>
<li>2009.3，Ryan Dahl在其博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。</li>
<li>2009.5，Ryan Dahl在GitHub上发布了最初的版本。</li>
<li>2009.12和2010.4，两届JSConf大会都安排了Node的讲座。</li>
<li>2010年年底，Node获得硅谷云计算服务商Joyent公司的资助，其创始人Ryan Dahl加入Joyent公司全职负责Node的发展。</li>
<li>2011.7，Node在微软的支持下发布了其Windows版本。</li>
<li>2011.11，Node超越Ruby on Rails，成为GitHub上关注度最高的项目（随后被Bootstrap项目超越，目前仍居第二）。</li>
<li>2012.1，Ryan Dahl在对Node架构设计满意的情况下，将掌门人的身份转交给Isaac Z. Schlueter，自己转向一些研究项目。Isaac Z. Schlueter是Node的包管理器NPM的作者，之后Node的版本发布和bug修复等工作由他接手。</li>
<li>2014.1.15 Node 掌门人更改为 TJ Fontaine, Isaac 成立公司 npm, Inc. 专注于 NPM 相关开发和维护.</li>
<li>2014.3 Node.js 0.12(1.0-RC)发布, API锁定, 下一版本即为1.0</li>
<li>2014.7.4 TJ Holowaychuk 离开Node世界， 转投Go怀抱</li>
<li>2014.10 Node 项目被fork， node-forward创建社区，想用新的方式推动Node的发展</li>
<li>2014.10.13 Node.js Advisory Board 以一种开发，自由的方式，推动 Node 项目发展</li>
<li>随后Node的发布计划主要集中在性能提升上。</li>
</ul>
<h3 id="Node的命名与起源">Node的命名与起源</h3><h4 id="为什么是JavaScript">为什么是JavaScript</h4><ul>
<li>高性能（Chrome浏览器JS的v8引擎性能在浏览器中第一）</li>
<li>符合事件驱动（JavaScript在浏览器有广泛的事件驱动方面的应用）</li>
<li>没有历史包袱（为其导入非阻塞的I/O库没有额外阻力）</li>
</ul>
<h4 id="为什么叫Node">为什么叫Node</h4><p>其目标是成为一个构建快速、可伸缩的网络应用平台。可以通过通信协议来组织许多Node，非常容易通过扩展来达成构建大型网络应用的目的。<br>每一个Node进程都构成这个网络应用的一个节点，这是它名字所含意义的真谛。</p>
<h3 id="Node给JavaScript带来的意义">Node给JavaScript带来的意义</h3><ul>
<li>Node结构与Chrome十分相似，基于事件驱动的异步结构</li>
<li>Node中得JavaScript可以访问本地文件，搭建服务器，连接数据库，玩转多进程</li>
<li>Node打破了过去JavaScript只能在浏览器中运行的局面，前后端统一</li>
</ul>
<h3 id="Node的特点">Node的特点</h3><ul>
<li>异步I/O</li>
<li>事件与回调函数</li>
<li>单线程</li>
<li>跨平台</li>
</ul>
<h3 id="Node的应用场景">Node的应用场景</h3><ul>
<li>I/O密集型</li>
<li>不是很擅长CPU密集型业务，但是可以合理调度</li>
<li>分布式应用</li>
</ul>
<p>关于Node，探讨的较多的主要由I/O密集型和CPU密集型，Node面向网络且擅长并行I/O，总而言之，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。</p>
<h3 id="Node的使用者">Node的使用者</h3><ul>
<li>前后端编程语言环境统一：雅虎开放了Cocktail框架</li>
<li>Node带来的高性能I/O用于实时应用：Voxer和腾讯</li>
<li>并行I/O使得使用者可以更高效地利用分布式环境：阿里巴巴和eBay</li>
<li>并行I/O，有效利用稳定接口提升Web渲染能力：雪球财经和LinkedIn</li>
<li>云计算平台提供Node支持：微软、Joyent、阿里云…</li>
<li>游戏开发领域：网易开源了pomelo实时框架</li>
<li>工具类应用</li>
</ul>
<h2 id="模块机制">模块机制</h2><h3 id="Node的模块">Node的模块</h3><p>JavaScript先天就缺乏一项功能：模块，其他高级语言中Java、Python有import机制，Ruby有require，PHP有include和require……浏览器JavaScript通过script标签引入代码的方式显得杂乱无章，语言自身显得毫无组织和约束能力</p>
<ul>
<li>Node的模块分为两类：一类是Node提供的模块，称为核心（原生）模块；另一类是用户编写的模块，称为文件模块</li>
<li>Node通过require引用模块</li>
<li>对应引用的功能，通过exports对象来导出当前模块的方法或变量。模块中还存在一个module对象，exports实际上是module的属性。在Node中，一个文件就是一个模块，模块内的“全局变量”对外都不可见，只有挂载在exports上的属性才是公开的。exports 是指向的 module.exports 的引用</li>
</ul>
<h3 id="包与NPM">包与NPM</h3><ul>
<li>包是在模块基础上更深一步的抽象,Node.js的包类似于 C/C++ 的函数库或者 Java/.Net 的类库。它将某个独立的功能封装起来,用于发布、更新、依赖管理和版本控制。</li>
<li>严格符合CommonJS规范的包应该包含以下文件:<ul>
<li>package.json:包描述文件</li>
<li>bin：用于存放可执行二进制文件的目录</li>
<li>lib：用于存放JavaScript代码的目录</li>
<li>doc：用于存放文档的目录</li>
<li>test：用于存放单元测试用例的代码 </li>
</ul>
</li>
</ul>
<h3 id="NPM：_Node包管理器（Node_Package_Manager）">NPM： Node包管理器（Node Package Manager）</h3><p>Node.js根据CommonJS规范实现了包机制,开发了npm来解决包的发布和获取需求。NPM常用功能：</p>
<ul>
<li>查看帮助：npm –h、npm help <command></li>
<li>安装依赖包：npm install express –g(全局安装)、npm install <file>(本地安装)</file></li>
<li>发布包</li>
<li>分析包</li>
</ul>
<h2 id="异步I/O">异步I/O</h2><p>异步I/O就是I/O 操作不采用阻塞的策略。当线程遇到 I/O 操作时,不会以阻塞的方式等待 I/O 操作 的完成或数据的返回,而只是将 I/O<br>请求发送给操作系统,继续执行下一条语句。当操作系统完成 I/O 操作时,以事件的形式通知执行 I/O 操作的线程,线程会在特定时候处理这个事件。<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/Nodejs1.png" alt=""></p>
<p>为了处理异步 I/O,线程必须有事件循环,不断地检查有没有未处理的事件,依次予以处理。CPU与 I/O并行执行，计算设备与I/O设备互不干扰</p>
<h3 id="为什么要异步I/O">为什么要异步I/O</h3><ul>
<li>用户体验</li>
</ul>
<p>假如一个资源来自于两个不同位置的数据的返回，第一个资源需要M毫秒的耗时，第二个资源需要N毫秒的耗时。如果采用同步的方式，代码大致如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费时间为M</span></span><br><span class="line">getData(<span class="string">'from_db'</span>);</span><br><span class="line"><span class="comment">//消费时间为N</span></span><br><span class="line">getData(<span class="string">'from_remote_api'</span>);</span><br></pre></td></tr></table></figure></p>
<p>如上如果采用同步方式，那么时间消耗为M+N。但是如果采用异步方式，第一个资源的获取并不会阻塞第二个资源。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//消费时间为M</span><br><span class="line">getData('from_db',function(<span class="literal">result</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">//消费时间为N</span><br><span class="line">getData('from_remote_api',function(<span class="literal">result</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果采用异步的方式则时间消耗为Max(M, N)。随着应用复杂性的增加，情景将会变为M+N+…和Max(M,N,…)</p>
<ul>
<li>资源分配：利用异步I/O，让单线程远离阻塞，更好利用CPU</li>
</ul>
<h3 id="Node的异步I/O">Node的异步I/O</h3><ul>
<li>事件循环</li>
<li>观察者</li>
<li>执行回调</li>
</ul>
<p>Node异步I/O环节事件循环、观察者、执行回调。当进程启动时，Node便会创建一个类似于while(true)的循环、每执行一次循环体的过程称为Tick。<br>每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。在每个Tick的过程中，如何判断是否有事件需要处理呢？这里必须引入的概念是观察者。每个事件循环中有一个或者多个观察者，而判断是否有事件处理的过程就是向这些观察者询问是否有要处理的事件。</p>
<h3 id="知名的基于事件驱动的实现">知名的基于事件驱动的实现</h3><ul>
<li>Ruby的Event Machine</li>
<li>Perl的AnyEvent</li>
<li>Python的Twisted</li>
<li>Node异步I/O</li>
</ul>
<p>前面介绍异步的实现原理的过程中，我们也勾勒出了事件驱动的本质，即通过主循环加事件触发的方式来运行程序。事实上，Node的异步I/O并非首创，但却是第一个成功地平台，在那之前，也有一些知名的基于事件驱动的实现，具体如下所示。这些库没有成功地原因是同步I/O库的存在。因为在这些成熟的语言平台上，异步不是主流，尽管有这些事件驱动的实现库，但开发者总会习惯性的采用同步I/O库，这导致预想的高性能直接落空。</p>
<h2 id="异步编程">异步编程</h2><p>有异步I/O，必有异步编程</p>
<h3 id="函数式编程">函数式编程</h3><p>JavaScript中，函数作为一等公民，使用非常自由</p>
<ul>
<li>直接调用</li>
<li>赋值给其他变量</li>
<li>作为参数</li>
<li>作为返回值</li>
</ul>
<h3 id="回调">回调</h3><p>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，异步的方式读取文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步读取文件内容</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'file.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (err) &#123; </span><br><span class="line">		<span class="built_in">console</span>.error(err);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="comment">//doSomething</span></span><br><span class="line">		<span class="built_in">console</span>.log(data);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end.'</span>);</span><br></pre></td></tr></table></figure>
<p>fs.readFile 接收了三个参数, 第一个是文件名,第二个是编码方式,第三个是一个函数,我们称这个函数为回调函数。 异步式 I/O 请求发送给了操作系统,然后立即 返回并执行后面的语句,执行完以后进入事件循环监听事件。当 fs 接收到 I/O 请求完成的 事件时,事件循环会主动调用回调函数以完成后续工作。因此我们会先看到 end.,再看到 file.txt 文件的内容。 </p>
<h3 id="异步编程的难点">异步编程的难点</h3><h4 id="异常处理">异常处理</h4><p>尝试对异步方法进行try/catch操作只能捕获当次事件循环内的异常，对callback执行时抛出的异常将无能为力，示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步方法</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">	process.nextTick(callback);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">async</span>(callback);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Node约定，将异常作为回调函数的第一个实参传回，</span></span><br><span class="line"><span class="comment">//如果为空值，则表明异步调用没有异常抛出</span></span><br><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span>(<span class="params">err,results</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Node约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出。我们自行编写的异步方法上，也需要遵循这样一些原则：</p>
<ul>
<li>必须执行调用者传入的回调函数；</li>
<li>正确传递回异常供调用者判断。</li>
</ul>
<h4 id="函数嵌套过深">函数嵌套过深</h4><p>世界上本没有嵌套回调，写得人多了，也便有了}}}}}}}}}}。比如遍历目录，三层嵌套：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历目录</span></span><br><span class="line">fs.readdir(path.join(__dirname,<span class="string">'..'</span>),<span class="function"><span class="keyword">function</span><span class="params">(err,files)</span></span>&#123;</span><br><span class="line">	files.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span><span class="params">(filename,index)</span></span>&#123;</span><br><span class="line">		fs.readFile(filename,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span><span class="params">(err,file)</span></span>&#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="阻塞代码">阻塞代码</h4><p>竟然没有sleep()这样的线程沉睡功能，所以有多半开发者会写出下述这样的代码来实现sleep(1000)的效果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - start &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要阻塞的代码</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码会持续占用CPU进行判断，与真正的线程沉睡相去甚远，完全破坏了事件循环的调度。由于Node单线程的原因，CPU资源全都会用于为这段代码服务，导致其余任何请求都会得不到响应。Node单线程不能充分利用多核CPU，后面会介绍相关解决办法</p>
<h3 id="异步编程解决方案">异步编程解决方案</h3><p>前面列举了因异步编程带来的一些问题，编程过程看起来似乎没有想象中美好，但是事实也没用那么糟糕。这里介绍一些典型的解决方案<br>后面两种方法复杂，需要长篇幅来介绍，这里只介绍一下前面的两种基础方法。</p>
<h4 id="事件发布/订阅模式">事件发布/订阅模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅</span></span><br><span class="line">emitter.on(<span class="string">"event1"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//发布</span></span><br><span class="line">emitter.emit(<span class="string">"event1"</span>,<span class="string">"I am message!"</span>);</span><br></pre></td></tr></table></figure>
<p>事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式。Node自身提供的events模块是发布/订阅模式的一个简单实现。</p>
<h4 id="流程控制库">流程控制库</h4><ul>
<li>async</li>
<li>Step<br>第二可以通过流程控制库，来处理异步的各种协作模式。Async和Step都提供了异步的串行执行和异步的并行执行等方法，相关用法查阅官方文档即可。</li>
</ul>
<h2 id="内存控制">内存控制</h2><p>JavaScript与Java一样，由垃圾回收机制来自行自动内存管理。对于性能敏感的服务器端程序，内存管理的好坏、<br>垃圾回收状况是否优良，都会对服务构成影响。而在Node，这一切都与Node的JavaScript执行引擎V8息息相关。<br>V8的垃圾回收策略主要基于分代式垃圾回收机制。</p>
<h3 id="V8的垃圾回收机制与内存控制">V8的垃圾回收机制与内存控制</h3><ul>
<li>Node与V8:Node在JavaScript的执行上直接受益于V8，同时也受到V8的一些限制</li>
<li>V8的内存限制：64位系统1.4GB，32位0.7GB</li>
<li>V8的对象分配：通过堆分配，内存使用量process.memoryUsage()可查询</li>
<li>V8的垃圾回收机制：<br>  （1）V8的内存分代：新生代（存活时间较短）和老生代（存活时间较长）<br>  （2）Scavenge算法（新生代）：采用复制的方式（空间换时间）<br>  （3）Mark-Sweep&amp;Mark-Compact（老生代）：标记清除，标记整理<br>  （4）Incremental Marking：增量标记</li>
</ul>
<p>Scavenge算法将堆内存分为两个空间，只有一个使用，称为From空间，另一个闲置，称为To空间。垃圾回收时，将From的存活对象复制到TO空间，非存活释放。然后两个空间对换，开始下一轮回收<br>标记清除：标记阶段遍历堆中所有对象，标记活得对象；接下来在清除阶段只清除没有被标记的对象<br>标记整理：标记清除的问题是清除后，内存不连续，会造成无法分配大对象。标记整理清除阶段将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。<br>增量标记：垃圾回收的3种基本算法都需要将应用逻辑暂停下来，这种暂停成为“全停顿”。V8先从标记阶段入手，将原本一口气停顿完成的动作改为增量标记，也就是拆分为许多小“步进”，每做完一步就让JS应用逻辑执行一小会儿。垃圾回收与应用逻辑交替执行，大大减少停顿时间</p>
<h3 id="内存指标">内存指标</h3><ul>
<li>查看进程占用：process.memoryUsage()</li>
<li>查看系统的内存占用：os模块中的totalmem()和freemem()分别返回总内存和闲置内存</li>
<li>堆外内存（不是通过V8分配：Buffer）：意味利用堆外内存可以突破内存的限制</li>
</ul>
<h3 id="内存泄露">内存泄露</h3><p>在垃圾回收机制下，通常的代码编写中，很少会出现内存泄露的情况，通常会造成内存泄露的原因有以下几个；<br>原因：缓存、队列消费不及时、作用域未释放<br>解决方案：将缓存转移到外部，减少常驻内存的对象的数量（Redis，Memcached）；监控队列的长度<br>内存泄露排查：node-heapdump（对V8堆内存抓取快照、分析）、node-memwatch（抓取快照、比较快照）</p>
<h2 id="理解Buffer">理解Buffer</h2><h3 id="Buffer结构">Buffer结构</h3><p>在网络流和文件的操作中，需要处理大量二进制数据，JavaScript自有的字符串远远不能满足这些需求，于是Buffer对象应运而生。它将性能相关的部分用C++实现，将非性能相关的部分用JavaScript实现。内存应用时，由于Node的内存限制，若不需要进行字符串层面的操作，可以尝试使用Buffer来操作，这不会受到V8堆内存的限制，但依然会受到物理内存限制。</p>
<ul>
<li>模块结构：JavaScript与C++结合的模块</li>
<li>Buffer对象：类似于数组，元素是16进制的两位数（0-255）</li>
<li>Buffer的内存分配：在Node的C++层面申请；不是V8分配的，属于堆外内存</li>
<li>在文件I/O和网络I/O中运用广泛，尤其在网络传输中，它的性能举足轻重</li>
</ul>
<h3 id="Buffer与字符串的相互转换">Buffer与字符串的相互转换</h3><ul>
<li>目前支持的编码类型：ASCII、UTF-8、UTF-16LE/UCS-2、Base64、Binary、Hex</li>
<li>字符串转Buffer：new Buffer(str, [encoding])</li>
<li>Buffer转字符串：buf.toString([encoding],[start],[end])</li>
<li>Buffer不支持的编码类型：通过Buffer.isEncoding(encoding)判断是否支持转换；中国常用的GBK、GB2312等都不支持；借助生态圈中的iconv和iconv-lite两个模块解决</li>
</ul>
<h3 id="网络编程">网络编程</h3><p>利用Node可以十分方便地搭建网络服务器，不需要专门的Web服务器作为容器，仅仅需要几行代码就可以构建服务器。Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务端和客户端。</p>
<h4 id="HTTP服务器&amp;&amp;TCP服务器">HTTP服务器&amp;&amp;TCP服务器</h4><ul>
<li>HTTP服务器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:1337/'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>TCP服务器</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var net = <span class="keyword">require</span>(<span class="string">'net'</span>);</span><br><span class="line">var server = net.createServer(function (<span class="keyword">socket</span>) &#123;</span><br><span class="line">  <span class="keyword">socket</span>.<span class="keyword">write</span>(<span class="string">'Echo server\r\n'</span>);</span><br><span class="line">  <span class="keyword">socket</span>.<span class="keyword">pipe</span>(<span class="keyword">socket</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="keyword">listen</span>(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="构建Web应用">构建Web应用</h2><p>构建Web应用过程中用到很多技术细节，如数据处理、路由、MVC、模板、RESTful等，详见以下脑图。实现这些细节就可以完成一个功能完备的Web开发框架。<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/Nodejs2.png" alt=""></p>
<h2 id="玩转进程">玩转进程</h2><h3 id="Node单线程">Node单线程</h3><p>好处：程序状态单一，没有多线程的锁、同步问题，操作系统调度较少的上下文切换，可以很好地提高CPU的使用率<br>问题：</p>
<ul>
<li>如何充分利用多核CPU服务器</li>
<li>如何保证进程的健壮性和稳定性</li>
</ul>
<h3 id="多进程架构">多进程架构</h3><p>Node提供了child_process模块，并提供child_process.fork()实现进程的复制。<br>worker.js：http服务器，监听1000到2000之间的一个随机端口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http  = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/plain'</span>&#125;);</span><br><span class="line">	res.end(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;).listen(<span class="built_in">Math</span>.round((<span class="number">1</span>+<span class="built_in">Math</span>.random())*<span class="number">1000</span>),<span class="string">'127.0.0.1'</span>);</span><br></pre></td></tr></table></figure>
<p>master.js：根据当前机器上的CPU地数量复制出对应Node进程数</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">fork</span> = <span class="keyword">require</span>(<span class="string">'child_process'</span>).<span class="keyword">fork</span>;</span><br><span class="line">var cpus = <span class="keyword">require</span>(<span class="string">'os'</span>).cpus();</span><br><span class="line"><span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; cpus.<span class="keyword">length</span>; i++)&#123;</span><br><span class="line">	<span class="keyword">fork</span>(<span class="string">'./worker.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理想状态下，每个进程各自利用一个CPU，以此实现多核CPU的利用。如下图：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/Nodejs3.png" alt=""></p>
<h3 id="Master-Worker模式（主从模式）">Master-Worker模式（主从模式）</h3><p><img src="http://7xonwi.com1.z0.glb.clouddn.com/Nodejs4.png" alt=""></p>
<p>上图就是著名的Master-Worker模式，又称主从模式。图中的进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好地可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是倾向于稳定的。fork进程是昂贵的，好在这里启动多个进程只是为了充分将CPU资源利用起来，而不是为了解决并发问题</p>
<h3 id="集群稳定之路:自动重启">集群稳定之路:自动重启</h3><p><img src="http://7xonwi.com1.z0.glb.clouddn.com/Nodejs5.png" alt=""><br>我们创建了很多工作进程，但每个工作进程依然是在单线程上执行的，稳定性不能得到保障。我们在主进程上加入一些子进程管理的机制，当有子进程退出时重新启动一个工作进程来继续服务。</p>
<ul>
<li>工作进程得知要退出时(有未捕获的异常出现)，向主进程发送自杀信号</li>
<li>然后停止接收新的连接，当所有连接断开后才退出</li>
<li>主进程接收自杀信号后，立即创建新的工作进程服务</li>
</ul>
<p>至此我们完成了进程的平滑重启，一旦有异常出现，主进程会创建新的工作进程来为用户服务，旧的进程一旦处理完已有连接就自动断开。整个过程使得我们的应用的稳定性和健壮性大大提高。</p>
<h3 id="负载均衡">负载均衡</h3><p>多进程架构将CPU资源都调用起来后，需要保证每个进程的工作量，既不能让一些进程忙不过来，也不能让一些进程闲着这种保证多个处理单元工作量公平的策略叫负载均衡。Node提供了叫Round-Robin策略，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。<br>分发策略：在N个工作进程中，每次选择第i=(i+1) mod n个进程来发送连接</p>
<ul>
<li>在cluster模块中启用：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启用Round-Robin</span></span><br><span class="line">cluster<span class="class">.schedulingPolicy</span> = cluster<span class="class">.SCHED_RR</span></span><br><span class="line"><span class="comment">//不启用Round-Robin</span></span><br><span class="line">cluster<span class="class">.schedulingPolicy</span> = cluster.SCHED_NONE</span><br></pre></td></tr></table></figure>
<ul>
<li>或在环境变量中设置NODE_CLUSTER_SCHED_POLICY的值：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_CLUSTER_SCHED_POLICY=rr</span><br><span class="line"><span class="built_in">export</span> NODE_CLUSTER_SCHED_POLICY=none</span><br></pre></td></tr></table></figure>
<h3 id="Cluster模块">Cluster模块</h3><p>cluster模块，用以解决多核CPU的利用率问题，是child_process和net模块的组合应用。作用：用于解决多核CPU的利用率问题，同时也提供较完善的API，用以处理进程的健壮性。</p>
<p>cluster模块中，一个主进程只能管理一组工作进程。child_process可以更灵活控制工作进程，甚至控制多组工作进程尽管通过child_process模块可以大幅度提升Node的稳定性，但是一旦主进程出现问题，所有子进程将会失去管理。在Node的进程管理之外，还需要监听进程数量或监听日志的方式确保整个系统的稳定性，即使主进程出错退出，也能及时得到监控报警，使得开发者可以及时处理故障。</p>
<h2 id="其他">其他</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Node简介">Node简介</h2><h3 id="Node诞生历程">Node诞生历程</h3><ul>
<li>2009.3，Ryan Dahl在其博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。</li>
<li>2009.5，Ryan D]]>
    </summary>
    
      <category term="读书笔记" scheme="http://blog.noobsky.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Nodejs" scheme="http://blog.noobsky.com/categories/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Number of 1 Bits 和 Counting Bits]]></title>
    <link href="http://blog.noobsky.com/2016/05/14/LeetCode-Number-of-1-Bits-%E5%92%8C-Counting-Bits/"/>
    <id>http://blog.noobsky.com/2016/05/14/LeetCode-Number-of-1-Bits-和-Counting-Bits/</id>
    <published>2016-05-13T17:06:33.000Z</published>
    <updated>2016-05-16T03:35:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Number_of_1_Bits">Number of 1 Bits</h2><h3 id="题目描述">题目描述</h3><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p>
<h4 id="代码一">代码一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// if((n &amp; 1)==1)&#123;</span></span><br><span class="line">        <span class="comment">//     count++;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//更好的写法</span></span><br><span class="line">        count = count + (n &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//注意应该使用无符号右移，如果使用&gt;&gt;遇到负数时会发生死循环</span></span><br><span class="line">        n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码二">代码二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           <span class="comment">//将n最右边为1的比特位置为0</span></span><br><span class="line">           n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码三">代码三</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接调用Integer的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> Integer.<span class="title">bitCount</span><span class="params">(n)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Counting_Bits">Counting Bits</h2><h3 id="题目描述-1">题目描述</h3><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>Follow up:</p>
<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.<br>Hint:</p>
<p>You should make use of what you have produced already.<br>Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.<br>Or does the odd/even status of the number help you in calculating the number of 1s?</p>
<h4 id="代码一-1">代码一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bits[i] = bits[i/2] + i%2;</span></span><br><span class="line"><span class="comment">//i/2相当于将i(i&gt;=0)右移一位，对于奇数(最右边的比特位为1,&amp;1一定为1)来说,少了一个为1的比特位，需要加1（i%2或者i&amp;1），</span></span><br><span class="line"><span class="comment">//对于偶数来说(最右边的比特位为0，&amp;1一定为0)来说，为1的比特位不变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码二-1">代码二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bits[i] = bits[i &amp; (i-1)] + 1;</span></span><br><span class="line"><span class="comment">//i &amp; (i-1)的结果就是讲i最右边为1的比特位置为0，使i的比特位减少1，加上1即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) bits[i] = bits[i &amp; (i-<span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Number_of_1_Bits">Number of 1 Bits</h2><h3 id="题目描述">题目描述</h3><p>Write a function that takes an unsigned integer and returns the num]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Single Number I II III]]></title>
    <link href="http://blog.noobsky.com/2016/05/13/LeetCode-Single-Number-I-II-III/"/>
    <id>http://blog.noobsky.com/2016/05/13/LeetCode-Single-Number-I-II-III/</id>
    <published>2016-05-13T02:30:10.000Z</published>
    <updated>2016-05-16T03:35:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Single_Number_I">Single Number I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用异或的性质，相同的数异或结果为0，一个数跟0异或等于其本身，而且异或满足交换律</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        res = res ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Single_Number_II">Single Number II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果我们将nums数组中所有数的二进制表示中第i比特位求和sum（统计第i比特位为1的个数）</span></span><br><span class="line">   <span class="comment">//如果该sum % 3，那么其结果必为0或1，而且sum % 3的结果一定是那个single number第i比特位（0或1）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">       <span class="keyword">int</span> length = nums.length; </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">           count = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++)&#123;</span><br><span class="line">               <span class="comment">//这里因为外层循环使用了32次限制，所以右移不会像统计某个数中bit为1的数目那样造成死循环（那种情况可以使用无符号右移代替）</span></span><br><span class="line">               <span class="comment">//if(((nums[j] &gt;&gt; i) &amp; 1) == 1) count++;</span></span><br><span class="line">               <span class="comment">//这样写也是可以，这种写法在统计bit为1的数目时也可以避免死循环，但是要注意的是使用!=0,不能使用&gt;0（有负数）</span></span><br><span class="line">               <span class="keyword">if</span>((nums[j] &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) count++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果count % 3 = 1，则这个1肯定是我们所找的那个数贡献，也就是说我们所找的那个数在第i bit为1，</span></span><br><span class="line">           <span class="comment">//左移i位，因为这是第i位上的0或1</span></span><br><span class="line">           res |= ((count % <span class="number">3</span>) &lt;&lt; i);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Single_Number_III">Single Number III</h2><h3 id="题目描述-2">题目描述</h3><p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似Single Number I，我们从头到尾依次异或数组中的每一个数，那么最终得到的结果就是两个只出现一次的数字的异或结果</span></span><br><span class="line">   <span class="comment">//因为其他数字都出现了两次，这些出现两次数字最后的异或结果为0。由于两个出现一次的数字肯定不一样，那么这两个</span></span><br><span class="line">   <span class="comment">//数字的异或结果肯定不为0，也就是说在这两个出现一次的数字的异或结果的二进制表示中至少有一个比特位为1。我们在</span></span><br><span class="line">   <span class="comment">//此异或结果中找到第一个(从低位往高位数，最右边)为1的比特位的位置，记为第N比特位。然后我们以第N位是不是1为标准</span></span><br><span class="line">   <span class="comment">//把原数组中的数字分成两个子数组，第一个子数组的第N位为1，第二个子数组的第N位都为0。则我们把原数组分成两个子数组，</span></span><br><span class="line">   <span class="comment">//每个子数组都包含了一个只出现一次的数字，而其他数字都出现了两次。因为，我们已经把问题转换为了Single Number I</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> xorRes = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//遍历一遍，计算全部数字的异或结果</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) xorRes = xorRes ^ nums[i];</span><br><span class="line">       <span class="comment">//计算异或结果找到第一个为1的比特位的掩码(最右边为1的比特位为1，其余比特位为0)</span></span><br><span class="line">       <span class="comment">//xorRes &amp; (xorRes - 1)的效果是把xorRes第一个（最右边）为1的比特位变为0，该技巧也可以用来统计二进制中比特位为1的个数</span></span><br><span class="line">       <span class="comment">//接着异或自身xorRes即可</span></span><br><span class="line">       <span class="comment">//也可以使用xorRes = xorRes &amp; (-xorRes)。</span></span><br><span class="line">       <span class="keyword">int</span> firstOneBitMask = (xorRes &amp; (xorRes-<span class="number">1</span>)) ^ xorRes;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span>[] res = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>((nums[i] &amp; firstOneBitMask) == <span class="number">0</span>)&#123;</span><br><span class="line">               res[<span class="number">0</span>] = res[<span class="number">0</span>] ^ nums[i];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               res[<span class="number">1</span>] = res[<span class="number">1</span>] ^ nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Single_Number_I">Single Number I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of integers, every element appears twice except for on]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Word Pattern]]></title>
    <link href="http://blog.noobsky.com/2016/05/13/LeetCode-Word-Pattern/"/>
    <id>http://blog.noobsky.com/2016/05/13/LeetCode-Word-Pattern/</id>
    <published>2016-05-12T16:25:27.000Z</published>
    <updated>2016-05-16T03:35:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</p>
<p>Examples:<br>pattern = “abba”, str = “dog cat cat dog” should return true.<br>pattern = “abba”, str = “dog cat cat fish” should return false.<br>pattern = “aaaa”, str = “dog cat cat dog” should return false.<br>pattern = “abba”, str = “dog dog dog dog” should return false.<br>Notes:<br>You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.</p>
<h3 id="解法一">解法一</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> wordPattern(<span class="keyword">String</span> pattern, <span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">       <span class="keyword">String</span>[] words = <span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">" "</span>);</span><br><span class="line">       <span class="keyword">if</span>(words.length != pattern.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       Map&lt;Character, Integer&gt; pat = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">       Map&lt;<span class="keyword">String</span>, Integer&gt; wo = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">           <span class="built_in">char</span> temp = pattern.charAt(i);</span><br><span class="line">           <span class="keyword">String</span> tempStr = words[i];</span><br><span class="line">           <span class="comment">//前面异或为真时：一个有映射，一个没有映射，false</span></span><br><span class="line">           <span class="keyword">if</span>(pat.containsKey(temp) ^ wo.containsKey(tempStr) || (pat.containsKey(temp) &amp;&amp; wo.containsKey(tempStr) &amp;&amp; !pat.<span class="built_in">get</span>(temp).equals(wo.<span class="built_in">get</span>(tempStr)))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           pat.put(pattern.charAt(i), i);</span><br><span class="line">           wo.put(words[i], i);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法二">解法二</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的改进版本   </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> wordPattern(String pattern, String <span class="keyword">str</span>)&#123;</span><br><span class="line">    String[] words = <span class="keyword">str</span>.split(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span>(words.length != pattern.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Map <span class="keyword">index</span> = <span class="keyword">new</span> HashMap();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意i为Integer,如果为i时自动装箱会有问题，因为Integer默认缓存-128-127的数，!=比较对象会有问题</span></span><br><span class="line">    <span class="comment">//如果i为Integer，放入同一个对象，能够正确判断</span></span><br><span class="line">    <span class="keyword">for</span>(Integer i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">        <span class="comment">//put函数的返回值存在key时，返回旧的value，不存在key时返回null</span></span><br><span class="line">        <span class="comment">//都还没有索引，即null == null;如果一个有索引，一个没索引（即上面异或为真的情况）!=肯定成立，返回false；</span></span><br><span class="line">        <span class="comment">//如果都存在索引，但是索引的值不同，返回false；</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">index</span>.put(pattern.charAt(i), i) != <span class="keyword">index</span>.put(words[i], i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">        <span class="comment">//put函数的返回值存在key时，返回旧的value，不存在key时返回null</span></span><br><span class="line">        <span class="comment">//都还没有索引，即null == null;如果一个有索引，一个没索引（即上面异或为真的情况）!=肯定成立，返回false；</span></span><br><span class="line">        <span class="comment">//如果都存在索引，但是索引的值不同，返回false；</span></span><br><span class="line">        <span class="comment">// if(index.put(pattern.charAt(i), i) != index.put(words[i], i)) return false;</span></span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(<span class="keyword">index</span>.put(pattern.charAt(i), i),<span class="keyword">index</span>.put(words[i], i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法三">解法三</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map建立pattern到word的映射</span></span><br><span class="line"><span class="comment">//Set保存已经建立映射的word</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> wordPattern(<span class="keyword">String</span> pattern, <span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">    <span class="keyword">String</span>[] words = <span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span>(words.length != pattern.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Character, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">        <span class="built_in">char</span> ch = pattern.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(ch))&#123;</span><br><span class="line">            <span class="comment">//跟前面建立的映射不一样，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.<span class="built_in">get</span>(ch).equals(words[i])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//已经有其他字符映射到了words[i],出现了多对一映射，返回false</span></span><br><span class="line">            <span class="comment">//其实判断是否有其他字符映射到当前的字符也可以不另外使用Set而是直接用HashMap的containsValue来判断</span></span><br><span class="line">            <span class="comment">//但是该方法的时间复杂度为O(n)</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.contains(words[i])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//建立映射</span></span><br><span class="line">            <span class="built_in">map</span>.put(ch, words[i]);</span><br><span class="line">            <span class="comment">//记录已经映射的word</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">set</span>.<span class="built_in">add</span>(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Here follow means a full match, suc]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
