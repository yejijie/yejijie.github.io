<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-07-15T08:26:13.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Integer to English Words]]></title>
    <link href="http://blog.noobsky.com/2016/07/15/LeetCode-Integer-to-English-Words/"/>
    <id>http://blog.noobsky.com/2016/07/15/LeetCode-Integer-to-English-Words/</id>
    <published>2016-07-15T08:24:13.000Z</published>
    <updated>2016-07-15T08:26:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.</p>
<p>For example,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span> -&gt; <span class="string">"One Hundred Twenty Three"</span></span><br><span class="line"><span class="number">12345</span> -&gt; <span class="string">"Twelve Thousand Three Hundred Forty Five"</span></span><br><span class="line"><span class="number">1234567</span> -&gt; <span class="string">"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"</span></span><br></pre></td></tr></table></figure></p>
<p>Hint:</p>
<pre><code><span class="number">1.</span> Did you see a pattern <span class="keyword">in</span> dividing <span class="keyword">the</span> <span class="type">number</span> <span class="keyword">into</span> chunk <span class="keyword">of</span> <span class="property">words</span>? For example, <span class="number">123</span> <span class="keyword">and</span> <span class="number">123000.</span>
<span class="number">2.</span> Group <span class="keyword">the</span> <span class="type">number</span> <span class="keyword">by</span> thousands (<span class="number">3</span> digits). You can <span class="command">write</span> a helper function <span class="keyword">that</span> takes a <span class="type">number</span> <span class="keyword">less than</span> <span class="number">1000</span> <span class="keyword">and</span> convert just <span class="keyword">that</span> chunk <span class="keyword">to</span> <span class="property">words</span>.
<span class="number">3.</span> There are many edge cases. What are <span class="keyword">some</span> good test cases? Does your code work <span class="keyword">with</span> input such <span class="keyword">as</span> <span class="number">0</span>? Or <span class="number">1000010</span>? (<span class="keyword">middle</span> chunk <span class="keyword">is</span> zero <span class="keyword">and</span> should <span class="keyword">not</span> be printed out)
</code></pre><h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] LESS_THAN_20 = &#123;<span class="string">""</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>, <span class="string">"Four"</span>, <span class="string">"Five"</span>, <span class="string">"Six"</span>, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>, <span class="string">"Ten"</span>, <span class="string">"Eleven"</span>, <span class="string">"Twelve"</span>, <span class="string">"Thirteen"</span>, <span class="string">"Fourteen"</span>, <span class="string">"Fifteen"</span>, <span class="string">"Sixteen"</span>, <span class="string">"Seventeen"</span>, <span class="string">"Eighteen"</span>, <span class="string">"Nineteen"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] TENS = &#123;<span class="string">""</span>, <span class="string">"Ten"</span>, <span class="string">"Twenty"</span>, <span class="string">"Thirty"</span>, <span class="string">"Forty"</span>, <span class="string">"Fifty"</span>, <span class="string">"Sixty"</span>, <span class="string">"Seventy"</span>, <span class="string">"Eighty"</span>, <span class="string">"Ninety"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] THOUSANDS = &#123;<span class="string">""</span>, <span class="string">"Thousand"</span>, <span class="string">"Million"</span>, <span class="string">"Billion"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Zero"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        String word = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等于0进去是没有意义，只会带来无用"" + ""或者"" + Thousand ...</span></span><br><span class="line">            <span class="comment">//比如1000000没有这个if条件转换的结果为One Million Thousand正确应该为One Million</span></span><br><span class="line">            <span class="keyword">if</span>(num % <span class="number">1000</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                word = helper(num % <span class="number">1000</span>) + THOUSANDS[i] +<span class="string">" "</span>+ word;</span><br><span class="line">            &#125;</span><br><span class="line">            num /= <span class="number">1000</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> word.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将小于1000的数转换为English words</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helper</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">return</span> LESS_THAN_20[num % <span class="number">20</span>] + <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">return</span> TENS[num / <span class="number">10</span>] + <span class="string">" "</span> + helper(num % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> LESS_THAN_20[num / <span class="number">100</span>] + <span class="string">" Hundred "</span> + helper(num % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Self Crossing]]></title>
    <link href="http://blog.noobsky.com/2016/07/15/LeetCode-Self-Crossing/"/>
    <id>http://blog.noobsky.com/2016/07/15/LeetCode-Self-Crossing/</id>
    <published>2016-07-15T03:59:51.000Z</published>
    <updated>2016-07-15T05:29:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>ou are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise.</p>
<p>Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not.</p>
<p>Example 1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given x = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">┌───┐</span><br><span class="line">│   │</span><br><span class="line">└───┼──&gt;</span><br><span class="line">    │</span><br><span class="line"></span><br><span class="line"><span class="function">Return <span class="title">true</span> <span class="params">(self crossing)</span></span></span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">┌──────┐</span><br><span class="line">│      │</span><br><span class="line">│</span><br><span class="line">│</span><br><span class="line">└────────────&gt;</span><br><span class="line"></span><br><span class="line"><span class="function">Return <span class="title">false</span> <span class="params">(not self crossing)</span></span></span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given x = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">┌───┐</span><br><span class="line">│   │</span><br><span class="line">└───┼&gt;</span><br><span class="line"></span><br><span class="line"><span class="function">Return <span class="title">true</span> <span class="params">(self crossing)</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><p>有三种情况：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*               i-2</span><br><span class="line">    case 1 : i-1┌─┐</span><br><span class="line">                └─┼─&gt;i</span><br><span class="line">                 i-3</span><br><span class="line"></span><br><span class="line">                    i-2</span><br><span class="line">    case 2 : i-1 ┌────┐</span><br><span class="line">                 └─══&gt;┘i-3</span><br><span class="line">                 i  i-4      (i overlapped i-4)</span><br><span class="line"></span><br><span class="line">    case 3 :    i-4</span><br><span class="line">               ┌──┐</span><br><span class="line">               │i&lt;┼─┐</span><br><span class="line">            i-3│ i-5│i-1</span><br><span class="line">               └────┘</span><br><span class="line">                i-2</span><br><span class="line"></span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>第一种情况是当前边(i)跟3步之前走的边(i-3)相交。比如第3条边和第0条边、第4条边和第1条边等等(下标从0开始)。需要满足的条件为i-1条边长度小于等于i-3条边，i条边的长度大于等于i-2条边。</p>
<p>第二种情况是当前边i跟4步之前走的i-4条边相交。比如第4条边和第0条边、第5条边和第1条边等等。需要满足的条件是i-1条边的长度和i-3条边的长度相等，i条边的长度大于等于i-2边和i-4边的长度之差。</p>
<p>第三种情况是当前边i跟5步之前走的的i-5边相交。比如第5条边和第0条边、第6条边跟第1条边等等。需要满足的条件为第i-2条边大于等于第i-4条边，第i-3条边大于等于第i-1条边，第i-1条边大于等于i-3条边和i-5条边之差，第i条边的长度大于等于第i-2条边和第i-4条边之差。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSelfCrossing</span><span class="params">(<span class="keyword">int</span>[] x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>, len = x.length; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//case 1</span></span><br><span class="line">            <span class="keyword">if</span>(x[i-<span class="number">1</span>] &lt;= x[i-<span class="number">3</span>] &amp;&amp; x[i] &gt;= x[i-<span class="number">2</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//case 2</span></span><br><span class="line">            <span class="comment">//用减法比加法好，没有溢出的危险</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">4</span> &amp;&amp; x[i-<span class="number">1</span>] == x[i-<span class="number">3</span>] &amp;&amp; x[i] &gt;= x[i-<span class="number">2</span>] - x[i-<span class="number">4</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//case 3，注意x[i-3] &gt;= x[i-1]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">5</span> &amp;&amp; x[i-<span class="number">2</span>] &gt;= x[i-<span class="number">4</span>] &amp;&amp; x[i-<span class="number">3</span>] &gt;= x[i-<span class="number">1</span>] &amp;&amp; x[i-<span class="number">1</span>] &gt;= x[i-<span class="number">3</span>] - x[i-<span class="number">5</span>] &amp;&amp; x[i] &gt;= x[i-<span class="number">2</span>] - x[i-<span class="number">4</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>ou are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Minimum Window Substring]]></title>
    <link href="http://blog.noobsky.com/2016/07/14/LeetCode-Minimum-Window-Substring/"/>
    <id>http://blog.noobsky.com/2016/07/14/LeetCode-Minimum-Window-Substring/</id>
    <published>2016-07-14T15:54:36.000Z</published>
    <updated>2016-07-15T04:00:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>For example,<br>S = “ADOBECODEBANC”<br>T = “ABC”<br>Minimum window is “BANC”.</p>
<p>Note:<br>If there is no such window in S that covers all characters in T, return the empty string “”.</p>
<p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p>
<h2 id="代码">代码</h2><p>基本思想就是使用两个指针start和end来表示一个滑动窗口。将end指针往后移动，找到一个有效窗口，包含t中所有字符。当得到一个有效窗口后，将start指针往前移动缩小窗口来找到一个最小的窗口。当然start指针往前移动的过程中要保证窗口是有效，即要包含t中所有的字符，如果窗口无效时要继续讲end指针往前移动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本思想就是使用两个指针start和end来表示一个滑动窗口</span></span><br><span class="line">    <span class="comment">// 将end指针往后移动，找到一个有效窗口，包含t中所有字符</span></span><br><span class="line">    <span class="comment">// 当得到一个有效窗口后，将start指针往前移动缩小窗口来找到一个最小的窗口</span></span><br><span class="line">    <span class="comment">// 当然start指针往前移动的过程中要保证窗口是有效，即要包含t中所有的字符，如果窗口无效时要继续讲end指针往前移动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设只有ASCII字符</span></span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="comment">//统计t中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            map[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, counter = t.length();</span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE, minStart = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//如果s中字符也在t中，counter--</span></span><br><span class="line">            <span class="keyword">if</span>(map[s.charAt(end)] &gt; <span class="number">0</span>) counter--;</span><br><span class="line">            <span class="comment">//如果s中的该字符没在t中出现，map[s.charAt[end]]会变成负数</span></span><br><span class="line">            map[s.charAt(end)]--;</span><br><span class="line">            end++;</span><br><span class="line">            <span class="comment">//我们找到了一个有效的窗口，start-end，该窗口中字符包含了t中的所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(counter == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(end -start &lt; minLen)&#123;</span><br><span class="line">                    <span class="comment">//记录窗口的长度和开始位置</span></span><br><span class="line">                    minLen = end - start;</span><br><span class="line">                    minStart = start;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将start往前移动，缩小滑动窗口</span></span><br><span class="line">                map[s.charAt(start)]++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//说明该符号也是t中的元素</span></span><br><span class="line">                <span class="keyword">if</span>(map[s.charAt(start)] &gt; <span class="number">0</span>) counter++;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minLen != Integer.MAX_VALUE) <span class="keyword">return</span> s.substring(minStart, minStart + minLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里自己使用数组模拟了一个HashMap，也可以使用Java中的HashMap，但速度肯定变慢了：）。上面的代码还有更简洁的写法，但是可读性就没有那么好了：），先拿上来看看吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设只有ASCII字符</span></span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="comment">//统计t中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) map[t.charAt(i)]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, counter = t.length(), minLen = Integer.MAX_VALUE, minStart = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//如果s中字符也在t中，counter--</span></span><br><span class="line">            <span class="comment">//如果s中的该字符没在t中出现，map[s.charAt[end]]会变成负数</span></span><br><span class="line">            <span class="keyword">if</span>(map[s.charAt(end++)]-- &gt; <span class="number">0</span>) counter--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//我们找到了一个有效的窗口，start-end，该窗口中字符包含了t中的所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(counter == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(end -start &lt; minLen) minLen = end - (minStart = start);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将start往前移动，缩小滑动窗口</span></span><br><span class="line">                <span class="comment">//说明该符号也是t中的元素</span></span><br><span class="line">                <span class="keyword">if</span>(map[s.charAt(start++)]++ == <span class="number">0</span>) counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minLen != Integer.MAX_VALUE ? s.substring(minStart, minStart + minLen) : <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有个大神根据这个解法给出一个解决substring问题的模板：）。对于大多数substring问题，一般是给定一个字符串让我们查找满足一些限制条件的substring。一般的方法就是使用HashMap和两个指针。模板如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSubstring</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用数组模拟hashmap</span></span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">//用于检查窗口中substring是否有效</span></span><br><span class="line">    <span class="keyword">int</span> counter; <span class="comment">// check whether the substring is valid</span></span><br><span class="line">    <span class="comment">//两个指针，一个指向窗口头部，一个指向窗口尾部</span></span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;<span class="comment">//two pointers, one point to tail and one  head</span></span><br><span class="line">    <span class="comment">//子字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> d;<span class="comment">//the length of substring</span></span><br><span class="line">    <span class="comment">//用于初始化hashmap</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;<span class="comment">/* initialize the hash map here */</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">        <span class="comment">//满足条件时修改计数器</span></span><br><span class="line">        <span class="keyword">if</span>(map[s.charAt(end++)]-- ?)&#123; <span class="comment">/* modify counter here */</span> &#125;</span><br><span class="line">        <span class="comment">//当计算器满足条件时进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="comment">/* counter condition */</span>)&#123;</span><br><span class="line">            <span class="comment">//如果找到更小的值，更新d</span></span><br><span class="line">            <span class="comment">/* update d here if finding minimum*/</span></span><br><span class="line">            <span class="comment">//将begin指针往前移动使得窗口无效/有效</span></span><br><span class="line">            <span class="comment">//increase begin to make it invalid/valid again</span></span><br><span class="line">            <span class="comment">//修改计数器</span></span><br><span class="line">            <span class="keyword">if</span>(map[s.charAt(begin++)++ ?])&#123;<span class="comment">/*modify counter here*/</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update d here if finding maximum*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当要求查找的是最大substring，我们需要在内层while循环结束之后才更新最大值因为内层循环来保证substring是有效的。而如果是查找最小的substring，我们在内层while循环中更新最小值。</p>
<p>应用此模板解决Longest Substring with At Most Two Distinct Characters的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>, counter = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//没有出现过的字符，计算器加1</span></span><br><span class="line">            <span class="keyword">if</span>(map[s.charAt(end++)]++ == <span class="number">0</span>) counter++;</span><br><span class="line">            <span class="comment">//不同的字符大于两个，移动指针使窗口重新有效</span></span><br><span class="line">            <span class="comment">//如果begin指向的字符只出现了一次，移动begin指针后，有效字符减1</span></span><br><span class="line">            <span class="keyword">while</span>(counter &gt; <span class="number">2</span>) <span class="keyword">if</span>(map[s.charAt(begin++)]-- == <span class="number">1</span>) counter--;</span><br><span class="line">            d = Math.max(d, end - begin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>解决Longest Substring Without Repeating Characters的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>, counter = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.length()) &#123;</span><br><span class="line">            <span class="comment">//大于0说明出现重复字符</span></span><br><span class="line">            <span class="keyword">if</span> (map[s.charAt(end++)]++ &gt; <span class="number">0</span>) counter++;</span><br><span class="line">            <span class="keyword">while</span> (counter &gt; <span class="number">0</span>) <span class="keyword">if</span> (map[s.charAt(begin++)]-- &gt; <span class="number">1</span>) counter--;</span><br><span class="line">            d = Math.max(d, end - begin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in comple]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Create Maximum Number]]></title>
    <link href="http://blog.noobsky.com/2016/07/14/LeetCode-Create-Maximum-Number/"/>
    <id>http://blog.noobsky.com/2016/07/14/LeetCode-Create-Maximum-Number/</id>
    <published>2016-07-14T11:11:37.000Z</published>
    <updated>2016-07-14T11:18:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k &lt;= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. You should try to optimize your time and space complexity.</p>
<p>Example 1:<br>nums1 = [3, 4, 6, 5]<br>nums2 = [9, 1, 2, 5, 8, 3]<br>k = 5<br>return [9, 8, 6, 5, 3]</p>
<p>Example 2:<br>nums1 = [6, 7]<br>nums2 = [6, 0, 4]<br>k = 5<br>return [6, 7, 6, 0, 4]</p>
<p>Example 3:<br>nums1 = [3, 9]<br>nums2 = [8, 9]<br>k = 3<br>return [9, 8, 9]</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 从数组nums中挑选出t个数，在保持元素相对顺序不变的情况下，使得选出的子数组最大化。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 在保持元素相对顺序不变的前提下，将数组nums1与数组nums2合并，使合并后的数组最大化。</span><br></pre></td></tr></table></figure>
<p>第一个子问题见<a href="http://noobsky.com/2016/06/20/LeetCode-Largest-Number/" target="_blank" rel="external">Delete Digits</a>。也可以用<a href="http://noobsky.com/2016/07/02/LeetCode-Remove-Duplicate-Letters/" target="_blank" rel="external">Remove Duplicate Letters</a>。</p>
<p>枚举第一个数组nums1的个数i，那么数组nums2的个数就确定了 k -i。</p>
<p>然后枚举出nums1和nums2长度分别为i和k-i的最大子数组，（可以用栈，类似leetcode Remove Duplicate Letters）</p>
<p>最后组合看看哪个大。</p>
<p>组合的过程类似合并排序，看看哪个数组大，就选哪个。</p>
<p>枚举数组长度复杂度O(k)，找出最大子数组O(n)，合并的话O(k^2)</p>
<p>而k最坏是m+n,所以总的复杂度就是O((m+n)^3)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最后k个数有i个来自数组1，则k-i个来自数组2，0&lt;= i &lt;= k</span></span><br><span class="line">    <span class="comment">//所以我们要在数组1中在保持元素相对顺序不变的情况下，选择i个元素组成的数最大</span></span><br><span class="line">    <span class="comment">//同理要在数组2中在保持元素相对顺序不变的情况下，选择k-i个元素组成的数最大</span></span><br><span class="line">    <span class="comment">//然后将选出来的两个子数组合并，类似归并排序中的merge操作，要在保持元素相对顺序的时候组成的数更大</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单的说就是：枚举nums1子数组与nums2子数组的长度i, k-i，分别求解最大子数组，并进行合并。</span></span><br><span class="line">    <span class="comment">//然后从合并得到的子数组中取最大数组即为所求。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxNumber(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.length, len2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="comment">//如果k &gt; len2，那么在nums1中至少要选k - len2个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = Math.max(<span class="number">0</span>, k - len2); i &lt;= k &amp;&amp; i &lt;= len1; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);</span><br><span class="line">            <span class="keyword">if</span>(greater(candidate, <span class="number">0</span>, ans, <span class="number">0</span>)) ans = candidate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将nums1和nums2中的k位数合并，使合并后的数最大（不能改变元素的原始相对顺序）</span></span><br><span class="line">    <span class="comment">//merge函数也可以不借助于greater函数来实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; k; r++)&#123;</span><br><span class="line">            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该函数本来只用来比较候选者candidate组成的数是否比ans的大，nums1和nums2merge的过程也可以使用</span></span><br><span class="line">    <span class="comment">//此时的作用是nums1[i...nums1.length]字典序是否比num2[j...nums2.length]的大</span></span><br><span class="line">    <span class="comment">//在merge函数中，我们将使用该函数来决定是先用nums1[i]还是nums2[j]来组合数使得组合的数更大</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> i, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">//跳过相等的元素</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length &amp;&amp; nums1[i] == nums2[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == nums2.length || (i &lt; nums1.length &amp;&amp; nums1[i] &gt; nums2[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从nums数组中在保持元素相对顺序不变的情况下选择长度为k的最大子数组（这里最大是指k个元素组成的最大）</span></span><br><span class="line">    <span class="comment">//或者说从nums数组中在保持元素相对顺序不变的情况下选择最大的k位数</span></span><br><span class="line">    <span class="comment">//比如nums[9, 1, 2, 5, 8, 3], k = 3，则结果为[9, 8, 3]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxArray(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= nums.length) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//对于每个nums[i]，在ans中选择一个合适的位置放置</span></span><br><span class="line">            <span class="comment">//将nums[i]跟ans已有的元素从后往前比较（ans[j-1...0]），如果nums[i]大于ans末尾中元素，删掉ans末尾的元素</span></span><br><span class="line">            <span class="comment">//当然在这个过程中要保证剩下的元素够k个，只需保证nums.length - i + j &gt; k，</span></span><br><span class="line">            <span class="comment">//（nums.length - i为nums重剩下的元素，j是已经找到的数）</span></span><br><span class="line">            <span class="comment">//在Delete digits中，我们采用的时不断删数的方法，这里是数组，删数要移动费时间</span></span><br><span class="line">            <span class="keyword">while</span>(nums.length - i + j &gt; k &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; ans[j - <span class="number">1</span>] &lt; nums[i]) j--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j &lt; k) ans[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Longest Valid Parentheses]]></title>
    <link href="http://blog.noobsky.com/2016/07/13/LeetCode-Longest-Valid-Parentheses/"/>
    <id>http://blog.noobsky.com/2016/07/13/LeetCode-Longest-Valid-Parentheses/</id>
    <published>2016-07-13T15:56:33.000Z</published>
    <updated>2016-07-14T03:35:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p>
<p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用栈匹配括号，最后不匹配的括号都留在栈中，为了后面求长度，我们栈中存括号的下标</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//左括号直接进栈</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            <span class="comment">//右括号可以尝试匹配</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; s.charAt(stack.peek()) == <span class="string">'('</span>)&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时栈为空，说明括号全部匹配</span></span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="comment">//栈不为空，里面是不匹配的括号</span></span><br><span class="line">        <span class="keyword">int</span> right = len, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           left = stack.pop();</span><br><span class="line">           longest = Math.max(longest, right - left - <span class="number">1</span>);</span><br><span class="line">           right = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//while对应着最后一个无效括号的下标，它前面还可能有有效括号的长度right是最大长度</span></span><br><span class="line">        longest = Math.max(longest, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实外面的if和else if是可以合并的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用栈匹配括号，最后不匹配的括号都留在栈中，为了后面求长度，我们栈中存括号的下标</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">// //左括号直接进栈</span></span><br><span class="line">            <span class="comment">// if(s.charAt(i) == '(')&#123;</span></span><br><span class="line">            <span class="comment">//     stack.push(i);</span></span><br><span class="line">            <span class="comment">// //右括号可以尝试匹配</span></span><br><span class="line">            <span class="comment">// &#125;else if(s.charAt(i) == ')')&#123;</span></span><br><span class="line">            <span class="comment">//     if(!stack.isEmpty() &amp;&amp; s.charAt(stack.peek()) == '(')&#123;</span></span><br><span class="line">            <span class="comment">//         stack.pop();</span></span><br><span class="line">            <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">            <span class="comment">//         stack.push(i);</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">//如果s中只有左右括号的话，if和else if还可以合并如下</span></span><br><span class="line">            <span class="comment">//找到一对配对的括号</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span> &amp;&amp; !stack.isEmpty() &amp;&amp; s.charAt(stack.peek()) == <span class="string">'('</span>)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时栈为空，说明括号全部匹配</span></span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="comment">//栈不为空，里面是不匹配的括号</span></span><br><span class="line">        <span class="keyword">int</span> right = len, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           left = stack.pop();</span><br><span class="line">           longest = Math.max(longest, right - left - <span class="number">1</span>);</span><br><span class="line">           right = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//while对应着最后一个无效括号的下标，它前面还可能有有效括号的长度right是最大长度</span></span><br><span class="line">        longest = Math.max(longest, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实上面的第二次遍历栈有点多余我们可以只用一遍扫描，在括号匹配时同时计算匹配的最长长度。<strong>该写法推荐</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//其实我们遍历一遍可以同时把最长长度算了。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> len = s.length();</span><br><span class="line">      <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">      stack.push(-<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">          <span class="comment">//因为我们加了一个-1，判断栈中为空时不是用isEmpty，需要改为stack.size() &gt; 1</span></span><br><span class="line">          <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span> &amp;&amp; stack.size() &gt; <span class="number">1</span> &amp;&amp; s.charAt(stack.peek()) == <span class="string">'('</span>)&#123;</span><br><span class="line">              <span class="comment">//此时说明我们找到了一对匹配的括号，我们计算匹配括号的长度，并更新匹配的最长长度</span></span><br><span class="line">              stack.pop();</span><br><span class="line">              <span class="comment">//)(())</span></span><br><span class="line">              <span class="comment">//i为当前字符的下标，pop之后栈顶为该次匹配括号前不匹配括号的下标，之差为匹配括号的长度</span></span><br><span class="line">              <span class="comment">//但是pop之后栈有可能为空，所以我们开始之前先将-1压栈，来处理边界情况</span></span><br><span class="line">              longest = Math.max(longest, i - stack.peek());</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              stack.push(i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不先压栈-1的话就自己判断，<strong>推荐该写法或上一种写法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//不先压入-1就要自己判断了</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">//因为我们加了一个-1，判断栈中为空时，需要改为stack.size() &gt; 1</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span> &amp;&amp; !stack.isEmpty() &amp;&amp; s.charAt(stack.peek()) == <span class="string">'('</span>)&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">int</span> lastPos = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty()) lastPos = stack.peek();</span><br><span class="line">            longest = Math.max(longest, i - lastPos);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该题还可以使用DP，代码也很简洁，先来看一下状态转移方程。<br>longest[i]表示以s[i]结尾的最长有效括号<br>if s[i] == ‘(‘，longest[i] = 0<br>else if s[i] == ‘)’<br>    if s[i-1] == ‘(‘ longest[i] = longest[i-2] + 2<br>    else if s[i-1] == ‘)’ &amp;&amp; s[i - longest[i-1] - 1] == ‘(‘, longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2]</p>
<p>其实第三种情况已经包含了第二种情况，所以代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] longest = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span> &amp;&amp; i - longest[i-<span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i - longest[i-<span class="number">1</span>] - <span class="number">1</span>) == <span class="string">'('</span>)&#123;</span><br><span class="line">                longest[i] = longest[i-<span class="number">1</span>] + <span class="number">2</span> + ((i - longest[i-<span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span>) ? longest[i - longest[i-<span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>);</span><br><span class="line">                max = Math.max(max, longest[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) pare]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Candy]]></title>
    <link href="http://blog.noobsky.com/2016/07/13/LeetCode-Candy/"/>
    <id>http://blog.noobsky.com/2016/07/13/LeetCode-Candy/</id>
    <published>2016-07-13T14:45:46.000Z</published>
    <updated>2016-07-13T14:48:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>There are N children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.<br>What is the minimum candies you must give?</li>
</ul>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化所有小孩的糖为1，然后从前往后扫描，如果第i个小孩的等级比i-1个小孩的等级高，那么i小孩的糖数目等于i-1小孩的糖数目+1</span></span><br><span class="line">    <span class="comment">//最后从后往前遍历扫描，如果第i-1个小孩的等级比i高但糖的数目却小于或等于，那么i-1的糖数目等于i糖数目+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings == <span class="keyword">null</span> || ratings.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(nums, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[i] = nums[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时在这个循环也可以统计糖的总和，但是为了可读性还是再开一个循环吧</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ratings.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i-<span class="number">1</span>] &gt; ratings[i] &amp;&amp; nums[i-<span class="number">1</span>] &lt;= nums[i]) nums[i-<span class="number">1</span>] = nums[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//if(ratings[i-1] &gt; ratings[i]) nums[i-1] = Math.max(nums[i] + 1, nums[i-1]);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>There are N children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to t]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximal Rectangle]]></title>
    <link href="http://blog.noobsky.com/2016/07/13/LeetCode-Maximal-Rectangle/"/>
    <id>http://blog.noobsky.com/2016/07/13/LeetCode-Maximal-Rectangle/</id>
    <published>2016-07-13T10:49:54.000Z</published>
    <updated>2016-07-13T14:14:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p>
<h2 id="代码">代码</h2><p>可以直接利用<a href="http://noobsky.com/2016/07/13/LeetCode-Largest-Rectangle-in-Histogram/" target="_blank" rel="external">Largest Rectangle in Histogram</a>的思想。<br>You can maintain a row length of Integer array H recorded its height of ‘1’s, and scan and update row by row to find out the largest rectangle of each row.</p>
<p>For each row, if matrix[row][i] == ‘1’. H[i] +=1, or reset the H[i] to zero.<br>and accroding the algorithm of [Largest Rectangle in Histogram], to update the maximum area.</p>
<p>如果我们把每一行看成x坐标，那高度就是从那一行开始往上数的连续1的个数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cLen = matrix[<span class="number">0</span>].length;    <span class="comment">// column length</span></span><br><span class="line">        <span class="keyword">int</span> rLen = matrix.length;       <span class="comment">// row length</span></span><br><span class="line">        <span class="comment">// height array</span></span><br><span class="line">        <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[cLen+<span class="number">1</span>];</span><br><span class="line">        h[cLen]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;rLen;row++) &#123;</span><br><span class="line">            Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cLen+<span class="number">1</span>;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&lt;cLen)</span><br><span class="line">                    <span class="keyword">if</span>(matrix[row][i]==<span class="string">'1'</span>)</span><br><span class="line">                        h[i]+=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> h[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s.isEmpty()||h[s.peek()]&lt;=h[i])</span><br><span class="line">                    s.push(i);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span>(!s.isEmpty()&amp;&amp;h[i]&lt;h[s.peek()])&#123;</span><br><span class="line">                        <span class="keyword">int</span> top = s.pop();</span><br><span class="line">                        <span class="keyword">int</span> area = h[top]*(s.isEmpty()?i:(i-s.peek()-<span class="number">1</span>));</span><br><span class="line">                        <span class="keyword">if</span> (area&gt;max)</span><br><span class="line">                            max = area;</span><br><span class="line">                    &#125;</span><br><span class="line">                    s.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下代码更模块化一点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] height = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="string">'1'</span>) height[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = largestInLine(height);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i ++)&#123;</span><br><span class="line">            resetHeight(matrix, height, i);</span><br><span class="line">            result = Math.max(result, largestInLine(height));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetHeight</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">int</span>[] height, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[idx][i] == <span class="string">'1'</span>) height[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> height[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestInLine</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> h = (i == len ? <span class="number">0</span> : height[i]);</span><br><span class="line">            <span class="keyword">if</span>(s.isEmpty() || h &gt;= height[s.peek()])&#123;</span><br><span class="line">                s.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tp = s.pop();</span><br><span class="line">                maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - <span class="number">1</span> - s.peek()));</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实也可以用先用二维数组先计算height在每一行时对应的值。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = matrix.length;</span><br><span class="line"><span class="keyword">int</span> n = m == <span class="number">0</span> ? <span class="number">0</span> : matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] height = <span class="keyword">new</span> <span class="keyword">int</span>[m][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(matrix[i][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">             height[i][j] = <span class="number">0</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             height[i][j] = i == <span class="number">0</span> ? <span class="number">1</span> : height[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详见博文<a href="http://www.cnblogs.com/lichen782/p/leetcode_maximal_rectangle.html" target="_blank" rel="external">LeetCode 笔记系列 18 Maximal Rectangle 学以致用</a></p>
<p> 讨论区还有一种<a href="https://discuss.leetcode.com/topic/6650/share-my-dp-solution" target="_blank" rel="external">dp的解法</a>，有时间再研究吧：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> left[n], right[n], height[n];</span><br><span class="line">        fill_n(left,n,<span class="number">0</span>); fill_n(right,n,n); fill_n(height,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_left=<span class="number">0</span>, cur_right=n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123; <span class="comment">// compute height (can do this from either side)</span></span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>) height[j]++;</span><br><span class="line">                <span class="keyword">else</span> height[j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123; <span class="comment">// compute left (from left to right)</span></span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>) left[j]=max(left[j],cur_left);</span><br><span class="line">                <span class="keyword">else</span> &#123;left[j]=<span class="number">0</span>; cur_left=j+<span class="number">1</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// compute right (from right to left)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>) right[j]=min(right[j],cur_right);</span><br><span class="line">                <span class="keyword">else</span> &#123;right[j]=n; cur_right=j;&#125;    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// compute the area of rectangle (can do this from either side)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                maxA = max(maxA,(right[j]-left[j])*height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its ar]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Largest Rectangle in Histogram]]></title>
    <link href="http://blog.noobsky.com/2016/07/13/LeetCode-Largest-Rectangle-in-Histogram/"/>
    <id>http://blog.noobsky.com/2016/07/13/LeetCode-Largest-Rectangle-in-Histogram/</id>
    <published>2016-07-13T10:24:06.000Z</published>
    <updated>2016-07-13T10:27:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br><img src="http://articles.leetcode.com/wp-content/uploads/2012/04/histogram.png" alt=""><br>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p>
<p><img src="http://www.leetcode.com/wp-content/uploads/2012/04/histogram_area.png" alt=""><br>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>For example,<br>Given heights = [2,1,5,6,2,3],<br>return 10.</p>
<h2 id="代码">代码</h2><p>思路参见<a href="http://www.geeksforgeeks.org/largest-rectangle-under-histogram/" target="_blank" rel="external">Largest Rectangular Area in a Histogram | Set 2</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//长方形的面积由组成的所以bar的最矮的bar决定</span></span><br><span class="line">    <span class="comment">//对于每一个bar我们计算该bar是矩形中最小的bar时矩形的面积</span></span><br><span class="line">    <span class="comment">//这些矩形面积中最大的即为所求</span></span><br><span class="line">    <span class="comment">//为了计算bar x为最小bar时矩形的面积，我们需要bar x左边更小的bar的下标和bar x右边更小的bar</span></span><br><span class="line">    <span class="comment">//我们用栈保存每个bar，当遇到一个更小的bar时，我们弹出栈顶的bar x，计算该bar为最小bar的矩形的面积</span></span><br><span class="line">    <span class="comment">//弹栈后栈顶的bar为bar x左边更小的bar，当前的bar的为bar x右边更小的bar</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="comment">//存bar对应的下标</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len;)&#123;</span><br><span class="line">            <span class="comment">//应该在heights的最后面加一个高度为0的bar</span></span><br><span class="line">            <span class="comment">//否则如果heights数组为递增时：1、2、3、4、5不会发生计算</span></span><br><span class="line">            <span class="keyword">int</span> h = (i == len) ? <span class="number">0</span> : heights[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当当前bar的高度大于栈顶bar的高度时，将当前bar压入栈中</span></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty() || h &gt;= heights[stack.peek()])&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tp = stack.pop();</span><br><span class="line">                <span class="comment">//计算以heights[tp]为最小bar的矩形的面积，并更新maxArea的值</span></span><br><span class="line">                maxArea = Math.max(maxArea, heights[tp] * (stack.isEmpty() ? i : i-<span class="number">1</span>-stack.peek()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]The Skyline Problem]]></title>
    <link href="http://blog.noobsky.com/2016/07/13/LeetCode-The-Skyline-Problem/"/>
    <id>http://blog.noobsky.com/2016/07/13/LeetCode-The-Skyline-Problem/</id>
    <published>2016-07-13T04:17:14.000Z</published>
    <updated>2016-07-13T06:53:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).</p>
<p><img src="https://leetcode.com/static/images/problemset/skyline1.jpg" alt=""><br><img src="https://leetcode.com/static/images/problemset/skyline2.jpg" alt=""></p>
<p>The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>
<p>For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .</p>
<p>The output is a list of “key points” (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], … ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>
<p>For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].</p>
<p>Notes:</p>
<ul>
<li>The number of buildings in any input list is guaranteed to be in the range [0, 10000].</li>
<li>The input list is already sorted in ascending order by the left x position Li.</li>
<li>The output list must be sorted by the x position.</li>
<li>There must be no consecutive horizontal lines of equal height in the output skyline. For instance, […[2 3], [4 5], [7 5], [11 5], [12 7]…] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: […[2 3], [4 5], [12 7], …]</li>
</ul>
<h2 id="代码">代码</h2><p>解题思路见以下博客<a href="https://briangordon.github.io/2014/08/the-skyline-problem.html" target="_blank" rel="external">The skyline problem</a>。最后作者的总结的方法为：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Our final solution, <span class="keyword">then</span>, <span class="operator">in</span> O(nlog⁡n) <span class="built_in">time</span>, is <span class="keyword">as</span> follows. First, <span class="built_in">sort</span> <span class="operator">the</span> critical</span><br><span class="line"></span><br><span class="line">points. Then scan across <span class="operator">the</span> critical points <span class="built_in">from</span> left <span class="built_in">to</span> <span class="constant">right</span>. When we encounter <span class="operator">the</span></span><br><span class="line"></span><br><span class="line">left edge <span class="operator">of</span> <span class="operator">a</span> rectangle, we <span class="built_in">add</span> that rectangle <span class="built_in">to</span> <span class="operator">the</span> heap <span class="operator">with</span> its height <span class="keyword">as</span> <span class="operator">the</span> key.</span><br><span class="line"></span><br><span class="line">When we encounter <span class="operator">the</span> <span class="constant">right</span> edge <span class="operator">of</span> <span class="operator">a</span> rectangle, we remove that rectangle <span class="built_in">from</span> <span class="operator">the</span> heap.</span><br><span class="line"></span><br><span class="line">(This requires keeping external pointers <span class="keyword">into</span> <span class="operator">the</span> heap.) Finally, <span class="keyword">any</span> <span class="built_in">time</span> we encounter <span class="operator">a</span></span><br><span class="line"></span><br><span class="line">critical point, <span class="keyword">after</span> updating <span class="operator">the</span> heap we <span class="built_in">set</span> <span class="operator">the</span> height <span class="operator">of</span> that critical point <span class="built_in">to</span> <span class="operator">the</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">value</span> peeked <span class="built_in">from</span> <span class="operator">the</span> top <span class="operator">of</span> <span class="operator">the</span> heap.</span><br></pre></td></tr></table></figure>
<p>关键点为矩形左边和右边顶点，即左上顶点和右上顶点。每个关键点的高度为涉及到的矩形的最大高度。我们使用最大堆保存这些关键点。当遇到矩形的左边界时，我们将该矩形加入到堆中（堆中元素为矩形的高度）；当遇到矩形的右边界时，我们将矩形从堆中移除。为了区分矩形的左边界和右边界，我们将左边界的左上顶点的高度取为矩形高度的相反数，将右边界上右上顶点的高度取为矩形高度。经过这样处理后，我们到达关键点后，涉及到的矩形即The skyline problem博客中说的active set of rectangle的高度都在堆中，关键点的高度为这些高度的最大值，即大顶堆的堆顶元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//矩形左上顶点表示为[Li, -Hi]，右上顶点表示为[Ri, Hi]</span></span><br><span class="line">        <span class="comment">//cp mean critical point</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; cps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] b : buildings)&#123;</span><br><span class="line">            cps.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;b[<span class="number">0</span>], -b[<span class="number">2</span>]&#125;);</span><br><span class="line">            cps.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;b[<span class="number">1</span>], b[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对critical point 排序</span></span><br><span class="line">        Collections.sort(cps, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">                <span class="comment">//纵坐标升序，左边界小于右边界，左边界在前面，正确</span></span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//横坐标升序</span></span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">                <span class="comment">//return b - a;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//防止pq为空时，int curr = pq.peek();发生空指针异常，</span></span><br><span class="line">        <span class="comment">//比如测试用例为只有一栋楼:[[0, 1, 3]]，该测试用例的结果应该为[[0,3],[1,0]]</span></span><br><span class="line">        <span class="comment">//本来优先级队列在为空时peek时返回null的，但是这里会有自动拆箱的过程将Integer转换为int，</span></span><br><span class="line">        <span class="comment">//如果Integer为null报空指针异常</span></span><br><span class="line">        pq.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//前一个最大高度</span></span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] cp : cps)&#123;</span><br><span class="line">            <span class="comment">//矩形的左边界，加入pq中</span></span><br><span class="line">            <span class="keyword">if</span>(cp[<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                pq.add(-cp[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//remove操作为O(lgn)</span></span><br><span class="line">                <span class="comment">//右边界，从pq中移除</span></span><br><span class="line">                pq.remove(cp[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前关键点涉及到的矩形的最大高度</span></span><br><span class="line">            <span class="keyword">int</span> curr = pq.peek();</span><br><span class="line">            <span class="comment">//参加注意事项最后一点</span></span><br><span class="line">            <span class="comment">//There must be no consecutive horizontal lines of equal height in the output skyline.</span></span><br><span class="line">            <span class="comment">//For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable;</span></span><br><span class="line">            <span class="comment">//the three lines of height 5 should be merged into one in the final output as such:</span></span><br><span class="line">            <span class="comment">//[...[2 3], [4 5], [12 7], ...]</span></span><br><span class="line">            <span class="keyword">if</span>(curr != prev)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cp[<span class="number">0</span>], curr&#125;);</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始还以为优先级队列remove(Object)的时间复杂度为O(lgn)，查了一下文档才发现是O(n)的，文档说明如下：</p>
<p>Implementation note: this implementation provides O(log(n)) time for the enqueing and dequeing methods (offer, poll, remove() and add); linear time for the remove(Object) and contains(Object) methods; and constant time for the retrieval methods (peek, element, and size).</p>
<p>详情见<a href="https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html" target="_blank" rel="external">PriorityQueue</a>。所以以上算法的时间复杂度为O(n^2)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Expression Add Operators]]></title>
    <link href="http://blog.noobsky.com/2016/07/13/LeetCode-Expression-Add-Operators/"/>
    <id>http://blog.noobsky.com/2016/07/13/LeetCode-Expression-Add-Operators/</id>
    <published>2016-07-13T02:41:12.000Z</published>
    <updated>2016-07-13T04:17:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.</p>
<p>Examples:<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"123"</span>, <span class="number">6</span> -&gt; [<span class="string">"1+2+3"</span>, <span class="string">"1*2*3"</span>]</span><br><span class="line"><span class="string">"232"</span>, <span class="number">8</span> -&gt; [<span class="string">"2*3+2"</span>, <span class="string">"2+3*2"</span>]</span><br><span class="line"><span class="string">"105"</span>, <span class="number">5</span> -&gt; [<span class="string">"1*0+5"</span>,<span class="string">"10-5"</span>]</span><br><span class="line"><span class="string">"00"</span>, <span class="number">0</span> -&gt; [<span class="string">"0+0"</span>, <span class="string">"0-0"</span>, <span class="string">"0*0"</span>]</span><br><span class="line"><span class="string">"3456237490"</span>, <span class="number">9191</span> -&gt; <span class="literal">[]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dfs</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addOperators</span><span class="params">(String num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用来保存dfs过程中形成的表达式</span></span><br><span class="line">        <span class="comment">//StringBuilder的append操作比字符串的"+"操作高效</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(res, sb, num, target, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//避免溢出，用long类型</span></span><br><span class="line">    <span class="comment">//0开头，长度不为1的数字无效，比如01</span></span><br><span class="line">    <span class="comment">//eval保存已经计算了的结果</span></span><br><span class="line">    <span class="comment">//还有一个很tricky的就是，需要保存当前新增的数，因为如果下一次递归是乘法，那么该数应该是与后面的数相乘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; res, StringBuilder sb, String num, <span class="keyword">int</span> target, <span class="keyword">int</span> pos, <span class="keyword">long</span> eval, <span class="keyword">long</span> multi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件，如果已经尝试到最后一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(pos == num.length())&#123;</span><br><span class="line">            <span class="comment">//如果表达式的计算结果跟target相等，加入结果集中</span></span><br><span class="line">            <span class="keyword">if</span>(eval == target) res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; num.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//以0开头的字符，只有0是有效的，其他长度大于1的都无效，直接break循环</span></span><br><span class="line">            <span class="keyword">if</span>(num.charAt(pos) == <span class="string">'0'</span> &amp;&amp; pos != i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">long</span> curr = Long.parseLong(num.substring(pos, i+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> len = sb.length();</span><br><span class="line">            <span class="comment">//第一个数字</span></span><br><span class="line">            <span class="keyword">if</span>(pos == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//递归调用</span></span><br><span class="line">                dfs(res, sb.append(curr), num, target, i+<span class="number">1</span>, curr, curr);</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                sb.setLength(len);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//尝试+、-、*</span></span><br><span class="line">                dfs(res, sb.append(<span class="string">"+"</span>).append(curr), num, target, i+<span class="number">1</span>, eval + curr, curr);</span><br><span class="line">                sb.setLength(len);</span><br><span class="line">                dfs(res, sb.append(<span class="string">"-"</span>).append(curr), num, target, i+<span class="number">1</span>, eval - curr, -curr);</span><br><span class="line">                sb.setLength(len);</span><br><span class="line">                <span class="comment">//乘法优先级比加减高，如果尝试乘法的化，eval中保存的上一个加入的数字(multi)应该跟这次的乘法相结合。</span></span><br><span class="line">                dfs(res, sb.append(<span class="string">"*"</span>).append(curr), num, target, i+<span class="number">1</span>, eval - multi + multi*curr, multi*curr);</span><br><span class="line">                sb.setLength(len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Russian Doll Envelopes]]></title>
    <link href="http://blog.noobsky.com/2016/07/13/LeetCode-Russian-Doll-Envelopes/"/>
    <id>http://blog.noobsky.com/2016/07/13/LeetCode-Russian-Doll-Envelopes/</id>
    <published>2016-07-12T16:09:46.000Z</published>
    <updated>2016-07-12T16:13:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>
<p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<p>Example:<br>Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</p>
<h2 id="代码">代码</h2><ol>
<li>Sort the array. Ascend on width and descend on height if width are same.</li>
<li>Find the <a href="http://noobsky.com/2016/06/07/LeetCode-Longest-Increasing-Subsequence/" target="_blank" rel="external">Longest Increasing Subsequence</a> based on height.</li>
</ol>
<ul>
<li>Since the width is increasing, we only need to consider height.</li>
<li>[3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] when sorting otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4]</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分两步</span></span><br><span class="line">    <span class="comment">//1. 信封按宽升序高降序排序</span></span><br><span class="line">    <span class="comment">//2. 对信封的高找最长递增子序列</span></span><br><span class="line">    <span class="comment">//因为信封的宽已经是升序，我们只要考虑信封的高就可以了</span></span><br><span class="line">    <span class="comment">//[3, 4]是装不下[3, 3]，所以我们需要将[3, 4]排在[3, 3]的前面，如果排序排成了[3,3] [3,4]会被当成递增序列，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span> || envelopes[<span class="number">0</span>].length != <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[<span class="number">0</span>] == arr2[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="comment">//高度降序</span></span><br><span class="line">                    <span class="keyword">return</span> arr2[<span class="number">1</span>] - arr1[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] envelope : envelopes)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(dp, <span class="number">0</span>, len, envelope[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                index = -(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[index] = envelope[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(index == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit in]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Recover Binary Search Tree]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Recover-Binary-Search-Tree/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Recover-Binary-Search-Tree/</id>
    <published>2016-07-12T15:08:56.000Z</published>
    <updated>2016-07-12T15:32:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Note:<br>A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">4</span></span><br><span class="line"> /    \</span><br><span class="line"><span class="number">2</span>      <span class="number">6</span></span><br><span class="line"> \    /  </span><br><span class="line">  <span class="number">3</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>错误交互后变成了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">4</span></span><br><span class="line"> /    \</span><br><span class="line"><span class="number">6</span>      <span class="number">2</span></span><br><span class="line"> \    /  </span><br><span class="line">  <span class="number">3</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>中序遍历会从2,3,4,5,6变成6,3,4,5,2，我们在中序遍历的过程中通过将当前节点的值跟下一个节点的值相比较，可以找出这两个发生了交换的节点。6 &gt; 3我们可以找到6是第一个发生交换的节点，2 &lt; 5我们可以找到第二个发生交换的节点。最后将这两个节点的值相互交互即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TreeNode firstNode = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode secondNode = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode prevNode = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="comment">//交换两个节点的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = firstNode.val;</span><br><span class="line">        firstNode.val = secondNode.val;</span><br><span class="line">        secondNode.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="comment">//找到了第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(firstNode == <span class="keyword">null</span> &amp;&amp; prevNode.val &gt;= root.val)&#123;</span><br><span class="line">            firstNode = prevNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了第二个节点</span></span><br><span class="line">        <span class="keyword">if</span>(firstNode != <span class="keyword">null</span> &amp;&amp; prevNode.val &gt;= root.val)&#123;</span><br><span class="line">            secondNode = root;</span><br><span class="line">        &#125;</span><br><span class="line">        prevNode = root;</span><br><span class="line"></span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n)，但空间复杂度因为有递归，需要栈空间O(lgn)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its st]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Scramble String]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Scramble-String/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Scramble-String/</id>
    <published>2016-07-12T14:30:07.000Z</published>
    <updated>2016-07-12T14:32:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of s1 = “great”:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    great</span><br><span class="line">   /    <span class="string">\</span></span><br><span class="line">  gr    eat</span><br><span class="line"> / <span class="string">\</span>    /  <span class="string">\</span></span><br><span class="line">g   r  e   at</span><br><span class="line">           / <span class="string">\</span></span><br><span class="line">          a   t</span><br></pre></td></tr></table></figure></p>
<p>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node “gr” and swap its two children, it produces a scrambled string “rgeat”.<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    rgeat</span><br><span class="line">   /    <span class="string">\</span></span><br><span class="line">  rg    eat</span><br><span class="line"> / <span class="string">\</span>    /  <span class="string">\</span></span><br><span class="line">r   g  e   at</span><br><span class="line">           / <span class="string">\</span></span><br><span class="line">          a   t</span><br></pre></td></tr></table></figure></p>
<p>We say that “rgeat” is a scrambled string of “great”.</p>
<p>Similarly, if we continue to swap the children of nodes “eat” and “at”, it produces a scrambled string “rgtae”.<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    rgtae</span><br><span class="line">   /    <span class="string">\</span></span><br><span class="line">  rg    tae</span><br><span class="line"> / <span class="string">\</span>    /  <span class="string">\</span></span><br><span class="line">r   g  ta  e</span><br><span class="line">       / <span class="string">\</span></span><br><span class="line">      t   a</span><br></pre></td></tr></table></figure></p>
<p>We say that “rgtae” is a scrambled string of “great”.<br>Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len1 != len2) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(len1 == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(s1.equals(s2)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//假设只有ASCII字符</span></span><br><span class="line">        <span class="keyword">int</span>[] letters = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个字符串的出现的字符以及每个字符出现的次数都要一样，否则为false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">            letters[s1.charAt(i)]++;</span><br><span class="line">            letters[s2.charAt(i)]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(letters[s1.charAt(i)] != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i从0开始，stackoverflow</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>, i), s2.substring(<span class="number">0</span>,i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>, i), s2.substring(len2 - i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(<span class="number">0</span>,len2-i))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Reverse Nodes in k-Group]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Reverse-Nodes-in-k-Group/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Reverse-Nodes-in-k-Group/</id>
    <published>2016-07-12T12:53:01.000Z</published>
    <updated>2016-07-12T14:30:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>
<p>Only constant memory is allowed.</p>
<p>For example,<br>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到第k+1个节点</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; count != k)&#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            curr = reverseKGroup(curr, k);</span><br><span class="line">            <span class="comment">//此时head为没有反转部分的头结点</span></span><br><span class="line">            <span class="comment">//curr是已经反转部分的头结点</span></span><br><span class="line">            <span class="comment">//我们需要将head为头结点的k个节点反转后，将curr指向的已经反转的部分链接到head反转后的后面</span></span><br><span class="line">            <span class="comment">//举个例子原始链表为1-&gt;2-&gt;3-&gt;4-&gt;5, k = 2</span></span><br><span class="line">            <span class="comment">//此时为1-&gt;2-&gt;4-&gt;3-&gt;5，此时head指向1，curr指向4，我们要变成2-&gt;1-&gt;4-&gt;3-&gt;5</span></span><br><span class="line">            <span class="comment">//k-- &gt; 0</span></span><br><span class="line">            <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//先保存head的下一个节点，下一轮迭代使用</span></span><br><span class="line">                ListNode temp = head.next;</span><br><span class="line">                head.next = curr;</span><br><span class="line">                curr = head;</span><br><span class="line">                head = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            head = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不足k个节点，返回</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>If the nu]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Serialize and Deserialize Binary Tree]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Serialize-and-Deserialize-Binary-Tree/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Serialize-and-Deserialize-Binary-Tree/</id>
    <published>2016-07-12T11:55:28.000Z</published>
    <updated>2016-07-12T11:56:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>For example, you may serialize the following tree<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>as “[1,2,3,null,null,4,5]”, just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.<br>Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SPLITER = <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAN = <span class="string">"##"</span>;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//采用先序遍历的方法，边遍历边序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode node, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NAN).append(SPLITER);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(node.val).append(SPLITER);</span><br><span class="line">            serialize(node.left, sb);</span><br><span class="line">            serialize(node.right, sb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        nodes.addAll(Arrays.asList(data.split(SPLITER)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">deserialize</span><span class="params">(Deque&lt;String&gt; nodes)</span></span>&#123;</span><br><span class="line">        String val = nodes.poll();</span><br><span class="line">        <span class="keyword">if</span>(val.equals(NAN)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(val));</span><br><span class="line">        node.left = deserialize(nodes);</span><br><span class="line">        node.right = deserialize(nodes);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be st]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Longest Increasing Path in a Matrix]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Longest-Increasing-Path-in-a-Matrix/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Longest-Increasing-Path-in-a-Matrix/</id>
    <published>2016-07-12T08:24:25.000Z</published>
    <updated>2016-07-12T08:26:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p>Example 1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Return 4<br>The longest increasing path is [1, 2, 6, 9].</p>
<p>Example 2:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Return 4<br>The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//四个搜索方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> len = dfs(matrix, i, j, row, col, cache);</span><br><span class="line">                max = Math.max(max, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度搜索从[i][j]出发的最长递增路径的长度</span></span><br><span class="line">    <span class="comment">//cache缓存，即备忘录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] cache)</span></span>&#123;</span><br><span class="line">        <span class="comment">//已经搜索过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(cache[i][j] != <span class="number">0</span>) <span class="keyword">return</span> cache[i][j];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//四个方向搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//matrix[x][y] &lt;= matrix[i][j]可以避免使用visited[row][col]数组</span></span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= row || y &lt; <span class="number">0</span> || y &gt;= col || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span> + dfs(matrix, x, y, row, col, cache);</span><br><span class="line">            max = Math.max(len, max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache[i][j] = max;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either mov]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Invalid Parentheses]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Remove-Invalid-Parentheses/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Remove-Invalid-Parentheses/</id>
    <published>2016-07-12T07:50:20.000Z</published>
    <updated>2016-07-12T07:52:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p>
<p>Note: The input string may contain letters other than the parentheses ( and ).</p>
<p>Examples:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"()())()"</span> -&gt; [<span class="string">"()()()"</span>, <span class="string">"(())()"</span>]</span><br><span class="line"><span class="string">"(a)())()"</span> -&gt; [<span class="string">"(a)()()"</span>, <span class="string">"(a())()"</span>]</span><br><span class="line"><span class="string">")("</span> -&gt; [<span class="string">""</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用BFS，我们通过溢出"("或者")"然后判断括号是否有效，如果是该层上有效的括号，加入到结果集中，不用继续往下一层搜索</span></span><br><span class="line">    <span class="comment">//如果是无效的加入到队列中，在BFS的下一层处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//s.length() == 0,应该有res.add("");</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来排除重复组合</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(s);</span><br><span class="line">        visited.add(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一旦BFS在某一层找到了有效的括号组合，就不用继续往下一层继续搜索了</span></span><br><span class="line">        <span class="comment">//因为题目要求移除最少括号</span></span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           String str = queue.poll();</span><br><span class="line">           <span class="keyword">if</span>(isValid(str))&#123;</span><br><span class="line">               res.add(str);</span><br><span class="line">               found = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//找到有效组合，不用继续往下一层搜索</span></span><br><span class="line">           <span class="keyword">if</span>(found) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">               <span class="comment">//只移除括号</span></span><br><span class="line">               <span class="keyword">if</span>(str.charAt(i) == <span class="string">'('</span> || str.charAt(i) == <span class="string">')'</span>)&#123;</span><br><span class="line">                   String temp = str.substring(<span class="number">0</span>, i) + str.substring(i+<span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">if</span>(!visited.contains(temp))&#123;</span><br><span class="line">                       queue.offer(temp);</span><br><span class="line">                       visited.add(temp);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'('</span>) count++;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible resu]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Longest Consecutive Sequence]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-Longest-Consecutive-Sequence/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-Longest-Consecutive-Sequence/</id>
    <published>2016-07-12T06:33:07.000Z</published>
    <updated>2016-07-12T07:51:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given [100, 4, 200, 1, 3, 2],<br>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最直接的想法是排序，然后遍历一遍找出最长的subarray，时间复杂度为O(nlgn)</span></span><br><span class="line">    <span class="comment">//一种比较tricky的方法就是使用HashMap，key为序列的边界元素（也有非边界但用不上），value为该元素当前所属的最长序列的长度</span></span><br><span class="line">    <span class="comment">//因为只有是序列的边界元素才有可能增加其他序列的长度</span></span><br><span class="line">    <span class="comment">//比如[100, 4, 200, 1, 3, 2]，map里有&lt;2, 4&gt;，&lt;1,4&gt;,&lt;4,1&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(num))&#123;</span><br><span class="line">                <span class="comment">//左边能扩展多长</span></span><br><span class="line">                <span class="keyword">int</span> left = map.containsKey(num - <span class="number">1</span>) ? map.get(num - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//右边能扩展多长</span></span><br><span class="line">                <span class="keyword">int</span> right = map.containsKey(num + <span class="number">1</span>) ? map.get(num + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> sum = left + right + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                res = Math.max(res, sum);</span><br><span class="line"></span><br><span class="line">                map.put(num, sum);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//扩展序列边界元素对应的序列长度</span></span><br><span class="line">                <span class="comment">//左边界为num - left</span></span><br><span class="line">                <span class="comment">//右边界为num + right</span></span><br><span class="line">                <span class="comment">//如果num没有相邻元素，left,right都为0，相当于没做什么：）</span></span><br><span class="line">                map.put(num - left, sum);</span><br><span class="line">                map.put(num + right, sum);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不写这个也是可以的：）</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用HashSet存取所有元素，判断一个元素是否是一个序列的开始，如果是，不断的扩展该序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//使用HashSet存取所有元素，判断一个元素是否是一个序列的开始，如果是，不断的扩展该序列</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">//没有左邻居说明，该元素是序列的起始元素</span></span><br><span class="line">        <span class="keyword">if</span>(!set.contains(nums[i] - <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(set.contains(temp))&#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = Math.max(res,temp - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For exam]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]N-Queens I II]]></title>
    <link href="http://blog.noobsky.com/2016/07/12/LeetCode-N-Queens-I-II/"/>
    <id>http://blog.noobsky.com/2016/07/12/LeetCode-N-Queens-I-II/</id>
    <published>2016-07-12T02:41:41.000Z</published>
    <updated>2016-07-12T03:36:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="N-Queens_I">N-Queens I</h2><h3 id="题目描述">题目描述</h3><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br><img src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png" alt=""><br>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p>For example,<br>There exist two distinct solutions to the 4-queens puzzle:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [<span class="string">".Q.."</span>,  // Solution <span class="number">1</span></span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  // Solution <span class="number">2</span></span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)</span><br><span class="line">            Arrays.fill(board[i], <span class="string">'.'</span>);</span><br><span class="line">        solveNQueens(res, board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一行来尝试放置皇后，每一行皇后尝试放置每一列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">char</span>[][] board, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">            res.add(construct(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于每一行，尝试每一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(board, row, i))&#123;</span><br><span class="line">                board[row][i] = <span class="string">'Q'</span>;</span><br><span class="line">                solveNQueens(res, board, row + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                board[row][i] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断皇后是否可以放到[row][col]位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为是逐行逐行搜索结果，只需要检查已经放置过皇后的行</span></span><br><span class="line">        <span class="comment">//所以x的终止条件为x&lt;row，y的终止条件却为n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; row; x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; board[<span class="number">0</span>].length; y++)&#123;</span><br><span class="line">                <span class="comment">//检查该列、45度对角线、135度对角线</span></span><br><span class="line">                <span class="comment">//45度对角线的方程为x+y == row + col</span></span><br><span class="line">                <span class="comment">//135度对角线为x + col = y + row</span></span><br><span class="line">                <span class="keyword">if</span>(board[x][y] == <span class="string">'Q'</span> &amp;&amp; (y == col || x + y == row + col || x + col == y + row))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">construct</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] rows: board)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(rows));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码还能优化，使用标记数组，不用每次搜索放置皇后是否有效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)</span><br><span class="line">            Arrays.fill(board[i], <span class="string">'.'</span>);</span><br><span class="line">        <span class="comment">//标记数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[] flagCol = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] d1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] d2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        solveNQueens(res, board, <span class="number">0</span>, flagCol, d1, d2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一行来尝试放置皇后，每一行皇后尝试放置每一列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">boolean</span>[] flagCol, <span class="keyword">boolean</span>[] d1, <span class="keyword">boolean</span>[] d2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">            res.add(construct(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于每一行，尝试每一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flagCol[i] &amp;&amp; !d1[row + i] &amp;&amp; !d2[board[<span class="number">0</span>].length-<span class="number">1</span>+i-row])&#123;</span><br><span class="line">                flagCol[i] = d1[row + i] = d2[board[<span class="number">0</span>].length-<span class="number">1</span>+i-row] = <span class="keyword">true</span>;</span><br><span class="line">                board[row][i] = <span class="string">'Q'</span>;</span><br><span class="line">                solveNQueens(res, board, row + <span class="number">1</span>, flagCol, d1, d2);</span><br><span class="line">                flagCol[i] = d1[row + i] = d2[board[<span class="number">0</span>].length-<span class="number">1</span>+i-row] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                board[row][i] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">construct</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] rows: board)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(rows));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="N-Queens_II">N-Queens II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for N-Queens problem.</p>
<p>Now, instead outputting board configurations, return the total number of distinct solutions.<br><img src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png" alt=""></p>
<h3 id="代码-1">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//也可以使用HashSet，但没啥必要，还偏慢</span></span><br><span class="line">    <span class="comment">//n列,作为全局变量是因为懒得传参数:)</span></span><br><span class="line">    <span class="keyword">boolean</span>[] cols;</span><br><span class="line">    <span class="comment">//2n - 1条45度对角线，row + col为其boolean中下标，对一对角线的row+col相等</span></span><br><span class="line">    <span class="keyword">boolean</span>[] d1;</span><br><span class="line">    <span class="comment">//2n - 1条135度对角线，n-1 + col - row</span></span><br><span class="line">    <span class="keyword">boolean</span>[] d2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cols = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        d1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line">        d2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n - <span class="number">1</span>];</span><br><span class="line">        backtracking(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试每一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)&#123;</span><br><span class="line">            <span class="comment">//如果某该列、两条对角线已经有皇后则不能放</span></span><br><span class="line">            <span class="keyword">if</span>(cols[col] || d1[row + col] || d2[n - <span class="number">1</span> + col - row]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//放置皇后</span></span><br><span class="line">            cols[col] = d1[row+col] = d2[n-<span class="number">1</span>+col-row] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(row+<span class="number">1</span>, n);</span><br><span class="line">            cols[col] = d1[row+col] = d2[n-<span class="number">1</span>+col-row] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="N-Queens_I">N-Queens I</h2><h3 id="题目描述">题目描述</h3><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard suc]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Surrounded Regions]]></title>
    <link href="http://blog.noobsky.com/2016/07/11/LeetCode-Surrounded-Regions/"/>
    <id>http://blog.noobsky.com/2016/07/11/LeetCode-Surrounded-Regions/</id>
    <published>2016-07-11T13:54:57.000Z</published>
    <updated>2016-07-11T15:24:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>For example,<br><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O O <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> O <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O <span class="keyword">X</span> <span class="keyword">X</span></span><br></pre></td></tr></table></figure></p>
<p>After running your function, the board should be:<br><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O <span class="keyword">X</span> <span class="keyword">X</span></span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] unionSet;<span class="comment">//并查集</span></span><br><span class="line">    <span class="keyword">boolean</span>[] hasEdgeO;<span class="comment">//表示每个并查集在矩阵的边上是否有一个O</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        unionSet = <span class="keyword">new</span> <span class="keyword">int</span>[row * col];</span><br><span class="line">        hasEdgeO = <span class="keyword">new</span> <span class="keyword">boolean</span>[unionSet.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化并查集，每个字符都是一个并查集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unionSet.length; i++) unionSet[i] = i;</span><br><span class="line">        <span class="comment">//初始化hasEdgeO</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unionSet.length; i++)&#123;</span><br><span class="line">            <span class="comment">//计算在矩阵中的下标</span></span><br><span class="line">            <span class="keyword">int</span> x = i / col, y = i % col;</span><br><span class="line">            hasEdgeO[i] = board[x][y] == <span class="string">'O'</span> &amp;&amp; (x ==<span class="number">0</span> || x == row - <span class="number">1</span> || y == <span class="number">0</span> || y == col - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历矩阵，如果某个字符和它上边或右边的字符相等，合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unionSet.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i / col, y = i % col, up = x - <span class="number">1</span>, right = y + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(up &gt;= <span class="number">0</span> &amp;&amp; board[x][y] == board[up][y]) union(i, i - col);</span><br><span class="line">            <span class="keyword">if</span>(right &lt; col &amp;&amp; board[x][y] == board[x][right]) union(i, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于矩阵中的每个字符O，如果它所在的集合没有edge O，那么该集合的所有元素都应该设置为X</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unionSet.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i / col, y = i % col;</span><br><span class="line">            <span class="keyword">if</span>(board[x][y] == <span class="string">'O'</span> &amp;&amp; !hasEdgeO[findSet(i)])&#123;</span><br><span class="line">                board[x][y] = <span class="string">'X'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并集合，记得两个集合有hasEdgeO则合并后的集合也要标记为hasEdgeO</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = findSet(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = findSet(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> hasEdgeO = <span class="keyword">this</span>.hasEdgeO[rootX] || <span class="keyword">this</span>.hasEdgeO[rootY];</span><br><span class="line">        unionSet[rootX] = rootY;</span><br><span class="line">        <span class="keyword">this</span>.hasEdgeO[rootY] = hasEdgeO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找每个集合的根，即代表元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSet</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(unionSet[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">        unionSet[x] = findSet(unionSet[x]);</span><br><span class="line">        <span class="keyword">return</span> unionSet[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用BFS的方法，不被包围的O是跟边界上O相连的，其他的O都是被包围的，会变成X的。所有我们使用BFS将跟边界上的O相连的O都标记为A。标记完之后，再遍历一遍矩阵，将O（被X包围的）改为X，A还原为O（没有被包围）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="comment">//边界元素</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || i == row - <span class="number">1</span> || j == <span class="number">0</span> || j == col - <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                        board[i][j] = <span class="string">'A'</span>;</span><br><span class="line">                        bfs(board, i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'A'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(i * col + j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = q.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> x = cur / col;</span><br><span class="line">            <span class="keyword">int</span> y = cur % col;</span><br><span class="line">            <span class="comment">//右边</span></span><br><span class="line">            <span class="keyword">if</span>(y + <span class="number">1</span> &lt; col &amp;&amp; board[x][y+<span class="number">1</span>] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                q.add(cur + <span class="number">1</span>);</span><br><span class="line">                board[x][y+<span class="number">1</span>] = <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下边</span></span><br><span class="line">            <span class="keyword">if</span>(x + <span class="number">1</span> &lt; row &amp;&amp; board[x+<span class="number">1</span>][y] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                q.add(cur + col);</span><br><span class="line">                board[x+<span class="number">1</span>][y] = <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左边</span></span><br><span class="line">            <span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[x][y-<span class="number">1</span>] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                q.add(cur - <span class="number">1</span>);</span><br><span class="line">                board[x][y-<span class="number">1</span>] = <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上边</span></span><br><span class="line">            <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[x-<span class="number">1</span>][y] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                q.add(cur - col);</span><br><span class="line">                board[x-<span class="number">1</span>][y] = <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p>
<p>A region is ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
