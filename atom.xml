<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-10-08T15:13:38.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Sort List]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Sort-List/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Sort-List/</id>
    <published>2016-10-08T14:45:35.000Z</published>
    <updated>2016-10-08T15:13:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将list分为两部分</span></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找链表中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分为两部分，pre为空说明slow前面前面没有元素，前半部分单链表为空</span></span><br><span class="line">        <span class="comment">// if(pre != null) pre.next = null;</span></span><br><span class="line">        <span class="comment">// else head = null;</span></span><br><span class="line">        <span class="comment">//这里因为前面if(head == null || head.next == null) return head;保证了起码有两个元素才会往下运行</span></span><br><span class="line">        <span class="comment">//则保证会进入while循环，则pre一定不会为空(前半部分单链表不可能为空)，写成上面先判空也可以</span></span><br><span class="line">        <span class="comment">//置为空，将链表割断</span></span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode l1 = sortList(head);</span><br><span class="line">        ListNode l2 = sortList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l1 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l2 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l2;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">quickSort</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  ListNode smallDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), small = smallDummy;</span><br><span class="line">  ListNode largeDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), large = largeDummy;</span><br><span class="line">  ListNode equalDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), equal = equalDummy;</span><br><span class="line"></span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.val &lt; head.val)&#123;</span><br><span class="line">      small.next = curr;</span><br><span class="line">      small = small.next;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr.val &gt; head.val)&#123;</span><br><span class="line">      large.next = curr;</span><br><span class="line">      large = large.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      equal.next = curr;</span><br><span class="line">      equal = equal.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  small.next = large.next = equal.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(merge(quickSort(smallDummy.next), quickSort(largeDummy.next)), equalDummy.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">            current.next = l1;</span><br><span class="line">            <span class="comment">//current = current.next;</span></span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            current.next = l2;</span><br><span class="line">            <span class="comment">//current = current.next;</span></span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if(l1 != null)&#123;</span></span><br><span class="line">    <span class="comment">//     current.next = l1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if(l2 != null)&#123;</span></span><br><span class="line">    <span class="comment">//     current.next = l2;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<figure class="highlight java"><table><]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Max Points on a Line]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Max-Points-on-a-Line/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Max-Points-on-a-Line/</id>
    <published>2016-10-08T13:52:36.000Z</published>
    <updated>2016-10-08T16:03:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>暴力法，注意相同的点和x坐标相等的点（斜率无穷大）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a point.</span><br><span class="line"> * class Point &#123;</span><br><span class="line"> *     int x;</span><br><span class="line"> *     int y;</span><br><span class="line"> *     Point() &#123; x = 0; y = 0; &#125;</span><br><span class="line"> *     Point(int a, int b) &#123; x = a; y = b; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(points.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> points.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++)&#123;</span><br><span class="line">      <span class="comment">//key为斜率，value为点数</span></span><br><span class="line">      HashMap&lt;Double, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="comment">//x坐标相等的点的数量</span></span><br><span class="line">      <span class="keyword">int</span> samex = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//记录相同点</span></span><br><span class="line">      <span class="keyword">int</span> samep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">          <span class="keyword">if</span>((points[j].x == points[i].x) &amp;&amp; (points[j].y == points[i].y))&#123;</span><br><span class="line">            samep++;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(points[j].x == points[i].x)&#123;</span><br><span class="line">            samex++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">double</span> k = (<span class="keyword">double</span>)(points[j].y - points[i].y) / (<span class="keyword">double</span>)(points[j].x - points[i].x);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(map.containsKey(k))&#123;</span><br><span class="line">            map.put(k, map.get(k) + <span class="number">1</span>);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(k, <span class="number">2</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          result = Math.max(result, map.get(k) + samep);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      result = Math.max(result, samex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>暴力法，注意相]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之Two Pointers问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8BTwo-Pointers%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/08/面试算法之Two-Pointers问题集锦/</id>
    <published>2016-10-08T12:18:29.000Z</published>
    <updated>2016-10-08T12:18:29.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之二分搜索问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/08/面试算法之二分搜索问题集锦/</id>
    <published>2016-10-08T09:07:05.000Z</published>
    <updated>2016-10-08T12:50:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="First_Bad_Version">First Bad Version</h2><p>给定一个判断版本是否是坏版本的函数，查找[1…n]中第一个坏的版本<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span><br><span class="line">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//int mid = left + (right - left)/2;</span></span><br><span class="line">            <span class="keyword">if</span>(!isBadVersion(mid)) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     public int firstBadVersion(int n) &#123;</span></span><br><span class="line"><span class="comment">//     int start = 1, end = n;</span></span><br><span class="line"><span class="comment">//     while (start &lt; end) &#123;</span></span><br><span class="line"><span class="comment">//         int mid = start + (end-start) / 2;</span></span><br><span class="line"><span class="comment">//         if (!isBadVersion(mid)) start = mid + 1;</span></span><br><span class="line"><span class="comment">//         else end = mid;            </span></span><br><span class="line"><span class="comment">//     &#125;        </span></span><br><span class="line"><span class="comment">//     return start;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Guess_Number_Higher_or_Lower">Guess Number Higher or Lower</h2><p>给定辅助guess(int num)函数，返回3种结果<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> lower</span><br><span class="line"> <span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> higher</span><br><span class="line"> <span class="number">0</span> : Congrats! You got <span class="keyword">it</span>!</span><br></pre></td></tr></table></figure></p>
<p>代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The guess API is defined in the parent class GuessGame.</span><br><span class="line">   @param num, your guess</span><br><span class="line">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span><br><span class="line">      int guess(int num); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(guess(mid) == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(guess(mid) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 1 : My number is higher,这里的My number是指要你猜的那个数</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Sqrt(x)">Sqrt(x)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid == x / mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; x / mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_a_2D_Matrix">Search a 2D Matrix</h2><p>矩阵每一行升序，每一行的第一个元素大于前一行的最后一个元素<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Given target = 3, return true.</p>
<p>每一行从左到右组成有序数组，数组下标范围为[0,row*col-1]，可以使用二分搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//row*col矩阵转换为数组=&gt;matrix[i][j] =&gt; array[i * col + j]</span></span><br><span class="line"><span class="comment">//数组转换为矩阵array[i] =&gt; matrix[i / col][i % col]</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">      <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">          <span class="keyword">int</span> mid = left+(right - left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Find_Peak_Element">Find Peak Element</h2><p>给定数组，num[i] ≠ num[i+1]，查找peek元素，并返回其下标</p>
<p>You may imagine that num[-1] = num[n] = -∞.</p>
<p>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//local maximum就是一个peek</span></span><br><span class="line">    <span class="comment">//mid = (left + right)/2,mid1 = mid + 1</span></span><br><span class="line">    <span class="comment">//如果nums[mid] &lt; nums[mid1]，那么nums[mid1...right]一定有peek，为什么？</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid1右边的数只能增加或者减少，如果mid1右边的数一直增加，则nums[right]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid1右边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="comment">//同理nums[mid] &gt; nums[mid1]，那么nums[left, mid]一定有peek，道理是一样的</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid左边的数只能增加或者减少，如果mid左边的数一直增加，则nums[left]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid左边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> mid1 = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右边一定有peek</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid1])&#123;</span><br><span class="line">                left = mid1;</span><br><span class="line">            <span class="comment">//左边一定有peek</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="comment">//如果出现相等就不符合题目中相邻元素不相等，可以抛异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历的方法不符合时间复杂度，但是实现非常tricky</span></span><br><span class="line">    <span class="comment">// public int findPeakElement(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     //右边有减小的话则peek出现</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] &lt; nums[i-1]) return i-1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //否则元素一直增大到最右边元素就是peek</span></span><br><span class="line">    <span class="comment">//     return nums.length - 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kth_Smallest_Element_in_a_BST">Kth Smallest Element in a BST</h2><p>寻找BST中第k小的元素<br>利用BST的性质，递归搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计左子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> count = countNodes(root.left);</span><br><span class="line">        <span class="comment">//左子树的节点个数大于等于k，说明第k小的元素在左子树中，递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.left, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第k个元素在右子树中，相当于在右子树中寻找第k-count-1小的元素</span></span><br><span class="line">        <span class="keyword">if</span>(count &lt; k-<span class="number">1</span>) <span class="keyword">return</span> kthSmallest(root.right, k - count -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//count = k-1,说明左子树有k-1个节点，跟该节点即为第k小的元素</span></span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以利用中序遍历，边遍历边查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用中序遍历法，因为中序遍历二叉树是有序的</span></span><br><span class="line"><span class="comment">//使用递归中序遍历</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    count = k;</span><br><span class="line">    dfsHelper(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) dfsHelper(root.left);</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">        number = root.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) dfsHelper(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_for_a_Range">Search for a Range</h2><p>给定有序数组，查找目标数在数组的开始和结束位置<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找左边界：mid = (left+right)/2，下取整，往左偏</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找左边界，所以right = mid</span></span><br><span class="line">    <span class="comment">// 2和3可以合并，合并后：if(nums[mid] &lt; target) left = mid+1; else right = mid;</span></span><br><span class="line">    <span class="comment">// 找右边界：mid = (left+right)/2+1，上取整，往右篇</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找右边界，所以left = mid</span></span><br><span class="line">    <span class="comment">// 1和3可以合并，合并后：if(nums[mid] &gt; target) right = mid-1; else left = mid;</span></span><br><span class="line">    <span class="comment">// 就是两种二分搜索的写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[left] != target) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> res[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line">        right = nums.length - <span class="number">1</span>;<span class="comment">//第二次时，left可以不重新设置为0，设置了也没错，多余而已</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//上取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有左边界，就一定能执行到这里，而且不用判断，right最起码等于前面判断左边界</span></span><br><span class="line">        res[<span class="number">1</span>] = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_a_2D_Matrix_II">Search a 2D Matrix II</h2><p>m*n的矩阵，每一行从左往右升序，每一列从上往下升序，在矩阵查找目标元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始比较位置为右上角即matrix[0][col-1],如果target大于该值，那么target不可能在该row，因为每一row都是升序，可以排除该row</span></span><br><span class="line">    <span class="comment">//如果target小于该值，那么target不可能在该col，因为每一col都是升序的，可以排除该col，</span></span><br><span class="line">    <span class="comment">//如果相等，返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[row][col])&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[row][col])&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Search_in_Rotated_Sorted_Array_II">Search in Rotated Sorted Array II</h2><p>[4 5 6 7 0 1 2]，考虑有重复元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//左半部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右半部分有序</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, rigth = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//左半部分有序</span></span><br><span class="line">      <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[] &lt; nums[right])&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Find_Minimum_in_Rotated_Sorted_Array">Find Minimum in Rotated Sorted Array</h2><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;<span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有重复元素呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="comment">//nums[mid] &gt; nums[right],nums[left:mid]有序，搜索右边</span></span><br><span class="line">    <span class="comment">//nums[mid] &lt; nums[right],nums[mid:right]有序，搜索左边</span></span><br><span class="line">    <span class="comment">//nums[mid] = nums[right],有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">    <span class="comment">//但可以肯定排除nums[right],即使min = A[right],排除A[right]并没有使min丢失</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Valid_Perfect_Square">Valid Perfect Square</h2><p>判断是否为完全平方数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里可以直接用数学规律</span></span><br><span class="line">    <span class="comment">//1 = 1</span></span><br><span class="line">    <span class="comment">//4 = 1 + 3</span></span><br><span class="line">    <span class="comment">//9 = 1 + 3 + 5</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//但是这里我们需要注意的是我们不能用加法来做</span></span><br><span class="line">    <span class="comment">//因为加法存在溢出的问题，我们可以逆向考虑，</span></span><br><span class="line">    <span class="comment">//用减法，减1、3...，看看最后num是否会为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            num -= i;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们不知道这个规律，之前实现过sqrt，同理这里也可以使用二分搜索</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//除法是下取整的，mid取值偏小</span></span><br><span class="line">            <span class="comment">//取值偏小的mid的平方都大于num，那么平方根肯定小于mid，所以right = mid - 1</span></span><br><span class="line">            <span class="comment">//除法防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(mid &gt; num / mid)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//小于等于</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &lt; num / mid)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果这样写会造成死循环，比如5</span></span><br><span class="line">                <span class="comment">//if(num % mid == 0) return true;</span></span><br><span class="line">                <span class="keyword">return</span> num % mid == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Find_the_Duplicate_Number">Find the Duplicate Number</h2><p>数组nums包含n+1个元素，每个元素的值在[1,n]区间<br>类似找到链表环的起点，快慢指针<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="LIS最长递增子序列">LIS最长递增子序列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.排序后的序列和原序列求LCS最长公共子序列</span></span><br><span class="line">    <span class="comment">//2.dp (O(n*n))</span></span><br><span class="line">    <span class="comment">//3.dp (O(nlgn))</span></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int[] ends = new int[nums.length];</span></span><br><span class="line">    <span class="comment">//     int len = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //二分搜索可以利用Arrays.binarySearch(int[] a, int fromIndex, int toIndex, int key),</span></span><br><span class="line">    <span class="comment">//     //该函数的返回值是这样的：如果a中存在key，则返回key在a中的index，不存在key返回-insertionpoint-1，所以</span></span><br><span class="line">    <span class="comment">//     //此时insertionpoint =  -(返回值+1)</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         int ret = Arrays.binarySearch(ends, 0, len, nums[i]);</span></span><br><span class="line">    <span class="comment">//         //小于0，不存在key，计算插入位置</span></span><br><span class="line">    <span class="comment">//         if(ret &lt; 0) ret = -(ret+1);</span></span><br><span class="line">    <span class="comment">//         //或者使用自己二分搜索函数</span></span><br><span class="line">    <span class="comment">//         //int ret = binarySearch(ends, 0, len, nums[i]);</span></span><br><span class="line">    <span class="comment">//         ends[ret] = nums[i];</span></span><br><span class="line">    <span class="comment">//         //在ends尾部增加了一个元素</span></span><br><span class="line">    <span class="comment">//         if(ret == len) len++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return len;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不记得Arrays.binarySearch返回值的含义，可以自己写一个二分搜索函数，</span></span><br><span class="line">    <span class="comment">//如果存在key返回index，不存在时返回插入位置的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = fromIndex, right = toIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == key) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; key) right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[j] = max(dp[i]) + 1 i&lt;j&amp;&amp;nums[i] &lt; nums[j]</span></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums)&#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int res = 0;</span></span><br><span class="line">    <span class="comment">//     int[] dp = new int[nums.length];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     for(int j = 0; j &lt; nums.length; j++)&#123;</span></span><br><span class="line">    <span class="comment">//         //也可以在前面用Arrays.fill(dp, 1)</span></span><br><span class="line">    <span class="comment">//         dp[j] = 1;</span></span><br><span class="line">    <span class="comment">//         for(int i = 0; i &lt; j; i++)&#123;</span></span><br><span class="line">    <span class="comment">//             if(nums[i] &lt; nums[j]) dp[j] = Math.max(dp[j], dp[i]+1);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         res = Math.max(res, dp[j]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums)&#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int[] numsCopy = new int[nums.length];</span></span><br><span class="line">    <span class="comment">//     numsCopy = Arrays.copyOfRange(nums, 0, nums.length);</span></span><br><span class="line">    <span class="comment">//     Arrays.sort(numsCopy);</span></span><br><span class="line">    <span class="comment">//     //System.arraycopy(nums, 0, numsCopy, 0, nums.length);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int dp[][] = new int[nums.length+1][nums.length+1];</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt;= nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 0; j &lt;= nums.length; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             if(i == 0 || j == 0) dp[i][j] = 0;</span></span><br><span class="line">    <span class="comment">//             else&#123;</span></span><br><span class="line">    <span class="comment">//                 if(nums[i-1] == numsCopy[j-1])&#123;</span></span><br><span class="line">    <span class="comment">//                     dp[i][j] = dp[i-1][j-1]+1;</span></span><br><span class="line">    <span class="comment">//                 &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                     dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);</span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return dp[nums.length][nums.length];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Russian_Doll_Envelopes">Russian Doll Envelopes</h2><p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>
<p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<p>Example:<br>Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分两步</span></span><br><span class="line">    <span class="comment">//1. 信封按宽升序高降序排序</span></span><br><span class="line">    <span class="comment">//2. 对信封的高找最长递增子序列</span></span><br><span class="line">    <span class="comment">//因为信封的宽已经是升序，我们只要考虑信封的高就可以了</span></span><br><span class="line">    <span class="comment">//[3, 4]是装不下[3, 3]，所以我们需要将[3, 4]排在[3, 3]的前面，如果排序排成了[3,3] [3,4]会被当成递增序列，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span> || envelopes[<span class="number">0</span>].length != <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[<span class="number">0</span>] == arr2[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="comment">//高度降序</span></span><br><span class="line">                    <span class="keyword">return</span> arr2[<span class="number">1</span>] - arr1[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] envelope : envelopes)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(dp, <span class="number">0</span>, len, envelope[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                index = -(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[index] = envelope[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(index == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="First_Bad_Version">First Bad Version</h2><p>给定一个判断版本是否是坏版本的函数，查找[1…n]中第一个坏的版本<br><figure class="highlight java"><table><tr><td class]]>
    </summary>
    
      <category term="Binary Search" scheme="http://blog.noobsky.com/tags/Binary-Search/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Find K Pairs with Smallest Sums]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Find-K-Pairs-with-Smallest-Sums/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Find-K-Pairs-with-Smallest-Sums/</id>
    <published>2016-10-08T08:46:58.000Z</published>
    <updated>2016-10-08T08:49:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.</p>
<p>Define a pair (u,v) which consists of one element from the first array and one element from the second array.</p>
<p>Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums.</p>
<p>Example 1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],  k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Return: [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">The first <span class="number">3</span> pairs are returned from the sequence:</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],  k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Return: [<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">The first <span class="number">2</span> pairs are returned from the sequence:</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">3</span>],  k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Return: [<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">All possible pairs are returned from the sequence:</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路">解题思路</h2><p>类似两路归并排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;Tuple&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.length &amp;&amp; j &lt; k; j++) pq.offer(<span class="keyword">new</span> Tuple(<span class="number">0</span>,j,nums1[<span class="number">0</span>]+nums2[j]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(k, nums1.length*nums2.length); i++)&#123;</span><br><span class="line">            Tuple temp = pq.poll();</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums1[temp.x], nums2[temp.y]&#125;);</span><br><span class="line">            <span class="keyword">if</span>(temp.x == nums1.length - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> Tuple(temp.x+<span class="number">1</span>, temp.y, nums1[temp.x+<span class="number">1</span>]+nums2[temp.y]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tuple</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Tuple that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - that.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.</p>
<p>Define a pair ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Permutations I II]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Permutations-I-II/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Permutations-I-II/</id>
    <published>2016-10-08T06:22:34.000Z</published>
    <updated>2016-10-08T16:15:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Permutations_I">Permutations I</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of distinct numbers, return all possible permutations.</p>
<p>For example,<br>[1,2,3] have the following permutations:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><ul>
<li><p>一般思路</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(nums, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void permute(<span class="keyword">int</span>[]nums, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">int</span> start)&#123;</span><br><span class="line">        <span class="comment">//产生了一个permutation</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= nums.length)&#123;</span><br><span class="line">            <span class="comment">//如果Arrays.asList(arr)的参数arr是原生数组的话并不能得到你想要的结果，</span></span><br><span class="line">            <span class="comment">//Arrays.asList(T...a)形参为可变长参数，如果传入int[] nums的话，会将int[]看做一个类型</span></span><br><span class="line">            <span class="comment">//List list = Arrays.asList(nums)则list.size() == 1;</span></span><br><span class="line">            <span class="comment">//res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums)));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//还是乖乖遍历吧，或者加多一个参数</span></span><br><span class="line">            <span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">list</span>.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">list</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">            <span class="comment">//注意第三个参数是start+1不是i+1</span></span><br><span class="line">            permute(nums, res, start+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//相当于还原回来</span></span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void swap(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码比较简洁易懂</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute(nums, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void permute(<span class="keyword">int</span>[] nums, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">List</span>&lt;Integer&gt; curr)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//curr中已经包含nums[i],跳过本次循环</span></span><br><span class="line">            <span class="keyword">if</span>(curr.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            permute(nums, res, curr);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Permutations_II">Permutations II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br>[1,1,2] have the following unique permutations:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码-1">代码</h3><ul>
<li><p>比较tricky的写法</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//注意排序，让重复的数相邻</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        helper(nums, used, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void helper(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, <span class="keyword">List</span>&lt;Integer&gt; curr, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//only insert duplicate element when the previous duplicate element has been inserted</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            helper(nums, used, curr, res);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常规思路加排重</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; permuteUnique(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute(nums, res, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> permute(<span class="built_in">int</span>[] nums, <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res, <span class="built_in">int</span> start)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">            <span class="built_in">List</span>&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> <span class="built_in">num</span>: nums) &#123;temp.add(<span class="built_in">num</span>);&#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//set在for循环外面定义，在里面定义错误</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; <span class="literal">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">set</span>.add(nums[i]))&#123;</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">                permute(nums, res, start+<span class="number">1</span>);</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> swap(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> x, <span class="built_in">int</span> y)&#123;</span><br><span class="line">        <span class="built_in">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Permutations_I">Permutations I</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of distinct numbers, return all possible permutation]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Preorder/Inorder/Postorder Traversal]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/</id>
    <published>2016-10-08T06:20:02.000Z</published>
    <updated>2016-10-08T16:03:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>return [1,2,3].</p>
<h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    preorder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    preorder(root.left,res);</span><br><span class="line">    preorder(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_Inorder_Traversal">Binary Tree Inorder Traversal</h2><h3 id="题目描述-1">题目描述</h3><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree [1,null,2,3],<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>return [1,3,2].</p>
<h3 id="代码-1">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inorder(root,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    inorder(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    TreeNode node = stack.pop();</span><br><span class="line">    res.add(node.val);</span><br><span class="line">    <span class="comment">//栈是先进后出，应该先把右子树进栈，先访问左子树</span></span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  TreeNode curr = root;</span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//如果curr非空，把curr加入栈，然后curr指向curr的左儿子</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">      stack.push(curr);</span><br><span class="line">      curr = curr.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//curr为空，跳出while循环，说明已经向左走到尽头，弹出当前栈顶元素，进行访问，然后指向右儿子</span></span><br><span class="line">    curr = stack.pop();</span><br><span class="line">    res.add(curr.val);</span><br><span class="line">    curr = curr.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Binary_Tree_Postorder_Traversal">Binary Tree Postorder Traversal</h2><h3 id="题目描述-2">题目描述</h3><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>return [3,2,1].</p>
<h3 id="代码-2">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    postorder(root,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorder(root.left, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    postorder(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前序遍历是root-left-right,后序是left-right-root</span></span><br><span class="line">    <span class="comment">//如果把前序遍历稍微修改下，改为root-right-left，则可以发现这种顺序跟后序的完全相反，最后reverse一下结果就行了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="comment">//栈是先进后出，要想先访问右子树，则先进栈左子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree, return the preorde]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google 2016面试题]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/Google-2016%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.noobsky.com/2016/10/08/Google-2016面试题/</id>
    <published>2016-10-08T02:17:47.000Z</published>
    <updated>2016-10-08T08:06:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="轴对称">轴对称</h2><h3 id="题目描述">题目描述</h3><p>给定平面上的n个点，问是否存在一条平行于y轴的直线，使得这n个点相对于这条直线对称。</p>
<p><strong>Follow-up</strong><br>是否存在一条直线使得这n个点关于这条直线对称？</p>
<h3 id="算法分析">算法分析</h3><p>因为对称轴一定平行于y轴，这看起来缩小了穷举范围（可是我们真的要穷举可能的对称轴吗？有实无限个可能点对称轴…）</p>
<p>那么我们怎么找到那条对称轴？对称轴的特点就是每一个点都在另一边有一个对应的点。第一想法是：最左边的点一定对应某个最右边的点，因此最左边的点和最右边的点的中点应该在对称轴上。当然还有很多其他的找对称轴的方法，比如求所有x坐标的平均值。</p>
<p>找到了对称轴的位置，我们就可以通过HashMap判断是否每一个点都有对应的点，最后输出答案即可。</p>
<p>时间复杂度为O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReflected</span><span class="params">(Point[] points)</span></span>&#123;</span><br><span class="line">    <span class="comment">//最右边点的x坐标值</span></span><br><span class="line">    <span class="keyword">int</span> max = Math.MIN_VALUE;</span><br><span class="line">    <span class="comment">//最左边点的x坐标值</span></span><br><span class="line">    <span class="keyword">int</span> min = Math.MAX_VALUE;</span><br><span class="line">    <span class="comment">//key为y坐标值，value为y坐标值为key的所有点的x坐标值的集合</span></span><br><span class="line">    HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">      <span class="comment">//找出最左边和最右边对应点的x坐标值</span></span><br><span class="line">      max = Math.max(max, points[i].x);</span><br><span class="line">      min = Math.min(min, points[i].x);</span><br><span class="line">      <span class="keyword">if</span>(!map.containsKey(points[i].y))&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(points[i].x);</span><br><span class="line">        map.put(points[i].y, set);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.get(points[i].y).add(points[i].x);</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//max-y0 = y0-min; p-y0 = y0 - p' =&gt; p' = max+min-p</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++)&#123;</span><br><span class="line">      <span class="comment">//根据对称轴判断其他点是否都有对应的点</span></span><br><span class="line">      <span class="keyword">if</span>(!map.containsKey(points[i].y) || !map.get(points[i].y).contains(max+min-points[i].x))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">int</span> y;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">()</span></span>&#123;x = <span class="number">0</span>; y = <span class="number">0</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;x = a; y = b;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组补丁">数组补丁</h2><h3 id="题目描述-1">题目描述</h3><p>给出一个从小到大排好序的整数数组nums和一个整数n，在数组中添加若干个补丁（元素）使得[1,n]的区间内的所有数都可以表示成nums中若干个数的和。返回最少需要添加的补丁个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>], n = <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>返回1，表示至少需要添加1个数｛2｝，才可以表示1到6之间所有数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">2</span>:</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>], n = <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>返回2，表示至少需要添加两个数｛2，4｝，才可以表示1到20之间所有数。</p>
<p>我们不妨先思考一个简单的问题，如果nums数组为空，那么最少需要多少个数字才能表示1到n之间所有数？相信大家都可以想到一个贪心算法，即按照1、2、4、8…都顺序添加，每次加入都数都比之前所有数的总和大1，直到总和大于n。本题的难点是预先给出了一些数，但这不影响我们的贪心策略：假设nums当前至多可以表示1到m之间的所有数，加入m+1；直到m大于等于n。</p>
<p>变量miss表示[0,n]中我们缺少的最小的和，也就是说nums中元素求和我们已经能得到[0,miss)范围内的数<br>遍历nums数组，如果nums[i] &lt;= miss,那么我们可以将我们能得到的和的范围[0,miss)扩充到[0,miss+nums[i]);如果nums[i] &gt; miss,那么我们将不能连续扩充[0,miss),也就是说[0,miss+nums[i])的一些元素我们不能得到，则这时我们需要patch元素，那么应该patch什么数？我们采用贪心算法，我们patch的元素为miss，因为选择miss可以得到最大的连续区间[0, miss+miss)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化为缺少1</span></span><br><span class="line">    <span class="keyword">int</span> miss = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//统计patch的数量</span></span><br><span class="line">    <span class="keyword">int</span> patch = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">//如果溢出，miss小于0</span></span><br><span class="line">    <span class="keyword">while</span>(miss &gt; <span class="number">0</span> &amp;&amp; miss &lt;= n)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i &lt; nums.length &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">        miss = miss + nums[i];</span><br><span class="line">        i++;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//扩充miss</span></span><br><span class="line">        miss = miss + miss;</span><br><span class="line">        patch++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> patch;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="不构造树的情况下验证先序遍历">不构造树的情况下验证先序遍历</h2><h3 id="题目描述-2">题目描述</h3><p>给出一个字符序列，问该序列是否是一棵合法的二叉树的先序遍历？<br>找到一种不需要构造二叉树的方法。<br>For example：<br>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>是下面这颗二叉树的先序遍历。其中＃代表空节点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">9</span></span><br><span class="line">       /      \</span><br><span class="line">      <span class="number">3</span>       <span class="number">2</span></span><br><span class="line">    /   \   /    \</span><br><span class="line">   <span class="number">4</span>     <span class="number">1</span> <span class="preprocessor">#      <span class="number">6</span></span></span><br><span class="line"> /   \  / \      / \</span><br><span class="line"><span class="preprocessor">#    #  #  #    #   #</span></span><br></pre></td></tr></table></figure></p>
<h3 id="分析解答">分析解答</h3><p>通过观察上图中二叉树我们可以发现，一棵合法的二叉树去掉某个叶子节点后仍是合法的二叉树。在给出的字符序列中，叶子节点有很明显的特征，即叶子节点之后一定紧跟两个空节点＃。通过不断的把number,#,#的子串缩成空节点#(把number,#,#子串替换为#)，如果最后字符序列可以缩短到只有一个字符＃，那它就是我们要找的合法的先序遍历了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span></span>&#123;</span><br><span class="line">    String s = preorder;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.length() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> index = s.indexOf(<span class="string">",#,#"</span>);</span><br><span class="line">      <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> start = index;</span><br><span class="line">      <span class="comment">//找到,#,#前一个节点</span></span><br><span class="line">      <span class="comment">//有可能数字有多位</span></span><br><span class="line">      <span class="keyword">while</span>(start &gt; <span class="number">0</span> &amp;&amp; s.charAt(start-<span class="number">1</span>) != <span class="string">','</span>)&#123;</span><br><span class="line">        start--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(s.charAt(start) == <span class="string">'#'</span>)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      s = s.substring(<span class="number">0</span>,start)+s.substring(index+<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"#"</span>) &amp;&amp; flag) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摆动排序_II">摆动排序 II</h2><p>给出一个整数数组nums，重新排列nums使得nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…<br>Example:<br>nums = [1, 5, 1, 1, 6, 4], 一个可能的答案是[1, 4, 1, 5, 1, 6]<br>数据保证必定有解。</p>
<h2 id="分析解答-1">分析解答</h2><p>本题有一种简单的做法，先快速排序，然后把最小的一半依次放在奇数位上，最大的一半依次放在偶数位上。算法复杂度是快速排序的复杂度O(NlogN)。仔细思考后发现快速排序不是必要的，只需要找到中位数即可。利用快速排序的思想找中位数的期望时间复杂度是O(N)。为了防止相等的数放在一起，需要注意放置的顺序。笔者采用的方法是依nums长度分两种情况：若长度为奇数，把比中位数小的依次放在0,2,4,…位置，比中位数大的依次放在length-2,length-4,…位置；若长度为偶数，把比中位数小的依次放在length-2,length-4,…位置，比中位数大的依次放在1,3,5,…位置。其余位置填充中位数。这样可以保证中位数一定与较小与较大的数相邻（题目保证一定有解）。</p>
<p>排序解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先排序数组，然后将数组的前半部分和后半部分merge起来</span></span><br><span class="line">    <span class="comment">//把更大的一般放到奇数下标中，更小的一半放到偶数下标中</span></span><br><span class="line">    <span class="comment">//比如nums=[1,2,3,4,5,6,7]</span></span><br><span class="line">    <span class="comment">//4 3 2 1</span></span><br><span class="line">    <span class="comment">// 7 6 5 = &gt; 4 7 3 6 2 5 1</span></span><br><span class="line">    <span class="comment">//该种解法只要输入中存在valid answer就能正确找到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        <span class="comment">//排序，分成两部分</span></span><br><span class="line">        Arrays.sort(copy);</span><br><span class="line">        <span class="comment">//left初始时指向中间元素的后一元素</span></span><br><span class="line">        <span class="keyword">int</span> right = nums.length, left = (nums.length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? copy[--left] : copy[--right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="矩阵中的最长上升路径">矩阵中的最长上升路径</h2><h3 id="题目描述-3">题目描述</h3><p>给出一个数字矩阵，寻找一条最长上升路径，每个位置只能向上下左右四个位置移动。<br>Example：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>返回 4，最长上升路径是[1, 2, 6, 9].</p>
<h3 id="分析解答-2">分析解答</h3><p>最直观的做法是穷举每一个数字作为起点，dfs寻找最长上升路径，时间复杂度是指数级别的。仔细思考dfs有些盲目，此题中的最长上升路径很符合bfs的特点（每次向外扩展一层），bfs可以显著降低时间复杂度，朴素的bfs复杂度为O(n^4)，因为在bfs的过程中，每个位置最多会经过k次（k为到这个点对最长上升路径长度，最大可能为n^2）。如果使用动态规划的思路，把到每个位置的最长上升路径长度储存下来，那每个点只会计算一次，可以使复杂度变为O(n^2)。当前位置最长上升路径可以通过周围四个点的最长上升路径而得到。但是这里有个问题就是动态规划的穷举顺序，有两种方法解决，一是通过拓扑排序来确定穷举顺序，因为最长上升路径总是从小到大扩展的；二是通过记忆化搜索实现动态规划，记忆化搜索是搜索和动态规划的结合，在搜索过程中记录已经求解完毕的状态，使得每个状态只需进行一次搜索。在本题中，dp[i][j]记录在(i,j)位置可以得到的最长上升路径，其值通过搜索相邻四个位置的dp值确定；flag[i][j]表示(i,j)位置的解是否已经搜索完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//四个搜索方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> len = dfs(matrix, i, j, row, col, cache);</span><br><span class="line">                max = Math.max(max, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度搜索从[i][j]出发的最长递增路径的长度</span></span><br><span class="line">    <span class="comment">//cache缓存，即备忘录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] cache)</span></span>&#123;</span><br><span class="line">        <span class="comment">//已经搜索过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(cache[i][j] != <span class="number">0</span>) <span class="keyword">return</span> cache[i][j];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//四个方向搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//matrix[x][y] &lt;= matrix[i][j]可以避免使用visited[row][col]数组</span></span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= row || y &lt; <span class="number">0</span> || y &gt;= col || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span> + dfs(matrix, x, y, row, col, cache);</span><br><span class="line">            max = Math.max(len, max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache[i][j] = max;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="岛屿计数2">岛屿计数2</h2><h2 id="Count_of_Smaller_Numbers_After_Self(数组计数)">Count of Smaller Numbers After Self(数组计数)</h2><h3 id="题目描述-4">题目描述</h3><p>给定一个数组nums,返回一个计数数组count，count[i]表示nums中第i个右边有多少个数小于nums[i]<br>Example:<br>nums = [5, 2, 6, 1]<br>输出[2,1,1,0]</p>
<h3 id="分析解答-3">分析解答</h3><p>此题不难给出O(N^2)的算法，先穷举nums中每个位置i，再穷举右边的数计算有多少个小于nums[i]。难点在于利用数据结构进行优化从而降低时间复杂度。线段树（segment tree）和平衡树（Balanced Binary Tree）是两种可以使用的数据结构。</p>
<p>线段树的每个节点表示一段区间，记录这个区间的某些信息，其基本思想是把区间一分为二，二分为四。。。直到不可再分（因此叶子节点的区间只包含一个数），如此可以把任意区间表示成log（区间大小）个子区间的拼接，以降低查询时间复杂度。在本题中，假设nums中的数字范围在0到maxnum之间，那么建树的区间为[0,maxnum]（也就是根节点所表示的区间）。每个节点记录其表示区间内的数字个数。本题涉及两种线段树基本操作：插入和查询。插入操作把nums[i]插入到线段树相应位置，同时对所有经过的区间的sum值进行累加；查询操作需要查询区间[0,nums[i]-1]所包含的数字个数，利用已经建好的线段树把查询区间分割为若干个节点所表示的区间，统计并返回这些节点的sum值之和。</p>
<p>平衡树用途更广，代码复杂度也更高，是一种保持叶子节点深度平衡的二叉搜索树，有多种方法实现，因篇幅有限不再赘述，大家可以自行在网上搜索学习。</p>
<h2 id="翻转游戏（Flip_Game_II）">翻转游戏（Flip Game II）</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&amp;mid=401839317&amp;idx=1&amp;sn=0660926cc1e5edab1b92aa8160fa93e6&amp;scene=21#wechat_redirect" target="_blank" rel="external">详见</a></p>
<p>搜索+回溯：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWin</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] state = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span>)&#123;</span><br><span class="line">        state[i] = <span class="keyword">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        state[i] = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search(state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">boolean</span>[] state)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; state.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//连续加号</span></span><br><span class="line">      <span class="keyword">if</span>(state[i] &amp;&amp; state[i+<span class="number">1</span>])&#123;</span><br><span class="line">        state[i] = <span class="keyword">false</span>;</span><br><span class="line">        state[i+<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//不能继续翻转</span></span><br><span class="line">        <span class="keyword">if</span>(!search(state))&#123;</span><br><span class="line">          state[i] = <span class="keyword">true</span>;</span><br><span class="line">          state[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//能继续翻转，回溯</span></span><br><span class="line">          state[i] = <span class="keyword">true</span>;</span><br><span class="line">          state[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="吹气球">吹气球</h2><h3 id="题目描述-5">题目描述</h3><p>有n个气球，编号为0到n-1，每个气球都有一个分数，存在nums数组中。每次吹气球i可以得到的分数为 nums[left] <em> nums[i] </em> nums[right]，left和right分别表示i气球相邻的两个气球。当i气球被吹爆后，其左右两气球即为相邻。要求吹爆所有气球，得到最多的分数。<br>注释:<br>(1) 你可以假设nums[-1] = nums[n] = 1<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>Example:<br>给出[3, 1, 5, 8]<br>返回167</p>
<p>dp解法：<br>Definition:<br>     dp[i][j]表示吹爆i到j之间的气球所能得到的最大分数</p>
<p>Function:<br>     dp[i][j] = max(dp[i][k-1] + score(k) + dp[k+1][j]) 对于所有k属于{i,j}</p>
<p>Intialize:<br>     dp[i][i] = 0 for each i.</p>
<p>Answer:<br>     dp[1][n]</p>
<h2 id="题目链接">题目链接</h2><p><a href="http://posts.careerengine.us/p/579993895afff74f7f7f9e42" target="_blank" rel="external">题目</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="轴对称">轴对称</h2><h3 id="题目描述">题目描述</h3><p>给定平面上的n个点，问是否存在一条平行于y轴的直线，使得这n个点相对于这条直线对称。</p>
<p><strong>Follow-up</strong><br>是否存在一条直线使得这n个]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Kth Smallest Element in a Sorted Matrix]]></title>
    <link href="http://blog.noobsky.com/2016/10/07/LeetCode-Kth-Smallest-Element-in-a-Sorted-Matrix/"/>
    <id>http://blog.noobsky.com/2016/10/07/LeetCode-Kth-Smallest-Element-in-a-Sorted-Matrix/</id>
    <published>2016-10-07T11:51:14.000Z</published>
    <updated>2016-10-08T08:32:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p><strong>Example:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">9</span>],</span><br><span class="line">   [<span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">   [<span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>]</span><br><span class="line">],</span><br><span class="line">k = <span class="number">8</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">13.</span></span><br></pre></td></tr></table></figure></p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ n2.</p>
<h2 id="解题思路">解题思路</h2><p>每一列、每一行都是有序的。其实这个问题类似k路归并排序。全部行或者全部列就是那k路有序数组。<br>可以利用最小堆。<br>首先利用第一行（或第一列）构造最小堆。然后进行k-1次取出最小堆的堆顶元素，取出堆顶元素之后，将所取堆顶元素所在列的下一元素加入最小堆中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int n = matrix.length;</span></span><br><span class="line">        PriorityQueue&lt;Tuple&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> bound = matrix.length &lt; k ? matrix.length : k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; i++) pq.offer(<span class="keyword">new</span> Tuple(<span class="number">0</span>,i,matrix[<span class="number">0</span>][i]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            Tuple t = pq.poll();</span><br><span class="line">            <span class="comment">//已经是某列的最后一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(t.row == matrix.length-<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> Tuple(t.row+<span class="number">1</span>, t.col, matrix[t.row+<span class="number">1</span>][t.col]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要知道元素对应的行或者列，所以使用Tuple类表示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tuple</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, col, val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.row = row;</span><br><span class="line">        <span class="keyword">this</span>.col = col;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Tuple that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - that.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest eleme]]>
    </summary>
    
      <category term="Binary Search" scheme="http://blog.noobsky.com/tags/Binary-Search/"/>
    
      <category term="Heap" scheme="http://blog.noobsky.com/tags/Heap/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Watch]]></title>
    <link href="http://blog.noobsky.com/2016/10/07/LeetCode-Binary-Watch/"/>
    <id>http://blog.noobsky.com/2016/10/07/LeetCode-Binary-Watch/</id>
    <published>2016-10-07T09:26:43.000Z</published>
    <updated>2016-10-07T09:46:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).</p>
<p>Each LED represents a zero or one, with the least significant bit on the right.<br><img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" alt=""></p>
<p>For example, the above binary watch reads “3:25”.</p>
<p>Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>
<p>Example:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Input</span>: <span class="keyword">n</span> = 1</span><br><span class="line"><span class="keyword">Return</span>: [<span class="string">"1:00"</span>, <span class="string">"2:00"</span>, <span class="string">"4:00"</span>, <span class="string">"8:00"</span>, <span class="string">"0:01"</span>, <span class="string">"0:02"</span>, <span class="string">"0:04"</span>, <span class="string">"0:08"</span>, <span class="string">"0:16"</span>, <span class="string">"0:32"</span>]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The order of output does not matter.</li>
<li>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</li>
<li>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</li>
</ul>
<h2 id="解题思路">解题思路</h2><p>思路特别巧妙，有多少个LEDs亮说明表示的时间中代表的二进制中有多少个比特1。<br>我们可以将时间表示转化为二进制，高四位代表时，低六位代表分钟。时间表示3:25转化为二进制位0011:011001，这样处理之后则问题转化为求时间二进制表示中比特位为1的数量为num的时间表示的全部情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; times = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; h++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; m++)&#123;</span><br><span class="line">                <span class="comment">// if(Integer.bitCount((h&lt;&lt;6) + m) == num)&#123;</span></span><br><span class="line">                <span class="comment">//     times.add(String.format("%d:%02d", h, m));</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">//或者</span></span><br><span class="line">                <span class="keyword">if</span>(Integer.bitCount(h)+Integer.bitCount(m) == num)&#123;</span><br><span class="line">                    times.add(String.format(<span class="string">"%d:%02d"</span>, h, m));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP]]></title>
    <link href="http://blog.noobsky.com/2016/10/07/HTTP/"/>
    <id>http://blog.noobsky.com/2016/10/07/HTTP/</id>
    <published>2016-10-07T02:30:19.000Z</published>
    <updated>2016-10-07T07:51:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="网络基础TCP/IP">网络基础TCP/IP</h2><h3 id="TCP/IP的分层管理">TCP/IP的分层管理</h3><p>TCP/IP协议族重要的一点就是分层。分为以下四层：应用层、传输层、网络层、数据链路层。</p>
<p><strong>应用层</strong><br>应用层决定了向用户提供应用服务时通信的活动</p>
<p>应用服务包括FTP、DNS、HTTP等</p>
<p><strong>传输层</strong></p>
<p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。<br>传输层协议包括TCP（传输控制协议）和UDP（用户数据报协议）</p>
<p><strong>网络层</strong><br>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。</p>
<p>网络层所起的作用就是在众多的选项内选择一条传输路线。</p>
<p><strong>链路层</strong><br>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p>
<h3 id="TCP/IP通信传输流">TCP/IP通信传输流</h3><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p>以HTTP举例来说：<br>首先作为发送端的客户端在应用层（HTTP协议）发送一个想看某个Web页面的HTTP请求。</p>
<p>接着为了传输方便，在传输层（TCP协议）把从应用层收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号即端口号后转发给网络层。</p>
<p>在网络层(IP协议)，增加作为通信目的地的MAC地址后转发给链路层。</p>
<p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客服端发送过来的HTTP请求。发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，没经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装。</p>
<h3 id="与HTTP关系密切的协议：IP、TCP和DNS">与HTTP关系密切的协议：IP、TCP和DNS</h3><h4 id="负责传输的IP协议">负责传输的IP协议</h4><p>IP协议位于网络层。作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要条件是IP地址和MAC地址。</p>
<p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变，但MAC地址一般不变。</p>
<p><strong>利用ARP协议获取MAC地址进行通信</strong></p>
<p>IP间的通信依赖MAC地址。网络上，通信双方在同一局域网内的情况很少，通常经过多台计算机和网络设备中转才能连接对方。而在中转时，利用MAC地址搜索下一个中转目标。利用ARP协议（地址解析协议）可以根据通信方的IP地址获取对应的MAC地址。</p>
<h4 id="确保可靠性的TCP协议">确保可靠性的TCP协议</h4><p>TCP位于传输层，提供可靠的字节流服务。<br>字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。</p>
<p><strong>确保数据能到达目标</strong></p>
<p>为了准确无误地将数据送达目标，TCP协议采用了三次握手策略。发送端首先发送一个带有SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表握手结束。</p>
<h3 id="负责域名解析的DNS服务">负责域名解析的DNS服务</h3><p>DNS服务位于应用层，提供域名到IP地址之间的解析服务。</p>
<h2 id="简单的HTTP协议">简单的HTTP协议</h2><h3 id="HTTP协议用于客户端和服务端之间的通信">HTTP协议用于客户端和服务端之间的通信</h3><p>请求访问的文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。</p>
<h3 id="通过请求和响应交换达成通信">通过请求和响应交换达成通信</h3><h3 id="HTTP是不保存状态的协议">HTTP是不保存状态的协议</h3><p>HTTP是无状态协议，也就说HTTP协议对于发送过的请求或响应都不做持久化处理。</p>
<p>HTTP为了实现保存状态的功能引入了Cookie技术。</p>
<h3 id="请求URI定位资源">请求URI定位资源</h3><h3 id="告知服务器意图的HTTP方法">告知服务器意图的HTTP方法</h3><ul>
<li><p>GET：获取资源</p>
</li>
<li><p>POST：传输实体主体</p>
</li>
<li><p>PUT：传输文件</p>
</li>
<li><p>HEAD：获取报文首部</p>
</li>
<li><p>DELETE：删除文件</p>
</li>
<li><p>OPTIONS：询问支持的方法</p>
</li>
<li><p>TRACE：追踪路径</p>
</li>
<li><p>CONNECT：要求用隧道协议连接代理</p>
</li>
</ul>
<h3 id="持久连接节省通信量">持久连接节省通信量</h3><p><strong>持久连接</strong></p>
<p>持久连接（HTTP Persistent Connections也称为HTTP keep-alive或者HTTP connection reuse）的方法。持久连接的特点是只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p>
<p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>
<p><strong>管线化</strong><br>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。以前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p>
<p>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应。</p>
<h3 id="使用Cookie的状态管理">使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p>
<p>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
<p>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<h2 id="HTTP报文">HTTP报文</h2><h3 id="请求报文">请求报文</h3><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。报文的一般格式如下：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;request-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;blank line&gt;</span><br><span class="line"></span><br><span class="line"><span class="annotation">[&lt;request-body&gt;]</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>请求行</li>
</ul>
<p>请求行由请求方法、URL字段和HTTP协议版本3个字段组成，由空格分隔。例如：GET /index.html HTTP/1.1。<br>HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p>
<ul>
<li><p>请求头部<br>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：<br>User-Agent: 产生请求的浏览器类型<br>Accept: 客户端可识别的内容类型列表。<br>Host: 请求主机名，允许多个域名同处于一个IP地址，即虚拟主机。</p>
</li>
<li><p>空行<br>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
</li>
<li><p>请求数据</p>
</li>
</ul>
<p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>
<h3 id="响应报文">响应报文</h3><p>HTTP响应也由三个部分组成，分别是：状态行、消息报头、空行和响应正文。格式如下：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;status-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;blank line&gt;</span><br><span class="line"></span><br><span class="line"><span class="annotation">[&lt;response-body&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p>
<p>状态行格式如下：</p>
<p>HTTP-Version Status-Code Reason-Phrase CRLF</p>
<p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p>
<p>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。</p>
<p>常见状态代码、状态描述的说明如下。</p>
<ul>
<li>200 OK：客户端请求成功。</li>
<li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li>
<li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li>
<li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li>
<li>500 Internal Server Error：服务器发生不可预期的错误。</li>
<li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<h2 id="编码提升传输速率">编码提升传输速率</h2><h3 id="压缩传输的内容编码">压缩传输的内容编码</h3><h3 id="分割发送的分块传输编码">分割发送的分块传输编码</h3><h2 id="HTTP状态码">HTTP状态码</h2><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">类别</th>
<th style="text-align:left">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">Informational（信息性状态码）</td>
<td style="text-align:left">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">Success （成功状态码）</td>
<td style="text-align:left">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">Redirection（重定向状态码）</td>
<td style="text-align:left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">Client Error（客户端错误状态码）</td>
<td style="text-align:left">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">Server Error（服务器错误状态码）</td>
<td style="text-align:left">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h2 id="确保Web安全的HTTPS">确保Web安全的HTTPS</h2><h3 id="HTTP的缺点">HTTP的缺点</h3><ul>
<li>通信使用明文（不加密），内容可能会被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭篡改</li>
</ul>
<h3 id="HTTP+加密+认证+完整性保护=HTTPS">HTTP+加密+认证+完整性保护=HTTPS</h3><h4 id="HTTP加上加密处理和认证以及完整性保护后即是HTTPS">HTTP加上加密处理和认证以及完整性保护后即是HTTPS</h4><h4 id="HTTPS是身披SSL外壳的HTTP">HTTPS是身披SSL外壳的HTTP</h4><p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。</p>
<p>通常HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。</p>
<h4 id="相互交换密钥的公开密钥加密技术">相互交换密钥的公开密钥加密技术</h4><ul>
<li>共享密钥加密（对称加密）的困境<br>加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也叫对称密钥加密。</li>
</ul>
<p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？因为只要拿到密钥任何人都能破解密码。</p>
<ul>
<li>使用两把密钥的公开密钥加密（非对称加密）</li>
</ul>
<p>公开密钥加密方式可以很好地解决共享密钥加密的困难。<br>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。私钥需要自行进行保护！公钥可以随便分享。</p>
<p>同时，生成的这个“私钥-公钥”对还有个强大的功能就是，使用私钥加密的信息，只能由该私钥对应的公钥才能解密，使用公钥加密的信息，只能由该公钥对应的私钥才能解密！</p>
<ul>
<li>HTTPS采用混合加密机制</li>
</ul>
<p>HTTPS采用共享密钥（对称）加密和公开密钥加密（非对称）两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p>
<p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立的通信交换报文阶段则使用共享密钥加密方式。</p>
<h4 id="证明公开密钥正确性的证书">证明公开密钥正确性的证书</h4><p>公开密钥加密方式存在的问题是无法证明公开密钥本身就是货真价实的公开密钥。公开密钥传输途中，可能被攻击者替换掉。</p>
<p>为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。</p>
<p>首先,服务器的 运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构 在判明提出申请者的身份之后,会对已申请的公开密钥做数字签名,然 后分配这个已签名的公开密钥,并将该公开密钥放入公钥证书后绑定在一起。</p>
<p>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户 端,以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接 称为证书。</p>
<p>接到证书的客户端可使用数字证书认证机构的公开密钥,对那张证 书上的数字签名进行验证,一旦验证通过,客户端便可明确两件事: 一,认证服务器的公开密钥的是真实有效的数字证书认证机构。二,服务器的公开密钥是值得信赖的。</p>
<p>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式 时,如何安全转交是一件很困难的事,因此,多数浏览器开发商发布版 本时,会事先在内部植入常用认证机关的公开密钥。</p>
<p><img src="http://7xonwi.com1.z0.glb.clouddn.com/https.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="网络基础TCP/IP">网络基础TCP/IP</h2><h3 id="TCP/IP的分层管理">TCP/IP的分层管理</h3><p>TCP/IP协议族重要的一点就是分层。分为以下四层：应用层、传输层、网络层、数据链路层。</p>
<p><strong>应用层</]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 8 新特性]]></title>
    <link href="http://blog.noobsky.com/2016/10/06/Java-8-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://blog.noobsky.com/2016/10/06/Java-8-新特性/</id>
    <published>2016-10-06T09:33:30.000Z</published>
    <updated>2016-10-06T14:38:40.000Z</updated>
    <content type="html"><![CDATA[<p>Java 8是Java 5（2004年发行）以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。本文会一一简要介绍。</p>
<h2 id="Java语言新特性">Java语言新特性</h2><h3 id="Lambda表达式和Functional接口">Lambda表达式和Functional接口</h3><p>Lambda表达式可以理解为简洁地传递匿名函数的一种方式（将函数作为一个方法的参数）。它没有名称，但它可以有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。写过函数式编程语言的程序员对这个概念一定并不陌生。</p>
<p>Java中Lambda表达式由逗号分隔的参数列表、-&gt;符号和函数体三部分组成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; System.out.println(e) );</span><br></pre></td></tr></table></figure>
<p>请注意参数e的类型是由编译器推测出来的。同时，你也可以通过把参数类型与参数包括在括号中的形式直接给出参数的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( ( String e ) -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure></p>
<p>在某些情况下lambda的函数体会更加复杂，这时可以把函数体放到在一对花括号中，就像在Java中定义普通函数一样。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; &#123;</span><br><span class="line">    System.out.print(e);</span><br><span class="line">    System.out.print(<span class="string">","</span>);</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<p>Lambda可以引用类的成员变量与局部变量（如果这些变量不是final的话，它们会被隐含的转为final，这样效率更高）。例如，下面两个代码片段是等价的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach(</span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach(</span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure></p>
<p>Lambda可能会返回一个值。返回值的类型也是由编译器推测出来的。如果lambda的函数体只有一行的话，那么没有必要显式使用return语句。下面两个代码片段是等价的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> result = e1.compareTo( e2 );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<p>如果表达式没有参数，你扔可以提供一对空的小括号，如同不含参数的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#125; doWork();</span><br></pre></td></tr></table></figure></p>
<p>语言设计者投入了大量精力来思考如何使现有的函数友好地支持lambda。最终采取的方法是：增加函数式接口的概念。对于只包含一个抽象方法的接口(除了隐含的Object对象的公共方法)，可以通过lambda表达式来创建该接口的对象。这种接口被称为函数式接口。像这样的接口，可以被隐式转换为lambda表达式。java.lang.Runnable与java.util.concurrent.Callable是函数式接口最典型的两个例子。在实际使用过程中，函数式接口是容易出错的：如有某个人在接口定义中增加了另一个方法，这时，这个接口就不再是函数式的了，并且编译过程也会失败。为了克服函数式接口的这种脆弱性并且能够明确声明接口作为函数式接口的意图，Java 8增加了一种特殊的注解@FunctionalInterface（Java 8中所有类库的已有接口都添加了@FunctionalInterface注解）。让我们看一下这种函数式接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要记住的一件事是：默认方法与静态方法并不影响函数式接口的契约，可以任意使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionalDefaultMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口的默认方法与静态方法">接口的默认方法与静态方法</h3><p>如果某个接口比如Collection添加了新方法，例如forEach，那么每个实现了Collection接口的自定义类就必须都实现该方法。这在Java中是完全无法接受的。</p>
<p>Java设计者们通过允许接口包含带有具体实现的方法（称为默认方法）来解决这个问题，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"Jaye"</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认方法终结了以前一种经典模式，即提供一个接口，以及一个实现接口的大多数或全部方法的抽象类，例如Collection/AbstractCollection，现在直接在接口中实现即可。</p>
<p>如果一个接口中定义了一个默认方法，而另外一个父类或者接口中又定义了一个同名的方法，选择方法的规则如下：</p>
<ol>
<li>选择父类中的方法。如果一个父类提供了具体的实现方法，那么接口中具有相同名称和参数的默认方法会被忽略。</li>
<li>接口冲突。如果一个父接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数类型的方法（不管该方法是否是默认方法），那么你必须通过覆盖该方法来解决冲突。</li>
</ol>
<p>某个类继承了某个父类并实现了某个接口，父类和接口有一个同名的方法，此时，只有父类中的方法会起作用，这是“类优先”规则。</p>
<p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。例如：</p>
<h3 id="方法引用">方法引用</h3><p>如果想传递给其他代码的操作已经有实现的方法，可以使用方法引用。</p>
<p>如果你希望不区分大小写地对字符串进行排序，那么可以传入方法引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings, String::compareToIgnoreCase)</span><br></pre></td></tr></table></figure></p>
<p>::操作符将方法名和对象或类的名字分隔开来。以下是三种主要的使用情况：</p>
<ul>
<li>对象::实例方法</li>
<li>类::静态方法</li>
<li>类::实例方法</li>
</ul>
<p>方法引用等同于提供方法参数的lambda表达式。<br>System.out::println等同于System.out.println(x)。相似的，Math::pow等同于(x, y) -&gt; Math.pow(x, y)。</p>
<p>在Arrays.sort(strings, String::compareToIgnoreCase)中第一个参数会成为执行方法的对象。例如：String::compareToIgnoreCase等同于(x, y) -&gt; x.compareToIgnoreCase(y)</p>
<p>还可以捕获方法中的this参数。例如this::equals就等同于x -&gt; this.equals(x)。也可以使用super对象。super::实例方法会使用this作为执行方法的对象，并调用父类中指定方法。</p>
<h3 id="重复注解">重复注解</h3><h3 id="更好的类型推测机制">更好的类型推测机制</h3><h3 id="扩展注解的支持">扩展注解的支持</h3><h2 id="Java编译器的新特性">Java编译器的新特性</h2><h3 id="参数名字">参数名字</h3><p>在Java 8中把这个获取参数名字的功能添加到语言层面（通过反射API与Parameter.getName()方法）与字节码文件（通过新版的javac的–parameters选项）中。</p>
<h2 id="Java类库的新特性">Java类库的新特性</h2><h3 id="Optional">Optional</h3><h3 id="Stream">Stream</h3><h3 id="Date/Time_API">Date/Time API</h3><h3 id="JavaScript引擎Nashorn">JavaScript引擎Nashorn</h3><h3 id="Base64">Base64</h3><h3 id="并行数组">并行数组</h3><h3 id="并发">并发</h3><h2 id="新的Java工具">新的Java工具</h2><p>Java 8带来了一些新的命令行工具。</p>
<h3 id="Nashorn引擎：jjs">Nashorn引擎：jjs</h3><h3 id="类依赖分析器jdeps">类依赖分析器jdeps</h3><h2 id="JVM的新特性">JVM的新特性</h2><p>PermGen空间被移除了，取而代之的是Metaspace（JEP 122）。JVM选项-XX:PermSize与-XX:MaxPermSize分别被-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。</p>
<h2 id="参考资料">参考资料</h2><p><a href="http://colobu.com/2014/10/28/secrets-of-java-8-functional-interface/" target="_blank" rel="external">Java 8函数式接口functional interface的秘密</a><br><a href="http://www.importnew.com/11908.html" target="_blank" rel="external">Java 8新特性终极指南</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java 8是Java 5（2004年发行）以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。本文会一一简要介绍。</p>
<h2 id="Java语言新特性">Java语言新特性</h2><h3 id="Lambda表达式和]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 8 CompletableFuture: 组合式异步编程]]></title>
    <link href="http://blog.noobsky.com/2016/10/06/Java-8-CompletableFuture-%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.noobsky.com/2016/10/06/Java-8-CompletableFuture-组合式异步编程/</id>
    <published>2016-10-06T08:52:54.000Z</published>
    <updated>2016-10-06T09:16:19.000Z</updated>
    <content type="html"><![CDATA[<p>Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。</p>
<p>虽然Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无畏的CPU资源，而且也不能及时得到计算结果。为什么不能使用观察者设计模式当计算结果完成及时通知监听者呢？</p>
<p>Nodejs采用回调的方式实现异步编程。Netty扩展了Java的Future接口提供了addListener等多个扩展方法。</p>
<p>Java 8中，新增加了一个包含50个方法左右的类：CompletableFuture，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p>
<p><a href="http://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="external"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。</p>
<p>虽然Future以及相关使用方法提供了异步执行任务的能]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8之杂项改进]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8%E4%B9%8B%E6%9D%82%E9%A1%B9%E6%94%B9%E8%BF%9B/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8之杂项改进/</id>
    <published>2016-10-05T13:48:48.000Z</published>
    <updated>2016-10-06T02:03:14.000Z</updated>
    <content type="html"><![CDATA[<p>要点包括：</p>
<ul>
<li>用分隔符连接字符串的至简方法</li>
<li>Integer类现在支持无符号数学运算</li>
<li>Math类现在有了检测整数是否溢出的方法</li>
<li>使用Math.floorMod(x, n)代替x % n来处理x可能是负数的情况</li>
<li>Collocation(removeIf)和List(replaceAll, sort)中提供了很多新的方法</li>
<li>Files.lines可以延迟读取一个包含文件行的流</li>
<li>Files.list可以延迟列举目录下的项目，而且Files.walk可以递归遍历它们</li>
<li>对Base64提供了官方支持</li>
<li>Objects类中提供了对null参数的检查</li>
</ul>
<h2 id="字符串">字符串</h2><p>将多个字符串通过分隔符组合起来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String joined = String.join(<span class="string">"/"</span>, <span class="string">"usr"</span>, <span class="string">"local"</span>, <span class="string">"bin"</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="数字类">数字类</h2><p>7种数字类型的包装类提供了一个BYTES字段，以byte为单位来表示该类型的长度</p>
<p>8种原始类型包装类提供了静态的hashCode方法</p>
<p>Short、Integer、Long、Float和Double提供了sum、max和min，用来在流操作中作为聚合函数使用<br>Boolean包含了静态方法logicalAnd、logicalOr、logicalXor</p>
<p>Integer类实现了支持无符号数学运算。<br>。。。</p>
<h2 id="新的数学函数">新的数学函数</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>要点包括：</p>
<ul>
<li>用分隔符连接字符串的至简方法</li>
<li>Integer类现在支持无符号数学运算</li>
<li>Math类现在有了检测整数是否溢出的方法</li>
<li>使用Math.floorMod(x, n)代替x % n来处理x可能是]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8之并发增强]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%A2%9E%E5%BC%BA/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8之并发增强/</id>
    <published>2016-10-05T13:03:08.000Z</published>
    <updated>2016-10-05T13:48:43.000Z</updated>
    <content type="html"><![CDATA[<p>要点包括：</p>
<ul>
<li>使用updateAndGet/accumulateAndGet方法可以更容易地更新原子变量</li>
<li>在激烈得竞争环境下，LongAccumulator/DoubleAccumulator比AtomicLong/AtomicDouble效率更高</li>
<li>使用compute和merge方法可以更容易地更新ConcurrentHashMap中的元素项</li>
<li>ConcurrentHashMap提供了对键、值、键值对及元素项的各类操作，例如search、reduce和forEach</li>
<li>集合视图允许你将ConcurrentHashMap作为一个Set来使用</li>
<li>Arrays类提供了排序、填充及前缀操作的并行方法</li>
<li>完善的Future类允许你创建异步的操作</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>要点包括：</p>
<ul>
<li>使用updateAndGet/accumulateAndGet方法可以更容易地更新原子变量</li>
<li>在激烈得竞争环境下，LongAccumulator/DoubleAccumulator比AtomicLong/AtomicDo]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8之新的日期和时间API]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8%E4%B9%8B%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8之新的日期和时间API/</id>
    <published>2016-10-05T12:31:58.000Z</published>
    <updated>2016-10-05T12:50:52.000Z</updated>
    <content type="html"><![CDATA[<p>要点包括：</p>
<ul>
<li>所有java.time对象都是不可变的</li>
<li>一个瞬间(Instant)是时间线上的一个点(与Date类似)</li>
<li>在Java时间中，每天都是86400秒（即没有闰秒）</li>
<li>持续时间(Duration)是两个瞬间之间的时间</li>
<li>LocalDateTime没有时区信息</li>
<li>TemporalAdjuster的方法可以处理常用的日历计算，例如找到某个月的第一个星期二</li>
<li>ZonedDateTime是指时区中的某一个时间点(类似于Gregorian Calendar)</li>
<li>当处理带时区的时间时，请使用时段(Period)，而非Duration，以便将夏令时的变化考虑在内</li>
<li>使用DateTimeFormatter来格式化和解析日期和时间</li>
</ul>
<h2 id="时间线">时间线</h2><h2 id="本地日期">本地日期</h2><h2 id="日期校正器">日期校正器</h2><h2 id="本地时间">本地时间</h2><h2 id="带时区的时间">带时区的时间</h2><h2 id="格式化和解析">格式化和解析</h2><h2 id="与遗留代码互操作">与遗留代码互操作</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>要点包括：</p>
<ul>
<li>所有java.time对象都是不可变的</li>
<li>一个瞬间(Instant)是时间线上的一个点(与Date类似)</li>
<li>在Java时间中，每天都是86400秒（即没有闰秒）</li>
<li>持续时间(Duratio]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8之StreamAPI]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8%E4%B9%8BStreamAPI/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8之StreamAPI/</id>
    <published>2016-10-05T08:46:46.000Z</published>
    <updated>2016-10-07T07:52:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="从迭代器到Stream操作">从迭代器到Stream操作</h2><p>统计长单词的数量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String w : words)&#123;</span><br><span class="line">  <span class="keyword">if</span>(w.length() &gt; <span class="number">12</span>) count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java8之前的此种写法很难被并行计算。这也是Java8引入大量操作符的原因。在Java8中，实现相同功能的操作如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.stream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure></p>
<p>stream方法会为单词列表生成一个Stream。filter方法会返回另一个只包含单词长度大于12的Stream。count方法会将Stream化简为一个结果。</p>
<p>Stream与集合的区别：</p>
<ul>
<li>Stream自己不会存储元素。元素可能被存储在底层的集合中，或者根据需要产生出来。</li>
<li>Stream操作符不会改变源对象。相反，它们会返回一个持有结果的新Stream。</li>
<li>Stream操作符可能是延迟执行的。这意味着它们会等到需要结果的时候才执行。</li>
</ul>
<p>当你使用Stream时，你会通过三个阶段来建立一个操作流水线。</p>
<ol>
<li>创建一个Stream</li>
<li>在一个或多个步骤中，指定将初始Stream转换为另一个Stream的中间操作</li>
<li>使用一个终止操作来产生一个结果。该操作会强制它之前的延迟操作立即执行。</li>
</ol>
<h2 id="创建Stream">创建Stream</h2><p>通过Java8在Collection接口中新添加的stream方法，可以将任何集合转化为一个Stream。如果你面对的是一个数组，可以用静态的Stream.of方法将它转化为一个Stream。</p>
<h2 id="filter、map和flatMap方法">filter、map和flatMap方法</h2><p>filter是过滤器转换，产生一个包含符合某个特定条件的所有元素的新的流</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="从迭代器到Stream操作">从迭代器到Stream操作</h2><p>统计长单词的数量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line]]>
    </summary>
    
      <category term="Stream API" scheme="http://blog.noobsky.com/tags/Stream-API/"/>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8 之lambda表达式]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8-%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8-之lambda表达式/</id>
    <published>2016-10-05T04:11:48.000Z</published>
    <updated>2016-10-05T08:45:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="lambda表达式的语法">lambda表达式的语法</h2><p>检查某个字符串的长度是否小于另一个字符串长度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line">  -&gt; Integer.compare(first.length(), second.length())</span><br></pre></td></tr></table></figure></p>
<p>Java中lambda表达式的格式：参数、箭头 -&gt;，以及一个表达式。如果负责计算的代码无法用一个表达式表示，那么可以用编写方法的方式来编写：即用{}包裹代码并明确使用return语句，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果表达式没有参数，你扔可以提供一对空的小括号，如同不含参数的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#125; doWork();</span><br></pre></td></tr></table></figure></p>
<p>如果lambda表达式的参数类型可以被推导，那么就可以省略它们的类型，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp</span><br><span class="line">  = (first, second)</span><br><span class="line">    -&gt; Integer.compare(first.length(), second.length());</span><br></pre></td></tr></table></figure></p>
<p>这里编译器会推导出first和second必须是字符串，因为lambda表达式被赋值给了一个字符串比较器</p>
<p>如果某个方法只含有一个参数，并且该参数的类型可以被推导出来，你甚至可以省略小括号：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventHandler&lt;ActionEvent&gt; listener = event -&gt;</span><br><span class="line">  System.out.println(<span class="string">"Thanks for clicking"</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以像对待方法参数一样向lambda表达式的参数添加注解或者final修饰符，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">final</span> String name) -&gt; ...</span><br><span class="line">(<span class="annotation">@NonNull</span> String name) -&gt; ...</span><br></pre></td></tr></table></figure></p>
<p>不需要为一个lambda表达式执行返回类型，它总是会从上下文中被推导出来，表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; Integer.compare(first.length(), second.length())</span><br></pre></td></tr></table></figure></p>
<p>可以被使用在期望结果类型为int 的上下文中。</p>
<p>在lambda表达式中，只在某些分支中返回值（其他分支没有返回值）是不合法的。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> x) -&gt; &#123;<span class="keyword">if</span>(x &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>是不合法的。</p>
<h2 id="函数式接口">函数式接口</h2><p>java中有许多已有的接口都需要封装代码块，例如Runnable或者Comparator。lambda表达式与这些接口是向后兼容的。</p>
<p>对于只包含一个抽象方法的接口，可以通过lambda表达式来创建该接口的对象。这种接口被称为函数式接口。</p>
<p>函数式接口转换,lambda表达式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words,</span><br><span class="line">  (first,second) -&gt; Integer.compare(first.length(), second.length()));</span><br></pre></td></tr></table></figure></p>
<p>Arrays.sort方法会接收一个实现了Comparator<string>接口的类的实例。调用该对象的compare方法会执行lambda表达式中的代码。这些对象和类的管理完全依赖于如何实现，因此比传统的内部类效率更高。</string></p>
<p>事实上，函数式接口的转换是你在Java中使用lambda表达式能做的唯一一件事。</p>
<p>当一个lambda表达式被转换成一个函数式接口的实例时，请注意处理检查期异常。如果lambda表达式中可能会抛出一个检查期异常，那么该异常需要在目标接口的抽象方法中进行声明。</p>
<h2 id="方法引用">方法引用</h2><p>如果想传递给其他代码的操作已经有实现的方法，可以使用方法引用。</p>
<p>如果你希望不区分大小写地对字符串进行排序，那么可以传入方法引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings, String::compareToIgnoreCase)</span><br></pre></td></tr></table></figure></p>
<p>::操作符将方法名和对象或类的名字分隔开来。以下是三种主要的使用情况：</p>
<ul>
<li>对象::实例方法</li>
<li>类::静态方法</li>
<li>类::实例方法</li>
</ul>
<p>方法引用等同于提供方法参数的lambda表达式。<br>System.out::println等同于System.out.println(x)。相似的，Math::pow等同于(x, y) -&gt; Math.pow(x, y)。</p>
<p>在Arrays.sort(strings, String::compareToIgnoreCase)中第一个参数会成为执行方法的对象。例如：String::compareToIgnoreCase等同于(x, y) -&gt; x.compareToIgnoreCase(y)</p>
<p>还可以捕获方法中的this参数。例如this::equals就等同于x -&gt; this.equals(x)。也可以使用super对象。super::实例方法会使用this作为执行方法的对象，并调用父类中指定方法。</p>
<h2 id="构造器引用">构造器引用</h2><p>构造器引用类似方法引用，不同的是在构造器引用中方法名是new。如Button::new表示Button类的构造器引用。</p>
<p>可以使用数组类型来编写构造器引用。如int[]::new是一个含有一个参数的构造器引用，这个参数就是数组的长度。它等同于lambda表达式x -&gt; new int[x]。</p>
<h2 id="变量作用域">变量作用域</h2><p>lambda表达式的闭合方法或类中访问其他的变量，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">  Runnable r = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++ ) &#123;</span><br><span class="line">      System.out.println(text);</span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设有以下调用：<br>repeatMessage(“Hello”, 1000);//在另一个线程中打印Hello一千次</p>
<p>注意看lambda表达式中的变量count和text，它们并没有在lambda表达式中被定义，而是方法repeatMessage的参数变量。lambda表达式可能会在repeatMessage返回之后才运行，此时参数变量已经消失了。</p>
<p>lambda表达式包含三个部分：</p>
<ul>
<li>一段代码</li>
<li>参数</li>
<li>自由变量的值，这里的“自由”指的是那些不是参数并且没有在代码中定义的变量。</li>
</ul>
<p>上面的text和count就是lambda表达式的自由变量。数据结构表示lambda表达式必须存储这两个变量的值。其实含有自由变量的代码块被称之为”闭包”。</p>
<p>Java的lambda表达式中，被引用的变量的值不可以被更改。例如，下面表达式不合法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">  Runnable r = () -&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      count--;</span><br><span class="line">      System.out.println(text);</span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>做出这个约束的原因是更改lambda表达式中的变量不是线程安全的。</p>
<h2 id="默认方法">默认方法</h2><p>Java8允许接口包含带有具体实现的方法(称为默认方法)。</p>
<p>如果一个接口中定义了一个默认方法，而另外一个父类或者接口中又定义了一个同名的方法，选择方法的规则如下：</p>
<ol>
<li>选择父类中的方法。如果一个父类提供了具体的实现方法，那么接口中具有相同名称和参数的默认方法会被忽略。</li>
<li>接口冲突。如果一个父接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数类型的方法（不管该方法是否是默认方法），那么你必须通过覆盖该方法来解决冲突。</li>
</ol>
<p>某个类继承了某个父类并实现了某个接口，父类和接口有一个同名的方法，此时，只有父类中的方法会起作用，这是“类优先”规则。</p>
<h2 id="接口中的静态方法">接口中的静态方法</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="lambda表达式的语法">lambda表达式的语法</h2><p>检查某个字符串的长度是否小于另一个字符串长度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span]]>
    </summary>
    
      <category term="lambda" scheme="http://blog.noobsky.com/tags/lambda/"/>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之数据库]]></title>
    <link href="http://blog.noobsky.com/2016/10/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://blog.noobsky.com/2016/10/02/Redis设计与实现之数据库/</id>
    <published>2016-10-02T13:18:54.000Z</published>
    <updated>2016-10-02T16:12:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="服务器中的数据库">服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">  redisDb *db;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//服务器的数据库数量</span></span><br><span class="line">  int dbnum;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dbnum属性的值有服务器的database选项决定，默认情况下，该选项的值为16，所以redis服务器默认会创建19个数据库。</p>
<h2 id="切换数据库">切换数据库</h2><p>每个Redis客户端都有自己的目标数据库，每当客服端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。</p>
<p>默认情况，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p>
<p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">//记录客户端当前正在使用的数据库</span></span><br><span class="line">  redisDb *db;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;redisClient</span><br></pre></td></tr></table></figure></p>
<p>通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能–这就是SELECT命令的实现原理。</p>
<h2 id="数据库键空间">数据库键空间</h2><p>Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">  dict *dict;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键也就是数据库的键，每个键都是一个字符串对象</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li>
</ul>
<h3 id="添加新键">添加新键</h3><p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</p>
<h3 id="删除键">删除键</h3><h3 id="更新键">更新键</h3><h3 id="对键取值">对键取值</h3><h3 id="其他键空间操作">其他键空间操作</h3><h2 id="设置键的生存时间或过期时间">设置键的生存时间或过期时间</h2><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live, TTL）,在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p>
<p>还可通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间。</p>
<p>TTL命令和PTT命令返回键的剩余生存时间。</p>
<h3 id="设置过期时间">设置过期时间</h3><ul>
<li>EXPIRE <key> <ttl> 生存时间为ttl秒</ttl></key></li>
<li>PEXPIRE <key> <ttl> 生存时间为ttl毫秒</ttl></key></li>
<li>EXPIREAT <key> <timestamp> 过期时间为timestamp所指定的秒数时间戳</timestamp></key></li>
<li>PEXPIREAT <key> <timestamp> 过期时间为timestamp所指定的毫秒数时间戳</timestamp></key></li>
</ul>
<p>实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的。</p>
<h3 id="保存过期时间">保存过期时间</h3><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）</li>
<li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间（毫秒精度的时间戳）</li>
</ul>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">  dict *expires</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移除过期时间">移除过期时间</h3><p>PERSIST命令可以移除一个键的过期时间</p>
<p>该命令会在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p>
<h3 id="计算并返回剩余生存时间">计算并返回剩余生存时间</h3><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间</p>
<h3 id="过期键的判定">过期键的判定</h3><ul>
<li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间</li>
<li>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期</li>
</ul>
<h2 id="过期键删除策略">过期键删除策略</h2><h3 id="定时删除">定时删除</h3><p>在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</p>
<p>该策略对内存友好，可以保证过期键尽可能快地被删除，并释放过期键所占用的内存</p>
<p>缺点是对CPU时间是不友好的，在过期键多时删除过期键的行为可能会占用相当一部分CPU时间，会对服务器的响应时间和吞吐量造成影响。</p>
<p>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式–无序链表，查找时间复杂度为O(n)，不能高效地处理大量时间事件。</p>
<h3 id="惰性删除">惰性删除</h3><p>放任键过期不管，但每次从键空间获取键时，都检查取得的键是否过期，如果过期，则删除；如果没有过期，就返回该键。</p>
<p>对CPU友好，对内存不友好，内存泄漏</p>
<h3 id="定期删除">定期删除</h3><ul>
<li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li>
<li>惰性删除浪费太多内存，有内存泄漏的危险</li>
</ul>
<p>定期删除策略是前两种策略的一种整合和折中：</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
<li>通过定期删除过期键有效地减少了因为过期键而带来的内存浪费</li>
</ul>
<p>合理设置删除操作的执行时长和执行频率</p>
<h2 id="Redis的过期键删除策略">Redis的过期键删除策略</h2><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>
<h3 id="生成RDB文件">生成RDB文件</h3><p>执行SAVE命令或者BGSAVE命令时，程序会对数据库中的键进行检查，忽略已经过期的键</p>
<h3 id="载入RDB文件">载入RDB文件</h3><ul>
<li>服务器是主服务器时，载入RDB文件时，忽略过期的键</li>
<li>从服务器，载入RDB文件时，不论是否过期都会被载入数据库中</li>
</ul>
<h3 id="AOF文件写入">AOF文件写入</h3><p>键过期，但没有被惰性删除或者定期删除，那么AOF文件没有影响<br>当过期键被惰性删除或者定期删除时，程序会向AOF文件追加一条DEL命令</p>
<h3 id="AOF重写">AOF重写</h3><p>过期的键不会被保存到重写后的AOF中</p>
<h3 id="复制">复制</h3><h2 id="数据库通知">数据库通知</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="服务器中的数据库">服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：<br><f]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之对象]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之对象/</id>
    <published>2016-09-30T12:56:57.000Z</published>
    <updated>2016-10-02T13:17:54.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。</p>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<p>通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</p>
<p>除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制：当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p>
<p>最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。</p>
<h2 id="对象的类型与编码">对象的类型与编码</h2><p>Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> \*ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<h3 id="类型">类型</h3><p>对象的type属性记录了对象的类型，这个属性可以是下表列出的常量的其中一个。<br>| 类型常量 | 对象的名称     |<br>| :————- | :————- |<br>| REDIS_STRING       | 字符串对象       |<br>| REDIS_LIST       | 列表对象       |<br>| REDIS_HASH       | 哈希对象       |<br>| REDIS_SET       | 集合对象       |<br>| REDIS_ZSET       | 有序集合对象       |</p>
<p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；</li>
<li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，</li>
</ul>
<h3 id="编码和底层实现">编码和底层实现</h3><p>对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。</p>
<p>encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是下表列出的常量的其中一个。</p>
<table>
<thead>
<tr>
<th style="text-align:left">编码常量</th>
<th style="text-align:left">编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">REDIS_ENCODING_INT</td>
<td style="text-align:left">long 类型的整数</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_EMBSTR</td>
<td style="text-align:left">embstr 编码的简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_RAW</td>
<td style="text-align:left">简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_HT</td>
<td style="text-align:left">字典</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_LINKEDLIST</td>
<td style="text-align:left">双端链表</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_ZIPLIST</td>
<td style="text-align:left">压缩列表</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_INTSET</td>
<td style="text-align:left">整数集合</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_SKIPLIST</td>
<td style="text-align:left">跳跃表和字典</td>
</tr>
</tbody>
</table>
<h2 id="字符串常量">字符串常量</h2><p>字符串对象的编码可以是int、raw或者embstr。</p>
<p>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。</p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 32 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。</p>
<p>embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构，</p>
<p>embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的， 但使用 embstr 编码的字符串对象来保存短字符串值有以下好处：</p>
<ul>
<li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。</li>
<li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ul>
<p>最后要说的是， 可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。</p>
<p>最后要说的是， 可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。</p>
<p>在有需要的时候， 程序会将保存在字符串对象里面的字符串值转换回浮点数值， 执行某些操作， 然后再将执行操作所得的浮点数值转换回字符串值， 并继续保存在字符串对象里面。</p>
<p>字符串对象保存各类型值的编码方式如下：<br>| 值 | 编码 |<br>| :————- | :————- |<br>| 可以用long类型保存的整数       | int       |<br>| 可以用long double类型保存的浮点数       | embstr或者raw       |<br>| 字符串值，或者因为长度太大而没办法用long类型表示的整数，又或者因为长度太大而没有办法用long double类型表示的浮点数       | embstr 或者 raw       |</p>
<h3 id="编码的转换">编码的转换</h3><p>int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。</p>
<p>对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。</p>
<p>另外， 因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>
<h3 id="字符串命令的实现">字符串命令的实现</h3><h2 id="列表对象">列表对象</h2><p>列表对象的编码可以是ziplist或者linkedlist。</p>
<p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点(entry)保存了一个列表元素。</p>
<p>另一方面，linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p>
<p>注意， linkedlist 编码的列表对象在底层的双端链表结构中包含了多个字符串对象， 这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现， 字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。</p>
<h3 id="编码转换">编码转换</h3><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li>
<li>列表对象保存的元素数量小于 512 个；<br>不能满足这两个条件的列表对象需要使用 linkedlist 编码。</li>
</ul>
<p>注意<br>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 list-max-ziplist-value 选项和 list-max-ziplist-entries 选项的说明。</p>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面， 对象的编码也会从 ziplist 变为 linkedlist 。</p>
<h3 id="列表命令的实现">列表命令的实现</h3><h2 id="哈希对象">哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable。</p>
<p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ul>
<p>另一方面， hashtable 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
<h3 id="编码转换-1">编码转换</h3><p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li>
<li>哈希对象保存的键值对数量小于 512 个；<br>不能满足这两个条件的哈希对象需要使用 hashtable 编码。</li>
</ul>
<p>注意：<br>这两个条件的上限值是可以修改的， 具体请看配置文件中关于 hash-max-ziplist-value 选项和 hash-max-ziplist-entries 选项的说明。</p>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 ziplist 变为 hashtable 。</p>
<h3 id="哈希命令的实现">哈希命令的实现</h3><h2 id="哈希对象-1">哈希对象</h2><p>集合对象的编码可以是 intset 或者 hashtable 。</p>
<p>intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。</p>
<p>另一方面， hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 。</p>
<h3 id="编码转换-2">编码转换</h3><p>当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码：</p>
<p>集合对象保存的所有元素都是整数值；<br>集合对象保存的元素数量不超过 512 个；<br>不能满足这两个条件的集合对象需要使用 hashtable 编码。</p>
<p>注意</p>
<p>第二个条件的上限值是可以修改的， 具体请看配置文件中关于 set-max-intset-entries 选项的说明。</p>
<p>对于使用 intset 编码的集合对象来说， 当使用 intset 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 intset 变为 hashtable 。</p>
<h3 id="集合命令的实现">集合命令的实现</h3><h2 id="有序集合对象">有序集合对象</h2><p>有序集合的编码可以是ziplist或者skiplist。</p>
<p>有序集合的编码可以是 ziplist 或者 skiplist 。</p>
<p>ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。</p>
<p>skiplist 编码的有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zset &#123;</span><br><span class="line"></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></p>
<p>zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 object 属性保存了元素的成员， 而跳跃表节点的 score 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</p>
<p>除此之外， zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。</p>
<p>有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 double 类型的浮点数。 值得一提的是， 虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p>
<p>为什么有序集合需要同时使用跳跃表和字典来实现？</p>
<p>在理论上来说， 有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现， 但无论单独使用字典还是跳跃表， 在性能上对比起同时使用字典和跳跃表都会有所降低。</p>
<p>举个例子， 如果我们只使用字典来实现有序集合， 那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留， 但是， 因为字典以无序的方式来保存集合元素， 所以每次在执行范围型操作 —— 比如 ZRANK 、 ZRANGE 等命令时， 程序都需要对字典保存的所有元素进行排序， 完成这种排序需要至少 O(NlogN) 时间复杂度， 以及额外的 O(N) 内存空间 （因为要创建一个数组来保存排序后的元素）。</p>
<p>另一方面， 如果我们只使用跳跃表来实现有序集合， 那么跳跃表执行范围型操作的所有优点都会被保留， 但因为没有了字典， 所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(log N) 。</p>
<p>因为以上原因， 为了让有序集合的查找和范围型操作都尽可能快地执行， Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p>
<h3 id="编码的转换-1">编码的转换</h3><p>当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码：</p>
<p>有序集合保存的元素数量小于 128 个；<br>有序集合保存的所有元素成员的长度都小于 64 字节；<br>不能满足以上两个条件的有序集合对象将使用 skiplist 编码。</p>
<p>注意</p>
<p>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 zset-max-ziplist-entries 选项和 zset-max-ziplist-value 选项的说明。</p>
<p>对于使用 ziplist 编码的有序集合对象来说， 当使用 ziplist 编码所需的两个条件中的任意一个不能被满足时， 程序就会执行编码转换操作， 将原本储存在压缩列表里面的所有集合元素转移到 zset 结构里面， 并将对象的编码从 ziplist 改为 skiplist 。</p>
<h3 id="有序集合命令的实现">有序集合命令的实现</h3><h2 id="类型检查与命令多态">类型检查与命令多态</h2><p>Redis中用于操作键的命令基本上可以分为两种类型。<br>其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。</p>
<p>而另一种命令只能对特定类型的键执行， 比如说：</p>
<ul>
<li>SET 、 GET 、 APPEND 、 STRLEN 等命令只能对字符串键执行；</li>
<li>HDEL 、 HSET 、 HGET 、 HLEN 等命令只能对哈希键执行；</li>
<li>RPUSH 、 LPOP 、 LINSERT 、 LLEN 等命令只能对列表键执行；</li>
<li>SADD 、 SPOP 、 SINTER 、 SCARD 等命令只能对集合键执行；</li>
<li>ZADD 、 ZCARD 、 ZRANK 、 ZSCORE 等命令只能对有序集合键执行</li>
</ul>
<h3 id="类型检查的实现">类型检查的实现</h3><p>从上面发生类型错误的代码示例可以看出， 为了确保只有指定类型的键可以执行某些特定的命令， 在执行一个类型特定的命令之前， Redis 会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。</p>
<p>类型特定命令所进行的类型检查是通过 redisObject 结构的 type 属性来实现的：</p>
<ul>
<li>在执行一个类型特定命令之前， 服务器会先检查输入数据库键的值对象是否为执行命令所需的类型， 如果是的话， 服务器就对键执行指定的命令；</li>
<li>否则， 服务器将拒绝执行命令， 并向客户端返回一个类型错误。</li>
</ul>
<h3 id="多态命令的实现">多态命令的实现</h3><p>Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外， 还会根据值对象的编码方式， 选择正确的命令实现代码来执行命令。</p>
<p>举个例子， 在前面介绍列表对象的编码时我们说过， 列表对象有 ziplist 和 linkedlist 两种编码可用， 其中前者使用压缩列表 API 来实现列表命令， 而后者则使用双端链表 API 来实现列表命令。</p>
<p>现在， 考虑这样一个情况， 如果我们对一个键执行 LLEN 命令， 那么服务器除了要确保执行命令的是列表键之外， 还需要根据键的值对象所使用的编码来选择正确的 LLEN 命令实现：</p>
<ul>
<li>如果列表对象的编码为 ziplist ， 那么说明列表对象的实现为压缩列表， 程序将使用 ziplistLen 函数来返回列表的长度；</li>
<li>如果列表对象的编码为 linkedlist ， 那么说明列表对象的实现为双端链表， 程序将使用 listLength 函数来返回双端链表的长度；</li>
</ul>
<p>借用面向对象方面的术语来说， 我们可以认为 LLEN 命令是多态（polymorphism）的： 只要执行 LLEN 命令的是列表键， 那么无论值对象使用的是 ziplist 编码还是 linkedlist 编码， 命令都可以正常执行。</p>
<h2 id="内存回收">内存回收</h2><p>因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。</p>
<p>每个对象的引用计数信息由 redisObject 结构的 refcount 属性记录：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    int refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时， 引用计数的值会被初始化为 1 ；</li>
<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。</li>
</ul>
<p>下表列出了修改对象引用计数的 API ， 这些 API 分别用于增加、减少、重置对象的引用计数。<br>| 函数 | 作用 |<br>| :————- | :————- |<br>| incrRefCount | 将对象的引用计数数值增一 |<br>| decrRefCount | 将对象的引用计数数值增一，当对象的引用计数值等于0时，释放对象 |<br>| resetRefCount | 将对象的引用计数数值设置为0，但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。 |</p>
<p>对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。</p>
<p>作为例子， 以下代码展示了一个字符串对象从创建到释放的整个过程：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象 s ，对象的引用计数为 1</span></span><br><span class="line">robj *s = <span class="function"><span class="title">createStringObject</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象 s 执行各种操作 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象 s 的引用计数减一，使得对象的引用计数变为 0</span></span><br><span class="line"><span class="comment">// 导致对象 s 被释放</span></span><br><span class="line"><span class="function"><span class="title">decrRefCount</span><span class="params">(s)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其他不同类型的对象也会经历类似的过程。</p>
<h2 id="对象共享">对象共享</h2><p>除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有对象共享的作用。</p>
<p>举个例子， 假设键 A 创建了一个包含整数值 100 的字符串对象作为值对象，</p>
<p>如果这时键 B 也要创建一个同样保存了整数值 100 的字符串对象作为值对象， 那么服务器有以下两种做法：</p>
<p>为键 B 新创建一个包含整数值 100 的字符串对象；<br>让键 A 和键 B 共享同一个字符串对象；<br>以上两种方法很明显是第二种方法更节约内存。</p>
<p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ul>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。</li>
</ul>
<p>共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存。</p>
<p>比如说， 假设数据库中保存了整数值 100 的键不只有键 A 和键 B 两个， 而是有一百个， 那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存的数据。</p>
<p>目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>
<p>注意</p>
<p>创建共享字符串对象的数量可以通过修改 redis.h/REDIS_SHARED_INTEGERS 常量来修改。</p>
<p>另外， 这些共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（linkedlist 编码的列表对象、 hashtable 编码的哈希对象、 hashtable 编码的集合对象、以及 zset 编码的有序集合对象）都可以使用这些共享对象。</p>
<p>为什么 Redis 不共享包含字符串的对象？</p>
<p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p>
<ul>
<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>
<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>
<li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。<br>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。</li>
</ul>
<h2 id="对象的空转时长">对象的空转时长</h2><p>除了前面介绍过的 type 、 encoding 、 ptr 和 refcount 四个属性之外， redisObject 结构包含的最后一个属性为 lru 属性， 该属性记录了对象最后一次被命令程序访问的时间：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; <span class="keyword">SET</span> msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 等待一小段时间</span></span><br><span class="line">redis&gt; <span class="built_in">OBJECT</span> IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 等待一阵子</span></span><br><span class="line">redis&gt; <span class="built_in">OBJECT</span> IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">180</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 访问 msg 键的值</span></span><br><span class="line">redis&gt; <span class="keyword">GET</span> msg</span><br><span class="line"><span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 键处于活跃状态，空转时长为 0</span></span><br><span class="line">redis&gt; <span class="built_in">OBJECT</span> IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>注意</p>
<p>OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 lru 属性。</p>
<p>除了可以被 OBJECT IDLETIME 命令打印出来之外， 键的空转时长还有另外一项作用： 如果服务器打开了 maxmemory 选项， 并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru ， 那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>
<p>配置文件的 maxmemory 选项和 maxmemory-policy 选项的说明介绍了关于这方面的更多信息。</p>
<h2 id="重点回顾">重点回顾</h2><ul>
<li>Redis 数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。</li>
<li>Redis 会共享值为 0 到 9999 的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。</p>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、]]>
    </summary>
    
      <category term="Redis设计与实现" scheme="http://blog.noobsky.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Redis" scheme="http://blog.noobsky.com/categories/Redis/"/>
    
  </entry>
  
</feed>
