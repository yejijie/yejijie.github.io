<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-05-16T07:56:52.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[深入浅出Node.js读书笔记]]></title>
    <link href="http://blog.noobsky.com/2016/05/16/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.noobsky.com/2016/05/16/深入浅出Node-js读书笔记/</id>
    <published>2016-05-16T03:34:25.000Z</published>
    <updated>2016-05-16T07:56:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Node简介">Node简介</h2><h3 id="Node诞生历程">Node诞生历程</h3><ul>
<li>2009.3，Ryan Dahl在其博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。</li>
<li>2009.5，Ryan Dahl在GitHub上发布了最初的版本。</li>
<li>2009.12和2010.4，两届JSConf大会都安排了Node的讲座。</li>
<li>2010年年底，Node获得硅谷云计算服务商Joyent公司的资助，其创始人Ryan Dahl加入Joyent公司全职负责Node的发展。</li>
<li>2011.7，Node在微软的支持下发布了其Windows版本。</li>
<li>2011.11，Node超越Ruby on Rails，成为GitHub上关注度最高的项目（随后被Bootstrap项目超越，目前仍居第二）。</li>
<li>2012.1，Ryan Dahl在对Node架构设计满意的情况下，将掌门人的身份转交给Isaac Z. Schlueter，自己转向一些研究项目。Isaac Z. Schlueter是Node的包管理器NPM的作者，之后Node的版本发布和bug修复等工作由他接手。</li>
<li>2014.1.15 Node 掌门人更改为 TJ Fontaine, Isaac 成立公司 npm, Inc. 专注于 NPM 相关开发和维护.</li>
<li>2014.3 Node.js 0.12(1.0-RC)发布, API锁定, 下一版本即为1.0</li>
<li>2014.7.4 TJ Holowaychuk 离开Node世界， 转投Go怀抱</li>
<li>2014.10 Node 项目被fork， node-forward创建社区，想用新的方式推动Node的发展</li>
<li>2014.10.13 Node.js Advisory Board 以一种开发，自由的方式，推动 Node 项目发展</li>
<li>随后Node的发布计划主要集中在性能提升上。</li>
</ul>
<h3 id="Node的命名与起源">Node的命名与起源</h3><h4 id="为什么是JavaScript">为什么是JavaScript</h4><ul>
<li>高性能（Chrome浏览器JS的v8引擎性能在浏览器中第一）</li>
<li>符合事件驱动（JavaScript在浏览器有广泛的事件驱动方面的应用）</li>
<li>没有历史包袱（为其导入非阻塞的I/O库没有额外阻力）</li>
</ul>
<h4 id="为什么叫Node">为什么叫Node</h4><p>其目标是成为一个构建快速、可伸缩的网络应用平台。可以通过通信协议来组织许多Node，非常容易通过扩展来达成构建大型网络应用的目的。<br>每一个Node进程都构成这个网络应用的一个节点，这是它名字所含意义的真谛。</p>
<h3 id="Node给JavaScript带来的意义">Node给JavaScript带来的意义</h3><ul>
<li>Node结构与Chrome十分相似，基于事件驱动的异步结构</li>
<li>Node中得JavaScript可以访问本地文件，搭建服务器，连接数据库，玩转多进程</li>
<li>Node打破了过去JavaScript只能在浏览器中运行的局面，前后端统一</li>
</ul>
<h3 id="Node的特点">Node的特点</h3><ul>
<li>异步I/O</li>
<li>事件与回调函数</li>
<li>单线程</li>
<li>跨平台</li>
</ul>
<h3 id="Node的应用场景">Node的应用场景</h3><ul>
<li>I/O密集型</li>
<li>不是很擅长CPU密集型业务，但是可以合理调度</li>
<li>分布式应用</li>
</ul>
<p>关于Node，探讨的较多的主要由I/O密集型和CPU密集型，Node面向网络且擅长并行I/O，总而言之，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。</p>
<h3 id="Node的使用者">Node的使用者</h3><ul>
<li>前后端编程语言环境统一：雅虎开放了Cocktail框架</li>
<li>Node带来的高性能I/O用于实时应用：Voxer和腾讯</li>
<li>并行I/O使得使用者可以更高效地利用分布式环境：阿里巴巴和eBay</li>
<li>并行I/O，有效利用稳定接口提升Web渲染能力：雪球财经和LinkedIn</li>
<li>云计算平台提供Node支持：微软、Joyent、阿里云…</li>
<li>游戏开发领域：网易开源了pomelo实时框架</li>
<li>工具类应用</li>
</ul>
<h2 id="模块机制">模块机制</h2><h3 id="Node的模块">Node的模块</h3><p>JavaScript先天就缺乏一项功能：模块，其他高级语言中Java、Python有import机制，Ruby有require，PHP有include和require……浏览器JavaScript通过<script>标签引入代码的方式显得杂乱无章，语言自身显得毫无组织和约束能力</p>
<ul>
<li>Node的模块分为两类：一类是Node提供的模块，称为核心（原生）模块；另一类是用户编写的模块，称为文件模块</li>
<li>Node通过require引用模块</li>
<li>对应引用的功能，通过exports对象来导出当前模块的方法或变量。模块中还存在一个module对象，exports实际上是module的属性。在Node中，一个文件就是一个模块，模块内的“全局变量”对外都不可见，只有挂载在exports上的属性才是公开的。exports 是指向的 module.exports 的引用</li>
</ul>
<h3 id="包与NPM">包与NPM</h3><ul>
<li>包是在模块基础上更深一步的抽象,Node.js的包类似于 C/C++ 的函数库或者 Java/.Net 的类库。它将某个独立的功能封装起来,用于发布、更新、依赖管理和版本控制。</li>
<li>严格符合CommonJS规范的包应该包含以下文件:<ul>
<li>package.json:包描述文件</li>
<li>bin：用于存放可执行二进制文件的目录</li>
<li>lib：用于存放JavaScript代码的目录</li>
<li>doc：用于存放文档的目录</li>
<li>test：用于存放单元测试用例的代码 </li>
</ul>
</li>
</ul>
<h3 id="NPM：_Node包管理器（Node_Package_Manager）">NPM： Node包管理器（Node Package Manager）</h3><p>Node.js根据CommonJS规范实现了包机制,开发了npm来解决包的发布和获取需求。NPM常用功能：</p>
<ul>
<li>查看帮助：npm –h、npm help <command></li>
<li>安装依赖包：npm install express –g(全局安装)、npm install <file>(本地安装)</li>
<li>发布包</li>
<li>分析包</li>
</ul>
<h2 id="异步I/O">异步I/O</h2><p>异步I/O就是I/O 操作不采用阻塞的策略。当线程遇到 I/O 操作时,不会以阻塞的方式等待 I/O 操作 的完成或数据的返回,而只是将 I/O<br>请求发送给操作系统,继续执行下一条语句。当操作系统完成 I/O 操作时,以事件的形式通知执行 I/O 操作的线程,线程会在特定时候处理这个事件。<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/Nodejs1.png" alt=""></p>
<p>为了处理异步 I/O,线程必须有事件循环,不断地检查有没有未处理的事件,依次予以处理。CPU与 I/O并行执行，计算设备与I/O设备互不干扰</p>
<h3 id="为什么要异步I/O">为什么要异步I/O</h3><ul>
<li>用户体验</li>
</ul>
<p>假如一个资源来自于两个不同位置的数据的返回，第一个资源需要M毫秒的耗时，第二个资源需要N毫秒的耗时。如果采用同步的方式，代码大致如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费时间为M</span></span><br><span class="line">getData(<span class="string">'from_db'</span>);</span><br><span class="line"><span class="comment">//消费时间为N</span></span><br><span class="line">getData(<span class="string">'from_remote_api'</span>);</span><br></pre></td></tr></table></figure></p>
<p>如上如果采用同步方式，那么时间消耗为M+N。但是如果采用异步方式，第一个资源的获取并不会阻塞第二个资源。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//消费时间为M</span><br><span class="line">getData('from_db',function(<span class="literal">result</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">//消费时间为N</span><br><span class="line">getData('from_remote_api',function(<span class="literal">result</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果采用异步的方式则时间消耗为Max(M, N)。随着应用复杂性的增加，情景将会变为M+N+…和Max(M,N,…)</p>
<ul>
<li>资源分配：利用异步I/O，让单线程远离阻塞，更好利用CPU</li>
</ul>
<h3 id="Node的异步I/O">Node的异步I/O</h3><ul>
<li>事件循环</li>
<li>观察者</li>
<li>执行回调</li>
</ul>
<p>Node异步I/O环节事件循环、观察者、执行回调。当进程启动时，Node便会创建一个类似于while(true)的循环、每执行一次循环体的过程称为Tick。<br>每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。在每个Tick的过程中，如何判断是否有事件需要处理呢？这里必须引入的概念是观察者。每个事件循环中有一个或者多个观察者，而判断是否有事件处理的过程就是向这些观察者询问是否有要处理的事件。</p>
<h3 id="知名的基于事件驱动的实现">知名的基于事件驱动的实现</h3><ul>
<li>Ruby的Event Machine</li>
<li>Perl的AnyEvent</li>
<li>Python的Twisted</li>
<li>Node异步I/O</li>
</ul>
<p>前面介绍异步的实现原理的过程中，我们也勾勒出了事件驱动的本质，即通过主循环加事件触发的方式来运行程序。事实上，Node的异步I/O并非首创，但却是第一个成功地平台，在那之前，也有一些知名的基于事件驱动的实现，具体如下所示。这些库没有成功地原因是同步I/O库的存在。因为在这些成熟的语言平台上，异步不是主流，尽管有这些事件驱动的实现库，但开发者总会习惯性的采用同步I/O库，这导致预想的高性能直接落空。</p>
<h2 id="异步编程">异步编程</h2><p>有异步I/O，必有异步编程</p>
<h3 id="函数式编程">函数式编程</h3><p>JavaScript中，函数作为一等公民，使用非常自由</p>
<ul>
<li>直接调用</li>
<li>赋值给其他变量</li>
<li>作为参数</li>
<li>作为返回值</li>
</ul>
<h3 id="回调">回调</h3><p>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，异步的方式读取文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步读取文件内容</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'file.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (err) &#123; </span><br><span class="line">		<span class="built_in">console</span>.error(err);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="comment">//doSomething</span></span><br><span class="line">		<span class="built_in">console</span>.log(data);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end.'</span>);</span><br></pre></td></tr></table></figure>
<p>fs.readFile 接收了三个参数, 第一个是文件名,第二个是编码方式,第三个是一个函数,我们称这个函数为回调函数。 异步式 I/O 请求发送给了操作系统,然后立即 返回并执行后面的语句,执行完以后进入事件循环监听事件。当 fs 接收到 I/O 请求完成的 事件时,事件循环会主动调用回调函数以完成后续工作。因此我们会先看到 end.,再看到 file.txt 文件的内容。 </p>
<h3 id="异步编程的难点">异步编程的难点</h3><h4 id="异常处理">异常处理</h4><p>尝试对异步方法进行try/catch操作只能捕获当次事件循环内的异常，对callback执行时抛出的异常将无能为力，示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步方法</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">	process.nextTick(callback);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">async</span>(callback);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Node约定，将异常作为回调函数的第一个实参传回，</span></span><br><span class="line"><span class="comment">//如果为空值，则表明异步调用没有异常抛出</span></span><br><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span>(<span class="params">err,results</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Node约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出。我们自行编写的异步方法上，也需要遵循这样一些原则：</p>
<ul>
<li>必须执行调用者传入的回调函数；</li>
<li>正确传递回异常供调用者判断。</li>
</ul>
<h4 id="函数嵌套过深">函数嵌套过深</h4><p>世界上本没有嵌套回调，写得人多了，也便有了}}}}}}}}}}。比如遍历目录，三层嵌套：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历目录</span></span><br><span class="line">fs.readdir(path.join(__dirname,<span class="string">'..'</span>),<span class="function"><span class="keyword">function</span><span class="params">(err,files)</span></span>&#123;</span><br><span class="line">	files.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span><span class="params">(filename,index)</span></span>&#123;</span><br><span class="line">		fs.readFile(filename,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span><span class="params">(err,file)</span></span>&#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="阻塞代码">阻塞代码</h4><p>竟然没有sleep()这样的线程沉睡功能，所以有多半开发者会写出下述这样的代码来实现sleep(1000)的效果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - start &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要阻塞的代码</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码会持续占用CPU进行判断，与真正的线程沉睡相去甚远，完全破坏了事件循环的调度。由于Node单线程的原因，CPU资源全都会用于为这段代码服务，导致其余任何请求都会得不到响应。Node单线程不能充分利用多核CPU，后面会介绍相关解决办法</p>
<h3 id="异步编程解决方案">异步编程解决方案</h3><p>前面列举了因异步编程带来的一些问题，编程过程看起来似乎没有想象中美好，但是事实也没用那么糟糕。这里介绍一些典型的解决方案<br>后面两种方法复杂，需要长篇幅来介绍，这里只介绍一下前面的两种基础方法。</p>
<h4 id="事件发布/订阅模式">事件发布/订阅模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅</span></span><br><span class="line">emitter.on(<span class="string">"event1"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//发布</span></span><br><span class="line">emitter.emit(<span class="string">"event1"</span>,<span class="string">"I am message!"</span>);</span><br></pre></td></tr></table></figure>
<p>事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式。Node自身提供的events模块是发布/订阅模式的一个简单实现。</p>
<h4 id="流程控制库">流程控制库</h4><ul>
<li>async</li>
<li>Step<br>第二可以通过流程控制库，来处理异步的各种协作模式。Async和Step都提供了异步的串行执行和异步的并行执行等方法，相关用法查阅官方文档即可。</li>
</ul>
<h2 id="内存控制">内存控制</h2><p>JavaScript与Java一样，由垃圾回收机制来自行自动内存管理。对于性能敏感的服务器端程序，内存管理的好坏、<br>垃圾回收状况是否优良，都会对服务构成影响。而在Node，这一切都与Node的JavaScript执行引擎V8息息相关。<br>V8的垃圾回收策略主要基于分代式垃圾回收机制。</p>
<h3 id="V8的垃圾回收机制与内存控制">V8的垃圾回收机制与内存控制</h3><ul>
<li>Node与V8:Node在JavaScript的执行上直接受益于V8，同时也受到V8的一些限制</li>
<li>V8的内存限制：64位系统1.4GB，32位0.7GB</li>
<li>V8的对象分配：通过堆分配，内存使用量process.memoryUsage()可查询</li>
<li>V8的垃圾回收机制：<br>  （1）V8的内存分代：新生代（存活时间较短）和老生代（存活时间较长）<br>  （2）Scavenge算法（新生代）：采用复制的方式（空间换时间）<br>  （3）Mark-Sweep&amp;Mark-Compact（老生代）：标记清除，标记整理<br>  （4）Incremental Marking：增量标记</li>
</ul>
<p>Scavenge算法将堆内存分为两个空间，只有一个使用，称为From空间，另一个闲置，称为To空间。垃圾回收时，将From的存活对象复制到TO空间，非存活释放。然后两个空间对换，开始下一轮回收<br>标记清除：标记阶段遍历堆中所有对象，标记活得对象；接下来在清除阶段只清除没有被标记的对象<br>标记整理：标记清除的问题是清除后，内存不连续，会造成无法分配大对象。标记整理清除阶段将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。<br>增量标记：垃圾回收的3种基本算法都需要将应用逻辑暂停下来，这种暂停成为“全停顿”。V8先从标记阶段入手，将原本一口气停顿完成的动作改为增量标记，也就是拆分为许多小“步进”，每做完一步就让JS应用逻辑执行一小会儿。垃圾回收与应用逻辑交替执行，大大减少停顿时间</p>
<h3 id="内存指标">内存指标</h3><ul>
<li>查看进程占用：process.memoryUsage()</li>
<li>查看系统的内存占用：os模块中的totalmem()和freemem()分别返回总内存和闲置内存</li>
<li>堆外内存（不是通过V8分配：Buffer）：意味利用堆外内存可以突破内存的限制</li>
</ul>
<h3 id="内存泄露">内存泄露</h3><p>在垃圾回收机制下，通常的代码编写中，很少会出现内存泄露的情况，通常会造成内存泄露的原因有以下几个；<br>原因：缓存、队列消费不及时、作用域未释放<br>解决方案：将缓存转移到外部，减少常驻内存的对象的数量（Redis，Memcached）；监控队列的长度<br>内存泄露排查：node-heapdump（对V8堆内存抓取快照、分析）、node-memwatch（抓取快照、比较快照）</p>
<h2 id="理解Buffer">理解Buffer</h2><h3 id="Buffer结构">Buffer结构</h3><p>在网络流和文件的操作中，需要处理大量二进制数据，JavaScript自有的字符串远远不能满足这些需求，于是Buffer对象应运而生。它将性能相关的部分用C++实现，将非性能相关的部分用JavaScript实现。内存应用时，由于Node的内存限制，若不需要进行字符串层面的操作，可以尝试使用Buffer来操作，这不会受到V8堆内存的限制，但依然会受到物理内存限制。</p>
<ul>
<li>模块结构：JavaScript与C++结合的模块</li>
<li>Buffer对象：类似于数组，元素是16进制的两位数（0-255）</li>
<li>Buffer的内存分配：在Node的C++层面申请；不是V8分配的，属于堆外内存</li>
<li>在文件I/O和网络I/O中运用广泛，尤其在网络传输中，它的性能举足轻重</li>
</ul>
<h3 id="Buffer与字符串的相互转换">Buffer与字符串的相互转换</h3><ul>
<li>目前支持的编码类型：ASCII、UTF-8、UTF-16LE/UCS-2、Base64、Binary、Hex</li>
<li>字符串转Buffer：new Buffer(str, [encoding])</li>
<li>Buffer转字符串：buf.toString([encoding],[start],[end])</li>
<li>Buffer不支持的编码类型：通过Buffer.isEncoding(encoding)判断是否支持转换；中国常用的GBK、GB2312等都不支持；借助生态圈中的iconv和iconv-lite两个模块解决</li>
</ul>
<h3 id="网络编程">网络编程</h3><p>利用Node可以十分方便地搭建网络服务器，不需要专门的Web服务器作为容器，仅仅需要几行代码就可以构建服务器。Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务端和客户端。</p>
<h4 id="HTTP服务器&amp;&amp;TCP服务器">HTTP服务器&amp;&amp;TCP服务器</h4><ul>
<li>HTTP服务器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:1337/'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>TCP服务器</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var net = <span class="keyword">require</span>(<span class="string">'net'</span>);</span><br><span class="line">var server = net.createServer(function (<span class="keyword">socket</span>) &#123;</span><br><span class="line">  <span class="keyword">socket</span>.<span class="keyword">write</span>(<span class="string">'Echo server\r\n'</span>);</span><br><span class="line">  <span class="keyword">socket</span>.<span class="keyword">pipe</span>(<span class="keyword">socket</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="keyword">listen</span>(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="构建Web应用">构建Web应用</h2><p>构建Web应用过程中用到很多技术细节，如数据处理、路由、MVC、模板、RESTful等，详见以下脑图。实现这些细节就可以完成一个功能完备的Web开发框架。<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/Nodejs2.png" alt=""></p>
<h2 id="玩转进程">玩转进程</h2><h3 id="Node单线程">Node单线程</h3><p>好处：程序状态单一，没有多线程的锁、同步问题，操作系统调度较少的上下文切换，可以很好地提高CPU的使用率<br>问题：</p>
<pre><code><span class="bullet">* </span>如何充分利用多核CPU服务器
<span class="bullet">* </span>如何保证进程的健壮性和稳定性
</code></pre><h3 id="多进程架构">多进程架构</h3><p>Node提供了child_process模块，并提供child_process.fork()实现进程的复制。<br>worker.js:http服务器，监听1000到2000之间的一个随机端口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http  = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/plain'</span>&#125;);</span><br><span class="line">	res.end(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;).listen(<span class="built_in">Math</span>.round((<span class="number">1</span>+<span class="built_in">Math</span>.random())*<span class="number">1000</span>),<span class="string">'127.0.0.1'</span>);</span><br></pre></td></tr></table></figure>
<p>master.js：根据当前机器上的CPU地数量复制出对应Node进程数</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">fork</span> = <span class="keyword">require</span>(<span class="string">'child_process'</span>).<span class="keyword">fork</span>;</span><br><span class="line">var cpus = <span class="keyword">require</span>(<span class="string">'os'</span>).cpus();</span><br><span class="line"><span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; cpus.<span class="keyword">length</span>; i++)&#123;</span><br><span class="line">	<span class="keyword">fork</span>(<span class="string">'./worker.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理想状态下，每个进程各自利用一个CPU，以此实现多核CPU的利用。如下图：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/Nodejs3.png" alt=""></p>
<h3 id="Master-Worker模式（主从模式）">Master-Worker模式（主从模式）</h3><p><img src="http://7xonwi.com1.z0.glb.clouddn.com/Nodejs4.png" alt=""></p>
<p>上图就是著名的Master-Worker模式，又称主从模式。图中的进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好地可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是倾向于稳定的。fork进程是昂贵的，好在这里启动多个进程只是为了充分将CPU资源利用起来，而不是为了解决并发问题</p>
<h3 id="集群稳定之路:自动重启">集群稳定之路:自动重启</h3><p><img src="http://7xonwi.com1.z0.glb.clouddn.com/Nodejs5.png" alt=""><br>我们创建了很多工作进程，但每个工作进程依然是在单线程上执行的，稳定性不能得到保障。我们在主进程上加入一些子进程管理的机制，当有子进程退出时重新启动一个工作进程来继续服务。</p>
<ul>
<li>工作进程得知要退出时(有未捕获的异常出现)，向主进程发送自杀信号</li>
<li>然后停止接收新的连接，当所有连接断开后才退出</li>
<li>主进程接收自杀信号后，立即创建新的工作进程服务</li>
</ul>
<p>至此我们完成了进程的平滑重启，一旦有异常出现，主进程会创建新的工作进程来为用户服务，旧的进程一旦处理完已有连接就自动断开。整个过程使得我们的应用的稳定性和健壮性大大提高。</p>
<h3 id="负载均衡">负载均衡</h3><p>多进程架构将CPU资源都调用起来后，需要保证每个进程的工作量，既不能让一些进程忙不过来，也不能让一些进程闲着这种保证多个处理单元工作量公平的策略叫负载均衡。Node提供了叫Round-Robin策略，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。<br>分发策略：在N个工作进程中，每次选择第i=(i+1) mod n个进程来发送连接</p>
<ul>
<li>在cluster模块中启用：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启用Round-Robin</span></span><br><span class="line">cluster<span class="class">.schedulingPolicy</span> = cluster<span class="class">.SCHED_RR</span></span><br><span class="line"><span class="comment">//不启用Round-Robin</span></span><br><span class="line">cluster<span class="class">.schedulingPolicy</span> = cluster.SCHED_NONE</span><br></pre></td></tr></table></figure>
<ul>
<li>或在环境变量中设置NODE_CLUSTER_SCHED_POLICY的值：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_CLUSTER_SCHED_POLICY=rr</span><br><span class="line"><span class="built_in">export</span> NODE_CLUSTER_SCHED_POLICY=none</span><br></pre></td></tr></table></figure>
<h3 id="Cluster模块">Cluster模块</h3><p>cluster模块，用以解决多核CPU的利用率问题，是child_process和net模块的组合应用。作用：用于解决多核CPU的利用率问题，同时也提供较完善的API，用以处理进程的健壮性。</p>
<p>cluster模块中，一个主进程只能管理一组工作进程。child_process可以更灵活控制工作进程，甚至控制多组工作进程尽管通过child_process模块可以大幅度提升Node的稳定性，但是一旦主进程出现问题，所有子进程将会失去管理。在Node的进程管理之外，还需要监听进程数量或监听日志的方式确保整个系统的稳定性，即使主进程出错退出，也能及时得到监控报警，使得开发者可以及时处理故障。</p>
<h2 id="其他">其他</h2></script></p>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Node简介">Node简介</h2><h3 id="Node诞生历程">Node诞生历程</h3><ul>
<li>2009.3，Ryan Dahl在其博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。</li>
<li>2009.5，Ryan D]]>
    </summary>
    
      <category term="读书笔记" scheme="http://blog.noobsky.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Nodejs" scheme="http://blog.noobsky.com/categories/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Number of 1 Bits 和 Counting Bits]]></title>
    <link href="http://blog.noobsky.com/2016/05/14/LeetCode-Number-of-1-Bits-%E5%92%8C-Counting-Bits/"/>
    <id>http://blog.noobsky.com/2016/05/14/LeetCode-Number-of-1-Bits-和-Counting-Bits/</id>
    <published>2016-05-13T17:06:33.000Z</published>
    <updated>2016-05-16T03:35:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Number_of_1_Bits">Number of 1 Bits</h2><h3 id="题目描述">题目描述</h3><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p>
<h4 id="代码一">代码一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// if((n &amp; 1)==1)&#123;</span></span><br><span class="line">        <span class="comment">//     count++;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//更好的写法</span></span><br><span class="line">        count = count + (n &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//注意应该使用无符号右移，如果使用&gt;&gt;遇到负数时会发生死循环</span></span><br><span class="line">        n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码二">代码二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           <span class="comment">//将n最右边为1的比特位置为0</span></span><br><span class="line">           n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码三">代码三</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接调用Integer的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> Integer.<span class="title">bitCount</span><span class="params">(n)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Counting_Bits">Counting Bits</h2><h3 id="题目描述-1">题目描述</h3><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>Follow up:</p>
<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.<br>Hint:</p>
<p>You should make use of what you have produced already.<br>Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous.<br>Or does the odd/even status of the number help you in calculating the number of 1s?</p>
<h4 id="代码一-1">代码一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bits[i] = bits[i/2] + i%2;</span></span><br><span class="line"><span class="comment">//i/2相当于将i(i&gt;=0)右移一位，对于奇数(最右边的比特位为1,&amp;1一定为1)来说,少了一个为1的比特位，需要加1（i%2或者i&amp;1），</span></span><br><span class="line"><span class="comment">//对于偶数来说(最右边的比特位为0，&amp;1一定为0)来说，为1的比特位不变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码二-1">代码二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bits[i] = bits[i &amp; (i-1)] + 1;</span></span><br><span class="line"><span class="comment">//i &amp; (i-1)的结果就是讲i最右边为1的比特位置为0，使i的比特位减少1，加上1即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) bits[i] = bits[i &amp; (i-<span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Number_of_1_Bits">Number of 1 Bits</h2><h3 id="题目描述">题目描述</h3><p>Write a function that takes an unsigned integer and returns the num]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Single Number I II III]]></title>
    <link href="http://blog.noobsky.com/2016/05/13/LeetCode-Single-Number-I-II-III/"/>
    <id>http://blog.noobsky.com/2016/05/13/LeetCode-Single-Number-I-II-III/</id>
    <published>2016-05-13T02:30:10.000Z</published>
    <updated>2016-05-16T03:35:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Single_Number_I">Single Number I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用异或的性质，相同的数异或结果为0，一个数跟0异或等于其本身，而且异或满足交换律</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        res = res ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Single_Number_II">Single Number II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果我们将nums数组中所有数的二进制表示中第i比特位求和sum（统计第i比特位为1的个数）</span></span><br><span class="line">   <span class="comment">//如果该sum % 3，那么其结果必为0或1，而且sum % 3的结果一定是那个single number第i比特位（0或1）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">       <span class="keyword">int</span> length = nums.length; </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">           count = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++)&#123;</span><br><span class="line">               <span class="comment">//这里因为外层循环使用了32次限制，所以右移不会像统计某个数中bit为1的数目那样造成死循环（那种情况可以使用无符号右移代替）</span></span><br><span class="line">               <span class="comment">//if(((nums[j] &gt;&gt; i) &amp; 1) == 1) count++;</span></span><br><span class="line">               <span class="comment">//这样写也是可以，这种写法在统计bit为1的数目时也可以避免死循环，但是要注意的是使用!=0,不能使用&gt;0（有负数）</span></span><br><span class="line">               <span class="keyword">if</span>((nums[j] &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) count++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果count % 3 = 1，则这个1肯定是我们所找的那个数贡献，也就是说我们所找的那个数在第i bit为1，</span></span><br><span class="line">           <span class="comment">//左移i位，因为这是第i位上的0或1</span></span><br><span class="line">           res |= ((count % <span class="number">3</span>) &lt;&lt; i);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Single_Number_III">Single Number III</h2><h3 id="题目描述-2">题目描述</h3><p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似Single Number I，我们从头到尾依次异或数组中的每一个数，那么最终得到的结果就是两个只出现一次的数字的异或结果</span></span><br><span class="line">   <span class="comment">//因为其他数字都出现了两次，这些出现两次数字最后的异或结果为0。由于两个出现一次的数字肯定不一样，那么这两个</span></span><br><span class="line">   <span class="comment">//数字的异或结果肯定不为0，也就是说在这两个出现一次的数字的异或结果的二进制表示中至少有一个比特位为1。我们在</span></span><br><span class="line">   <span class="comment">//此异或结果中找到第一个(从低位往高位数，最右边)为1的比特位的位置，记为第N比特位。然后我们以第N位是不是1为标准</span></span><br><span class="line">   <span class="comment">//把原数组中的数字分成两个子数组，第一个子数组的第N位为1，第二个子数组的第N位都为0。则我们把原数组分成两个子数组，</span></span><br><span class="line">   <span class="comment">//每个子数组都包含了一个只出现一次的数字，而其他数字都出现了两次。因为，我们已经把问题转换为了Single Number I</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> xorRes = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//遍历一遍，计算全部数字的异或结果</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) xorRes = xorRes ^ nums[i];</span><br><span class="line">       <span class="comment">//计算异或结果找到第一个为1的比特位的掩码(最右边为1的比特位为1，其余比特位为0)</span></span><br><span class="line">       <span class="comment">//xorRes &amp; (xorRes - 1)的效果是把xorRes第一个（最右边）为1的比特位变为0，该技巧也可以用来统计二进制中比特位为1的个数</span></span><br><span class="line">       <span class="comment">//接着异或自身xorRes即可</span></span><br><span class="line">       <span class="comment">//也可以使用xorRes = xorRes &amp; (-xorRes)。</span></span><br><span class="line">       <span class="keyword">int</span> firstOneBitMask = (xorRes &amp; (xorRes-<span class="number">1</span>)) ^ xorRes;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span>[] res = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>((nums[i] &amp; firstOneBitMask) == <span class="number">0</span>)&#123;</span><br><span class="line">               res[<span class="number">0</span>] = res[<span class="number">0</span>] ^ nums[i];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               res[<span class="number">1</span>] = res[<span class="number">1</span>] ^ nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Single_Number_I">Single Number I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of integers, every element appears twice except for on]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Word Pattern]]></title>
    <link href="http://blog.noobsky.com/2016/05/13/LeetCode-Word-Pattern/"/>
    <id>http://blog.noobsky.com/2016/05/13/LeetCode-Word-Pattern/</id>
    <published>2016-05-12T16:25:27.000Z</published>
    <updated>2016-05-16T03:35:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</p>
<p>Examples:<br>pattern = “abba”, str = “dog cat cat dog” should return true.<br>pattern = “abba”, str = “dog cat cat fish” should return false.<br>pattern = “aaaa”, str = “dog cat cat dog” should return false.<br>pattern = “abba”, str = “dog dog dog dog” should return false.<br>Notes:<br>You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.</p>
<h3 id="解法一">解法一</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> wordPattern(<span class="keyword">String</span> pattern, <span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">       <span class="keyword">String</span>[] words = <span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">" "</span>);</span><br><span class="line">       <span class="keyword">if</span>(words.length != pattern.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       Map&lt;Character, Integer&gt; pat = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">       Map&lt;<span class="keyword">String</span>, Integer&gt; wo = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">           <span class="built_in">char</span> temp = pattern.charAt(i);</span><br><span class="line">           <span class="keyword">String</span> tempStr = words[i];</span><br><span class="line">           <span class="comment">//前面异或为真时：一个有映射，一个没有映射，false</span></span><br><span class="line">           <span class="keyword">if</span>(pat.containsKey(temp) ^ wo.containsKey(tempStr) || (pat.containsKey(temp) &amp;&amp; wo.containsKey(tempStr) &amp;&amp; !pat.<span class="built_in">get</span>(temp).equals(wo.<span class="built_in">get</span>(tempStr)))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           pat.put(pattern.charAt(i), i);</span><br><span class="line">           wo.put(words[i], i);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法二">解法二</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的改进版本   </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> wordPattern(String pattern, String <span class="keyword">str</span>)&#123;</span><br><span class="line">    String[] words = <span class="keyword">str</span>.split(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span>(words.length != pattern.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Map <span class="keyword">index</span> = <span class="keyword">new</span> HashMap();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意i为Integer,如果为i时自动装箱会有问题，因为Integer默认缓存-128-127的数，!=比较对象会有问题</span></span><br><span class="line">    <span class="comment">//如果i为Integer，放入同一个对象，能够正确判断</span></span><br><span class="line">    <span class="keyword">for</span>(Integer i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">        <span class="comment">//put函数的返回值存在key时，返回旧的value，不存在key时返回null</span></span><br><span class="line">        <span class="comment">//都还没有索引，即null == null;如果一个有索引，一个没索引（即上面异或为真的情况）!=肯定成立，返回false；</span></span><br><span class="line">        <span class="comment">//如果都存在索引，但是索引的值不同，返回false；</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">index</span>.put(pattern.charAt(i), i) != <span class="keyword">index</span>.put(words[i], i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">        <span class="comment">//put函数的返回值存在key时，返回旧的value，不存在key时返回null</span></span><br><span class="line">        <span class="comment">//都还没有索引，即null == null;如果一个有索引，一个没索引（即上面异或为真的情况）!=肯定成立，返回false；</span></span><br><span class="line">        <span class="comment">//如果都存在索引，但是索引的值不同，返回false；</span></span><br><span class="line">        <span class="comment">// if(index.put(pattern.charAt(i), i) != index.put(words[i], i)) return false;</span></span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(<span class="keyword">index</span>.put(pattern.charAt(i), i),<span class="keyword">index</span>.put(words[i], i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法三">解法三</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map建立pattern到word的映射</span></span><br><span class="line"><span class="comment">//Set保存已经建立映射的word</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> wordPattern(<span class="keyword">String</span> pattern, <span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">    <span class="keyword">String</span>[] words = <span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span>(words.length != pattern.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Character, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">        <span class="built_in">char</span> ch = pattern.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(ch))&#123;</span><br><span class="line">            <span class="comment">//跟前面建立的映射不一样，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.<span class="built_in">get</span>(ch).equals(words[i])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//已经有其他字符映射到了words[i],出现了多对一映射，返回false</span></span><br><span class="line">            <span class="comment">//其实判断是否有其他字符映射到当前的字符也可以不另外使用Set而是直接用HashMap的containsValue来判断</span></span><br><span class="line">            <span class="comment">//但是该方法的时间复杂度为O(n)</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.contains(words[i])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//建立映射</span></span><br><span class="line">            <span class="built_in">map</span>.put(ch, words[i]);</span><br><span class="line">            <span class="comment">//记录已经映射的word</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">set</span>.<span class="built_in">add</span>(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Here follow means a full match, suc]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]包含min函数的栈 Min Stack]]></title>
    <link href="http://blog.noobsky.com/2016/05/12/LeetCode-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88-Min-Stack/"/>
    <id>http://blog.noobsky.com/2016/05/12/LeetCode-包含min函数的栈-Min-Stack/</id>
    <published>2016-05-12T06:35:43.000Z</published>
    <updated>2016-05-12T06:35:43.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]字符串和数字转换相关的几道题Reverse Integer、atoi和Valid Number]]></title>
    <link href="http://blog.noobsky.com/2016/05/12/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%A0%E9%81%93%E9%A2%98Reverse-Integer%E3%80%81atoi%E5%92%8CValid-Number/"/>
    <id>http://blog.noobsky.com/2016/05/12/LeetCode-字符串和数字转换相关的几道题Reverse-Integer、atoi和Valid-Number/</id>
    <published>2016-05-12T02:29:36.000Z</published>
    <updated>2016-05-12T02:29:36.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashSet源码分析]]></title>
    <link href="http://blog.noobsky.com/2016/05/09/HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://blog.noobsky.com/2016/05/09/HashSet源码分析/</id>
    <published>2016-05-09T07:38:48.000Z</published>
    <updated>2016-05-09T07:38:48.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <link href="http://blog.noobsky.com/2016/05/09/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://blog.noobsky.com/2016/05/09/HashMap源码分析/</id>
    <published>2016-05-09T07:38:28.000Z</published>
    <updated>2016-05-09T07:38:28.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tricky知识点与任务列表]]></title>
    <link href="http://blog.noobsky.com/2016/05/06/Tricky%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/"/>
    <id>http://blog.noobsky.com/2016/05/06/Tricky知识点与任务列表/</id>
    <published>2016-05-06T03:09:33.000Z</published>
    <updated>2016-05-10T03:58:17.000Z</updated>
    <content type="html"><![CDATA[<p>n &amp; (n-1)的效果是把该数二进制中最右边的一个1变成0，可以用来统计二进制中1的个数，或者判断二进制中只有一个1（n &amp; (n-1) == 0）<br>return num &gt; 0 &amp;&amp; (num&amp;(num-1)) == 0 &amp;&amp; (num &amp; 0x55555555) != 0;可以用来判断是否是4的指数（//0x55555555 is to get rid of those power of 2 but not power of 4,so that the single 1 bit always appears at the odd position ）<br>return num &gt; 0 &amp;&amp; (num&amp;(num-1)) == 0可以用来判断是否是2的指数</p>
<p>n!尾部含0的个数为n/5 + n/25 + n/125 + n/625 + ……</p>
<p>HashMap的源码<br>TreeMap的源码<br>HashSet的源码<br>Concurrent的源码<br>ArrayList的源码<br>LinkedList的源码<br>。。。</p>
<p>String<br>StringBuffer<br>StringBuilder<br>Integer<br>Arrays<br>Collections<br>Byte</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>n &amp; (n-1)的效果是把该数二进制中最右边的一个1变成0，可以用来统计二进制中1的个数，或者判断二进制中只有一个1（n &amp; (n-1) == 0）<br>return num &gt; 0 &amp;&amp; (num&amp;(num-1)) == ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode对称树]Symmetric Tree]]></title>
    <link href="http://blog.noobsky.com/2016/05/05/LeetCode%E5%AF%B9%E7%A7%B0%E6%A0%91-Symmetric-Tree/"/>
    <id>http://blog.noobsky.com/2016/05/05/LeetCode对称树-Symmetric-Tree/</id>
    <published>2016-05-05T06:33:07.000Z</published>
    <updated>2016-05-05T07:24:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>But the following is not:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>判断一颗二叉树是否是对称的，二叉树是对称的如果它的左子树和右子树是镜像对称的，<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/symtree1.png" alt=""><br>所以问题就是判断两棵树是否镜像对称。当两棵树互为镜像对称时，它们满足以下条件：</p>
<ul>
<li>它们的根的值相等</li>
<li>一棵树的左子树、右子树分别和另一棵树的右子树、左子树是镜像对称的<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/symtree2.png" alt=""><br>这里给出该题的两种解法，分别为递归法和迭代法</li>
</ul>
<h3 id="方法一：递归法">方法一：递归法</h3><p>代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="function"><span class="keyword">return</span> <span class="title">isMirror</span><span class="params">(root.left, root.right)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//判断左右子树是否为镜像</span></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> t1.val == t2.val &amp;&amp; isMirror(t1.left, t2.right) &amp;&amp; isMirror(t1.right, t2.left);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>因为树的每一个节点都需要遍历到，所以算法的时间复杂度为O(n)。递归调用的上界为树的高度，最坏情况下，树退化为线性的链表，高度为O(n)，所以递归调用栈空间复杂度的最坏情况为O(n)。</p>
<h3 id="方法二：迭代法">方法二：迭代法</h3><p>我们也可以利用队列使用迭代的方法来解决该问题。队列中每两个连续的节点都应该相等，而且它们的子树互为镜像对称。初始化时，队列中包含根节点的左右子节点。该算法类似于BFS，稍微做了下修改。每一次循环，从队列中取出两个元素并比较它们的值。然后两个节点的左右孩子以相反的顺序加入队列中。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> isSymmetric(TreeNode root)&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">       <span class="built_in">queue</span><span class="built_in">.</span>offer(root<span class="built_in">.</span>left);</span><br><span class="line">       <span class="built_in">queue</span><span class="built_in">.</span>offer(root<span class="built_in">.</span>right);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">           TreeNode t1 = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">           TreeNode t2 = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(t1 == <span class="built_in">null</span> <span class="subst">&amp;&amp;</span> t2 == <span class="built_in">null</span>) continue;</span><br><span class="line">           <span class="keyword">if</span>(t1 == <span class="built_in">null</span> <span class="subst">||</span> t2 == <span class="built_in">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(t1<span class="built_in">.</span>val != t2<span class="built_in">.</span>val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="built_in">queue</span><span class="built_in">.</span>offer(t1<span class="built_in">.</span>left);</span><br><span class="line">           <span class="built_in">queue</span><span class="built_in">.</span>offer(t2<span class="built_in">.</span>right);</span><br><span class="line">           <span class="built_in">queue</span><span class="built_in">.</span>offer(t1<span class="built_in">.</span>right);</span><br><span class="line">           <span class="built_in">queue</span><span class="built_in">.</span>offer(t2<span class="built_in">.</span>left);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>因为树的每一个节点都需要遍历到，所以算法的时间复杂度为O(n)。另外还需要额外的空间，最坏情况我们需要将全部节点插入队列中，所以空间复杂度为O(n)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example,]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树的层次遍历]]></title>
    <link href="http://blog.noobsky.com/2016/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>http://blog.noobsky.com/2016/05/05/二叉树的层次遍历/</id>
    <published>2016-05-05T02:28:49.000Z</published>
    <updated>2016-05-05T03:44:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="二叉树的层次遍历">二叉树的层次遍历</h3><p>二叉树的层次遍历是指从上往下，从左往右按层打印树的每个节点。一般可以使用DFS和BFS的方法。<br>首先给出二叉树的代码：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     int <span class="variable"><span class="keyword">val</span>;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode(int x) &#123; <span class="keyword">val</span></span> = x; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用BFS思想的代码如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">    <span class="comment">//对一般的分层遍历稍加改进，就能实现分行打印每一层</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一般的分层遍历都是每次循环从队列头中取出一个元素然后将其左右节点分别入队列，</span></span><br><span class="line">        TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">        res<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">        <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>left);</span><br><span class="line">        <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>right);            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展一">扩展一</h3><p>一般的二叉树的层次遍历所有结点都输出在同一行。如果希望仅仅同层结点输出在同一行，该如何修改代码？我们稍微修改一下上面的二叉树的层次遍历即可，详细见下面代码的注释。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">    <span class="comment">//对一般的分层遍历稍加改进，就能实现分行打印每一层</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">        <span class="comment">//先不急着出队列，记录队列的大小，相当于每层元素的个数</span></span><br><span class="line">        int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//一般的分层遍历都是每次循环从队列头中取出一个元素然后将其左右节点分别入队列，</span></span><br><span class="line">        <span class="comment">//改进后就是每次从队列头中取出levelNumber个元素,</span></span><br><span class="line">        <span class="comment">//然后将每个元素的左右节点分别入队列。</span></span><br><span class="line">        f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">            <span class="comment">//使用peek可以节省一个局部变量</span></span><br><span class="line">            <span class="comment">// if(queue.peek().left != null) queue.add(queue.peek().left);</span></span><br><span class="line">            <span class="comment">// if(queue.peek().right != null) queue.add(queue.peek().right);</span></span><br><span class="line">            <span class="comment">// subList.add(queue.poll().val);</span></span><br><span class="line">            <span class="comment">//使用局部变量,测试发现速度能稍微快一点</span></span><br><span class="line">            TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">            subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">            <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>left);</span><br><span class="line">            <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>right);</span><br><span class="line">        &#125;</span><br><span class="line">        res<span class="built_in">.</span>add(subList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实我们也可以使用DFS的思想，代码如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(level &gt;= res<span class="built_in">.</span>size())&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res<span class="built_in">.</span>get(level)<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level+<span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展二">扩展二</h3><p>前面的讨论都是从上往下、从左往右分层遍历二叉树，那么如果希望自下往上、从左右往右遍历二叉树，该如何修改代码呢？<br>方法很简单，我们只要把扩展一中的结果反转一下就可以了。详见下面的代码。<br>使用BFS思想:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//使用LinkedList，不使用ArrayList，原因见后面</span></span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//将root加入队列中</span></span><br><span class="line">        <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">        <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">            int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">            LinkedList&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> LinkedList();</span><br><span class="line">            f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">                subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>left);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//总是在0索引的位置插入每一层的遍历结果，最后遍历res的时候结果就是反过来的，即从下往上分层遍历</span></span><br><span class="line">            <span class="comment">//这里之所以使用LinkedList的原因是ArrayList的底层是数组，插入元素时需要移动大量的元素，效率低</span></span><br><span class="line">            <span class="comment">//而LinkedList的底层是链表，插入操作非常高效</span></span><br><span class="line">            res<span class="built_in">.</span>add(<span class="number">0</span>,subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用DFS思想：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrderBottom(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res<span class="built_in">.</span>size() &lt;= level)&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="number">0</span>, <span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res<span class="built_in">.</span>get(res<span class="built_in">.</span>size()-<span class="number">1</span><span class="attribute">-level</span>)<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level + <span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="二叉树的层次遍历">二叉树的层次遍历</h3><p>二叉树的层次遍历是指从上往下，从左往右按层打印树的每个节点。一般可以使用DFS和BFS的方法。<br>首先给出二叉树的代码：<br><figure class="highlight kotlin"><table>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Implement Queue using Stacks]]></title>
    <link href="http://blog.noobsky.com/2016/05/04/LeetCode-Implement-Queue-using-Stacks/"/>
    <id>http://blog.noobsky.com/2016/05/04/LeetCode-Implement-Queue-using-Stacks/</id>
    <published>2016-05-04T13:30:27.000Z</published>
    <updated>2016-05-05T03:47:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Implement the following operations of a queue using stacks.</p>
<p>push(x) – Push element x to the back of queue.<br>pop() – Removes the element from in front of queue.<br>peek() – Get the front element.<br>empty() – Return whether the queue is empty.<br>Notes:<br>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.<br>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.<br>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</p>
<p>题意很容易理解，就是利用栈实现队列的功能，我们知道栈是FILO即先进后出，而队列是FIFO即先进先出，我们如何才能利用栈的先进后出实现队列的先进先出呢？答案就是利用两个栈，一个栈是先进后出，两个先进后出的结果就是先进先出就是队列的功能。先把元素压入（push）第一个栈inputStack，然后从第一个栈inputStack中弹栈（pop），接着将弹出的元素压入（push）到第二个栈outputStack中。这样做之后我们先进栈的元素将位于第二个栈outputStack中栈顶，当我们需要从队头取出元素时（pop）时，我们只要在第二个栈outputStack中弹栈（pop）即可。当我们需要向队尾放入元素（push）时，我们向第一个栈inputStack中压入元素（push）即可。这样第一个栈inputStack相当于队尾，第二个栈outputStack相当于队头。</p>
<p>算法思想已经理解，但是实现起来还是有需要注意的地方，下面是我一开始写的代码：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack&lt;Integer&gt; outputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = outputStack.<span class="keyword">pop</span>();</span><br><span class="line">            inputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStack.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">pop</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        outputStack.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> peek() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> inputStack.isEmpty() &amp;&amp; outputStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试之后发现结果不对，比如当我们执行<code>push(1),push(2),peek,push(3),peek</code>后发现输出为1、3，但是正确的输出应该为1。错误的原因如下：开始我们向inputStack压入1、2，然后第一次peek的时候，我们依次从inputStack弹出2、1然后压入outputStack，此时元素是反转过来变成了先进先出，因此我们peek的时候输出1，接着向栈inputStack压入3，最后peek的时候又直接将3压入outpuStack中，这时3和1、2的顺序是错误的。然后我的修改是往inputStack中push元素的时候将outputStack中元素弹出再反压入inputStack中保持元素的顺序，代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack&lt;Integer&gt; outputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = outputStack.<span class="keyword">pop</span>();</span><br><span class="line">            inputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStack.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">pop</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        outputStack.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> peek() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> inputStack.isEmpty() &amp;&amp; outputStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试通过，但是这样写性能太低了，时间复杂度有点大。其实push元素的时候我们不需要将元素反压入inputStack中，而是在pop或者peek时，只在outputStack为空时才将inputStack中的元素弹出然后反压入outputStack中。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack&lt;Integer&gt; outputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        inputStack.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">pop</span>() &#123;</span><br><span class="line">    	<span class="comment">//这段代码跟peek中的重复，可以直接调用peek替代</span></span><br><span class="line">        <span class="keyword">if</span>(outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        outputStack.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> peek() &#123;</span><br><span class="line">        <span class="keyword">if</span>(outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> inputStack.isEmpty() &amp;&amp; outputStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Implement the following operations of a queue using stacks.</p>
<p>push(x) – Push element x to the back of queue.<]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Swap Nodes in Pairs]]></title>
    <link href="http://blog.noobsky.com/2016/05/02/LeetCode-Swap-Nodes-in-Pairs/"/>
    <id>http://blog.noobsky.com/2016/05/02/LeetCode-Swap-Nodes-in-Pairs/</id>
    <published>2016-05-02T05:52:39.000Z</published>
    <updated>2016-05-05T03:46:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
<p>这个题目的思想很简单，但是要想写对代码还是有点繁琐的，稍微不慎可能就蒙圈了。<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode swapPairs(ListNode head)&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">       </span><br><span class="line">       ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       dummy.<span class="keyword">next</span> = head;</span><br><span class="line">       ListNode current = dummy;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>(current.<span class="keyword">next</span> != <span class="literal">null</span> &amp;&amp; current.<span class="keyword">next</span>.<span class="keyword">next</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">           ListNode first = current.<span class="keyword">next</span>;</span><br><span class="line">           ListNode second = current.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">           </span><br><span class="line">           first.<span class="keyword">next</span> = second.<span class="keyword">next</span>;</span><br><span class="line">           current.<span class="keyword">next</span> = second;</span><br><span class="line">           second.<span class="keyword">next</span> = first;//或者是current.<span class="keyword">next</span>.<span class="keyword">next</span> = first;</span><br><span class="line">           </span><br><span class="line">           current = current.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们就以1-&gt;2-&gt;3-&gt;4为例，第一对邻接节点1和2的交换过程示意图如下：<br>初始化，执行<code>ListNode first = current.next; ListNode second = current.next.next;</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes1.png" alt=""></p>
<p>执行<code>first.next = second.next</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes2.png" alt=""></p>
<p>执行<code>current.next = second</code>之后<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes3.png" alt=""></p>
<p>执行<code>second.next = first</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes4.png" alt=""></p>
<p>执行<code>current = current.next.next</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes5.png" alt=""></p>
<p>之后进入下一次循环，过程类似。</p>
<p>其实该题更简洁的方法是使用递归，代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode swapPairs(ListNode head)&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">       </span><br><span class="line">       ListNode temp = head.<span class="keyword">next</span>;</span><br><span class="line">       head.<span class="keyword">next</span> = swapPairs(head.<span class="keyword">next</span>.<span class="keyword">next</span>);</span><br><span class="line">       temp.<span class="keyword">next</span> = head;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock系列]]></title>
    <link href="http://blog.noobsky.com/2016/04/30/Best-Time-to-Buy-and-Sell-Stock/"/>
    <id>http://blog.noobsky.com/2016/04/30/Best-Time-to-Buy-and-Sell-Stock/</id>
    <published>2016-04-30T10:49:01.000Z</published>
    <updated>2016-05-05T03:47:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Best_Time_to_Buy_and_Sell_Stock">Best Time to Buy and Sell Stock</h2><h3 id="题目描述">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>开始我对这个题目不是很理解，存在一些误区，然后看了一个歪果仁的更清楚的说明：<br>If you were only permitted to complete at most one buy and at most one sell during the whole period of days, design an algorithm such that your profit, i.e., sell price minus buy price, is maximized. Note that you can only not sell a stock before you buy one.</p>
<p>For example:</p>
<p>[1,2,3,4] ==&gt; returns 3 (buy at 1 and sell at 4)</p>
<p>[4,3,2,1] ==&gt; returns 0 (don’t buy)</p>
<p>[4,10,25,2,10] ==&gt; returns 21 (buy at 4 and sell at 25)</p>
<p>题目大意是说整个期间你最多只能买一次股票然后只能卖出一次，当然也可以不买股票。设计一个算法计算最大收益。<br>该问题可以使用动态规划解决，设dp[i]是[0,1,2…i]区间的最大利润，则该问题的一维动态规划方程如下：<br>dp[i+1] = max{dp[i], prices[i+1] - minPrices},minPrices是区间[0,1,2…,i]内的最低价格,我们要求解的最大利润 = max{dp[0], dp[1], dp[2], …, dp[n-1]} 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> maxProfit=<span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           <span class="comment">//最大收益</span></span><br><span class="line">           maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">           <span class="comment">//保存最小的price</span></span><br><span class="line">           minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果我们不再从每日的股票价格的角度去看待输入数据，而是考察每日股票价格的变化，第i天的股票价格变化定义为第i天和第i-1的价格差。并将这些价格差看做一个新数组A{prices[1]-prices[0], prices[2]-prices[1], prices[3]-prices[2], …, prices[n-1]-prices[n-2]}，那么问题就转化为寻找新数组A的最大子数组和。最大子数组和也是一个DP问题，详见维基百科<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank" rel="external">Maximum subarray problem</a>和本博客的博文最大子数组和。最大子数组和的Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_subarray</span><span class="params">(A)</span>:</span></span><br><span class="line">    max_ending_here = max_so_far = A[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> A[<span class="number">1</span>:]:</span><br><span class="line">        max_ending_here = max(x, max_ending_here + x)</span><br><span class="line">        max_so_far = max(max_so_far, max_ending_here)</span><br><span class="line">    <span class="keyword">return</span> max_so_far</span><br></pre></td></tr></table></figure>
<p>根据最大子数组和的程序，利用最大子数组和算法解决本股票问题的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxEndingHere = prices[<span class="number">1</span>] - prices[<span class="number">0</span>], maxSoFar = prices[<span class="number">1</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            maxEndingHere = Math.max(prices[i] - prices[i-<span class="number">1</span>], maxEndingHere+prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最大收益为负数，则不买股票，返回0</span></span><br><span class="line">        <span class="keyword">return</span> maxSoFar &gt; <span class="number">0</span> ? maxSoFar : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码可能不够直观，可以使用额外的O(n)的内存空间来存股票价格变化数组，更为直观的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span>[] diffPrices = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length-<span class="number">1</span>];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           diffPrices[i-<span class="number">1</span>] = prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> res = maxSubarray(diffPrices);</span><br><span class="line">       <span class="keyword">return</span> res &gt; <span class="number">0</span> ? res : <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> maxEndingHere = arr[<span class="number">0</span>],maxSoFar = arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">           maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);</span><br><span class="line">           maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxSoFar;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_II">Best Time to Buy and Sell Stock II</h2><h3 id="题目描述-1">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>在上一题的基础上，可以买卖多次股票，但是再买股票时必须把之前的股票卖出去，也就是说手上最多只能有一只股票。可以找到所有价格的递增区间，把这些递增区间的收益全部加起来就是最后的最大收益。代码有以下两种写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码一：</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> length = prices.length;</span><br><span class="line">       <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//注意循环结束条件是i &lt; length-1,如果是i &lt; length在&#123;1，2&#125;会陷入死循环</span></span><br><span class="line">       <span class="keyword">while</span>(i &lt; length - <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">while</span>(i+<span class="number">1</span> &lt; length &amp;&amp; prices[i+<span class="number">1</span>] &gt;= prices[i])&#123;</span><br><span class="line">               profit += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">               i++;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">while</span>(i+<span class="number">1</span> &lt; length &amp;&amp; prices[i+<span class="number">1</span>] &lt; prices[i]) i++;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> profit;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//代码二：</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(prices[i+<span class="number">1</span>] &gt; prices[i]) profit += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> profit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_III">Best Time to Buy and Sell Stock III</h2><h3 id="题目描述-2">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>这一题是最多只能买卖两次股票，求最大收益，同理手上最多只能有一只股票。因为不能连续买入两次股票，所以买卖两次肯定分布在两个不同区间。容易想到的解决办法是，把prices[] 分成两部分prices[0…m] 和 prices[m…length]  ，分别计算在这两部分内做交易的做大收益。在每个区间的问题又回到了I的情况。由于做n次划分，每次划分后求解的时间复杂度为O(n),所以总的时间复杂度为O(n<sup>2</sup>)，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n*n) time limit exceeded</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           maxProfit = Math.max(maxProfit,maxProfitOnce(prices, <span class="number">0</span>, i) + maxProfitOnce(prices, i, prices.length -<span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfitOnce</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> minPrice = prices[start];</span><br><span class="line">       <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">           maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">           minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是由于时间复杂度为O(n<sup>2</sup>)，效率低，运行超时。可以利用动态规划的思想进行改进，保持计算的中间结果，减少重复的计算。那就是第一步扫描，先计算出子序列[0,…,i]中的最大利润，用一个数组保存下来，那么时间是O(n)。计算方法也是利用第一个问题的计算方法。第二步是逆向扫描，计算子序列[i,…,n-1]上的最大利润，这一步同时就能结合上一步的结果计算最终的最大利润了，这一步也是O(n)。 所以最后算法的复杂度就是O(n)的。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] maxProfitFromHead = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        maxProfitFromHead[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">            maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">            maxProfitFromHead[i] = maxProfit;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxPrice = prices[prices.length -<span class="number">1</span>];</span><br><span class="line">        maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> finalMaxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.length -<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            maxPrice = Math.max(prices[i], maxPrice);</span><br><span class="line">            maxProfit = Math.max(maxProfit, maxPrice - prices[i]);</span><br><span class="line">            finalMaxProfit = Math.max(finalMaxProfit, maxProfit + maxProfitFromHead[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> finalMaxProfit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Best_Time_to_Buy_and_Sell_Stock">Best Time to Buy and Sell Stock</h2><h3 id="题目描述">题目描述</h3><p>Say you have an array for which the i]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Happy Number与Floyd判圈算法]]></title>
    <link href="http://blog.noobsky.com/2016/04/30/Happy-Number%E4%B8%8EFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.noobsky.com/2016/04/30/Happy-Number与Floyd判圈算法/</id>
    <published>2016-04-30T04:46:38.000Z</published>
    <updated>2016-05-05T03:46:35.000Z</updated>
    <content type="html"><![CDATA[<p>最近在刷LeetCode的时候，遇到一题为Happy Number的题，该题最容易想到的思路就是利用集合，还有一个很巧妙的解法就是利用Floyd判圈算法来做，下面就来看看。</p>
<h3 id="题目描述">题目描述</h3><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example: 19 is a happy number</p>
<p>1<sup>2</sup> + 9<sup>2</sup> = 82<br>8<sup>2</sup> + 2<sup>2</sup> = 68<br>6<sup>2</sup> + 8<sup>2</sup> = 100<br>1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1</p>
<p>最直接的解法就是利用集合来判断各位的平方和是否已经出现过，如果出现过，则不是Happy Number。代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, digit;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            digit = n % <span class="number">10</span>;</span><br><span class="line">            sum += digit * digit;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">set</span>.add(n))&#123;</span><br><span class="line">            n = digitSquareSum(n);</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去讨论区里发现了一种利用Floyd判圈算法的解法非常巧妙，下面就来介绍一下Floyd判圈算法（Floyd Cycle Detection Algorithm）。</p>
<p>Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)。该算法由美国科学家罗伯特·弗洛伊德发明，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。</p>
<p>Floyd判圈算法的基本思想可以用我们跑步的例子来解释，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。</p>
<p>基于上面的想法，Floyd算法用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果是等价的，只要一个比另一个快就行，从后面的讨论我们可以看出这一点）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没环。详见维基百科<a href="https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare" target="_blank" rel="external">Cycle detection</a></p>
<p>下面从数学的角度来推导一下：<br>乌龟和兔子从起点同时出发，首先假设乌龟每次走一步，兔子每次走两步，则乌龟和兔子最后必定会相遇。<br>借用这张经典的解析图：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/floyd_cycle_detection.jpg" alt=""><br>假设乌龟走的路程为L，兔子走的路程为2L，则有如下等式：<br>1) L = m + p <em> n + k<br>2) 2L = m + q </em> n + k<br>这里的p和q分别为乌龟和兔子在环里走的圈数（q&gt;p）。由1）和2）式可得：<br> 2( m + p <em> n + k ) = m + q </em> n + k<br> =&gt; 2m + 2pn + 2k = m + nq + k<br> =&gt; m + k = (q - 2p)n<br>因此，如果我们能够证明至少有一种k, p, q的值可以使得这个等式成立，我们就证明了假设成立。这里我们只要使p=0，q=m，k=mn-m，上式成立。</p>
<p>下面我们来解决第二个问题，即环的起点在哪里。<br>当乌龟和兔子相遇后，我们让乌龟放回链表起点，兔子留在相遇点，然后他们以相同的速度前进（都是一次一步），则乌龟和兔子将会在在环的起点处相遇。为什么？下面来推导一下。<br>假设让乌龟走m+k步，则乌龟会到达之前跟兔子的相遇点，前面我们已经证明m + k = (q - 2p)n，也就是说m+k是环路长度n的整数倍，同时，兔子绕环路（q-2p）圈后也回到该点（距离环路起点k步处）。我们不是让乌龟走m+k步而是只走m步，则乌龟会到达环路的起点处，而兔子此时还差k步才走完（q-2p）圈环路，而兔子是从离环路起点k步的地方开始走的，所以此时兔子也走到环路起点处。该算法还能用来判断链表中是否有环及找出环的起点，详见()[]。下面是Floyd判圈算法的python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floyd</span><span class="params">(f, x0)</span>:</span></span><br><span class="line">    <span class="comment"># Main phase of algorithm: finding a repetition x_i = x_2i.</span></span><br><span class="line">    <span class="comment"># The hare moves twice as quickly as the tortoise and</span></span><br><span class="line">    <span class="comment"># the distance between them increases by 1 at each step.</span></span><br><span class="line">    <span class="comment"># Eventually they will both be inside the cycle and then,</span></span><br><span class="line">    <span class="comment"># at some point, the distance between them will be</span></span><br><span class="line">    <span class="comment"># divisible by the period λ.</span></span><br><span class="line">    tortoise = f(x0) <span class="comment"># f(x0) is the element/node next to x0.</span></span><br><span class="line">    hare = f(f(x0))</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        tortoise = f(tortoise)</span><br><span class="line">        hare = f(f(hare))</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># At this point the tortoise position, ν, which is also equal</span></span><br><span class="line">    <span class="comment"># to the distance between hare and tortoise, is divisible by</span></span><br><span class="line">    <span class="comment"># the period λ. So hare moving in circle one step at a time, </span></span><br><span class="line">    <span class="comment"># and tortoise (reset to x0) moving towards the circle, will </span></span><br><span class="line">    <span class="comment"># intersect at the beginning of the circle. Because the </span></span><br><span class="line">    <span class="comment"># distance between them is constant at 2ν, a multiple of λ,</span></span><br><span class="line">    <span class="comment"># they will agree as soon as the tortoise reaches index μ.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the position μ of first repetition.    </span></span><br><span class="line">    mu = <span class="number">0</span></span><br><span class="line">    tortoise = x0</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        tortoise = f(tortoise)</span><br><span class="line">        hare = f(hare)   <span class="comment"># Hare and tortoise move at same speed</span></span><br><span class="line">        mu += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Find the length of the shortest cycle starting from x_μ</span></span><br><span class="line">    <span class="comment"># The hare moves one step at a time while tortoise is still.</span></span><br><span class="line">    <span class="comment"># lam is incremented until λ is found.</span></span><br><span class="line">    lam = <span class="number">1</span></span><br><span class="line">    hare = f(tortoise)</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        hare = f(hare)</span><br><span class="line">        lam += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> lam, mu</span><br></pre></td></tr></table></figure>
<p>好了，现在回到Happy Number本身。如果一个数不是Happy Number，则计算该数的各位的平方和时会出现环路，则我们可以利用Floyd判圈算法来做，慢“指针”（乌龟）每次计算一次Number的各位的平方和，快“指针”（兔子）每次计算两次Number的每位的平方和。如果慢指针和快指针相遇（计算的Number的每位平方和相等），则Number不是Happy的。反之最后计算的值都为1，则为Happy Number。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, digit;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            digit = n % <span class="number">10</span>;</span><br><span class="line">            sum += digit * digit;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow=n, fast = n;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = digitSquareSum(slow);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        <span class="keyword">if</span>(slow == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在刷LeetCode的时候，遇到一题为Happy Number的题，该题最容易想到的思路就是利用集合，还有一个很巧妙的解法就是利用Floyd判圈算法来做，下面就来看看。</p>
<h3 id="题目描述">题目描述</h3><p>Write an algorithm t]]>
    </summary>
    
      <category term="Floyd判圈算法" scheme="http://blog.noobsky.com/tags/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[罗马数字和阿拉伯数字的相互转换]]></title>
    <link href="http://blog.noobsky.com/2016/04/28/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E5%92%8C%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
    <id>http://blog.noobsky.com/2016/04/28/罗马数字和阿拉伯数字的相互转换/</id>
    <published>2016-04-28T06:37:29.000Z</published>
    <updated>2016-05-05T03:46:20.000Z</updated>
    <content type="html"><![CDATA[<p>罗马数字基本字符和阿拉伯数字的对应关系</p>
<table>
<thead>
<tr>
<th>Roman Literal</th>
<th>Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
</tbody>
</table>
<h3 id="记数方法">记数方法</h3><ul>
<li>相同的数字连写、所表示的数等于这些数字相加得到的数、如：Ⅲ=3；</li>
<li>小的数字在大的数字的右边、所表示的数等于这些数字相加得到的数、 如：Ⅷ=8、Ⅻ=12；</li>
<li>小的数字、（限于 Ⅰ、X 和 C）在大的数字的左边、所表示的数等于大数减小数得到的数、如：Ⅳ=4、Ⅸ=9；</li>
<li>正常使用时、连写的数字重复不得超过三次；</li>
<li>在一个数的上面画一条横线、表示这个数扩大 1000 倍。</li>
</ul>
<h3 id="组数规则">组数规则</h3><ul>
<li>基本数字 Ⅰ、X 、C 中的任何一个、自身连用构成数目、或者放在大数的右边连用构成数目、都不能超过三个；放在大数的左边只能用一个；</li>
<li>不能把基本数字 V 、L 、D 中的任何一个作为小数放在大数的左边采用相减的方法构成数目；放在大数的右边采用相加的方式构成数目、只能使用一个；</li>
<li>V 和 X 左边的小数字只能用 Ⅰ；</li>
<li>L 和 C 左边的小数字只能用X；</li>
<li>D 和 M 左边的小数字只能用 C。</li>
</ul>
<h3 id="罗马数字转阿拉伯数字">罗马数字转阿拉伯数字</h3><h4 id="题目描述">题目描述</h4><p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<ul>
<li>从左往右遍历转换</li>
</ul>
<p>初始化结果为0，然后从左往右遍历罗马数字，如果某个数比左边一个数小，则把该数加入到结果中；反之（即某个数比左边一个数大），则在结果中两次减去前一个数并加上当前这个数。这里解释一下后者，比如罗马数字IV，开始时遍历到I，然后将结果加1，接着遇到了V，我们知道V的前面出现了一个比V小的的I，所以我们需要从V中减去I，但是我们前面已经加过I，所以我们需要减去两倍的I。下面看一个更复杂的例子：</p>
<table>
<thead>
<tr>
<th>Roman literals from left to right</th>
<th>Accumulated total</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>1000</td>
</tr>
<tr>
<td>MX</td>
<td>1000 + 10 = 1010</td>
</tr>
<tr>
<td>MXC</td>
<td>1010 + (100 - 2 * 10) = 1010 + 80 = 1090</td>
</tr>
<tr>
<td>MXCV</td>
<td>1090 + 5 = 1095</td>
</tr>
<tr>
<td>MXCVI</td>
<td>1095 + 1 = 1096</td>
</tr>
</tbody>
</table>
<p>代码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="built_in">map</span>.get(s.charAt(i));</span><br><span class="line">            sum += (curr &gt; pre) ? (curr - <span class="number">2</span> * pre):curr;</span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>从右往左遍历转换</li>
</ul>
<p>其实更直观的转换方式是从右往左转换，如果某个数大于等于右边的数，则直接加入到结果中；反之，从结果中减去该数。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="built_in">map</span>.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(curr &gt;= pre)&#123;</span><br><span class="line">                sum += curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum -= curr;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="阿拉伯数字转罗马数字">阿拉伯数字转罗马数字</h3><h4 id="题目描述-1">题目描述</h4><p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<p>把所有小数字在前的组合也作为基本数字，对应的数值表如下：</p>
<table>
<thead>
<tr>
<th>Roman Literal</th>
<th>Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>IV</td>
<td>4</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>IX</td>
<td>9</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>XL</td>
<td>40</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>XC</td>
<td>90</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>CD</td>
<td>400</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>CM</td>
<td>900</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> values[] = &#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        String[] symbols = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = num / values[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++)&#123;</span><br><span class="line">                sb.append(symbols[i]);</span><br><span class="line">                num -= values[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>罗马数字基本字符和阿拉伯数字的对应关系</p>
<table>
<thead>
<tr>
<th>Roman Literal</th>
<th>Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>1</td>
</]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximum Depth of Binary Tree二叉树的深度]]></title>
    <link href="http://blog.noobsky.com/2016/04/26/Maximum-Depth-of-Binary-Tree%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://blog.noobsky.com/2016/04/26/Maximum-Depth-of-Binary-Tree二叉树的深度/</id>
    <published>2016-04-26T07:43:33.000Z</published>
    <updated>2016-05-05T03:46:56.000Z</updated>
    <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>最直接的方式是递归方法，树的深度为左右子树深度最大值+1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法是使用广度搜索的方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth2</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">queue</span>.offer(root);</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="built_in">queue</span>.size();</span><br><span class="line">		<span class="comment">//让每一层的节点依次出队列，并把左右子节点加入队列中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">			TreeNode node = <span class="built_in">queue</span>.poll();</span><br><span class="line">			<span class="keyword">if</span>(node.left != null)&#123;</span><br><span class="line">				<span class="built_in">queue</span>.offer(node.left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(node.right != null)&#123;</span><br><span class="line">				<span class="built_in">queue</span>.offer(node.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="问题描述">问题描述</h3><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest pat]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nim Game]]></title>
    <link href="http://blog.noobsky.com/2016/04/26/Nim-Game/"/>
    <id>http://blog.noobsky.com/2016/04/26/Nim-Game/</id>
    <published>2016-04-26T03:03:39.000Z</published>
    <updated>2016-05-05T03:47:01.000Z</updated>
    <content type="html"><![CDATA[<p>今天遇到LeetCode上一道题叫Nim Game，虽然可以用程序解决，但感觉更像是一道数学题，游戏题。</p>
<h3 id="题目描述">题目描述</h3><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
<p><strong>Hint:</strong></p>
<p>If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?</p>
<p>根据题目描述可知，当n==1、2、3时，先手必赢，因为先手都可以一次性把石头移完。<br>当n==4时，先手必输，题目描述中也提到了这个，因为不管先手拿1、2、3个，对手都会拿走剩下的石头<br>当n==5，6，7，先手必赢，先手分别取走1、2、3颗石头，则后手的状态转化为n==4的情况，所以此时后手必输<br>当n==8时，无论先手第一轮拿1、2、3颗石头，下一轮后手都是转化为n==5、6、7的情况，此时先手必输。<br>当n==9,10,11，先手必赢，先手分别取走1、2、3颗石头，则后手的状态转化为n==8的情况，所以此时后手必输<br>……<br>以此类推，我们得出的结论是：<br>当数量是4的倍数时，即n % 4 == 0时，先手必输，否则先手必赢<br>有了上面的结论编写程序就很容易了，如下，但是想到上面的结论不太容易…..<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然想不到上面的数学解法，我们可以通过程序来解决<br>首先来个容易想到的递归解法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//如果不管先手拿1、2、3颗石头，后手都赢，那么先手必输</span></span><br><span class="line">       <span class="keyword">if</span>(canWinNim(n - <span class="number">1</span>) &amp;&amp; canWinNim(n - <span class="number">2</span>) &amp;&amp; canWinNim(n - <span class="number">3</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>递归解法会计算太多的重复值，可以证明程序的运行时间是指数级增长的，在LeetCode上当n==41时程序就已经超时了。<br>我们可以采用带备忘的（memoized）的方法记住已经计算过了的结果，程序如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">canWinNim2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    boolean[] dp = <span class="keyword">new</span> boolean[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = dp[<span class="number">3</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">        dp[i] = !(dp[i-<span class="number">1</span>] &amp;&amp; dp[i-<span class="number">2</span>] &amp;&amp; dp[i-<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这个程序在输入n非常大的时候，内存会超过限制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天遇到LeetCode上一道题叫Nim Game，虽然可以用程序解决，但感觉更像是一道数学题，游戏题。</p>
<h3 id="题目描述">题目描述</h3><p>You are playing the following Nim Game with your frien]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reverse String 反转字符串]]></title>
    <link href="http://blog.noobsky.com/2016/04/26/Reverse-String-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://blog.noobsky.com/2016/04/26/Reverse-String-反转字符串/</id>
    <published>2016-04-26T01:41:43.000Z</published>
    <updated>2016-05-05T03:47:07.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Write a function that takes a string as input and returns the string reversed.</p>
<p><strong>Example:</strong><br>Given s = “hello”, return “olleh”.</p>
<p>首先我想到的思路是将输入字符串转换为char数组，然后将字符反转最后返回字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] temp = s.toCharArray();</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temp.length-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者不借助StringBuffer或StringBuilder的帮忙。<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        char[] <span class="keyword">in</span> = s.toCharArray();</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = <span class="keyword">in</span>.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</span><br><span class="line">			char temp = <span class="keyword">in</span>[<span class="built_in">left</span>];</span><br><span class="line">			<span class="keyword">in</span>[<span class="built_in">left</span>] = <span class="keyword">in</span>[<span class="built_in">right</span>];</span><br><span class="line">			<span class="keyword">in</span>[<span class="built_in">right</span>] = temp;</span><br><span class="line">			<span class="built_in">left</span>++;</span><br><span class="line">			<span class="built_in">right</span>--;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return <span class="keyword">new</span> <span class="built_in">String</span>(<span class="keyword">in</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是其他一些常用解法，使用byte<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        byte[] bytes = s.getBytes();</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = bytes.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</span><br><span class="line">        	byte temp = bytes[<span class="built_in">left</span>];</span><br><span class="line">        	bytes[<span class="built_in">left</span>] = bytes[<span class="built_in">right</span>];</span><br><span class="line">        	bytes[<span class="built_in">right</span>] = temp;</span><br><span class="line">        	<span class="built_in">left</span>++;</span><br><span class="line">        	<span class="built_in">right</span>--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return <span class="keyword">new</span> <span class="built_in">String</span>(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>交互两个变量值最常使用的方法是使用一个临时变量temp，还有一种比较巧妙的方法就是使用异或运算<br>比如交互变量a和b：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> = a<span class="regexp"> ^</span> b;</span><br><span class="line"><span class="title">b</span> = b<span class="regexp"> ^</span> a;</span><br><span class="line"><span class="title">a</span> = b<span class="regexp"> ^</span> a;</span><br></pre></td></tr></table></figure></p>
<p>因为异或有两个特性：</p>
<ul>
<li>一个数异或自身恒等于0，比如6^6恒等于0；</li>
<li>一个数异或0恒等于自身，比如6^0恒等于6。</li>
</ul>
<p>所以不使用临时变量的交互则代码如下：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        byte[] bytes = s.getBytes();</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = bytes.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</span><br><span class="line">        	bytes[<span class="built_in">left</span>] = (byte)(bytes[<span class="built_in">left</span>] ^ bytes[<span class="built_in">right</span>]);</span><br><span class="line">        	bytes[<span class="built_in">right</span>] = (byte)(bytes[<span class="built_in">left</span>] ^ bytes[<span class="built_in">right</span>]);</span><br><span class="line">        	bytes[<span class="built_in">left</span>] = (byte)(bytes[<span class="built_in">left</span>] ^ bytes[<span class="built_in">right</span>]);</span><br><span class="line">        	<span class="built_in">left</span>++;</span><br><span class="line">        	<span class="built_in">right</span>--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return <span class="keyword">new</span> <span class="built_in">String</span>(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实自己不够熟悉StringBuffer或StringBuilder的api，既然想到用它们，就应该想起它们都有reverse方法，所以代码so easy：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String reverseString(String s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer(s).<span class="keyword">reverse</span>().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后也可以使用递归的方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        String leftString = s.substring(<span class="number">0</span>, length &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        String rightString = s.substring(length &gt;&gt; <span class="number">2</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverseString(leftString) + reverseString(rightString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Write a function that takes a string as input and returns the string reversed.</p>
<p><strong>Example:</strong><br]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <link href="http://blog.noobsky.com/2016/04/18/Java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://blog.noobsky.com/2016/04/18/Java序列化/</id>
    <published>2016-04-18T12:53:50.000Z</published>
    <updated>2016-04-18T12:53:50.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
</feed>
