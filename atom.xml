<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-06-13T16:10:44.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Construct Binary Tree from Preorder/Postorder and Inorder Traversal]]></title>
    <link href="http://blog.noobsky.com/2016/06/13/LeetCode-Construct-Binary-Tree-from-Preorder-Postorder-and-Inorder-Traversal/"/>
    <id>http://blog.noobsky.com/2016/06/13/LeetCode-Construct-Binary-Tree-from-Preorder-Postorder-and-Inorder-Traversal/</id>
    <published>2016-06-13T15:29:51.000Z</published>
    <updated>2016-06-13T16:10:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal">Construct Binary Tree from Preorder and Inorder Traversal</h2><h3 id="题目描述">题目描述</h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong> Note: </strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>preorder[0]一定是树的根，然后在inorder中找到preorder[0],将inorder分成了两部分，前半部分是preorder[0]的左子树，右半部分是preorder[0]的右子树，然后在子数组中递归处理。</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == null || inorder == null || preorder.length != inorder.length) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//preorder[0]一定是树的根，然后在inorder中找到preorder[0],将inorder分成了两部分，前半部分是preorder[0]</span></span><br><span class="line">    <span class="comment">//的左子树，右半部分是preorder[0]的右子树，然后在子数组中递归处理。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preorder.length - <span class="number">1</span> || inStart &gt; inEnd) <span class="keyword">return</span> null;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出preorder[preStart]在inorder中的下标</span></span><br><span class="line">        <span class="comment">//题目中假设没有重复元素</span></span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == preorder[preStart])&#123;</span><br><span class="line">                inIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.left = helper(preStart + <span class="number">1</span>, inStart, inIndex - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">        <span class="comment">//右子树根节点的索引：preStart + inIndex - inStart + 1，稍微举个例子算算就可以了</span></span><br><span class="line">        root.right = helper(preStart + inIndex - inStart + <span class="number">1</span>, inIndex + <span class="number">1</span>, inEnd, preorder, inorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法每次都要到inorder中线性搜索root节点的index，如果我们构造的的二叉树是平衡的，那么时间复杂度为O(nlgn)。如果构造的树退化为单链表（每个节点只有左/右节点），那么久需要O(n)的时间复杂度。我们可以使用HashMap缓存inorder中值和对应的index，将时间复杂度降到O(n)。修改后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == null || inorder == null || preorder.length != inorder.length) <span class="keyword">return</span> null;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, inorder, <span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//preorder[0]一定是树的根，然后在inorder中找到preorder[0],将inorder分成了两部分，前半部分是preorder[0]</span></span><br><span class="line">    <span class="comment">//的左子树，右半部分是preorder[0]的右子树，然后在子数组中递归处理。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, Map&lt;Integer, Integer&gt; <span class="built_in">map</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preorder.length - <span class="number">1</span> || inStart &gt; inEnd) <span class="keyword">return</span> null;</span><br><span class="line">    </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出preorder[preStart]在inorder中的下标</span></span><br><span class="line">        <span class="comment">//题目中假设没有重复元素</span></span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="built_in">map</span>.get(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        root.left = helper(preStart + <span class="number">1</span>, inStart, inIndex - <span class="number">1</span>, preorder, inorder, <span class="built_in">map</span>);</span><br><span class="line">        <span class="comment">//右子树根节点的索引：preStart + inIndex - inStart + 1，稍微举个例子算算就可以了</span></span><br><span class="line">        root.right = helper(preStart + inIndex - inStart + <span class="number">1</span>, inIndex + <span class="number">1</span>, inEnd, preorder, inorder, <span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal">Construct Binary Tree from Inorder and Postorder Traversal</h2><h3 id="题目描述-1">题目描述</h3><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><strong> Note: </strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>postorder[postorder.length - 1]为树的根节点,然后在inorder中找到postorder[postorder.length - 1]的索引,将inorder分成两部分，分别为左右子树，然后递归处理。</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(inorder == null || postorder == null || inorder.length != postorder.length) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">return</span> helper(postorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//postorder[postorder.length - 1]为树的根节点,然后在inorder中找到postorder[postorder.length - 1]的索引</span></span><br><span class="line">    <span class="comment">//将inorder分成两部分，分别为左右子树，递归处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> postEnd, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postEnd &lt; <span class="number">0</span> || inStart &gt; inEnd) <span class="keyword">return</span> null;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postEnd]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == postorder[postEnd])&#123;</span><br><span class="line">                inIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.left = helper(postEnd - (inEnd - inIndex) - <span class="number">1</span> ,inStart,inIndex - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">        root.right = helper(postEnd - <span class="number">1</span>, inIndex+<span class="number">1</span>, inEnd, inorder, postorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="http://articles.leetcode.com/construct-binary-tree-from-inorder-and-preorder-postorder-traversal" target="_blank" rel="external">Construct Binary Tree From Inorder and Preorder/Postorder Traversal</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal">Construct Binary Tree from Preorder and Inorder Traversal</h2><h3 id="题目描]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Lowest Common Ancestor of a Binary Search Tree or Search Tree]]></title>
    <link href="http://blog.noobsky.com/2016/06/13/LeetCode-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-or-Search-Tree/"/>
    <id>http://blog.noobsky.com/2016/06/13/LeetCode-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-or-Search-Tree/</id>
    <published>2016-06-13T08:09:00.000Z</published>
    <updated>2016-06-13T12:16:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Lowest_Common_Ancestor_of_a_Binary_Search_Tree">Lowest Common Ancestor of a Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    /              \</span><br><span class="line"> ___2__          ___8__</span><br><span class="line">/      \        /      \</span><br><span class="line"><span class="number">0</span>      _4       <span class="number">7</span>       <span class="number">9</span></span><br><span class="line">      /  \</span><br><span class="line">      <span class="number">3</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
<p>根据BST树的性质，可知，在遍历树的时候，如果当前节点的值都大于p和q节点的值，则p和q在当前节点的左子树中，则它们的LCA也在左子树；如果当前节点的值都小于p和q两个节点的值，则p和q在当前节点的右子树，在右子树中查找LCA。如果不是以上情况，则当前节点就是p和q的LCA。</p>
<h3 id="代码">代码</h3><ul>
<li>递归法</li>
</ul>
<p>时间复杂度O(h)，空间复杂度O(h)递归栈空间</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//p和q分居root的两边，lca为root</span></span><br><span class="line">        <span class="comment">//等价于</span></span><br><span class="line">        <span class="keyword">if</span>((root.<span class="keyword">val</span> - p.<span class="keyword">val</span>)*(root.<span class="keyword">val</span> - q.<span class="keyword">val</span>) &lt;= <span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//if((p.val &lt;= root.val &amp;&amp; root.val &lt;= q.val) || (q.val &lt;= root.val &amp;&amp; root.val &lt;= p.val)) return root;</span></span><br><span class="line">        <span class="comment">//p和q分居root的一边（左或右子树里）</span></span><br><span class="line">        root = p.<span class="keyword">val</span> &lt; root.<span class="keyword">val</span> ? root.left : root.right;</span><br><span class="line">        <span class="comment">//尾递归可以改写为迭代的形式</span></span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root, p,q);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>更clean的code：</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    return (root<span class="string">.val</span> - p<span class="string">.val)</span> * (root<span class="string">.val</span> - q<span class="string">.val)</span> &lt; 1 ? root :</span><br><span class="line">           lowestCommonAncestor(p<span class="string">.val</span> &lt; root<span class="string">.val</span> ? root<span class="string">.left</span> : root<span class="string">.right</span>, p, q);</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>一般我写下面朴实的写法：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//root.val大于p.val和q.val，则p和q在左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="keyword">val</span> &gt; p.<span class="keyword">val</span> &amp;&amp; root.<span class="keyword">val</span> &gt; q.<span class="keyword">val</span>) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="comment">//在右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.<span class="keyword">val</span> &lt; p.<span class="keyword">val</span> &amp;&amp; root.<span class="keyword">val</span> &lt; q.<span class="keyword">val</span>) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>迭代法</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾递归可以改写为迭代的形式</span></span><br><span class="line"><span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)&#123;</span><br><span class="line">    <span class="comment">//p、q各分居root同一侧：(p.val - root.val) * (root.val - q.val) &gt; 0表达式不对比如【2，1，3】分居两侧也大于0</span></span><br><span class="line">    <span class="comment">//正确的表达式为(root.val-p.val)*(root.val-q.val) &gt; 0</span></span><br><span class="line">    <span class="keyword">while</span>((root.<span class="keyword">val</span>-p.<span class="keyword">val</span>)*(root.<span class="keyword">val</span>-q.<span class="keyword">val</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        root = p.<span class="keyword">val</span> &lt; root.<span class="keyword">val</span> ? root.left : root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分居两侧时lca为root</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// while ((root.val - p.val) * (root.val - q.val) &gt; 0)</span></span><br><span class="line">    <span class="comment">//     root = p.val &lt; root.val ? root.left : root.right;</span></span><br><span class="line">    <span class="comment">//return root;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lowest_Common_Ancestor_of_a_Search_Tree">Lowest Common Ancestor of a Search Tree</h2><h3 id="题目描述-1">题目描述</h3><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line"><span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></span><br><span class="line">      /  \</span><br><span class="line">      <span class="number">7</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<p>可以利用深度优先搜索，从叶子节点向上，标记子树中出现目标节点的情况。如果子树中有目标节点，则通过返回该目标节点标记该子树有那个目标节点，如果没有，标记为null。如果左子树、右子树都有标记，说明p和q两个目标节点正好有一个在左子树中有一个在右子树中，则LCA就是当前节点。如果只有一个子树（左或右）有标记，则说明p和q都在这子树上，而且p或者q就是该子树的根节点，则p或者q就是LCA。</p>
<h3 id="代码-1">代码</h3><ul>
<li>递归法</li>
</ul>
<p>时间复杂度O(n)，空间复杂度O(h)栈空间<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> lowestCommonAncestor(<span class="type">TreeNode</span> root, <span class="type">TreeNode</span> p, <span class="type">TreeNode</span> q) &#123;</span><br><span class="line">        <span class="comment">//发现目标(p或q)节点就通过返回该目标节点标记该子树发现了某个目标节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == null || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">left</span> = lowestCommonAncestor(root.<span class="keyword">left</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">right</span> = lowestCommonAncestor(root.<span class="keyword">right</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//都不为空，说明p和q两个目标节点正好有一个在左子树中有一个在右子树中，则LCA为root</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span> != null &amp;&amp; <span class="keyword">right</span>  != null) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//如果left(或者right)不为空，而且left为p或者q节点，如果在left(left为p或者q)的子树中查找p和q的LCA，则必定是left</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span> != null ? <span class="keyword">left</span> : <span class="keyword">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法假设两个节点都在二叉树里，这里的题目也说了给定二叉树里的两个节点。如果这点不能保证，也就是一个节点在二叉树而另一个不在，那么该方法返回那个出现在二叉树中的节点，但是正确的做法是返回null。我们可以扩展上面的方法使得也能够正确处理这种情况，使用两个boolean变量v1和v2，如果p在二叉树中，则设置v1为true；如果q在二叉树中，设置v2为true。修改后的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> boolean v1, v2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> lowestCommonAncestor(<span class="type">TreeNode</span> root, <span class="type">TreeNode</span> p, <span class="type">TreeNode</span> q) &#123;</span><br><span class="line">        v1 = <span class="literal">false</span>;</span><br><span class="line">        v2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="type">LCA</span> = lowestCommonAncestorHelper(root, p, q);</span><br><span class="line">        <span class="keyword">if</span>(v1 &amp;&amp; v2) <span class="keyword">return</span> <span class="type">LCA</span>;</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> lowestCommonAncestorHelper(<span class="type">TreeNode</span> root, <span class="type">TreeNode</span> p, <span class="type">TreeNode</span> q) &#123;</span><br><span class="line">        <span class="comment">//发现目标(p或q)节点就通过返回该目标节点标记该子树发现了某个目标节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root == p)&#123;</span><br><span class="line">            v1 = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//注意！！！不能直接返回，如果直接返回，比如树为[2, 2], p = 2(root节点), q = 2(root.left节点)</span></span><br><span class="line">            <span class="comment">//会判断错误，因为只把v1设置为true之后就直接返回，但是v2也应该为true，应该在递归后加入代码：</span></span><br><span class="line">            <span class="comment">//if(root == p || root == q) return root;才能正确处理。</span></span><br><span class="line">            <span class="comment">//return root;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == q)&#123;</span><br><span class="line">            v2 = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//return root;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">left</span> = lowestCommonAncestorHelper(root.<span class="keyword">left</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">right</span> = lowestCommonAncestorHelper(root.<span class="keyword">right</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在这里判断返回才能正确处理类似树为[2, 2], p = 2(root节点), q = 2(root.left节点)的情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//都不为空，说明p和q两个目标节点正好有一个在左子树中有一个在右子树中，则LCA为root</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span> != null &amp;&amp; <span class="keyword">right</span>  != null) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//如果left(或者right)不为空，而且left为p或者q节点，如果在left(left为p或者q)的子树中查找p和q的LCA，则必定是left</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span> != null ? <span class="keyword">left</span> : <span class="keyword">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代法</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        Map<span class="tag">&lt;TreeNode, TreeNode&gt;</span> parent = new HashMap<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        Deque<span class="tag">&lt;TreeNode&gt;</span> stack = new ArrayDeque<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        parent.put(root, null);</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        while (!parent.containsKey(p) || !parent.containsKey(q)) &#123;</span><br><span class="line">            TreeNode <span class="keyword">node</span><span class="identifier"> </span><span class="title">= stack</span>.pop();</span><br><span class="line">            if (<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span> != null) &#123;</span><br><span class="line">                parent.put(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>, <span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">                stack</span>.push(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            if (<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span> != null) &#123;</span><br><span class="line">                parent.put(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>, <span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">                stack</span>.push(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Set<span class="tag">&lt;TreeNode&gt;</span> ancestors = new HashSet<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            ancestors.add(p);</span><br><span class="line">            p = parent.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        while (!ancestors.contains(q))</span><br><span class="line">            q = parent.get(q);</span><br><span class="line">        return q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/" target="_blank" rel="external">Lowest Common Ancestor in a Binary Search Tree</a><br><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/" target="_blank" rel="external">Lowest Common Ancestor in a Binary Tree</a><br><a href="https://segmentfault.com/a/1190000003509399" target="_blank" rel="external">Lowest Common Ancestor of a Binary Tree 最小公共祖先</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Lowest_Common_Ancestor_of_a_Binary_Search_Tree">Lowest Common Ancestor of a Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]3Sum And 3Sum Closest]]></title>
    <link href="http://blog.noobsky.com/2016/06/13/LeetCode-3Sum-And-3Sum-Closest/"/>
    <id>http://blog.noobsky.com/2016/06/13/LeetCode-3Sum-And-3Sum-Closest/</id>
    <published>2016-06-13T06:46:13.000Z</published>
    <updated>2016-06-13T07:19:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="3Sum">3Sum</h2><h3 id="题目描述">题目描述</h3><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong> Note: </strong>The solution set must not contain duplicate triplets.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For example, given <span class="built_in">array</span> S = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">A solution <span class="built_in">set</span> is:</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这个题目跟3Sum Closest的思路都类似。首先排序，然后使用三个索引指针。</p>
<p>开始时：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">^  ^                                               ^</span><br><span class="line">|  |                                               |</span><br><span class="line">|  +- <span class="keyword">second</span>                                     <span class="keyword">third</span></span><br><span class="line">+-<span class="keyword">first</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>nums[first]+nums[second]+nums[third]</code>小于target，我们需要增大sum。所以讲second索引指针往右移动。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">^    ^                                             ^</span><br><span class="line">|    |                                             |</span><br><span class="line">|    +- <span class="keyword">second</span>                                   <span class="keyword">third</span></span><br><span class="line">+-<span class="keyword">first</span></span><br></pre></td></tr></table></figure>
<p>如果sum大于target，则我们需要减小sum。所以将third索引指针往前移动。如果sum等于target，那么我们返回sum或者加入到结果集中。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">^    ^                                          ^</span><br><span class="line">|    |                                          |</span><br><span class="line">|    +- <span class="keyword">second</span>                                <span class="keyword">third</span></span><br><span class="line">+-<span class="keyword">first</span></span><br></pre></td></tr></table></figure>
<p>当second和third相遇时，这一回合结束。将first往右移动开始下一回合，并且重置second和third。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">  ^    ^                                           ^</span><br><span class="line">  |    |                                           |</span><br><span class="line">  |    +- <span class="keyword">second</span>                                 <span class="keyword">third</span></span><br><span class="line">  +-<span class="keyword">first</span></span><br></pre></td></tr></table></figure></p>
<p>在这个过程中能得到满足条件的Sum或者Closest。最后三个索引指针聚集在数组末端。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">                                         ^    ^    ^</span><br><span class="line">                                         |    |    `- <span class="keyword">third</span></span><br><span class="line">                                         |    +- <span class="keyword">second</span></span><br><span class="line">                                         +-<span class="keyword">first</span></span><br></pre></td></tr></table></figure></p>
<h3 id="代码">代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; res = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//先排序，后面更好处理</span></span><br><span class="line">        <span class="type">Arrays</span>.<span class="built_in">sort</span>(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; nums.length -<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//进行nums[i] != nums[i-1]判断去除重复的结果，就不用利用集合去重了</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> ||(i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="comment">//先固定第一个数nums[i]，然后在数组的剩下部分查找两元素之和等于-nums[i]的组合</span></span><br><span class="line">                int sum = -nums[i];</span><br><span class="line">                <span class="comment">//使用两个索引指针，一头一尾进行扫荡</span></span><br><span class="line">                int <span class="keyword">left</span> = i+<span class="number">1</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] == sum)&#123;</span><br><span class="line">                        <span class="comment">//找到一种组合，加入结果集中</span></span><br><span class="line">                        res.add(<span class="type">Arrays</span>.asList(nums[i], nums[<span class="keyword">left</span>], nums[<span class="keyword">right</span>]));</span><br><span class="line">                        <span class="comment">//跳过重复元素</span></span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>+<span class="number">1</span>] == nums[<span class="keyword">left</span>]) <span class="keyword">left</span>++;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>-<span class="number">1</span>] == nums[<span class="keyword">right</span>]) <span class="keyword">right</span>--;</span><br><span class="line">                        <span class="keyword">left</span>++;</span><br><span class="line">                        <span class="keyword">right</span>--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] &lt; sum) <span class="keyword">left</span>++;<span class="comment">//数组有序，小于sum时，增大左边数才有可能相等</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">right</span>--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3Sum_Closest">3Sum Closest</h2><h3 id="题目描述-1">题目描述</h3><p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, given <span class="built_in">array</span> S = &#123;-<span class="number">1</span> <span class="number">2</span> <span class="number">1</span> -<span class="number">4</span>&#125;, and target = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is <span class="number">2.</span> (-<span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>
<h3 id="代码-1">代码</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Solution</span> &#123;</span><br><span class="line">    public <span class="type">int</span> threeSumClosest(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        //如果nums.length&lt;<span class="number">3</span>,如何处理，随时沟通:)</span><br><span class="line">        </span><br><span class="line">        //排序，然后我们就能慢慢逼近target</span><br><span class="line">        <span class="type">Arrays</span>.sort(nums);</span><br><span class="line">        </span><br><span class="line">        //初始化结果，找三个数，nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[nums.length - <span class="number">1</span>]</span><br><span class="line">        <span class="type">int</span> <span class="literal">result</span> = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]; </span><br><span class="line">        //<span class="type">int</span> <span class="literal">result</span> = nums[<span class="number">0</span>] + nums[<span class="number">1</span>]+nums[nums.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(<span class="type">Math</span>.abs(<span class="literal">result</span> - target) &gt; <span class="type">Math</span>.abs(sum - target))&#123;</span><br><span class="line">                    <span class="literal">result</span> = sum;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="literal">result</span> == target) <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                //sum &gt; target ? right-- : left++;</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target) left++;</span><br><span class="line">                <span class="keyword">else</span> right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="3Sum">3Sum</h2><h3 id="题目描述">题目描述</h3><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Fi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Search for a Range]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Search-for-a-Range/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Search-for-a-Range/</id>
    <published>2016-06-12T13:28:54.000Z</published>
    <updated>2016-06-12T13:49:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return <font color="red">[-1, -1]</font>.</p>
<p>For example,<br>Given <font color="red">[5, 7, 7, 8, 8, 10]</font> and target value 8,<br>return <font color="red">[3, 4]</font>.</p>
<p>找左边界：mid = (left+right)/2，下取整，往左偏。有以下三种可能：</p>
<ul>
<li>nums[mid] &lt; target, target在mid的右边，left = mid+1</li>
<li>nums[mid] &gt; target, target在mid的左边，right = mid-1</li>
<li>nums[mid] = target, 找左边界，所以right = mid</li>
</ul>
<p>2和3可以合并，合并后：if(nums[mid] &lt; target) left = mid+1; else right = mid;</p>
<p>找右边界：mid = (left+right)/2+1，上取整，往右偏。同理也有三种可能：</p>
<ul>
<li>nums[mid] &lt; target, target在mid的右边，left = mid+1</li>
<li>nums[mid] &gt; target, target在mid的左边，right = mid-1</li>
<li>nums[mid] = target, 找右边界，所以left = mid</li>
</ul>
<p>1和3可以合并，合并后：if(nums[mid] &gt; target) right = mid-1; else left = mid;</p>
<p>就是两种二分搜索的写法</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// 找左边界：mid = (left+right)/2，下取整，往左偏</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找左边界，所以right = mid</span></span><br><span class="line">    <span class="comment">// 2和3可以合并，合并后：if(nums[mid] &lt; target) left = mid+1; else right = mid;</span></span><br><span class="line">    <span class="comment">// 找右边界：mid = (left+right)/2+1，上取整，往右篇</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找右边界，所以left = mid</span></span><br><span class="line">    <span class="comment">// 1和3可以合并，合并后：if(nums[mid] &gt; target) right = mid-1; else left = mid;</span></span><br><span class="line">    <span class="comment">// 就是两种二分搜索的写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[left] != target) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> res[<span class="number">0</span>] = left;</span><br><span class="line">        </span><br><span class="line">        right = nums.length - <span class="number">1</span>;<span class="comment">//第二次时，left可以不重新设置为0，设置了也没错，多余而已</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//上取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有左边界，就一定能执行到这里，而且不用判断，right最起码等于前面判断左边界</span></span><br><span class="line">        res[<span class="number">1</span>] = right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algor]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Reverse Linked List I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Reverse-Linked-List-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Reverse-Linked-List-I-II/</id>
    <published>2016-06-12T07:24:14.000Z</published>
    <updated>2016-06-12T12:07:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Reverse_Linked_List_I">Reverse Linked List I</h2><h3 id="题目描述">题目描述</h3><p>Reverse a singly linked list.</p>
<p><strong> Hint: </strong><br>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<h3 id="代码">代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//遍历单链表，采用前插的方式构建单链表就能反转单链表</span></span><br><span class="line">        <span class="comment">//该循环可以改成尾递归的形式</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//后面会修改head.next的指向，先保存原始的head.next</span></span><br><span class="line">            <span class="comment">//先保存下一个前插的节点</span></span><br><span class="line">            ListNode <span class="keyword">next</span> = head.<span class="keyword">next</span>;</span><br><span class="line">            <span class="comment">//往前插入节点</span></span><br><span class="line">            head.<span class="keyword">next</span> = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = <span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse_Linked_List_II">Reverse Linked List II</h2><h3 id="题目描述-1">题目描述</h3><p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p>
<p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<p><strong> Note: </strong><br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p>
<h3 id="代码-1">代码</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> for singly-linked list.</span><br><span class="line"> * public <span class="keyword">class</span> <span class="type">ListNode</span> &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     <span class="type">ListNode</span> next;</span><br><span class="line"> *     <span class="type">ListNode</span>(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="title">public</span> <span class="keyword">class</span> <span class="type">Solution</span> &#123;</span><br><span class="line">    //链表的题目就要多用笔在草稿上多画画</span><br><span class="line">    public <span class="type">ListNode</span> reverseBetween(<span class="type">ListNode</span> head, int m, int n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == null) return head;</span><br><span class="line">        //虚拟头结点</span><br><span class="line">        <span class="type">ListNode</span> dummy = new <span class="type">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        //pre用来标记需要反转子链表头节点的前一节点</span><br><span class="line">        <span class="type">ListNode</span> pre = dummy;</span><br><span class="line">        </span><br><span class="line">        for(int i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) pre = pre.next;</span><br><span class="line">        //start节点指向需要反转的子链表的头结点</span><br><span class="line">        <span class="type">ListNode</span> start = pre.next;</span><br><span class="line">        //指向将被反转的结点</span><br><span class="line">        <span class="type">ListNode</span> <span class="keyword">then</span> = start.next;</span><br><span class="line">        </span><br><span class="line">        //<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>, m = <span class="number">2</span>, n = <span class="number">4</span>, pre = <span class="number">1</span>, start = <span class="number">2</span>, <span class="keyword">then</span> = <span class="number">3</span></span><br><span class="line">        //dummy-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">        </span><br><span class="line">        //我们需要将<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>有三个节点的子链表反转成dummy-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">        //我们只需要进行n-m=<span class="number">2</span>次交换：首先把<span class="number">3</span>交互到pre.next的位置变成dum-&gt;<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">        //然后将<span class="number">4</span>交互到pre.next的位置变成dummy-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">        </span><br><span class="line">        for(int i = <span class="number">0</span>; i &lt; n - m; i++)&#123;</span><br><span class="line">            start.next = <span class="keyword">then</span>.next;</span><br><span class="line">            <span class="keyword">then</span>.next = pre.next;</span><br><span class="line">            pre.next = <span class="keyword">then</span>;</span><br><span class="line">            //下一个需要反转的节点</span><br><span class="line">            <span class="keyword">then</span> = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化后：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         start </span><br><span class="line">          |</span><br><span class="line">dummy-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">	|     |</span><br><span class="line">       pre  <span class="keyword">then</span></span><br></pre></td></tr></table></figure></p>
<p>进入for循环执行第一次反转后：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">           start </span><br><span class="line">             |</span><br><span class="line">dummy-&gt;<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">	|        |</span><br><span class="line">       pre     <span class="keyword">then</span></span><br></pre></td></tr></table></figure></p>
<p>再次进入for循环进行第二次反转后：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              start </span><br><span class="line">                |</span><br><span class="line">dummy-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">	|           |</span><br><span class="line">       pre        <span class="keyword">then</span></span><br></pre></td></tr></table></figure>
<p>至此，循环结束，返回结果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Reverse_Linked_List_I">Reverse Linked List I</h2><h3 id="题目描述">题目描述</h3><p>Reverse a singly linked list.</p>
<p><strong> Hint: </str]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Linked List Cycle I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Linked-List-Cycle-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Linked-List-Cycle-I-II/</id>
    <published>2016-06-12T07:16:06.000Z</published>
    <updated>2016-06-12T07:19:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Linked_List_Cycle_I">Linked List Cycle I</h2><h3 id="题目描述">题目描述</h3><p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<p>判圈算法请看本博客中的<a href="http://noobsky.com/2016/04/30/Happy-Number%E4%B8%8EFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/" target="_blank" rel="external">Happy Number与Floyd判圈算法</a></p>
<h3 id="代码">代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//判圈算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> hasCycle(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Linked_List_Cycle_I-1">Linked List Cycle I</h2><h3 id="题目描述-1">题目描述</h3><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h3 id="代码-1">代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// public ListNode detectCycle(ListNode head) &#123;</span></span><br><span class="line">    <span class="comment">//     if(head == null) return head;</span></span><br><span class="line">    <span class="comment">//     ListNode slow = head, fast = head;</span></span><br><span class="line">    <span class="comment">//     boolean isCycle = false;</span></span><br><span class="line">    <span class="comment">//     while(fast != null &amp;&amp; fast.next != null)&#123;</span></span><br><span class="line">    <span class="comment">//         fast = fast.next.next;</span></span><br><span class="line">    <span class="comment">//         slow = slow.next;</span></span><br><span class="line">    <span class="comment">//         if(slow == fast )&#123;</span></span><br><span class="line">    <span class="comment">//             isCycle = true;</span></span><br><span class="line">    <span class="comment">//             break;</span></span><br><span class="line">    <span class="comment">//         &#125; </span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     if(isCycle == false) return null;</span></span><br><span class="line">    <span class="comment">//     //有circle</span></span><br><span class="line">    <span class="comment">//     slow = head;</span></span><br><span class="line">    <span class="comment">//     while(slow != fast)&#123;</span></span><br><span class="line">    <span class="comment">//         slow = slow.next;</span></span><br><span class="line">    <span class="comment">//         fast = fast.next;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return slow;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">boolean</span> isCycle = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast )&#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">                    slow = slow.<span class="keyword">next</span>;</span><br><span class="line">                    fast = fast.<span class="keyword">next</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Linked_List_Cycle_I">Linked List Cycle I</h2><h3 id="题目描述">题目描述</h3><p>Given a linked list, determine if it has a cycle in it.</p>
<]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Patching Array]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Patching-Array/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Patching-Array/</id>
    <published>2016-06-12T03:11:37.000Z</published>
    <updated>2016-06-12T03:53:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p>
<p><strong> Example 1: </strong><br>nums = [1, 3], n = 6<br>Return 1.</p>
<p>Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.<br>Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].<br>Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].<br>So we only need 1 patch.</p>
<p><strong> Example 2: </strong><br>nums = [1, 5, 10], n = 20<br>Return 2.<br>The two patches can be [2, 4].</p>
<p><strong> Example 3: </strong><br>nums = [1, 2, 2], n = 5<br>Return 0.</p>
<p>变量miss表示[0,n]中我们缺少的最小的和，也就是说nums中元素求和我们已经能得到[0,miss)范围内的数。遍历nums数组，如果nums[i] &lt;= miss,那么我们可以将我们能得到的和的范围[0,miss)扩充到[0, miss+nums[i])。如果nums[i] &gt; miss,那么我们将不能连续扩充[0,miss),也就是说[0, miss+nums[i])的一些元素我们不能得到，则这时我们需要patch元素，那么应该patch什么数？我们采用贪心算法，我们patch的元素为miss，因为选择miss可以得到最大的连续区间[0, miss+miss)</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 变量miss表示[0,n]中我们缺少的最小的和，也就是说nums中元素求和我们已经能得到[0,miss)范围内的数</span></span><br><span class="line">        <span class="comment">// 遍历nums数组，如果nums[i] &lt;= miss,那么我们可以将我们能得到的和的范围[0,miss)扩充到[0, miss+nums[i])</span></span><br><span class="line">        <span class="comment">// 如果nums[i] &gt; miss,那么我们将不能连续扩充[0,miss),也就是说[0, miss+nums[i])的一些元素我们不能得到，</span></span><br><span class="line">        <span class="comment">// 则这时我们需要patch元素，那么应该patch什么数？我们采用贪心算法，我们patch的元素为miss，因为选择miss</span></span><br><span class="line">        <span class="comment">// 可以得到最大的连续区间[0, miss+miss)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> miss = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//统计patch元素的数量</span></span><br><span class="line">        <span class="keyword">int</span> patch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(miss &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; nums.length &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">                miss = miss + nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                miss = miss + miss;</span><br><span class="line">                patch++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> patch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里程序有一个隐藏的bug，当测试用例为nums=[1,2,31,33], n=2147483647,程序运行到最后我们扩充miss的时候回超过Integer.MAX_VALUE即2147483647会造成miss溢出然后miss &lt;= n会一直为true，程序不能终止而超时。我们可以用long类型来表示miss或者在while的条件里增加miss &gt; 0的条件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 变量miss表示[0,n]中我们缺少的最小的和，也就是说nums中元素求和我们已经能得到[0,miss)范围内的数</span></span><br><span class="line">        <span class="comment">// 遍历nums数组，如果nums[i] &lt;= miss,那么我们可以将我们能得到的和的范围[0,miss)扩充到[0, miss+nums[i])</span></span><br><span class="line">        <span class="comment">// 如果nums[i] &gt; miss,那么我们将不能连续扩充[0,miss),也就是说[0, miss+nums[i])的一些元素我们不能得到，</span></span><br><span class="line">        <span class="comment">// 则这时我们需要patch元素，那么应该patch什么数？我们采用贪心算法，我们patch的元素为miss，因为选择miss</span></span><br><span class="line">        <span class="comment">// 可以得到最大的连续区间[0, miss+miss)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//long miss = 1;</span></span><br><span class="line">        <span class="keyword">int</span> miss = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//统计patch元素的数量</span></span><br><span class="line">        <span class="keyword">int</span> patch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//while(miss &lt;= n)&#123;</span></span><br><span class="line">        <span class="keyword">while</span>(miss &gt; <span class="number">0</span> &amp;&amp; miss &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; nums.length &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">                miss = miss + nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                miss = miss + miss;</span><br><span class="line">                patch++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> patch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Insertion Sort List 和 Sort List]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Insertion-Sort-List/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Insertion-Sort-List/</id>
    <published>2016-06-12T02:32:38.000Z</published>
    <updated>2016-06-12T06:45:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Insertion_Sort_List">Insertion Sort List</h2><h3 id="题目描述">题目描述</h3><p>Sort a linked list using insertion sort.</p>
<h3 id="代码">代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode insertionSortList(ListNode head) &#123;</span><br><span class="line">        <span class="comment">//虚拟头结点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//每次用来查找元素插入位置，从头往后遍历有序部分</span></span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="comment">//当前插入的元素</span></span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//每次从头开始在有序部分查找插入位置</span></span><br><span class="line">            pre = dummy;</span><br><span class="line">            <span class="keyword">while</span>(pre.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; pre.<span class="keyword">next</span>.val &lt;= curr.val)&#123;</span><br><span class="line">                pre = pre.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将curr元素插入到pre和pre.next之间时会修改curr.next</span></span><br><span class="line">            <span class="comment">//需要将curr.next先保存起来，下一次循环才能找到下一个插入元素</span></span><br><span class="line">            ListNode <span class="keyword">next</span> = curr.<span class="keyword">next</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//插入位置为pre.next</span></span><br><span class="line">            <span class="comment">//将curr元素插入到pre和pre.next之间</span></span><br><span class="line">            curr.<span class="keyword">next</span> = pre.<span class="keyword">next</span>;</span><br><span class="line">            pre.<span class="keyword">next</span> = curr;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//下一个插入的元素</span></span><br><span class="line">            curr = <span class="keyword">next</span>;           </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sort_List">Sort List</h2><h3 id="题目描述-1">题目描述</h3><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<h3 id="代码-1">代码</h3><p>类似归并排序：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode sortList(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将list分为两部分</span></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//寻找链表中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分为两部分，pre为空说明slow前面前面没有元素，前半部分单链表为空</span></span><br><span class="line">        <span class="comment">// if(pre != null) pre.next = null;</span></span><br><span class="line">        <span class="comment">// else head = null;</span></span><br><span class="line">        <span class="comment">//这里因为前面if(head == null || head.next == null) return head;保证了起码有两个元素才会往下运行</span></span><br><span class="line">        <span class="comment">//则保证会进入while循环，则pre一定不会为空(前半部分单链表不可能为空)，写成上面先判空也可以</span></span><br><span class="line">        <span class="comment">//置为空将链表割断</span></span><br><span class="line">        pre.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode l1 = sortList(head);</span><br><span class="line">        ListNode l2 = sortList(slow);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode merge(ListNode l1, ListNode l2)&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                current.<span class="keyword">next</span> = l1;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l1 = l1.<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current.<span class="keyword">next</span> = l2;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l2 = l2.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(l1 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(l2 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l2;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        current.<span class="keyword">next</span> = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序跟<a href="http://noobsky.com/2016/06/02/LeetCode-Convert-Sorted-Array-List-to-Binary-Search-Tree/" target="_blank" rel="external">Convert Sorted List to Binary Search Tree</a>有点类似，可对比理解。但是该程序使用了递归，空间复杂度不为O(1)，每次递归需要用到栈，空间复杂度为O(lgn)。不过这里的O(lgn)的栈空间算不算空间复杂度。可以先跟面试官商量，或者我们使用迭代的方法来进行归并。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Insertion_Sort_List">Insertion Sort List</h2><h3 id="题目描述">题目描述</h3><p>Sort a linked list using insertion sort.</p>
<h3 id="代码">代码</]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Partition List]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Partition-List/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Partition-List/</id>
    <published>2016-06-12T01:10:15.000Z</published>
    <updated>2016-06-12T01:13:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<p>维护两个临时链表，然后遍历一个原链表，将val小于x的存到第一个临时链表中，其他的存到第二个临时链表中，最后将两个临时链接起来即可</p>
<h2 id="代码">代码</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//维护两个临时链表，然后遍历一个原链表，将val小于x的存到第一个临时链表中，</span></span><br><span class="line">    <span class="comment">//其他的存到第二个临时链表中，然后将两个临时链接起来即可</span></span><br><span class="line">    <span class="keyword">public</span> ListNode partition(ListNode head, <span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="comment">//维护虚拟头结点</span></span><br><span class="line">        ListNode dummy1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>), dummy2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr1 = dummy1, curr2 = dummy2;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">                curr1.<span class="keyword">next</span> = head;</span><br><span class="line">                curr1 = head; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr2.<span class="keyword">next</span> = head;</span><br><span class="line">                curr2 = head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2，最后curr2指向5，curr2.next指向2，</span></span><br><span class="line">        <span class="comment">//我们需要将curr2.next置为null，不然会出现circle</span></span><br><span class="line">        curr2.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将第一个链表跟第二个链表链接起来</span></span><br><span class="line">        curr1.<span class="keyword">next</span> = dummy2.<span class="keyword">next</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy1.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Triangle]]></title>
    <link href="http://blog.noobsky.com/2016/06/11/LeetCode-Triangle/"/>
    <id>http://blog.noobsky.com/2016/06/11/LeetCode-Triangle/</id>
    <published>2016-06-11T15:55:58.000Z</published>
    <updated>2016-06-11T15:57:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:<br>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<h2 id="代码">代码</h2><p>public class Solution {<br>    //bottom-up简单<br>    //状态转移方程：minpath[k][i] = min(minpath[k+1][i], minpath[k+1][i+1]) + triangle[k][i]<br>    //Or even better, since the row minpath[k+1] would be useless after minpath[k] is computed,<br>    //we can simply set minpath as a 1D array, and iteratively update itself:<br>    //For the kth level:minpath[i] = min(minpath[i], minpath[i+1])+triangle[k][i]<br>    public int minimumTotal(List<list<integer>&gt; triangle) {<br>        if(triangle == null || triangle.size() == 0) return 0;<br>        List<integer> res = new ArrayList&lt;&gt;(triangle.get(triangle.size()-1));</integer></list<integer></p>
<pre><code>    <span class="comment">//从倒数第二行开始</span>
    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="built_in">triangle</span>.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--){
        <span class="comment">//i行有i+1个元素</span>
        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt;= i; j++){
            res.<span class="built_in">set</span>(j, Math.<span class="built_in">min</span>(res.<span class="built_in">get</span>(j), res.<span class="built_in">get</span>(j+<span class="number">1</span>)) + <span class="built_in">triangle</span>.<span class="built_in">get</span>(i).<span class="built_in">get</span>(j)); 
        }
    }

    <span class="keyword">return</span> res.<span class="built_in">get</span>(<span class="number">0</span>);
}
</code></pre><p>}</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Bitwise AND of Numbers Range]]></title>
    <link href="http://blog.noobsky.com/2016/06/11/LeetCode-Bitwise-AND-of-Numbers-Range/"/>
    <id>http://blog.noobsky.com/2016/06/11/LeetCode-Bitwise-AND-of-Numbers-Range/</id>
    <published>2016-06-11T14:43:50.000Z</published>
    <updated>2016-06-11T15:05:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p>
<p>For example, given the range [5, 7], you should return 4.</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code"> bin     dec</span></span><br><span class="line"><span class="code"> 101       5</span></span><br><span class="line"><span class="code"> 110       6</span></span><br><span class="line"><span class="header"> 111       7</span><br><span class="line">-------------</span></span><br><span class="line"><span class="code"> 100       4</span></span><br></pre></td></tr></table></figure>
<p>再举一个例子<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code"> bin      dec</span></span><br><span class="line"><span class="code"> 1000       8 </span></span><br><span class="line"><span class="code"> 1001       9</span></span><br><span class="line"><span class="code"> 1010       10</span></span><br><span class="line"><span class="header"> 1011       11</span><br><span class="line">-------------</span></span><br><span class="line"><span class="code"> 1000       8</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出[m,n]范围内的书按位与的结果为m与n二进制表示左边（高位）的共同部分</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//[m,n]范围内的书按位与的结果为m与n二进制表示左边（高位）的共同部分</span></span><br><span class="line">    <span class="comment">// public int rangeBitwiseAnd(int m, int n) &#123;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int step = 0;</span></span><br><span class="line">    <span class="comment">//     while(m != n)&#123;</span></span><br><span class="line">    <span class="comment">//         m &gt;&gt;= 1;</span></span><br><span class="line">    <span class="comment">//         n &gt;&gt;= 1;</span></span><br><span class="line">    <span class="comment">//         step++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return m&lt;&lt;step;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            i &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m*i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Subsets I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/11/LeetCode-Subsets-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/11/LeetCode-Subsets-I-II/</id>
    <published>2016-06-11T03:20:59.000Z</published>
    <updated>2016-06-11T07:25:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Subsets_I">Subsets I</h2><h3 id="题目描述">题目描述</h3><p>Given a set of <font color="red">distinct</font> integers, nums, return all possible subsets.</p>
<p><strong> Note: </strong>The solution set must not contain duplicate subsets.</p>
<p>For example,<br>If nums = [1,2,3], a solution is:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><ul>
<li>位操作</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//位操作</span></span><br><span class="line">    <span class="comment">//[] =&gt; 000 [1] =&gt; 001 [2] =&gt; 010 ...... [1, 2, 3] =&gt; 111</span></span><br><span class="line">    <span class="comment">//所以逻辑很简单，二进制表示中代表i的比特位为1表示i在subset中，否则不在,比如001中代表1的比特位为1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">1</span> &lt;&lt; nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++)&#123;</span><br><span class="line">            <span class="keyword">List</span>&lt;Integer&gt; subSet = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="comment">//i&amp;(1 &lt;&lt; j)可以避免死循环，但其实这里没有负数</span></span><br><span class="line">                <span class="comment">//(i&gt;&gt;j) &amp; 1的写法也是可以的</span></span><br><span class="line">                <span class="keyword">if</span>((i &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) subSet.add(nums[j]);</span><br><span class="line">                <span class="comment">//if(((i &gt;&gt; j) &amp; 1) != 0) subSet.add(nums[j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.add(subSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>回溯法</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">	public List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.<span class="keyword">length</span> == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        List&lt;Integer&gt; <span class="sub"><span class="keyword">sub</span> = new ArrayList&lt;&gt;();</span></span><br><span class="line">        genSubsets(nums, <span class="number">0</span>, <span class="sub"><span class="keyword">sub</span>, res);</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void genSubsets(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;Integer&gt; <span class="sub"><span class="keyword">sub</span>, List&lt;List&lt;Integer&gt;&gt; res)&#123;</span></span><br><span class="line">        //一定要先新new一个</span><br><span class="line">        res.add(new ArrayList&lt;Integer&gt;(<span class="sub"><span class="keyword">sub</span>));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.<span class="keyword">length</span>; i++)&#123;</span><br><span class="line">            <span class="sub"><span class="keyword">sub</span>.add(nums[i]);</span></span><br><span class="line">            genSubsets(nums, i+<span class="number">1</span>, <span class="sub"><span class="keyword">sub</span>, res);</span></span><br><span class="line">            <span class="sub"><span class="keyword">sub</span>.remove(<span class="keyword">sub</span>.size() - 1);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代法<br>思路如下：</li>
</ul>
<ol>
<li>初始化：[[]]</li>
<li>将第一个数加入到所有已有的子集中：[[],[1]]</li>
<li>同理加入第二个数：[[], [1], [2], [1,2]]</li>
<li>加入第三个数：[[], [1], [2],[1,2], [3], [1,3], [2,3], [1,2,3]]</li>
</ol>
<p>显然规律为加入新元素nums[i]后，新增的subset为克隆现有的所有subset，并在它们后面都加上nums[i]。<br>代码如下：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">	public List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.<span class="keyword">length</span> == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        List&lt;Integer&gt; <span class="sub"><span class="keyword">sub</span> = new ArrayList&lt;&gt;();</span></span><br><span class="line">        res.add(<span class="sub"><span class="keyword">sub</span>);</span>//empty set</span><br><span class="line">        //Arrays.<span class="keyword">sort</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="keyword">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> size = res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">                <span class="regexp">//</span> NOTE: must create a new <span class="sub"><span class="keyword">sub</span> object, and add element to it.</span><br><span class="line">                //If you don't create a new object and directly add element in res.get(j), </span><br><span class="line">                //you will also change the value which has been set into res, </span><br><span class="line">                //since they are using the same reference.</span><br><span class="line">                <span class="keyword">sub</span> = new ArrayList&lt;Integer&gt;(res.get(j));</span></span><br><span class="line">                <span class="sub"><span class="keyword">sub</span>.add(nums[i]);</span></span><br><span class="line">                res.add(<span class="sub"><span class="keyword">sub</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Subsets_II">Subsets II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a collection of integers that might contain <font color="red">duplicates</font>, nums, return all possible subsets.</p>
<p><strong> Note: </strong>The solution set must not contain duplicate subsets.</p>
<p>For example,<br>If nums = [1,2,2], a solution is:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>比如重复元素出现两次[6,6],则我们对于6有三种选择：不加入元素6，加入1个6，加入2个6；如果重复元素出现三次[6,6,6],则我们对于6有四种选择，不加入6，加入1个6、2个6、3个6。所以可推知规律为如果重复元素出现了k次，那么对该重复元素有k+1种选择。设数组[a1,a2,a3,…,an],其中每个元素出现的次数为[k1,k2,k3,…,kn],则子集的个数为(k1+1)*(k2+1)*(k3+1)…(kn+1),上一题没有重复元素只是特例，每个元素只出现一次，则子集总数为2*2*2……</p>
<h3 id="代码-1">代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//比如重复元素出现两次[6,6],则我们对于6有三种选择：不加入元素6，加入1个6，加入2个6</span></span><br><span class="line">    <span class="comment">//如果重复元素出现三次[6,6,6],则我们对于6有四种选择，不加入6，加入1个6、2个6、3个6</span></span><br><span class="line">    <span class="comment">//所以可推知规律为如果重复元素出现了k次，那么对该重复元素有k+1种选择</span></span><br><span class="line">    <span class="comment">//设数组[a1,a2,a3,...,an],其中每个元素出现的次数为[k1,k2,k3,...,kn],则子集的个数为</span></span><br><span class="line">    <span class="comment">//(k1+1)*(k2+1)*(k3+1)...(kn+1),上一题没有重复元素只是特例，每个元素只出现一次，</span></span><br><span class="line">    <span class="comment">//则子集总数为2*2*2......</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());<span class="comment">//初始化，加入[]</span></span><br><span class="line">        <span class="comment">//必须，方便计算元素的出现次数</span></span><br><span class="line">        Arrays.<span class="keyword">sort</span>(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;)&#123;</span><br><span class="line">            <span class="comment">//用来统计每个元素出现的次数</span></span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((<span class="keyword">count</span>+i) &lt; nums.length &amp;&amp; nums[i+<span class="keyword">count</span>] == nums[i]) <span class="keyword">count</span>++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//上一次迭代时子集的总数</span></span><br><span class="line">            <span class="keyword">int</span> preSize = res.<span class="keyword">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; preSize; j++)&#123;</span><br><span class="line">                List&lt;Integer&gt; sub = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(res.get(j));</span><br><span class="line">                <span class="comment">//元素出现count，有count+1个选择，一种选择就是重复元素都不选，该选项在初始化[]已经做过，</span></span><br><span class="line">                <span class="comment">//所以还有count种选择，循环countci</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="keyword">count</span>; k++)&#123;</span><br><span class="line">                    sub.add(nums[i]);</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(sub));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//跳过重复元素，进行下一个元素的子集生成</span></span><br><span class="line">            i += <span class="keyword">count</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步观察可知，If we want to insert an element which is a dup, we can only insert it after the newly inserted elements from last step.所以可得如下代码：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; subsetsWithDup(<span class="built_in">int</span>[] <span class="built_in">num</span>) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    </span><br><span class="line">        Arrays.sort(<span class="built_in">num</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> size = <span class="number">0</span>, startIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">num</span>.length; i++) &#123;</span><br><span class="line">            startIndex = (i &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">num</span>[i] == <span class="built_in">num</span>[i - <span class="number">1</span>]) ? size : <span class="number">0</span>;</span><br><span class="line">            size = res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = startIndex; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="built_in">List</span>&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;(res.<span class="literal">get</span>(j));</span><br><span class="line">                temp.add(<span class="built_in">num</span>[i]);</span><br><span class="line">                res.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Subsets_I">Subsets I</h2><h3 id="题目描述">题目描述</h3><p>Given a set of <font color="red">distinct</font> integers, nums, return all possi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Verify Preorder Serialization of a Binary Tree]]></title>
    <link href="http://blog.noobsky.com/2016/06/11/LeetCode-Verify-Preorder-Serialization-of-a-Binary-Tree/"/>
    <id>http://blog.noobsky.com/2016/06/11/LeetCode-Verify-Preorder-Serialization-of-a-Binary-Tree/</id>
    <published>2016-06-11T02:31:03.000Z</published>
    <updated>2016-06-11T02:50:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    /   <span class="string">\</span></span><br><span class="line">   <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">  / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"> <span class="number">4</span>   <span class="number">1</span>  <span class="comment">#  6</span></span><br><span class="line">/ <span class="string">\</span> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="comment"># # # #   # #</span></span><br></pre></td></tr></table></figure></p>
<p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node.</p>
<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>
<p>Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p>
<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”.</p>
<p><strong> Example 1: </strong><br>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>Return true</p>
<p><strong> Example 2: </strong><br>“1,#”<br>Return false</p>
<p><strong> Example 3: </strong><br>“9,#,#,1”<br>Return false</p>
<p>将空节点当做影子叶子节点，则：</p>
<ul>
<li>除了根节点，所有非空节点提供2个出度和一个入度(2个子节点和一个父节点)</li>
<li>所有空节点提供0个出度和1个入度(0个子节点和一个父节点)<br>接着我们构造这棵树，在构造的过程中记录出度和入度之差<code>diff = outdegree - indegree</code>。当构造一个节点时，diff减1，因为该节点提供了一个入度。如果该节点非空我们还要将diff加2，因为该节点提供了两个出度。如果树的序列化正确，diff不会小于零而且最后会等于0</li>
</ul>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//diff = outdegree - indegree</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == null || preorder.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        String[] nodes = preorder.split(<span class="string">","</span>);</span><br><span class="line">        <span class="comment">//初始化为1</span></span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(String node: nodes)&#123;</span><br><span class="line">            <span class="comment">//除根节点每个节点都会提供一个入度，diff-1，如果小于0，错误</span></span><br><span class="line">            <span class="keyword">if</span>(--diff &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//非空节点，提供了两个出度diff+2</span></span><br><span class="line">            <span class="keyword">if</span>(!node.equals(<span class="string">"#"</span>)) diff += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Search in Rotated Sorted Array I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Search-in-Rotated-Sorted-Array-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Search-in-Rotated-Sorted-Array-I-II/</id>
    <published>2016-06-10T12:06:10.000Z</published>
    <updated>2016-06-11T02:33:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Search_in_Rotated_Sorted_Array_I">Search in Rotated Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p><font color="red">You may assume no duplicate exists in the array</font>.</p>
<h3 id="代码">代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以用Find Minimum in Rotated Sorted Array中的方法找出最小元素的下标，进而我们可以知道旋转数组旋转的步数rot</span></span><br><span class="line">    <span class="comment">//有了旋转步数我们就可以知道某个元素在旋转数组中真实位置</span></span><br><span class="line">    <span class="keyword">public</span> int search(int[] nums, int target) &#123;</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//nums[left...mid]有序，最小元素在右边，mid = left + 1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>]) <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">right</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束后，最小元素的下标为left，则旋转步数rot = left</span></span><br><span class="line">        int rot = <span class="keyword">left</span>;</span><br><span class="line">        <span class="keyword">left</span> = <span class="number">0</span>;<span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分搜索target</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt;= <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//计算真正的中间元素在数组中的位置</span></span><br><span class="line">            int realMid = (mid+rot) % nums.length;</span><br><span class="line">            <span class="keyword">if</span>(nums[realMid] == target) <span class="keyword">return</span> realMid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[realMid] &gt; target) <span class="keyword">right</span> = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法比较tricky，当然也可以用Search in Rotated Sorted Array II中的常规写法。</p>
<h2 id="Search_in_Rotated_Sorted_Array_II">Search in Rotated Sorted Array II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for “Search in Rotated Sorted Array”:<br>What if duplicates are allowed?</p>
<p>Would this affect the run-time complexity? How and why?</p>
<p>Write a function to determine if a given target is in the array.</p>
<h3 id="代码-1">代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> boolean search(int[] nums, int target) &#123;</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//左边有序，</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[<span class="keyword">left</span>] &amp;&amp; target &lt; nums[mid]) <span class="keyword">right</span> = mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">             <span class="comment">//右边有序   </span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[<span class="keyword">right</span>]) <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">right</span> = mid;</span><br><span class="line">            <span class="comment">//重复元素，无法判断哪边有序，但去掉两相等元素中的一个不影响后面的判断</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="keyword">left</span>] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种写法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> boolean search(int[] nums, int target)&#123;</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt;= <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//左半部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[<span class="keyword">left</span>] &amp;&amp; target &lt; nums[mid]) <span class="keyword">right</span> = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右半部分有序</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[<span class="keyword">right</span>]) <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">right</span> = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两种写法，参照二分搜索的两种正确写法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Search_in_Rotated_Sorted_Array_I">Search in Rotated Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Suppose a sorted array is rotated a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Perfect Squares]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Perfect-Squares/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Perfect-Squares/</id>
    <published>2016-06-10T11:46:46.000Z</published>
    <updated>2016-06-11T01:01:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p>
<p>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>
<h2 id="代码">代码</h2><p>使用动态规划，dp[i]表示正整数i最少能由多少个完全平方数之和组成，则状态转移方程为dp[i] = min(dp[i - j*j]) + 1，i - j*j &gt;= 0 &amp;&amp; j &gt;= 1 ==&gt; j &lt;= sqrt(i) &amp;&amp; j &gt;= 1，根据状态转移方程很容易写出以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//dp[i]表示正整数i最少能由多少个完全平方数之和组成</span></span><br><span class="line">    <span class="comment">//则dp[i] = min(dp[i - j\*j]) + 1，i - j\*j &gt;= 0 &amp;&amp; j &gt;= 1 ==&gt; j &lt;= sqrt(i) &amp;&amp; j &gt;= 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//全部元素初始化为最大值</span></span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i - j*j &gt;= <span class="number">0</span>; j++)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j*j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该题有数学解法，考察四平方和定理(Lagrange’s Four-Square Theorem)：所有自然数至多只要用四个数的平方和就可以表示。那么就是说返回结果只有1,2,3或4其中的一个，首先我们将数字化简一下，由于一个数如果含有因子4，那么我们可以把4都去掉，并不影响结果，比如2和8,3和12等等，返回的结果都相同，读者可自行举更多的例子。还有一个可以化简的地方就是，如果一个数除以8余7的话，那么肯定是由4个完全平方数组成，这些数学上都可以证明，但我也不会证明，读者可自行举例验证。那么做完两步后，一个很大的数有可能就会变得很小了，大大减少了运算时间，下面我们就来尝试的将其拆为两个平方数之和，如果拆成功了那么就会返回1或2，因为其中一个平方数可能为0. (注：由于输入的n是正整数，所以不存在两个平方数均为0的情况)。注意下面的!!a + !!b这个表达式，可能很多人不太理解这个的意思，其实很简单，感叹号!表示逻辑取反，那么一个正整数逻辑取反为0，再取反为1，所以用两个感叹号!!的作用就是看a和b是否为正整数，都为正整数的话返回2，只有一个是正整数的话返回1，参见代码如下(C代码)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">        n /= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">8</span> == <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a=<span class="number">0</span>; a*a&lt;=n; ++a) &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="built_in">sqrt</span>(n - a*a);</span><br><span class="line">        <span class="keyword">if</span> (a*a + b*b == n)</span><br><span class="line">            <span class="keyword">return</span> !!a + !!b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为Java代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n % <span class="number">4</span> == <span class="number">0</span>) n = n / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">8</span> == <span class="number">7</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a =<span class="number">0</span>; a * a &lt;= n; a++)&#123;</span><br><span class="line">            <span class="keyword">int</span> b = (<span class="keyword">int</span>)Math.<span class="built_in">sqrt</span>(n - a*a);</span><br><span class="line">            <span class="keyword">if</span>(a * a + b* b == n)&#123;</span><br><span class="line">                <span class="keyword">return</span> (a &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) + (b &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which su]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Duplicates from Sorted Array I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Remove-Duplicates-from-Sorted-Array-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Remove-Duplicates-from-Sorted-Array-I-II/</id>
    <published>2016-06-10T09:48:29.000Z</published>
    <updated>2016-06-10T10:48:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Remove_Duplicates_from_Sorted_Array_I">Remove Duplicates from Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// public int removeDuplicates(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int newLength = 1;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] != nums[i-1]) nums[newLength++] = nums[i];</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return newLength;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="comment">//第一个元素直接往里面放，后面nums[i]只要不跟前一个放进去的相等都能往里面放</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">1</span> || num != nums[i-<span class="number">1</span>])</span><br><span class="line">                nums[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove_Duplicates_from_Sorted_Array_II">Remove Duplicates from Sorted Array II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for “Remove Duplicates”:<br>What if duplicates are allowed at most twice?</p>
<p>For example,<br>Given sorted array nums = [1,1,1,2,2,3],</p>
<p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length.</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//前两个元素直接加入，后面的元素nums[i]只要不跟前面倒数第二个放进去的nums[i-2]相等都能往里面放</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">2</span> || num != nums[i-<span class="number">2</span>])</span><br><span class="line">                nums[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Remove_Duplicates_from_Sorted_Array_I">Remove Duplicates from Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Given a sorted array, rem]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]H-Index I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-H-Index-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-H-Index-I-II/</id>
    <published>2016-06-10T04:15:37.000Z</published>
    <updated>2016-06-10T07:48:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="H-Index_I">H-Index I</h2><h3 id="题目描述">题目描述</h3><p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”</p>
<p>For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.</p>
<p><strong> Note: </strong>If there are several possible values for h, the maximum one is taken as the h-index.</p>
<p><strong> Hint: </strong></p>
<pre><code>1. An easy approach is to sort the<span class="instruction"> array </span>first.
2. What are the possible values of h-index?
3. A faster approach is to use extra space.
</code></pre><p>一名科学家的h指数是指其发表的N篇论文中有h篇每篇至少被引用了h次，其余的N-h篇引用次数均不超过h次(小于或等于)。使用数组count记录引用次数在0~N的文章篇数，引用次数大于N文章也算做引用了N次的文章(h指数小于等于论文总数N)。然后从后往前遍历，并统计引用次数至少为i次文章数量。</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//一名科学家的h指数是指其发表的N篇论文中有h篇每篇至少被引用了h次，其余的N-h篇引用次数均不超过h次(小于或等于)</span></span><br><span class="line">    <span class="comment">//使用数组count记录引用次数在0~N的文章篇数，引用次数大于N文章也算做引用了N次的文章(h指数小于等于论文总数N)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(citations == null || citations.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = citations.length;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> citation: citations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(citation &gt; length) count[length]++;</span><br><span class="line">            <span class="keyword">else</span> count[citation]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//然后从后往前遍历，并统计引用次数至少为i次文章数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            total += count[i];</span><br><span class="line">            <span class="comment">//有total篇文章每篇至少被引用了i次，则h指数为i</span></span><br><span class="line">            <span class="comment">//total&gt;=i,所以肯定满足有i篇文章每篇至少被引用了i次</span></span><br><span class="line">            <span class="keyword">if</span>(total &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用排序的方法，但那样的时间复杂度为O(nlgn)。按文章引用次数升序排序代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(citations == null || citations.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line">        <span class="keyword">int</span> length = citations.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; citations.length; i++)&#123;</span><br><span class="line">            <span class="comment">// if(length &lt;= citations[i])&#123;</span></span><br><span class="line">            <span class="comment">//     return length;</span></span><br><span class="line">            <span class="comment">// &#125;else&#123;</span></span><br><span class="line">            <span class="comment">//     length--;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">//等价于</span></span><br><span class="line">            <span class="keyword">if</span>(citations[i] &gt;= length - i)</span><br><span class="line">                <span class="keyword">return</span> length - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="H-Index_I-1">H-Index I</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?</p>
<p><strong> Hint: </strong></p>
<pre><code><span class="number">1</span>. Expected runtime complexity is <span class="keyword">in</span> <span class="function"><span class="title">O</span><span class="params">(log n)</span></span> and the <span class="tag">input</span> is sorted.
</code></pre><h3 id="代码-1">代码</h3><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hIndex(<span class="built_in">int</span>[] citations) &#123;</span><br><span class="line">        <span class="keyword">if</span>(citations == <span class="literal">null</span> || citations.length == <span class="number">0</span>) return <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = citations.length - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> length = citations.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt;= <span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (<span class="built_in">right</span> - <span class="built_in">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(citations[<span class="built_in">mid</span>] == length - <span class="built_in">mid</span>) return length - <span class="built_in">mid</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(citations[<span class="built_in">mid</span>] &gt; length - <span class="built_in">mid</span>) <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">left</span> = <span class="built_in">mid</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return length - <span class="built_in">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="H-Index_I">H-Index I</h2><h3 id="题目描述">题目描述</h3><p>According to the definition of h-index on Wikipedia: “A scientist has index h if ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Find Peak Element]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Find-Peak-Element/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Find-Peak-Element/</id>
    <published>2016-06-10T04:03:06.000Z</published>
    <updated>2016-06-10T05:24:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array where <font color="red">num[i] ≠ num[i+1]</font>, find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that <font color="red">num[-1] = num[n] = -∞</font>.</p>
<p>For example, in array <font color="red">[1, 2, 3, 1]</font>, 3 is a peak element and your function should return the index number 2.</p>
<p><strong> Note: </strong><br>Your solution should be in logarithmic complexity.</p>
<p>local maximum就是一个peek，mid = (left + right)/2,mid1 = mid + 1<br>如果nums[mid] &lt; nums[mid1]，那么nums[mid1…right]一定有peek，为什么？因为相邻的数不能相等,那么mid1右边的数只能增加或者减少，如果mid1右边的数一直增加，则nums[right]就是peek，否则的话mid1右边的数出现下降的时候就会出现peek同理nums[mid] &gt; nums[mid1]，那么nums[left, mid]一定有peek，道理是一样的。因为相邻的数不能相等,那么mid左边的数只能增加或者减少，如果mid左边的数一直增加，则nums[left]就是peek，否则的话mid左边的数出现下降的时候就会出现peek。</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//local maximum就是一个peek</span></span><br><span class="line">    <span class="comment">//mid = (left + right)/2,mid1 = mid + 1</span></span><br><span class="line">    <span class="comment">//如果nums[mid] &lt; nums[mid1]，那么nums[mid1...right]一定有peek，为什么？</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid1右边的数只能增加或者减少，如果mid1右边的数一直增加，则nums[right]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid1右边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="comment">//同理nums[mid] &gt; nums[mid1]，那么nums[left, mid]一定有peek，道理是一样的</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid左边的数只能增加或者减少，如果mid左边的数一直增加，则nums[left]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid左边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> mid1 = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右边一定有peek</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid1])&#123;</span><br><span class="line">                left = mid1;</span><br><span class="line">            <span class="comment">//左边一定有peek</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="comment">//如果出现相等就不符合题目中相邻元素不相等，可以抛异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历的方法不符合时间复杂度，但是实现非常tricky，代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//遍历的方法不符合时间复杂度，但是实现非常tricky</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//右边有减小的话则peek出现</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>]) <span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则元素一直增大到最右边元素就是peek</span></span><br><span class="line">        <span class="keyword">return</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array where <font color="re]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Set Matrix Zeroes]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Set-Matrix-Zeroes/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Set-Matrix-Zeroes/</id>
    <published>2016-06-10T02:39:50.000Z</published>
    <updated>2016-06-10T02:44:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p><strong> Follow up: </strong><br>Did you use extra space?<br>A straight forward solution using O(mn) space is probably a bad idea.<br>A simple improvement uses O(m + n) space, but still not the best solution.<br>Could you devise a constant space solution?</p>
<p>mxn的矩阵，比较直接的思路就是用两个数组记录哪一列需要置为0，哪一行需要置为0。比如int[rows]、int[cols]或者用boolean数组也可以，这样的话我们需要O(m+n)的空间复杂度，其实我们可以省掉这些空间开销，只需要O(1)的空间复杂度，方法就是复用matrix数组的第0行和第0列，而matrix本身的第0行和第0列是否需要置为0，我们只要利用两个变量比如row0和col0记录下来就可以,其实也可以精简到只用一个变量col0就可以，我感觉那样做代码虽然精简但没有那么好理解，没必要为了节省一个变量和精简代码而牺牲代码可读性。</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//mxn的矩阵，比较直接的思路就是用两个数组记录哪一列需要置为0，哪一行需要置为0</span></span><br><span class="line">    <span class="comment">//int[rows]、int[cols]或者用boolean数组也可以，这样的话我们需要O(m+n)的空间复杂度，其实我们可以</span></span><br><span class="line">    <span class="comment">//省掉这些空间开销，只需要O(1)的空间复杂度，方法就是复用matrix数组的第0行和第0列，而matrix本身的</span></span><br><span class="line">    <span class="comment">//第0行和第0列是否需要置为0，我们只要利用两个变量比如row0和col0记录下来就可以,其实也可以精简到只用</span></span><br><span class="line">    <span class="comment">//一个变量col0就可以，我感觉那样做代码虽然精简但没有那么好理解，没必要为了节省一个变量和精简代码而牺牲代码可读性。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        boolean row0 = <span class="literal">false</span>, col0 = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果原始数组的第0行有元素为0，那么最终第0行也是要全部置为0，用row0 = true表示</span></span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>) row0 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//如果原始数组的第0列有元素为0，那么最终第0列也是要全部置为0，用row0 = true表示</span></span><br><span class="line">                    <span class="keyword">if</span>(j == <span class="number">0</span>) col0 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//第i行和第j列都要置为0，记录在matrix[i][0]和matrix[0][j]中</span></span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(row0)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(col0)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p><strong> Foll]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Peeking Iterator]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Peeking-Iterator/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Peeking-Iterator/</id>
    <published>2016-06-10T00:58:11.000Z</published>
    <updated>2016-06-10T01:07:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation – it essentially peek() at the element that will be returned by the next call to next().</p>
<p>Here is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3].</p>
<p>Call next() gets you 1, the first element in the list.</p>
<p>Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.</p>
<p>You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false.</p>
<p><strong> Hint: </strong></p>
<pre><code>1. Think of "looking ahead". You want to <span class="operator"><span class="keyword">cache</span> the <span class="keyword">next</span> <span class="keyword">element</span>.
<span class="number">2.</span> <span class="keyword">Is</span> one <span class="keyword">variable</span> sufficient? Why <span class="keyword">or</span> why <span class="keyword">not</span>?
<span class="number">3.</span> <span class="keyword">Test</span> your design <span class="keyword">with</span> <span class="keyword">call</span> <span class="keyword">order</span> <span class="keyword">of</span> peek() <span class="keyword">before</span> <span class="keyword">next</span>() vs <span class="keyword">next</span>() <span class="keyword">before</span> peek().
<span class="number">4.</span> <span class="keyword">For</span> a clean implementation, <span class="keyword">check</span> <span class="keyword">out</span> Google<span class="string">'s guava library source code.</span></span>
</code></pre><p>Follow up: How would you extend your design to be generic and work with all types, not just integer?</p>
<h2 id="代码">代码</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">Java</span> <span class="type">Iterator</span> <span class="keyword">interface</span> reference:</span><br><span class="line">// https://docs.oracle.com/javase/<span class="number">8</span>/docs/api/java/util/<span class="type">Iterator</span>.html</span><br><span class="line">//可以将next元素缓存起来，如果next为null则说明<span class="type">Iterator</span>没有元素了</span><br><span class="line">class <span class="type">PeekingIterator</span> implements <span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; &#123;</span><br><span class="line">    private <span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; iter;</span><br><span class="line">    private <span class="type">Integer</span> next = null;</span><br><span class="line">	public <span class="type">PeekingIterator</span>(<span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; <span class="keyword">iterator</span>) &#123;</span><br><span class="line">	    // initialize <span class="type">any</span> member here.</span><br><span class="line">	    iter = <span class="keyword">iterator</span>;</span><br><span class="line">	    <span class="keyword">if</span>(iter.hasNext())</span><br><span class="line">	        next = iter.next();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // <span class="type">Returns</span> the next element <span class="keyword">in</span> the iteration <span class="keyword">without</span> advancing the <span class="keyword">iterator</span>.</span><br><span class="line">	public <span class="type">Integer</span> peek() &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// hasNext() <span class="keyword">and</span> next() should behave the same <span class="keyword">as</span> <span class="keyword">in</span> the <span class="type">Iterator</span> <span class="keyword">interface</span>.</span><br><span class="line">	// <span class="type">Override</span> them <span class="keyword">if</span> needed.</span><br><span class="line">	@<span class="type">Override</span></span><br><span class="line">	public <span class="type">Integer</span> next() &#123;</span><br><span class="line">	    <span class="type">Integer</span> res = next;</span><br><span class="line">	    //更新next元素</span><br><span class="line">	    next = iter.hasNext() ? iter.next() : null;</span><br><span class="line">	    //返回前一next元素</span><br><span class="line">	    <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@<span class="type">Override</span></span><br><span class="line">	public boolean hasNext() &#123;</span><br><span class="line">	    <span class="keyword">return</span> next != null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Google’s_guava">Google’s guava</h2><p>guava的实现使用peekedElement记录peek元素，并使用一个标记位hasPeeked来判断是否有peek元素，Google’s guava的实现如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * <span class="type">Implementation</span> <span class="keyword">of</span> <span class="type">PeekingIterator</span> that avoids peeking unless necessary.</span><br><span class="line">   */</span><br><span class="line">  private <span class="keyword">static</span> class <span class="type">PeekingImpl</span>&lt;E&gt; implements <span class="type">PeekingIterator</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final <span class="type">Iterator</span>&lt;? extends E&gt; <span class="keyword">iterator</span>;</span><br><span class="line">    private boolean hasPeeked;</span><br><span class="line">    private E peekedElement;</span><br><span class="line"></span><br><span class="line">    public <span class="type">PeekingImpl</span>(<span class="type">Iterator</span>&lt;? extends E&gt; <span class="keyword">iterator</span>) &#123;</span><br><span class="line">      this.<span class="keyword">iterator</span> = checkNotNull(<span class="keyword">iterator</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">      <span class="keyword">return</span> hasPeeked || <span class="keyword">iterator</span>.hasNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    public E next() &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasPeeked) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">iterator</span>.next();</span><br><span class="line">      &#125;</span><br><span class="line">      E <span class="literal">result</span> = peekedElement;</span><br><span class="line">      hasPeeked = <span class="literal">false</span>;</span><br><span class="line">      peekedElement = null;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    public <span class="type">void</span> remove() &#123;</span><br><span class="line">      checkState(!hasPeeked, <span class="string">"Can't remove after you've peeked at next"</span>);</span><br><span class="line">      <span class="keyword">iterator</span>.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    public E peek() &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasPeeked) &#123;</span><br><span class="line">        peekedElement = <span class="keyword">iterator</span>.next();</span><br><span class="line">        hasPeeked = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> peekedElement;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
