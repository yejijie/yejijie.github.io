<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-07-02T09:47:03.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-Binary-Tree-Maximum-Path-Sum/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-Binary-Tree-Maximum-Path-Sum/</id>
    <published>2016-07-02T09:47:03.000Z</published>
    <updated>2016-07-02T09:47:03.000Z</updated>
    <content type="html"><![CDATA[<p>title: ‘[LeetCode]Binary Tree Maximum Path Sum’<br>date: 2016-07-02 17:45:09<br>tags:</p>
<ul>
<li>Java</li>
<li>算法<br>categories:</li>
<li>Leetcode</li>
</ul>
<h2 id="题目描述">题目描述</h2><p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root.</p>
<p>For example:<br>Given the below binary tree,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Return 6.</p>
<h2 id="代码">代码</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree <span class="keyword">node</span>.<span class="identifier"></span><br><span class="line"> </span><span class="title">* public</span> class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//<span class="number">1</span>. <span class="keyword">Node</span><span class="identifier"> </span><span class="title">only</span></span><br><span class="line">//<span class="number">2</span>. L-sub + <span class="keyword">Node</span><span class="identifier"></span><br><span class="line"></span><span class="title">//3</span>. R-sub + <span class="keyword">Node</span><span class="identifier"></span><br><span class="line"></span><span class="title">//4</span>. L-sub + <span class="keyword">Node</span><span class="identifier"> </span><span class="title">+ R-sub</span></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    //Java中pass by value，不像C++的引用或者指针</span><br><span class="line">    //解决办法是用全局变量、数组、包装类，这里用全局变量</span><br><span class="line">    int max = Integer.MIN_VALUE;</span><br><span class="line">    //因为存在负数，所以最大值不一定是roog+l-sub+r-sub</span><br><span class="line">    public int maxPathSum(TreeNode root) &#123;</span><br><span class="line">        maxPathDown(root);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //该函数计算路径最高节点为<span class="keyword">node</span><span class="identifier"></span><span class="title">的最大路径和(返回值)，并更新全局最大值</span><br><span class="line">    //returns</span> the maximum sum of the path that can be extended to input <span class="keyword">node</span><span class="identifier"></span><span class="title">'s</span> parent.</span><br><span class="line">    //返回能扩展输入节点（<span class="keyword">node</span><span class="identifier"></span><span class="title">）的父节点的路径的最大和</span><br><span class="line">    //能扩展输入节点node</span>的父节点的路径只有三种情况：</span><br><span class="line">    //<span class="number">1</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">only</span></span><br><span class="line">    //<span class="number">2</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">+ l-sub</span></span><br><span class="line">    //<span class="number">3</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">+ r-sub</span></span><br><span class="line">    //而<span class="keyword">node</span><span class="identifier"></span><span class="title">+l-sub</span>+r-sub是不能扩展<span class="keyword">node</span><span class="identifier"></span><span class="title">的父节点的</span><br><span class="line">    // private</span> int maxPathDown(TreeNode <span class="keyword">node</span><span class="identifier"></span><span class="title">)&#123;</span><br><span class="line">    //     if</span>(<span class="keyword">node</span><span class="identifier"> </span><span class="title">== null</span>) return <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    //     int left = maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>);</span><br><span class="line">    //     int right = maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>);</span><br><span class="line">        </span><br><span class="line">    //     //表示通过<span class="keyword">node</span><span class="identifier"></span><span class="title">节点能到达node</span>的parent节点的最大和，作为返回值返回给父节点的函数调用</span><br><span class="line">    //     //因为更新全局最大值也要用到所以先用局部变量存起来，不用重复计算</span><br><span class="line">    //     int maxPathAcrossNodeToParent = Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    //     //更新全局最大值</span><br><span class="line">    //     max = Math.max(max, Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right, maxPathAcrossNodeToParent));</span><br><span class="line">    //     //return Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    //     return maxPathAcrossNodeToParent;</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    //其实maxPathDown的可以优化如下：</span><br><span class="line">    private int maxPathDown(TreeNode <span class="keyword">node</span><span class="identifier"></span><span class="title">)&#123;</span><br><span class="line">        if</span>(<span class="keyword">node</span><span class="identifier"> </span><span class="title">== null</span>) return <span class="number">0</span>;</span><br><span class="line">        //节点存在负数，如果为负数则对路径最大和没有任何帮助，抛弃即可</span><br><span class="line">        //left或right至少大于<span class="number">0</span>才对max有帮助</span><br><span class="line">        //这样处理后更新全局最大值时用max跟<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right比较即可</span><br><span class="line">        //<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right代表了<span class="keyword">node</span><span class="identifier"></span><span class="title">、node</span>+l-sub、<span class="keyword">node</span><span class="identifier"></span><span class="title">+r-sub</span>、<span class="keyword">node</span><span class="identifier"></span><span class="title">+l-sub</span>+r-sub最大值</span><br><span class="line">        int left = Math.max(<span class="number">0</span>,maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>));</span><br><span class="line">        int right = Math.max(<span class="number">0</span>, maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>));</span><br><span class="line">        </span><br><span class="line">        max = Math.max(max, <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right);</span><br><span class="line">        </span><br><span class="line">        return Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>title: ‘[LeetCode]Binary Tree Maximum Path Sum’<br>date: 2016-07-02 17:45:09<br>tags:</p>
<ul>
<li>Java</li>
<li>算法<br>categories:</li>
<]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]First Missing Positive]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-First-Missing-Positive/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-First-Missing-Positive/</id>
    <published>2016-07-02T05:22:11.000Z</published>
    <updated>2016-07-02T09:45:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br>Given [1,2,0] return 3,<br>and [3,4,-1,1] return 2.</p>
<p>Your algorithm should run in O(n) time and uses constant space.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//注意0不是正数,找出第一个缺失的正数</span></span><br><span class="line">    <span class="comment">//所以把1放到下标0的位置，2放到下标1，3放到下标2，。。。。。。</span></span><br><span class="line">    <span class="comment">//即把nums[i]放到nums[nums[i] - 1]的位置</span></span><br><span class="line">    <span class="comment">//然后从前往后遍历找出第一个缺失的正数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//注意交换过来的可能是一个正数，也不在其正确的位置上，所以我们需要用while而不是if</span></span><br><span class="line">            <span class="comment">//用while直到交换过来是负数或者大于nums.length的数</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums.length &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如[1,2,3]缺4</span></span><br><span class="line">        <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br>Given [1,2,0] ret]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Duplicate Letters]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-Remove-Duplicate-Letters/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-Remove-Duplicate-Letters/</id>
    <published>2016-07-02T03:46:27.000Z</published>
    <updated>2016-07-02T03:53:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p>Example:<br>Given “bcabc”<br>Return “abc”</p>
<p>Given “cbacdcbc”<br>Return “acdb”</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//时间复杂度为O(kn)，k为唯一字符的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)  count[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="comment">//题目要求字典序最小，如何贪心选择s[pos]</span></span><br><span class="line">        <span class="comment">//选择左边最小的字符，并且保证s[i...length]包含所有唯一的字符，</span></span><br><span class="line">        <span class="comment">//break条件是遇到词频最小的字符</span></span><br><span class="line">        <span class="comment">//贪心选择：假设词频最小的字符为s[i],那么贪心选择s[0...i]中最小的字符</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &lt; s.charAt(pos)) pos = i;</span><br><span class="line">            <span class="comment">//找到唯一字符或者词频最小的字符，循环终止</span></span><br><span class="line">            <span class="keyword">if</span>(--count[s.charAt(i) - <span class="string">'a'</span>] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//贪心选择后s.charAt(pos),如何构造新字符串</span></span><br><span class="line">        <span class="comment">//抛弃s[pos]左边的字符，移除s[pos+1...length]中为s[pos]的字符</span></span><br><span class="line">        <span class="keyword">return</span> s.length() == <span class="number">0</span> ? <span class="string">""</span> : s.charAt(pos) + removeDuplicateLetters(s.substring(pos+<span class="number">1</span>).replaceAll(<span class="string">""</span>+s.charAt(pos), <span class="string">""</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用栈</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//时间复杂度为O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) freq[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录字符是否在栈中</span></span><br><span class="line">        boolean[] visited = <span class="keyword">new</span> boolean[<span class="number">26</span>];</span><br><span class="line">        Stack&lt;Character&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            </span><br><span class="line">            freq[ch - <span class="string">'a'</span>]--;</span><br><span class="line">            <span class="comment">//已在栈中</span></span><br><span class="line">            <span class="keyword">if</span>(visited[ch-<span class="string">'a'</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//栈顶字符字符比当前字符大而且后面还有该字符，弹栈</span></span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty() &amp;&amp; <span class="built_in">stack</span>.peek() &gt; ch &amp;&amp; freq[<span class="built_in">stack</span>.peek() - <span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//弹栈并且设置为不在栈中false</span></span><br><span class="line">                visited[<span class="built_in">stack</span>.pop() - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="built_in">stack</span>.push(ch);</span><br><span class="line">            visited[ch - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//这样遍历栈相当于把栈逆过来：），意外发现</span></span><br><span class="line">        <span class="comment">// for(char ch : stack)&#123;</span></span><br><span class="line">        <span class="comment">//     sb.append(ch);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//return sb.toString();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty())&#123;</span><br><span class="line">            sb.append(<span class="built_in">stack</span>.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once an]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Copy List with Random Pointer]]></title>
    <link href="http://blog.noobsky.com/2016/07/01/LeetCode-Copy-List-with-Random-Pointer/"/>
    <id>http://blog.noobsky.com/2016/07/01/LeetCode-Copy-List-with-Random-Pointer/</id>
    <published>2016-07-01T12:34:32.000Z</published>
    <updated>2016-07-01T14:21:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<h2 id="代码">代码</h2><p>最简单的思路就是用HashMap存取node节点，第一遍将node存到HashMap中，第二遍遍历为每个节点的next和random赋值。时间复杂度为O(n)，空间复杂度为O(n)。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list with a random pointer.</span><br><span class="line"> * class RandomListNode &#123;</span><br><span class="line"> *     int label;</span><br><span class="line"> *     RandomListNode next, random;</span><br><span class="line"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    //使用HashMap，遍历两遍</span><br><span class="line">    //第一遍把所以节点加入到HashMap中</span><br><span class="line">    //第二遍给map中节点的next和random赋值</span><br><span class="line">    public RandomListNode copyRandomList(RandomListNode head) &#123;</span><br><span class="line">        if(head == null) return head;</span><br><span class="line">        </span><br><span class="line">        Map<span class="tag">&lt;RandomListNode, RandomListNode&gt;</span> map = new HashMap<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        </span><br><span class="line">        RandomListNode <span class="keyword">node</span><span class="identifier"> </span><span class="title">= head</span>;</span><br><span class="line">        while(<span class="keyword">node</span><span class="identifier"> </span><span class="title">!= null</span>)&#123;</span><br><span class="line">            map.put(<span class="keyword">node</span><span class="identifier"></span><span class="title">, new</span> RandomListNode(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">label</span>));</span><br><span class="line">            <span class="keyword">node</span><span class="identifier"> </span><span class="title">= node</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">node</span><span class="identifier"> </span><span class="title">= head</span>;</span><br><span class="line">        //为每个节点赋值next和random的指向</span><br><span class="line">        while(<span class="keyword">node</span><span class="identifier"> </span><span class="title">!= null</span>)&#123;</span><br><span class="line">            map.get(<span class="keyword">node</span><span class="identifier"></span><span class="title">).next</span> = map.get(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">next</span>);</span><br><span class="line">            map.get(<span class="keyword">node</span><span class="identifier"></span><span class="title">).random</span> = map.get(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">random</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">node</span><span class="identifier"> </span><span class="title">= node</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方法，包括三步：</p>
<ul>
<li><p>为每个原始节点复制一个副本节点，链接到原始节点之后</p>
</li>
<li><p>将每个原始节点的random指针赋值给副本节点的random指针，curr.next.random = curr.random.next;</p>
</li>
<li><p>将链表划分为两部分，一个为原始链表，一个为复制链表</p>
</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">public</span> RandomListNode copyRandomList(RandomListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        RandomListNode curr = head;</span><br><span class="line">        <span class="comment">//为每个节点复制一份副本链接到原始节点的后面</span></span><br><span class="line">        <span class="comment">//如A-&gt;B-&gt;C变为A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode <span class="keyword">copy</span> = <span class="keyword">new</span> RandomListNode(curr.label);</span><br><span class="line">            <span class="keyword">copy</span>.<span class="keyword">next</span> = curr.<span class="keyword">next</span>;</span><br><span class="line">            curr.<span class="keyword">next</span> = <span class="keyword">copy</span>;</span><br><span class="line">            </span><br><span class="line">            curr = <span class="keyword">copy</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="comment">//第二次遍历，将每个原始节点的random指针赋值给副本的random指针</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">                curr.<span class="keyword">next</span>.random = curr.random.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将链表分成两个，一个还原为原链表，一个就是复制的链表</span></span><br><span class="line">        curr = head;</span><br><span class="line">        RandomListNode newHead = head.<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">// while(curr != null &amp;&amp; curr.next != null)&#123;</span></span><br><span class="line">        <span class="comment">//     //这种写法比较tricky</span></span><br><span class="line">        <span class="comment">//     //写链接原始节点，接着副本节点，然后又原始节点，又副本节点。。。。</span></span><br><span class="line">        <span class="comment">//     RandomListNode temp = curr.next;</span></span><br><span class="line">        <span class="comment">//     curr.next = temp.next;</span></span><br><span class="line">        <span class="comment">//     curr = temp;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//复制节点</span></span><br><span class="line">            RandomListNode <span class="keyword">copy</span> = curr.<span class="keyword">next</span>;</span><br><span class="line">            </span><br><span class="line">            curr.<span class="keyword">next</span> = <span class="keyword">copy</span>.<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">copy</span>.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">copy</span>.<span class="keyword">next</span> = <span class="keyword">copy</span>.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Merge Intervals and Insert Interval]]></title>
    <link href="http://blog.noobsky.com/2016/07/01/LeetCode-Merge-Intervals-and-Insert-Interval/"/>
    <id>http://blog.noobsky.com/2016/07/01/LeetCode-Merge-Intervals-and-Insert-Interval/</id>
    <published>2016-07-01T07:03:24.000Z</published>
    <updated>2016-07-01T07:38:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Merge_Intervals">Merge Intervals</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,<br>Given [1,3],[2,6],[8,10],[15,18],<br>return [1,6],[8,10],[15,18].</p>
<h3 id="代码">代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for an interval.</span><br><span class="line"> * public class Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() &#123; start = 0; end = 0; &#125;</span><br><span class="line"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">//我们按interval的start升序来排序，然后将interval的end和下一个interval的start比较，看是否出现了overlap</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        </span><br><span class="line">        Collections.<span class="built_in">sort</span>(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> compare(Interval i1, Interval i2)&#123;</span><br><span class="line">                <span class="comment">//按start的升序排序，可以直接利用Integer的compare函数</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(i1.start, i2.start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> start = intervals.<span class="built_in">get</span>(<span class="number">0</span>).start;</span><br><span class="line">        <span class="comment">//上一interval的end</span></span><br><span class="line">        <span class="built_in">int</span> end = intervals.<span class="built_in">get</span>(<span class="number">0</span>).end;</span><br><span class="line">        <span class="keyword">for</span>(Interval interval : intervals)&#123;</span><br><span class="line">            <span class="comment">//当前interval的start小于上一个interval的end，说明出现overlap</span></span><br><span class="line">            <span class="keyword">if</span>(interval.start &lt;= end)&#123;</span><br><span class="line">                <span class="comment">//则end为上一个interval和当前interval的end的较大值</span></span><br><span class="line">                end = Math.<span class="built_in">max</span>(interval.end, end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">add</span>(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入最后一个Interval</span></span><br><span class="line">        res.<span class="built_in">add</span>(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Insert_Interval">Insert Interval</h2><h3 id="题目描述-1">题目描述</h3><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were <font color="red">initially sorted</font> according to their start times.</p>
<p>Example 1:<br>Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>
<p>Example 2:<br>Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].</p>
<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>
<h3 id="代码-1">代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先将那些与newInterval没有overlap的interval放入结果集中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).end &lt; newInterval.start)&#123;</span><br><span class="line">            res.<span class="built_in">add</span>(intervals.<span class="built_in">get</span>(i));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合并所有overlapping的intervals,赋值为newInterval</span></span><br><span class="line">        <span class="comment">//如果intervals.get(i).start &gt; newInterval.end说明已经没有Overlapping</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).start &lt;= newInterval.end)&#123;</span><br><span class="line">            newInterval = <span class="keyword">new</span> Interval(Math.<span class="built_in">min</span>(newInterval.start, intervals.<span class="built_in">get</span>(i).start), Math.<span class="built_in">max</span>(newInterval.end, intervals.<span class="built_in">get</span>(i).end));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将合并结果加入结果中</span></span><br><span class="line">        res.<span class="built_in">add</span>(newInterval);</span><br><span class="line">        <span class="comment">//将剩下的元素加入结果中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">add</span>(intervals.<span class="built_in">get</span>(i));</span><br><span class="line">            i++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实可以直接在原始的List上操作：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	<span class="comment">//在原始的List中直接操作</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//没有overlapping的直接跳过</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).end &lt; newInterval.start)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并具有overlapping的intervals</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).start &lt;= newInterval.end)&#123;</span><br><span class="line">            newInterval = <span class="keyword">new</span> Interval(Math.<span class="built_in">min</span>(newInterval.start, intervals.<span class="built_in">get</span>(i).start), Math.<span class="built_in">max</span>(newInterval.end, intervals.<span class="built_in">get</span>(i).end));</span><br><span class="line">            <span class="comment">//移除下标为i的元素</span></span><br><span class="line">            intervals.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.<span class="built_in">add</span>(i, newInterval);</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Merge_Intervals">Merge Intervals</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of intervals, merge all overlapping intervals.</p>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Burst Balloons]]></title>
    <link href="http://blog.noobsky.com/2016/07/01/LeetCode-Burst-Balloons/"/>
    <id>http://blog.noobsky.com/2016/07/01/LeetCode-Burst-Balloons/</id>
    <published>2016-07-01T01:38:48.000Z</published>
    <updated>2016-07-01T04:23:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.</p>
<p>Find the maximum coins you can collect by bursting the balloons wisely.</p>
<p><strong> Note: </strong><br>(1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</p>
<p><strong> Example: </strong></p>
<p>Given [3, 1, 5, 8]</p>
<p>Return 167</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>] --&gt; [<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>] --&gt;   [<span class="number">3</span>,<span class="number">8</span>]   --&gt;  [<span class="number">8</span>]  --&gt; []</span><br><span class="line">coins =  <span class="number">3</span>*<span class="number">1</span>*<span class="number">5</span>      +  <span class="number">3</span>*<span class="number">5</span>*<span class="number">8</span>    +  <span class="number">1</span>*<span class="number">3</span>*<span class="number">8</span>      + <span class="number">1</span>*<span class="number">8</span>*<span class="number">1</span>   = <span class="number">167</span></span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2><p>最自然的方法就是打掉一个气球然后将原问题划分成了两个子问题，分别为打掉气球的左边和右边的气球，但是它们相邻接，会对maxCoins造成影响。我们可以逆向思考，我们不是通过第一个打掉的气球来划分原问题，而是通过最后一个打掉的气球来划分。前者获得的分数为<code>nums[i-1]*nums[i]*nums[i+1]</code>，后者为<code>nums[-1]*nums[i]*nums[n]</code>。</p>
<p>dp[i][j]表示打破区间[i,j]中所有气球能得到的分数(coins)。<br>如果最后一个打破的气球为k，则可以获得的分数为：nums[i-1]*nums[k]*nums[j+1]。则状态转移方程为：<br>dp[i][j] = max(dp[i][j], nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j]), i &lt;= k &lt;= j<br>为了方便代码的书写，在数组的两端插入两个1，即nums[-1] = 1，nums[n] = 1</p>
<p>还可以将所有为0的气球先打破，因为它们不能带来任何分数，当然不做这个也是可以的。</p>
<ul>
<li>Divide And Conquer with Memoization</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] eNums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           eNums[i+<span class="number">1</span>] = nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        eNums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        eNums[nums.length + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>][nums.length + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> burst(eNums, dp, <span class="number">1</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带备忘的递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">burst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[][] dp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[left][right] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[left][right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i为最后打破的气球</span></span><br><span class="line">        <span class="comment">//dp[i][j] = max(dp[i][j], nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j]), i &lt;= k &lt;= j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            res = Math.max(res, nums[left-<span class="number">1</span>]*nums[i]*nums[right+<span class="number">1</span>] + burst(nums, dp, left, i-<span class="number">1</span>) + burst(nums, dp, i+<span class="number">1</span>, right));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[left][right] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>DP</li>
</ul>
<p>直接dp的话，类似最优二叉搜索树，见算法导论，可对比理解<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//直接dp的话，类似最优二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] eNums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           eNums[i+<span class="number">1</span>] = nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        eNums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        eNums[nums.length + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>][nums.length + <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先求长度为1、2、3.。。。n的区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= nums.length; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">1</span>; left &lt;= nums.length - len + <span class="number">1</span>; left++)&#123;</span><br><span class="line">                <span class="keyword">int</span> right = left + len - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//注意用扩展后的eNums数组</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = left; k &lt;= right; k++)&#123;</span><br><span class="line">                    dp[left][right] = Math.max(dp[left][right], eNums[left-<span class="number">1</span>]*eNums[k]*eNums[right+<span class="number">1</span>]+dp[left][k-<span class="number">1</span>] + dp[k+<span class="number">1</span>][right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][nums.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考">参考</h2><p><strong> Better idea </strong></p>
<p>We then think can we apply the divide and conquer technique? After all there seems to be many self similar sub problems from the previous analysis.</p>
<p>Well, the nature way to divide the problem is burst one balloon and separate the balloons into 2 sub sections one on the left and one one the right. However, in this problem the left and right become adjacent and have effects on the maxCoins in the future.</p>
<p>Then another interesting idea come up. Which is quite often seen in dp problem analysis. That is reverse thinking. Like I said the coins you get for a balloon does not depend on the balloons already burst. Therefore instead of divide the problem by the first balloon to burst, we divide the problem by the last balloon to burst.</p>
<p>Why is that? Because only the first and last balloons we are sure of their adjacent balloons before hand!</p>
<p>For the first we have nums[i-1]<em>nums[i]</em>nums[i+1] for the last we have nums[-1]<em>nums[i]</em>nums[n].</p>
<p>OK. Think about n balloons if i is the last one to burst, what now?</p>
<p>We can see that the balloons is again separated into 2 sections. But this time since the balloon i is the last balloon of all to burst, the left and right section now has well defined boundary and do not affect each other! Therefore we can do either recursive method with memoization or dp.</p>
<p>Final</p>
<p>Here comes the final solutions. Note that we put 2 balloons with 1 as boundaries and also burst all the zero balloons in the first round since they won’t give any coins. The algorithm runs in O(n^3) which can be easily seen from the 3 loops in dp solution.</p>
<p>详见<a href="https://leetcode.com/discuss/72216/share-some-analysis-and-explanations" target="_blank" rel="external">Share some analysis and explanations</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. Yo]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Intersection of Two Arrays I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Intersection-of-Two-Arrays-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Intersection-of-Two-Arrays-I-II/</id>
    <published>2016-06-26T07:10:50.000Z</published>
    <updated>2016-07-01T01:40:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Intersection_of_Two_Arrays_I">Intersection of Two Arrays I</h2><h3 id="题目描述">题目描述</h3><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong> Example: </strong><br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>
<p><strong> Note: </strong></p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
<h3 id="代码">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	 <span class="comment">//使用HashSet，分别遍历两个数组</span></span><br><span class="line">    <span class="comment">//首先把第一个数组加入到集合中</span></span><br><span class="line">    <span class="comment">//然后遍历第二个数组时判断集合中是否包含元素</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(n)，空间复杂度为O(n)</span></span><br><span class="line">    public <span class="built_in">int</span>[] intersection(<span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; <span class="literal">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//利用集合对交集进行去重</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; intersect = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num1: nums1)&#123;</span><br><span class="line">            <span class="literal">set</span>.add(num1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num2: nums2)&#123;</span><br><span class="line">            <span class="comment">//nums1中包含</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">set</span>.contains(num2))&#123;</span><br><span class="line">                intersect.add(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[intersect.size()];</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer <span class="built_in">num</span> : intersect)&#123;</span><br><span class="line">            res[i++] = <span class="built_in">num</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//另外还可以先排序然后使用tow pointers，类似merge array，时间复杂度为O(n)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">set</span>.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">set</span>.size()];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : <span class="built_in">set</span>)&#123;</span><br><span class="line">            res[k++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或者对一个数组排序，然后使用二分搜索在排序数组中搜索另一个数组的元素</span></span><br><span class="line">    <span class="comment">//时间复杂度都为O(nlgn)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Intersection_of_Two_Arrays_II">Intersection of Two Arrays II</h2><h3 id="题目描述-1">题目描述</h3><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong> Example: </strong><br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>
<p><strong> Note: </strong></p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p><strong> Follow up: </strong></p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<h3 id="代码-1">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Solution</span>&#123;</span><br><span class="line">	    //使用<span class="type">HashMap</span>，key为nums1中的元素，value为该元素出现的次数</span><br><span class="line">    //时间复杂度为O(n)，空间复杂度为O(n)</span><br><span class="line">    public <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> new <span class="type">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">Integer</span>, <span class="type">Integer</span>&gt; map = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; <span class="literal">result</span> = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num1 : nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num1))&#123;</span><br><span class="line">                map.put(num1, map.get(num1) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num1, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num2: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num2) &amp;&amp; map.get(num2) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="literal">result</span>.add(num2);</span><br><span class="line">                map.put(num2, map.get(num2) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] res = new <span class="type">int</span>[<span class="literal">result</span>.size()];</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Integer</span> num: <span class="literal">result</span>)&#123;</span><br><span class="line">            res[i++] = num;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Solution</span>&#123;</span><br><span class="line">	    //时间复杂度为O(nlgn)， 空间复杂度为O(n)</span><br><span class="line">    public <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> new <span class="type">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">Arrays</span>.sort(nums1);</span><br><span class="line">        <span class="type">Arrays</span>.sort(nums2);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; <span class="literal">result</span> = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="literal">result</span>.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] res = new <span class="type">int</span>[<span class="literal">result</span>.size()];</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Integer</span> num : <span class="literal">result</span>)&#123;</span><br><span class="line">            res[k++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution_to_3rd_follow-up_question">Solution to 3rd follow-up question</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What <span class="keyword">if</span> elements <span class="keyword">of</span> nums2 are stored <span class="function_start"><span class="keyword">on</span></span> disk, <span class="keyword">and</span> <span class="keyword">the</span> memory <span class="keyword">is</span> limited such <span class="keyword">that</span> you cannot load all elements <span class="keyword">into</span> <span class="keyword">the</span> memory <span class="keyword">at</span> once?</span><br></pre></td></tr></table></figure>
<ul>
<li><p>If only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</p>
</li>
<li><p>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), then read 2 elements from each array at a time in memory, record intersections.</p>
</li>
</ul>
<p>Thanks for the solution. I think the second part of the solution is impractical, if you read 2 elements at a time, this procedure will take forever. In principle, we want minimize the number of disk access during the run-time.</p>
<p>An improvement can be sort them using external sort, read (let’s say) 2G of each into memory and then using the 2 pointer technique, then read 2G more from the array that has been exhausted. Repeat this until no more data to read from disk.</p>
<p>But I am not sure this solution is good enough for an interview setting. Maybe the interviewer is expecting some solution using Map-Reduce paradigm.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Intersection_of_Two_Arrays_I">Intersection of Two Arrays I</h2><h3 id="题目描述">题目描述</h3><p>Given two arrays, write a function to compu]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Count of Smaller Numbers After Self and Count of Range Sum]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Count-of-Smaller-Numbers-After-Self-and-Count-of-Range-Sum/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Count-of-Smaller-Numbers-After-Self-and-Count-of-Range-Sum/</id>
    <published>2016-06-26T04:03:35.000Z</published>
    <updated>2016-06-26T04:03:35.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximum Gap]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Maximum-Gap/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Maximum-Gap/</id>
    <published>2016-06-26T03:01:25.000Z</published>
    <updated>2016-06-26T03:33:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Try to solve it in linear time/space.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>
<h2 id="代码">代码</h2><ul>
<li>解法一</li>
</ul>
<p>排序，依次计算相邻元素，时间复杂度不符合要求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//时间复杂度为O(nlgn)不符合要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxGap = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            maxGap = Math.max(maxGap, nums[i+<span class="number">1</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<p>[Thoughts]<br>Suppose there are N elements and they range from A to B.<br>Then the maximum gap will be no smaller than ceiling[(B - A) / (N - 1)]<br>Let the length of a bucket to be len = ceiling[(B - A) / (N - 1)], then we will have at most num = (B - A) / len + 1 of bucket<br>for any number K in the array, we can easily find out which bucket it belongs by calculating loc = (K - A) / len and therefore maintain the maximum and minimum elements in each bucket.<br>Since the maximum difference between elements in the same buckets will be at most len - 1, so the final answer will not be taken from two elements in the same buckets.<br>For each non-empty buckets p, find the next non-empty buckets q, then q.min - p.max could be the potential answer to the question. Return the maximum of all those values.</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">//时间复杂度为O(nlgn)不符合要求</span></span><br><span class="line">    <span class="comment">// public int maximumGap(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length &lt;= 1) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     Arrays.sort(nums);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int maxGap = Integer.MIN_VALUE;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length - 1; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         maxGap = Math.max(maxGap, nums[i+1] - nums[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return maxGap;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//桶排序</span></span><br><span class="line">    <span class="comment">//最大的gap必定是两个相邻桶的最小值和最大值之差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maximumGap(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">min</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//求数组中最大最小元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num: nums)&#123;</span><br><span class="line">            <span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, num);</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不然后面的gap会为0，/gap抛出除0异常</span></span><br><span class="line">        <span class="comment">//或者后面的gap至少为1，Math.max(1, ...);</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span> == <span class="built_in">max</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// the minimum possibale gap, ceiling of the integer division</span></span><br><span class="line">        <span class="comment">//也是桶的range</span></span><br><span class="line">        <span class="built_in">int</span> gap = (<span class="built_in">int</span>)Math.<span class="built_in">ceil</span>((<span class="keyword">double</span>)(<span class="built_in">max</span> - <span class="built_in">min</span>) / (nums.length - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> bucketLen = (<span class="built_in">max</span> - <span class="built_in">min</span>)/gap + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只保存桶的最大最小元素即可</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] bucketsMin = <span class="keyword">new</span> <span class="built_in">int</span>[bucketLen];</span><br><span class="line">        <span class="built_in">int</span>[] bucketsMax = <span class="keyword">new</span> <span class="built_in">int</span>[bucketLen];</span><br><span class="line">        </span><br><span class="line">        Arrays.<span class="built_in">fill</span>(bucketsMin, Integer.MAX_VALUE);</span><br><span class="line">        Arrays.<span class="built_in">fill</span>(bucketsMax, Integer.MIN_VALUE);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num: nums)&#123;</span><br><span class="line">            <span class="built_in">int</span> bucketIndex = (num - <span class="built_in">min</span>) / gap;</span><br><span class="line">            <span class="comment">//更新每个桶的最大最小值</span></span><br><span class="line">            bucketsMin[bucketIndex] = Math.<span class="built_in">min</span>(bucketsMin[bucketIndex], num);</span><br><span class="line">            bucketsMax[bucketIndex] = Math.<span class="built_in">max</span>(bucketsMax[bucketIndex], num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> maxGap = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//前一个桶的最大值</span></span><br><span class="line">        <span class="built_in">int</span> prev = <span class="built_in">min</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bucketLen; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucketsMin[i] == Integer.MAX_VALUE) <span class="keyword">continue</span>;<span class="comment">//empty bucket</span></span><br><span class="line">            maxGap = Math.<span class="built_in">max</span>(maxGap, bucketsMin[i] - prev);</span><br><span class="line">            prev = bucketsMax[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Tr]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sliding Window Maximum]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-Sliding-Window-Maximum/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-Sliding-Window-Maximum/</id>
    <published>2016-06-25T13:01:48.000Z</published>
    <updated>2016-06-25T16:33:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>] -<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [-<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span> [-<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>Therefore, return the max sliding window as [3,3,5,5,6,7].</p>
<p><strong> Note: </strong><br>You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong> Follow up: </strong><br>Could you solve it in linear time?</p>
<p><strong> Hint: </strong></p>
<ol>
<li>How about using a data structure such as deque (double-ended queue)?</li>
<li>The queue size need not be the same as the window’s size.</li>
<li>Remove redundant elements and the queue should store only elements that need to be considered.</li>
</ol>
<h2 id="代码">代码</h2><ul>
<li>解法一</li>
</ul>
<p>使用堆，维护一个大小为k的最大堆，堆中存放滑动窗口的中元素，时间复杂度为O(nlgk)，空间复杂度为O(k)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//维护一个最大堆，并维护堆的大小为k即窗口大小，则堆顶元素即为每个滑动窗口的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//Collections.reverseOrder()返回一个逆序的Comparator，则构建一个最大堆</span></span><br><span class="line">        <span class="comment">//Arrays.sort(arr, Collections.reverseOrder())</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//滑动窗口大小已经为k，删除窗口最左边的元素，为下一个元素腾空间</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) pq.remove(nums[i-k]);</span><br><span class="line">            pq.offer(nums[i]);</span><br><span class="line">            <span class="comment">//窗口大小已经为k</span></span><br><span class="line">            <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) res[i-k+<span class="number">1</span>] = pq.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>解法二</li>
</ul>
<p>使用双端队列，时间复杂度为O(n)，空间复杂度为O(k)。<br>当遍历到数组中一个新元素时，将该元素与队列中队尾元素相比较，如果末尾元素比新元素小，则移除末尾元素，直到该队列的末尾元素比新元素大或者队列为空时才停止。这样我们可以保证队头元素是窗口[i-(k-1), i]中最大的元素，其实队列中的窗口中元素降序。由于我们我们新加数的时候，已经把很多没用的元素移除了，无法正确的判断队列中滑动窗口的大小。这里比较tricky的就是在队列中保存元素在数组中下标，这样既能知道这个数的值，也能判断该数是不是窗口最左边的数。这里的均摊时间复杂度为O(n)，因为每个元素被加入队列和移除队列各一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//使用双端队列存元素在数组中的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//nums.length - k + 1个滑动窗口</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="comment">//dq.peek() == i-k</span></span><br><span class="line">            <span class="comment">//滑动窗口大小已经为k，删除窗口最左边的元素，为下一个元素腾空间</span></span><br><span class="line">            <span class="keyword">if</span>(!dq.isEmpty() &amp;&amp; dq.peek() &lt; i - k + <span class="number">1</span>)&#123;</span><br><span class="line">                dq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//我们将nums[i]加入队尾之前，如果队列中元素小于nums[i]，则可以删除，因为他们不可能是滑动窗口的最大值</span></span><br><span class="line">            <span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt; nums[i])&#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dq.offer(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) res[i-k+<span class="number">1</span>] = nums[dq.peek()];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the ve]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]One Edit Distance And Edit Distance]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-One-Edit-Distance-And-Edit-Distance/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-One-Edit-Distance-And-Edit-Distance/</id>
    <published>2016-06-25T04:00:10.000Z</published>
    <updated>2016-06-25T12:03:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="One_Edit_Distance">One Edit Distance</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Edit_Distance">Edit Distance</h2><h3 id="题目描述-1">题目描述</h3><p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
<h3 id="代码-1">代码</h3><p>dp[i][j]表示word1[0…i-1]转换到word2[0…j-1]的最少操作步数(编辑距离)。 下面来看状态转移方程。<br>边界情况：</p>
<ul>
<li><p>dp[i][0] = i</p>
</li>
<li><p>dp[0][j] = j </p>
</li>
</ul>
<p>这两个结论都很显然，比如word1[0…i-1]到空字符串””的编辑距离显然是i（i次删除）。</p>
<p>接下来看word1[0…i-1]到word2[0…j-1]，子问题就是word1[0…i-2]转换到word2[0…j-2]的编辑距离，也就是dp[i-1][j-1]。现在考虑word1[i-1]和word2[j-1]关系，如果它们相等，则dp[i][j] = dp[i-1][j-1]，如果word1[i-1]和word2[j-1]不相等，则有以下三种情况。</p>
<ol>
<li>替换：将word1[i-1]替换成word2[j-1]，则dp[i][j] = dp[i-1][j-1] + 1 </li>
<li>删除：将word1[i-1]删除后，则dp[i][j] = dp[i-1][j] + 1</li>
<li>插入：将word2[j-1]插入到word1[i-1]的后面，则dp[i][j] = dp[i][j-1] + 1</li>
</ol>
<p>所以，状态转移方程如下：</p>
<ol>
<li>dp[i][0] = i;</li>
<li>dp[0][j] = j;</li>
<li>dp[i][j] = dp[i-1][j-1] + 1, if word1[i-1] = word2[j-1]</li>
<li>dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1, dp[i][j-1] + 1), if word1[i-1] != word2[j-1]</li>
</ol>
<p>根据以上状态转移方程，可得如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word1 == null || word2 == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=n; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>, dp[i-<span class="number">1</span>][j] + <span class="number">1</span>), dp[i][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp[i][j]只跟dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]有关系，其实我们并不需要维护m*n的矩阵，维护一行或一列就可以了，空间复杂度能够降到O(m)或者O(n)。</p>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.geeksforgeeks.org/dynamic-programming-set-5-edit-distance/" target="_blank" rel="external">Dynamic Programming | Set 5 (Edit Distance)</a><br><a href="https://leetcode.com/discuss/43398/20ms-detailed-explained-c-solutions-o-n-space" target="_blank" rel="external">20ms Detailed Explained C++ Solutions (O(n) Space)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="One_Edit_Distance">One Edit Distance</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Edit_Distance">Edit Distance</h2><h3 id="]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Distinct Subsequences]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-Distinct-Subsequences/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-Distinct-Subsequences/</id>
    <published>2016-06-25T02:34:18.000Z</published>
    <updated>2016-06-25T03:25:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>Here is an example:<br>S = “rabbbit”, T = “rabbit”</p>
<p>Return 3.</p>
<h2 id="代码">代码</h2><p>dp[i][j]表示T[0…j-1]在S[0…i-1]中distinc subsequences的数量，则以S =”rabbbit”,T = “rabbit”为例）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    r a b b b i t</span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">r <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">a <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">i <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">t <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>所以状态转移方程为</p>
<p>dp[0][0] = 1; // T和S都是空串.<br>dp[0][1 … S.length() - 1] = 1; // T是空串，S只有一种子序列匹配。<br>dp[1 … T.length() - 1][0] = 0; // S是空串，T不是空串，S没有子序列匹配。<br>dp[i][j] = dp[i][j - 1] + (T[i - 1] == S[j - 1] ? dp[i - 1][j - 1] : 0).1 &lt;= i &lt;= T.length(), 1 &lt;= j &lt;= S.length()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(s.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return t.length() == 0 ? 1 : 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(t.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i-<span class="number">1</span>) == s.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[t.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a st]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Trapping Rain Water]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-Trapping-Rain-Water/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-Trapping-Rain-Water/</id>
    <published>2016-06-25T01:00:24.000Z</published>
    <updated>2016-06-25T01:39:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="http://articles.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt=""><br>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<h2 id="代码">代码</h2><p>对任意位置i，在i上的积水，由左右两边最高的bar：A[left] = max{A[j], j<i}, a[right]="max{A[j]," j="">i}决定。定义Hmin = min(A[left], A[right])，则积水量Si为：</i},></p>
<p>Hmin &lt;= A[i]时，Si = 0<br>Hmin &gt; A[i]时，Si = Hmin - A[i]</p>
<p>简单的说，对于某个值A[i]来说，能trapped的最多的water取决于在i之前最高海拔leftMostHeight[i]和i右边最高的海拔值rightMostHeight[i]。如果min(leftMostHeight[i], rightMostHeight[i]) &gt; A[i]，那么在i这个位置上能trapped的water就是min(leftMostHeight[i], rightMostHeight[i]) - A[i]。所以根据以上思想，进行两遍for循环，第一遍从左到右计算数组leftMostHeight，第二遍从右到左计算rightMostHeight同时也可以计算出i位置的结果。时间复杂度为O(n)，空间复杂度为O(n)。 </p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">// public int trap(int[] height) &#123;</span></span><br><span class="line">    <span class="comment">//     if(height == null || height.length == 0) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int res = 0;</span></span><br><span class="line">    <span class="comment">//     //非负数组，可以初始化为0，否则考虑height[0]</span></span><br><span class="line">    <span class="comment">//     int max = 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int[] leftMostHeight = new int[height.length];</span></span><br><span class="line">    <span class="comment">//     int[] rightMostHeight = new int[height.length];</span></span><br><span class="line">    <span class="comment">//     //leftMostHeight[i]为0~i-1中的最大值</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; height.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         leftMostHeight[i] = max;</span></span><br><span class="line">    <span class="comment">//         max = Math.max(max, height[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     max = 0;</span></span><br><span class="line">    <span class="comment">//     for(int i = height.length - 1; i &gt;= 0; i--)&#123;</span></span><br><span class="line">    <span class="comment">//         rightMostHeight[i] = max;</span></span><br><span class="line">    <span class="comment">//         max = Math.max(max, height[i]);</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">//         int container = Math.min(leftMostHeight[i], rightMostHeight[i]);</span></span><br><span class="line">    <span class="comment">//         res += container &gt; height[i] ? container - height[i] : 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其实rightMostHeight数组没必要存了，直接用max变量保存就可以了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> trap(<span class="built_in">int</span>[] <span class="variable">height</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">height</span> == <span class="keyword">null</span> || <span class="variable">height</span>.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//非负数组，可以初始化为0，否则考虑height[0]</span></span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] leftMostHeight = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="variable">height</span>.length];</span><br><span class="line">        <span class="comment">//leftMostHeight[i]为0~i-1中的最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="variable">height</span>.length; i++)&#123;</span><br><span class="line">            leftMostHeight[i] = <span class="built_in">max</span>;</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, <span class="variable">height</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="variable">height</span>.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> container = Math.<span class="built_in">min</span>(leftMostHeight[i], <span class="built_in">max</span>);</span><br><span class="line">            res += container &gt; <span class="variable">height</span>[i] ? container - <span class="variable">height</span>[i] : <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, <span class="variable">height</span>[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有更tricky的方法只扫描一遍即可，这里先贴上C++代码，有时间再研究一下：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> trap(<span class="built_in">int</span> A[], <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>; <span class="built_in">int</span> <span class="built_in">right</span>=n-<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> maxleft=<span class="number">0</span>, maxright=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[<span class="built_in">left</span>]&lt;=A[<span class="built_in">right</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[<span class="built_in">left</span>]&gt;=maxleft) maxleft=A[<span class="built_in">left</span>];</span><br><span class="line">                <span class="keyword">else</span> res+=maxleft-A[<span class="built_in">left</span>];</span><br><span class="line">                <span class="built_in">left</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[<span class="built_in">right</span>]&gt;=maxright) maxright= A[<span class="built_in">right</span>];</span><br><span class="line">                <span class="keyword">else</span> res+=maxright-A[<span class="built_in">right</span>];</span><br><span class="line">                <span class="built_in">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much wat]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Find the Duplicate Number]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Find-the-Duplicate-Number/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Find-the-Duplicate-Number/</id>
    <published>2016-06-21T10:02:00.000Z</published>
    <updated>2016-06-21T10:02:00.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Preorder/Inorder/Postorder Traversal]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/</id>
    <published>2016-06-21T06:20:02.000Z</published>
    <updated>2016-06-21T06:21:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Binary_Tree_Inorder_Traversal">Binary Tree Inorder Traversal</h2><h3 id="题目描述-1">题目描述</h3><h3 id="代码-1">代码</h3><h2 id="Binary_Tree_Postorder_Traversal">Binary Tree Postorder Traversal</h2><h3 id="题目描述-2">题目描述</h3><h3 id="代码-2">代码</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Binary_Tree_Ino]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Fraction to Recurring Decimal]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Fraction-to-Recurring-Decimal/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Fraction-to-Recurring-Decimal/</id>
    <published>2016-06-21T06:11:07.000Z</published>
    <updated>2016-06-21T06:12:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>For example,</p>
<ul>
<li>Given numerator = 1, denominator = 2, return “0.5”.</li>
<li>Given numerator = 2, denominator = 1, return “2”.</li>
<li>Given numerator = 2, denominator = 3, return “0.(6)”.</li>
</ul>
<p><strong> Hint: </strong></p>
<ol>
<li>No scary math, just apply elementary math knowledge. Still remember how to perform a long division?</li>
<li>Try a long division on 4/9, the repeating part is obvious. Now try 4/333. Do you see a pattern?</li>
<li>Be wary of edge cases! List out as many test cases as you can think of and test your code thoroughly.</li>
</ol>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分母为0</span></span><br><span class="line">        <span class="keyword">if</span>(denominator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"NaN"</span>;</span><br><span class="line">        <span class="keyword">if</span>(numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//异或为true说明符合相异</span></span><br><span class="line">        <span class="keyword">if</span>((numerator &gt; <span class="number">0</span>) ^ (denominator &gt; <span class="number">0</span>)) sb.append(<span class="string">"-"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//MIN_VALUE的绝对值会溢出，所以用long类型</span></span><br><span class="line">        <span class="keyword">long</span> num = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)numerator);</span><br><span class="line">        <span class="keyword">long</span> den = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)denominator);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//整数部分</span></span><br><span class="line">        sb.append(num/den);</span><br><span class="line">        </span><br><span class="line">        num = num % den;</span><br><span class="line">        <span class="comment">//能整除直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不能整除，存在小数部分，先加入小数点</span></span><br><span class="line">        sb.append(<span class="string">"."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//余数</span></span><br><span class="line">        <span class="keyword">long</span> remainder = num;</span><br><span class="line">        <span class="comment">//使用HashMap记录余数和在结果res中的下标，记录下标是因为出现循环小数要插入括号</span></span><br><span class="line">        <span class="comment">//key为余数，value为下标</span></span><br><span class="line">        <span class="comment">//当重复出现某一个余数时说明结果为循环小数</span></span><br><span class="line">        HashMap&lt;Long, Integer&gt; <span class="built_in">map</span>= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(remainder != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//出现重复余数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(remainder))&#123;</span><br><span class="line">                sb.insert(<span class="built_in">map</span>.get(remainder), <span class="string">"("</span>);</span><br><span class="line">                sb.append(<span class="string">")"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将余数加入map中</span></span><br><span class="line">            <span class="built_in">map</span>.put(remainder, sb.length());</span><br><span class="line">            <span class="comment">//并计算一位小数</span></span><br><span class="line">            remainder *= <span class="number">10</span>;</span><br><span class="line">            sb.append(remainder/den);</span><br><span class="line">            remainder = remainder % den;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Flatten Binary Tree to Linked List]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Flatten-Binary-Tree-to-Linked-List/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Flatten-Binary-Tree-to-Linked-List/</id>
    <published>2016-06-21T03:16:39.000Z</published>
    <updated>2016-06-21T05:24:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>The flattened tree should look like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong> Hints: </strong><br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
<h2 id="代码">代码</h2><p>直接先序遍历，从头到尾把节点链接起来：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">private</span> TreeNode lastVisited = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用先序遍历，top-down</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">flatten</span>(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">        TreeNode savedRight = root.right;</span><br><span class="line">        <span class="keyword">if</span>(lastVisited != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastVisited.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//在这里会修改上一访问节点的right指向，应该先保存</span></span><br><span class="line">            <span class="comment">//比如先序遍历到3时，lastVisited指向2（此时结果为1-&gt;2），然后在这里修改2的节点的left为null，right节点为3</span></span><br><span class="line">            <span class="comment">//遍历完3节点后，接着遍历节点4，但是如果我们不提前保存节点4，我们就找不到4了因为节点2的右节点已经被修改为3</span></span><br><span class="line">            <span class="comment">//这就是需要保存右节点的原因</span></span><br><span class="line">            lastVisited.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        lastVisited = root;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">flatten</span>(root.left);</span><br><span class="line">        <span class="keyword">flatten</span>(savedRight);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者采用前插构建单链表的形式，bottom-up方式</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//前序、中序、后序遍历好像都不是</span></span><br><span class="line">    <span class="comment">//这里引出一种新的遍历方式</span></span><br><span class="line">    <span class="comment">//先遍历右子树，然后左子树，根节点，有点类似后序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      1</span></span><br><span class="line">    <span class="comment">//     / \</span></span><br><span class="line">    <span class="comment">//    2   5</span></span><br><span class="line">    <span class="comment">//   / \   \</span></span><br><span class="line">    <span class="comment">//  3   4   6</span></span><br><span class="line">    <span class="comment">//比如题目中树采用该种遍历方式的结果为6、5、4、3、2、1相当于结果的逆序，但是如果我们采用前插构建单链表的方式</span></span><br><span class="line">    <span class="comment">//就可以把该结果反转过来，变成1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，这里讲left节点都置为空，就能将树退化为单链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null，prev开始指向null，然后指向6，然后指向5，然后指向4，然后指向3......</span></span><br><span class="line">    <span class="comment">//prev上一次遍历的节点</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">flatten</span>(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//先右子树</span></span><br><span class="line">        <span class="keyword">flatten</span>(root.right);</span><br><span class="line">        <span class="keyword">flatten</span>(root.left);</span><br><span class="line">        </span><br><span class="line">        root.right = prev;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//更新prev的指向</span></span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代的方式，暂时没咋研究，有时间再研究，好像跟Morris traversal有关系。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//迭代的方式</span></span><br><span class="line">    <span class="keyword">public</span> void flatten(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.<span class="keyword">left</span> != null) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> last = cur.<span class="keyword">left</span>;</span><br><span class="line">                <span class="keyword">while</span> (last.<span class="keyword">right</span> != null) last = last.<span class="keyword">right</span>;</span><br><span class="line">                last.<span class="keyword">right</span> = cur.<span class="keyword">right</span>;</span><br><span class="line">                cur.<span class="keyword">right</span> = cur.<span class="keyword">left</span>;</span><br><span class="line">                cur.<span class="keyword">left</span> = null;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.<span class="keyword">right</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlig]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Decode Ways]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Decode-Ways/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Decode-Ways/</id>
    <published>2016-06-21T00:10:11.000Z</published>
    <updated>2016-06-26T03:39:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'A'</span> <span class="subst">-&gt; </span><span class="number">1</span></span><br><span class="line"><span class="string">'B'</span> <span class="subst">-&gt; </span><span class="number">2</span></span><br><span class="line"><span class="attribute">...</span></span><br><span class="line"><span class="string">'Z'</span> <span class="subst">-&gt; </span><span class="number">26</span></span><br></pre></td></tr></table></figure></p>
<p>Given an encoded message containing digits, determine the total number of ways to decode it.</p>
<p>For example,<br>Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).</p>
<p>The number of ways decoding “12” is 2.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//类似Climbing Stairs，只是多了一些限制条件</span></span><br><span class="line">    <span class="comment">//nums[i]：表示字符串s[0...i-1]的解码方式的总数</span></span><br><span class="line">    <span class="comment">//nums[i] = nums[i-1] if s[i-1] is valid char</span></span><br><span class="line">    <span class="comment">//or nums[i-1] + nums[i-2] if s[i-1] and s[i-2] to gether is still a valid char</span></span><br><span class="line">    <span class="comment">// public int numDecodings(String s) &#123;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(s == null || s.length() == 0) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int[] nums = new int[s.length() + 1];</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     //表示空字符串只有一种解码方式</span></span><br><span class="line">    <span class="comment">//     nums[0] = 1;</span></span><br><span class="line">    <span class="comment">//     //只含有s[0]一个字符的解码方式，如果是有效字符不为'0'则有一种方式，否则为零</span></span><br><span class="line">    <span class="comment">//     nums[1] = s.charAt(0) != '0' ? 1 : 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     for(int i = 2; i &lt;= s.length(); i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(isValid(s.substring(i-1,i)))&#123;</span></span><br><span class="line">    <span class="comment">//             nums[i] += nums[i-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">//         if(isValid(s.substring(i-2, i)))&#123;</span></span><br><span class="line">    <span class="comment">//             nums[i] += nums[i-2];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return nums[s.length()];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> value = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">1</span> &amp;&amp; value &lt;= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//表示空字符串只有一种解码方式</span></span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//只含有s[0]一个字符的解码方式，如果是有效字符不为'0'则有一种方式，否则为零</span></span><br><span class="line">        nums[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = Integer.parseInt(s.substring(i-<span class="number">1</span>, i));</span><br><span class="line">            <span class="keyword">int</span> second = Integer.parseInt(s.substring(i-<span class="number">2</span>, i));</span><br><span class="line">            <span class="keyword">if</span>(first &gt;= <span class="number">1</span> &amp;&amp; first &lt;= <span class="number">9</span>)&#123;</span><br><span class="line">                nums[i] += nums[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意second要大于等于10</span></span><br><span class="line">            <span class="keyword">if</span>(second &gt;= <span class="number">10</span> &amp;&amp; second &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                nums[i] += nums[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两种写法都是top down dp，我们还可以用bottom up dp的方式，从字符串尾部往前dp。nums[i]表示s[i…s.length]的解码方式。以’0’开头的字符串解码方式为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//空字符串的解码方式</span></span><br><span class="line">        nums[length] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        nums[length-<span class="number">1</span>] = s.charAt(length - <span class="number">1</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>) <span class="keyword">continue</span>;<span class="comment">//以0开头的字符串都是无效的字符串，解码方式为0，默认初始化为0，写nums[i] = 0也可以</span></span><br><span class="line">            <span class="keyword">else</span> nums[i] = Integer.parseInt(s.substring(i, i+<span class="number">2</span>)) &lt;= <span class="number">26</span> ? nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] : nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:<br><figure class="h]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Reverse Words in a String I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/20/LeetCode-Reverse-Words-in-a-String-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/20/LeetCode-Reverse-Words-in-a-String-I-II/</id>
    <published>2016-06-20T12:52:55.000Z</published>
    <updated>2016-06-20T13:55:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Reverse_Words_in_a_String_I">Reverse Words in a String I</h2><h3 id="题目描述">题目描述</h3><p>Given an input string, reverse the string word by word.</p>
<p>For example,<br>Given s = “the sky is blue”,<br>return “blue is sky the”.</p>
<p>Update (2015-02-12):<br>For C programmers: Try to solve it in-place in O(1) space.</p>
<h3 id="代码">代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	 <span class="comment">//使用split函数切割，然后逆序append起来即可</span></span><br><span class="line">    <span class="comment">//考虑前导空格、words之间多个空格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> reverseWords(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一个空格或多个空格split</span></span><br><span class="line">        <span class="keyword">String</span>[] strs = s.<span class="built_in">trim</span>().<span class="built_in">split</span>(<span class="string">"\\s+"</span>);</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = strs.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            sb.<span class="built_in">append</span>(strs[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.<span class="built_in">append</span>(strs[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法就是逆序遍历字符串，使用两个指针追踪words的开始和结尾，当我们遍历到words的开始时，将words append到结果中。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//j指针初始指向字符串最后一个字符的下一位置，在每一次迭代中j指向上一个遍历的空格</span></span><br><span class="line">        <span class="keyword">int</span> j = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//遍历到空格，更新j的指向，指向新的空格</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">' '</span>)&#123;<span class="comment">//charAt(i - 1) == ' '说明i当前指向某个word的开头，可以获取到该word</span></span><br><span class="line">                <span class="keyword">if</span>(sb.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                    sb.append(<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(s.substring(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//其他情况直接跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse_Words_in_a_String_II">Reverse Words in a String II</h2><h3 id="题目描述-1">题目描述</h3><p>Similar to Question [Reverse Words in a String], but with the following constraints:<br>“The input string does not contain leading or trailing spaces and the words are always separated by a single space.”<br>Could you do it in-place without allocating extra space?</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将整个字符串翻转，然后将每个word翻转</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] s)</span></span>&#123;</span><br><span class="line">       reverse(s, <span class="number">0</span>, s.length - <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//j指向每个word的开始</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i == s.length - <span class="number">1</span> || s[i] == <span class="string">' '</span> )&#123;</span><br><span class="line">               reverse(s, j, i);</span><br><span class="line">               j = i+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">           <span class="keyword">char</span> temp = s[end];</span><br><span class="line">           s[end] = s[start];</span><br><span class="line">           s[start] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Reverse_Words_in_a_String_I">Reverse Words in a String I</h2><h3 id="题目描述">题目描述</h3><p>Given an input string, reverse the string wor]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Divide Two Integers]]></title>
    <link href="http://blog.noobsky.com/2016/06/20/LeetCode-Divide-Two-Integers/"/>
    <id>http://blog.noobsky.com/2016/06/20/LeetCode-Divide-Two-Integers/</id>
    <published>2016-06-20T08:37:13.000Z</published>
    <updated>2016-06-20T11:49:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//最直接的方法就是不断用被除数减去除数，直到被除数小于除数，迭代次数为结果大小</span></span><br><span class="line">    <span class="comment">//这里介绍一种方法，用例子来说明：dividend = 15， divisor = 3</span></span><br><span class="line">    <span class="comment">//15-3 = 12，结果为整数，我们尝试减多一点，我们将3左移一位得6，15-6 = 9仍然是正数，我们还可以减更多一点</span></span><br><span class="line">    <span class="comment">//再讲3左移一位得12，15-12 = 3仍然大于0，我们尝试3再左移得24这回不可以了。所以最多减去12。12是除数3左移两位得到，4*3 = 12</span></span><br><span class="line">    <span class="comment">//那么我们怎么得到这个4，我们初始化为1，然后除数3左移时，1也左移。3左移两次1左移两次为4。我们将4加到相除的结果中（初始化</span></span><br><span class="line">    <span class="comment">//为0）。上面的过程就像 15 = 3*4 + 3。现在我们得到商为4，余数为3。</span></span><br><span class="line">    <span class="comment">//然后我们继续以上过程，新的被除数dividend = 3，除数divisor = 3，3 - 3 = 0。迭代结束，这次没有发生左移，所以结果中加上</span></span><br><span class="line">    <span class="comment">//1&lt;&lt;0 = 1，最后我们等到5。</span></span><br><span class="line">    <span class="comment">//我们还需要处理溢出，有以下情况:</span></span><br><span class="line">    <span class="comment">//1. divisor = 0；</span></span><br><span class="line">    <span class="comment">//2. dividend = Integer.MIN_VALUE，divisor = -1（因为 Math.abs(MIN_VALUE) = MAX_VALUE + 1）</span></span><br><span class="line">    <span class="comment">//最后还要考虑正负号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor == <span class="number">0</span> || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//除数和被除数符号相异时为负，否则为正，用异或</span></span><br><span class="line">        <span class="keyword">int</span> sign = ((dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换为整数处理，Integer.MIN_VALUE绝对值会溢出，用long类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> dvd = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)dividend);</span><br><span class="line">        <span class="keyword">long</span> dvs = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环终止条件为被除数小于除数</span></span><br><span class="line">        <span class="keyword">while</span>(dvd &gt;= dvs)&#123;</span><br><span class="line">            <span class="keyword">long</span> temp = dvs, factor = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(dvd &gt;= (temp&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//左移一位</span></span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                factor &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dvd -= temp;</span><br><span class="line">            res += factor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sign == <span class="number">1</span> ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实用long也不是长久之计，如果输入时long类型，咱又用什么好，用BigInteger:)，那如果。。。其实主要的溢出就是Intege.MIN_VALUE，绝对值后会溢出，那么就对MIN_VALUE单独处理好了；还有temp左移可能溢出。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//其实用long也不是长久之计，如果输入时long类型，咱又用什么好，用BigInteger:)，那如果。。。</span></span><br><span class="line">    <span class="comment">//其实主要的溢出就是Intege.MIN_VALUE，绝对值后会溢出，那么就对MIN_VALUE单独处理好了</span></span><br><span class="line">    <span class="comment">//还有temp左移可能溢出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dividend == Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(divisor == <span class="number">1</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="comment">//奇数跟前者等价，偶数跟后者等价</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> ((divisor&amp;<span class="number">1</span>) == <span class="number">1</span>) ? divide(dividend + <span class="number">1</span>, divisor) : divide(dividend &gt;&gt; <span class="number">1</span>, divisor &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(divisor == Integer.MIN_VALUE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if(divisor == 1) return dividend;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//除数和被除数符号相异时为负，否则为正，用异或</span></span><br><span class="line">        <span class="keyword">int</span> sign = ((dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换为整数处理，Integer.MIN_VALUE绝对值会溢出，用long类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dvd = Math.<span class="built_in">abs</span>(dividend);</span><br><span class="line">        <span class="keyword">int</span> dvs = Math.<span class="built_in">abs</span>(divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环终止条件为被除数小于除数</span></span><br><span class="line">        <span class="keyword">while</span>(dvd &gt;= dvs)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dvs, factor = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//(temp &lt;&lt; 1) &gt; divisor是避免temp左移溢出造成死循环，溢出了(temp &lt;&lt; 1) &lt; divisor</span></span><br><span class="line">            <span class="comment">//比如dividend = Integer.MAX_VALUE, divisor = 1或2，死循环</span></span><br><span class="line">            <span class="keyword">while</span>(dvd &gt;= (temp &lt;&lt; <span class="number">1</span>) &amp;&amp; ((temp &lt;&lt; <span class="number">1</span>) &gt; dvs))&#123;</span><br><span class="line">                <span class="comment">//左移一位</span></span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                factor &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dvd -= temp;</span><br><span class="line">            res += factor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sign == <span class="number">1</span> ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(lgn)，空间复杂度为O(1)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
