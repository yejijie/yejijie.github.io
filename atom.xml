<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-07-04T08:52:57.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Median of Two Sorted Arrays]]></title>
    <link href="http://blog.noobsky.com/2016/07/04/LeetCode-Median-of-Two-Sorted-Arrays/"/>
    <id>http://blog.noobsky.com/2016/07/04/LeetCode-Median-of-Two-Sorted-Arrays/</id>
    <published>2016-07-04T03:48:13.000Z</published>
    <updated>2016-07-04T08:52:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p><strong> Example 1: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">The median is <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p><strong> Example 2: </strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = <span class="comment">[1, 2]</span></span><br><span class="line">nums2 = <span class="comment">[3, 4]</span></span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<h2 id="解题思路">解题思路</h2><p>首先要明白中位数的用途，在统计学中<font color="red"><code>dividing a set into two equal length subsets, that one subset is always greater than the other.</code></font>这就告诉了我们大概的思路。</p>
<p>首先，将数组A在随机位置i上划分成两部分：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      left_A             |        right_A</span><br><span class="line">A<span class="string">[0]</span>, A<span class="string">[1]</span>, ..., A<span class="string">[i-1]</span>  |  A<span class="string">[i]</span>, A<span class="string">[i+1]</span>, ..., A<span class="string">[m-1]</span></span><br></pre></td></tr></table></figure>
<p>数组A有m个元素，所以i的取值有m+1（0~m）种选择来划分数组A，而且len(left_A) = i，len(right_A) = m-i。需要注意的是，如果i=0，则left_A为空；如果i=m，则right_A为空。</p>
<p>同理，我们在随机位置j上将数组B划分为两部分：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      left_B             |        right_B</span><br><span class="line">B<span class="string">[0]</span>, B<span class="string">[1]</span>, ..., B<span class="string">[j-1]</span>  |  B<span class="string">[j]</span>, B<span class="string">[j+1]</span>, ..., B<span class="string">[n-1]</span></span><br></pre></td></tr></table></figure>
<p>我们将left_A和left_B放到一个集合中，right_A和right_B放到另一个集合中，分别为left_part和right_part:</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      left_part          |        right_part</span><br><span class="line">A<span class="string">[0]</span>, A<span class="string">[1]</span>, ..., A<span class="string">[i-1]</span>  |  A<span class="string">[i]</span>, A<span class="string">[i+1]</span>, ..., A<span class="string">[m-1]</span></span><br><span class="line">B<span class="string">[0]</span>, B<span class="string">[1]</span>, ..., B<span class="string">[j-1]</span>  |  B<span class="string">[j]</span>, B<span class="string">[j+1]</span>, ..., B<span class="string">[n-1]</span></span><br></pre></td></tr></table></figure>
<p>所以我们只需要确保：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="function"><span class="title">len</span><span class="params">(left_part)</span></span> == <span class="function"><span class="title">len</span><span class="params">(right_part)</span></span></span><br><span class="line"><span class="number">2</span>) <span class="function"><span class="title">max</span><span class="params">(left_part)</span></span> &lt;= <span class="function"><span class="title">min</span><span class="params">(right_part)</span></span></span><br></pre></td></tr></table></figure></p>
<p>那么我们就能将全部元素划分为相等的两部分（或者相差1），并且一部分中的元素都小于另一部分的元素。那么中位数为<font color="red"><code>median = (max(left_part) + min(right_part))/2</code></font>。</p>
<p>为了确保以上两个条件，我们需要满足：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) i + j == <span class="keyword">m</span> - i + <span class="keyword">n</span> - j (or: <span class="keyword">m</span> - i + <span class="keyword">n</span> - j + 1)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">n</span> &gt;= <span class="keyword">m</span>, we just need to <span class="keyword">set</span>: i = 0 ~ <span class="keyword">m</span>, j = (<span class="keyword">m</span> + <span class="keyword">n</span> + 1)/2 - <span class="literal">i</span></span><br><span class="line">(2) B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]</span><br></pre></td></tr></table></figure>
<p>如果m+n为奇数时，两部分的长度相差1，所以i + j == m - i + n - j (or: m - i + n - j + 1,(m+n为奇数时))。而让n &gt;= m是因为i = 0~m, j=(m+n+1)/2-i，n &gt;= m能确保j不为负数。为了简单，我们这里先假设A[i-1],B[j-1],A[i],B[j] 都是有限的，我们在后面再讨论i=0/i=m/j=0/j=n的边界情况。</p>
<p>所以，我们需要做的是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Searching <span class="tag">i</span> <span class="keyword">in</span> [<span class="number">0</span>, m], to find an <span class="tag">object</span> `i` that:</span><br><span class="line">    B[j-<span class="number">1</span>] &lt;= A[i] and A[i-<span class="number">1</span>] &lt;= B[j], ( where j = (m + n + <span class="number">1</span>)/<span class="number">2</span> - <span class="tag">i</span> )</span><br></pre></td></tr></table></figure>
<p>因为数组是有序的，所以我们可以利用二分搜索来查找，伪代码如下：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">1</span>&gt; Set imin = <span class="number">0</span>, imax = m, then start searching in [imin, imax]</span><br><span class="line"></span><br><span class="line">&lt;<span class="number">2</span>&gt; Set i = (imin + imax)/<span class="number">2</span>, j = (m + n + <span class="number">1</span>)/<span class="number">2</span> - i</span><br><span class="line"></span><br><span class="line">&lt;<span class="number">3</span>&gt; Now we have len(left_part)==len(right_part). <span class="literal">And</span> there are only <span class="number">3</span> situations</span><br><span class="line"><span class="label">     that we may encounter:</span></span><br><span class="line">    &lt;<span class="literal">a</span>&gt; B[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i] <span class="literal">and</span> <span class="literal">A</span>[i-<span class="number">1</span>] &lt;= B[j]</span><br><span class="line">        Means we have found the object <span class="escape">`i</span><span class="escape">`,</span> so stop searching.</span><br><span class="line">    &lt;b&gt; B[j-<span class="number">1</span>] &gt; <span class="literal">A</span>[i]</span><br><span class="line">        Means <span class="literal">A</span>[i] is too small. We must <span class="escape">`a</span>just<span class="escape">` </span>i to get <span class="escape">`B</span>[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i]<span class="escape">`.</span></span><br><span class="line">        Can we <span class="escape">`i</span>ncrease<span class="escape">` </span>i?</span><br><span class="line">            Yes. Because when i is increased, j will be decreased.</span><br><span class="line">            So B[j-<span class="number">1</span>] is decreased <span class="literal">and</span> <span class="literal">A</span>[i] is increased, <span class="literal">and</span> <span class="escape">`B</span>[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i]<span class="escape">` </span>may</span><br><span class="line">            be satisfied.</span><br><span class="line">        Can we <span class="escape">`d</span>ecrease<span class="escape">` </span>i?</span><br><span class="line">            <span class="escape">`N</span>o!<span class="escape">` </span>Because when i is decreased, j will be increased.</span><br><span class="line">            So B[j-<span class="number">1</span>] is increased <span class="literal">and</span> <span class="literal">A</span>[i] is decreased, <span class="literal">and</span> B[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i] will</span><br><span class="line">            be never satisfied.</span><br><span class="line">        So we must <span class="escape">`i</span>ncrease<span class="escape">` </span>i. That is, we must ajust the searching range to</span><br><span class="line">        [i+<span class="number">1</span>, imax]. So, set imin = i+<span class="number">1</span>, <span class="literal">and</span> goto &lt;<span class="number">2</span>&gt;.</span><br><span class="line">    &lt;c&gt; <span class="literal">A</span>[i-<span class="number">1</span>] &gt; B[j]</span><br><span class="line">        Means <span class="literal">A</span>[i-<span class="number">1</span>] is too big. <span class="literal">And</span> we must <span class="escape">`d</span>ecrease<span class="escape">` </span>i to get <span class="escape">`A</span>[i-<span class="number">1</span>]&lt;=B[j]<span class="escape">`.</span></span><br><span class="line">        That is, we must ajust the searching range to [imin, i-<span class="number">1</span>].</span><br><span class="line">        So, set imax = i-<span class="number">1</span>, <span class="literal">and</span> goto &lt;<span class="number">2</span>&gt;.</span><br></pre></td></tr></table></figure>
<p>当我们找到下标i后，那么中位数为：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max<span class="list">(<span class="keyword">A</span>[i-1], B[j-1])</span> <span class="list">(<span class="keyword">when</span> m + n is odd)</span></span><br><span class="line">or <span class="list">(<span class="keyword">max</span><span class="list">(<span class="keyword">A</span>[i-1], B[j-1])</span> + min<span class="list">(<span class="keyword">A</span>[i], B[j])</span>)</span>/2 <span class="list">(<span class="keyword">when</span> m + n is even)</span></span><br></pre></td></tr></table></figure>
<p>下面来处理那些边界情况：i=0,i=m,j=0,j=n ，此时A[i-1],B[j-1],A[i],B[j]并不存在。</p>
<p>我们需要确保max(left_part) &lt;= min(right_part)，如果i和j不是边界值，那么我们需要检查B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]。如果A[i-1],B[j-1],A[i],B[j]有些不存在，那么B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]这两个条件我们可以不检查一个条件（或者两个都不用检查）。比如，如果i=0，那么A[i-1]不存在，则我们不需要检查A[i-1] &lt; B[j]。所以我们需要做的修改为：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Searching i <span class="keyword">in</span> [<span class="number">0</span>, m], <span class="keyword">to</span> find an object `i` <span class="keyword">that</span>:</span><br><span class="line">    (j == <span class="number">0</span> <span class="keyword">or</span> i == m <span class="keyword">or</span> B[j-<span class="number">1</span>] &lt;= A[i]) <span class="keyword">and</span></span><br><span class="line">    (i == <span class="number">0</span> <span class="keyword">or</span> j == n <span class="keyword">or</span> A[i-<span class="number">1</span>] &lt;= B[j])</span><br><span class="line">    <span class="keyword">where</span> j = (m + n + <span class="number">1</span>)/<span class="number">2</span> - i</span><br></pre></td></tr></table></figure>
<p>搜索过程中，我们会遇到以下三种情况：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt; (j == <span class="number">0</span> or <span class="tag">i</span> == m or B[j-<span class="number">1</span>] &lt;= A[i]) and</span><br><span class="line">    (<span class="tag">i</span> == <span class="number">0</span> or j = n or A[i-<span class="number">1</span>] &lt;= B[j])</span><br><span class="line">    Means <span class="tag">i</span> is perfect, we can stop searching.</span><br><span class="line"></span><br><span class="line">&lt;b&gt; j &gt; <span class="number">0</span> and <span class="tag">i</span> &lt; m and B[j - <span class="number">1</span>] &gt; A[i]</span><br><span class="line">    Means <span class="tag">i</span> is too small, we must increase it.</span><br><span class="line"></span><br><span class="line">&lt;c&gt; <span class="tag">i</span> &gt; <span class="number">0</span> and j &lt; n and A[<span class="tag">i</span> - <span class="number">1</span>] &gt; B[j]</span><br><span class="line">    Means <span class="tag">i</span> is too big, we must decrease it.</span><br></pre></td></tr></table></figure>
<p>所以代码如下(python)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    m, n = len(A), len(B)</span><br><span class="line">    <span class="keyword">if</span> m &gt; n:</span><br><span class="line">        A, B, m, n = B, A, n, m</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line">    imin, imax, half_len = <span class="number">0</span>, m, (m + n + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> imin &lt;= imax:</span><br><span class="line">        i = (imin + imax) / <span class="number">2</span></span><br><span class="line">        j = half_len - i</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; m <span class="keyword">and</span> B[j-<span class="number">1</span>] &gt; A[i]:</span><br><span class="line">            <span class="comment"># i is too small, must increase it</span></span><br><span class="line">            imin = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &lt; n <span class="keyword">and</span> A[i-<span class="number">1</span>] &gt; B[j]:</span><br><span class="line">            <span class="comment"># i is too big, must decrease it</span></span><br><span class="line">            imax = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># i is perfect</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: max_of_left = B[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>: max_of_left = A[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>: max_of_left = max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> max_of_left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == m: min_of_right = B[j]</span><br><span class="line">            <span class="keyword">elif</span> j == n: min_of_right = A[i]</span><br><span class="line">            <span class="keyword">else</span>: min_of_right = min(A[i], B[j])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (max_of_left + min_of_right) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>修改为Java版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(nums1 == null || nums2 == null) return 0.0;</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m &gt; n) <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = m;</span><br><span class="line">        <span class="comment">//j = (m+n+1)/2 - i前面一部分是固定，可以先算，不用再while中重复计算</span></span><br><span class="line">        <span class="keyword">int</span> halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> maxOfLeft;</span><br><span class="line">        <span class="keyword">int</span> minOfRight;</span><br><span class="line">        <span class="comment">//在[0,m]中二分搜索</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            i = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            j = halfLen - i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; nums2[j-<span class="number">1</span>] &gt; nums1[i])&#123;</span><br><span class="line">                left = i+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; nums1[i-<span class="number">1</span>] &gt; nums2[j])&#123;</span><br><span class="line">                right = i-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) maxOfLeft = nums2[j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) maxOfLeft = nums1[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> maxOfLeft = Math.max(nums1[i-<span class="number">1</span>], nums2[j-<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//m+n为奇数</span></span><br><span class="line">                <span class="keyword">if</span>((m + n) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> maxOfLeft;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i == m) minOfRight = nums2[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == n) minOfRight = nums1[i];</span><br><span class="line">                <span class="keyword">else</span> minOfRight = Math.min(nums1[i], nums2[j]);</span><br><span class="line">                <span class="keyword">return</span> (maxOfLeft + minOfRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Interleaving String]]></title>
    <link href="http://blog.noobsky.com/2016/07/03/LeetCode-Interleaving-String/"/>
    <id>http://blog.noobsky.com/2016/07/03/LeetCode-Interleaving-String/</id>
    <published>2016-07-03T01:54:30.000Z</published>
    <updated>2016-07-04T08:58:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Given:<br>s1 = “aabcc”,<br>s2 = “dbbca”,</p>
<p>When s3 = “aadbbcbcac”, return true.<br>When s3 = “aadbbbaccc”, return false.</p>
<h2 id="代码">代码</h2><p>dp[i][j]表示s1[0…i-1]和s2[0…j-1]能表示s3[0…i+j-1]，即s1的前i个字符和s2的前j个字符能按规则表示s3的前i+j个字符。则：</p>
<p>dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1] 或者 dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]</p>
<p>结果为：</p>
<p>dp[s1.length()][s2.length()]</p>
<p>边界情况：</p>
<p>i=0,j=0:dp[i][j] = true，表示s1、s2、s3都未空字符串<br>i=0 dp[i][j] = dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]<br>j=0 dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s1.length() + s2.length() != s3.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        boolean[][] dp = <span class="keyword">new</span> boolean[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//注意循环条件可以等于</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s2.length(); j++)&#123;</span><br><span class="line">                <span class="comment">//都为空字符串</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//s1为空字符串</span></span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] &amp;&amp; s2.charAt(j-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//s2为空字符</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] &amp;&amp; s1.charAt(i-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//有两种情况s3[i+j-1]取自s1[i-1]或者取自s2[j-1]</span></span><br><span class="line">                    dp[i][j] = (dp[i][j-<span class="number">1</span>] &amp;&amp; s2.charAt(j-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>)) || (dp[i-<span class="number">1</span>][j] &amp;&amp; s1.charAt(i-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Given:<br>s1 ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Merge k Sorted Lists]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-Merge-k-Sorted-Lists/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-Merge-k-Sorted-Lists/</id>
    <published>2016-07-02T13:40:00.000Z</published>
    <updated>2016-07-04T08:58:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<h2 id="代码">代码</h2><ul>
<li>利用优先级队列</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	 <span class="comment">//使用优先级队列存k个sorted lists的节点</span></span><br><span class="line">    <span class="comment">//队列大小初始化为k，初始化时从每个Sorted lists中放入一个节点到优先级队列中，找出最小值</span></span><br><span class="line">    <span class="comment">//然后加入最小值ListNode.next的节点</span></span><br><span class="line">    <span class="keyword">public</span> ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> compare(ListNode l1, ListNode l2)&#123;</span><br><span class="line">                <span class="comment">//按val的自然序排序</span></span><br><span class="line">                <span class="comment">//return l1.val - l2.val;</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(l1.val, l2.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(ListNode node : lists)&#123;</span><br><span class="line">            <span class="comment">//注意判空</span></span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.offer(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            curr.<span class="keyword">next</span> = pq.poll();</span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            <span class="comment">//出队列的节点有next节点，加入队列中</span></span><br><span class="line">            <span class="keyword">if</span>(curr.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.offer(curr.<span class="keyword">next</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlgk)</p>
<ul>
<li>利用Merge Two Sorted Lists</li>
</ul>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">	    //使用merge two Sorted List的方法</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode merge(ListNode l1, ListNode l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l1;</span><br><span class="line">                l1 = l1.<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l2;</span><br><span class="line">                l2 = l2.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curr.<span class="keyword">next</span> = l1 != <span class="literal">null</span> ? l1 : l2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode mergeKListsHelper(ListNode[] lists, int start, int <span class="keyword">end</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="keyword">end</span>) <span class="keyword">return</span> lists[start];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start &gt; <span class="keyword">end</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        int mid = start + (<span class="keyword">end</span> - start)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode l1 = mergeKListsHelper(lists, start, mid);</span><br><span class="line">        ListNode l2 = mergeKListsHelper(lists, mid+<span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">        //<span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeKListsHelper(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlgk)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the no]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Maximum Path Sum]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-Binary-Tree-Maximum-Path-Sum/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-Binary-Tree-Maximum-Path-Sum/</id>
    <published>2016-07-02T09:45:09.000Z</published>
    <updated>2016-07-04T08:57:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root.</p>
<p>For example:<br>Given the below binary tree,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Return 6.</p>
<h2 id="代码">代码</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree <span class="keyword">node</span>.<span class="identifier"></span><br><span class="line"> </span><span class="title">* public</span> class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//<span class="number">1</span>. <span class="keyword">Node</span><span class="identifier"> </span><span class="title">only</span></span><br><span class="line">//<span class="number">2</span>. L-sub + <span class="keyword">Node</span><span class="identifier"></span><br><span class="line"></span><span class="title">//3</span>. R-sub + <span class="keyword">Node</span><span class="identifier"></span><br><span class="line"></span><span class="title">//4</span>. L-sub + <span class="keyword">Node</span><span class="identifier"> </span><span class="title">+ R-sub</span></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    //Java中pass by value，不像C++的引用或者指针</span><br><span class="line">    //解决办法是用全局变量、数组、包装类，这里用全局变量</span><br><span class="line">    int max = Integer.MIN_VALUE;</span><br><span class="line">    //因为存在负数，所以最大值不一定是roog+l-sub+r-sub</span><br><span class="line">    public int maxPathSum(TreeNode root) &#123;</span><br><span class="line">        maxPathDown(root);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //该函数计算路径最高节点为<span class="keyword">node</span><span class="identifier"></span><span class="title">的最大路径和(返回值)，并更新全局最大值</span><br><span class="line">    //returns</span> the maximum sum of the path that can be extended to input <span class="keyword">node</span><span class="identifier"></span><span class="title">'s</span> parent.</span><br><span class="line">    //返回能扩展输入节点（<span class="keyword">node</span><span class="identifier"></span><span class="title">）的父节点的路径的最大和</span><br><span class="line">    //能扩展输入节点node</span>的父节点的路径只有三种情况：</span><br><span class="line">    //<span class="number">1</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">only</span></span><br><span class="line">    //<span class="number">2</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">+ l-sub</span></span><br><span class="line">    //<span class="number">3</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">+ r-sub</span></span><br><span class="line">    //而<span class="keyword">node</span><span class="identifier"></span><span class="title">+l-sub</span>+r-sub是不能扩展<span class="keyword">node</span><span class="identifier"></span><span class="title">的父节点的</span><br><span class="line">    // private</span> int maxPathDown(TreeNode <span class="keyword">node</span><span class="identifier"></span><span class="title">)&#123;</span><br><span class="line">    //     if</span>(<span class="keyword">node</span><span class="identifier"> </span><span class="title">== null</span>) return <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    //     int left = maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>);</span><br><span class="line">    //     int right = maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>);</span><br><span class="line">        </span><br><span class="line">    //     //表示通过<span class="keyword">node</span><span class="identifier"></span><span class="title">节点能到达node</span>的parent节点的最大和，作为返回值返回给父节点的函数调用</span><br><span class="line">    //     //因为更新全局最大值也要用到所以先用局部变量存起来，不用重复计算</span><br><span class="line">    //     int maxPathAcrossNodeToParent = Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    //     //更新全局最大值</span><br><span class="line">    //     max = Math.max(max, Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right, maxPathAcrossNodeToParent));</span><br><span class="line">    //     //return Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    //     return maxPathAcrossNodeToParent;</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    //其实maxPathDown的可以优化如下：</span><br><span class="line">    private int maxPathDown(TreeNode <span class="keyword">node</span><span class="identifier"></span><span class="title">)&#123;</span><br><span class="line">        if</span>(<span class="keyword">node</span><span class="identifier"> </span><span class="title">== null</span>) return <span class="number">0</span>;</span><br><span class="line">        //节点存在负数，如果为负数则对路径最大和没有任何帮助，抛弃即可</span><br><span class="line">        //left或right至少大于<span class="number">0</span>才对max有帮助</span><br><span class="line">        //这样处理后更新全局最大值时用max跟<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right比较即可</span><br><span class="line">        //<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right代表了<span class="keyword">node</span><span class="identifier"></span><span class="title">、node</span>+l-sub、<span class="keyword">node</span><span class="identifier"></span><span class="title">+r-sub</span>、<span class="keyword">node</span><span class="identifier"></span><span class="title">+l-sub</span>+r-sub最大值</span><br><span class="line">        int left = Math.max(<span class="number">0</span>,maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>));</span><br><span class="line">        int right = Math.max(<span class="number">0</span>, maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>));</span><br><span class="line">        </span><br><span class="line">        max = Math.max(max, <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right);</span><br><span class="line">        </span><br><span class="line">        return Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.geeksforgeeks.org/find-maximum-path-sum-in-a-binary-tree/" target="_blank" rel="external">Maximum Path Sum in a Binary Tree</a><br><a href="http://blog.csdn.net/fightforyourdream/article/details/16894069" target="_blank" rel="external"> Binary Tree Maximum Path Sum 二叉树最大路径和 @LeetCode</a><br><a href="https://leetcode.com/discuss/14190/accepted-short-solution-in-java" target="_blank" rel="external">Accepted short solution in Java</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of node]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]First Missing Positive]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-First-Missing-Positive/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-First-Missing-Positive/</id>
    <published>2016-07-02T05:22:11.000Z</published>
    <updated>2016-07-02T09:45:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br>Given [1,2,0] return 3,<br>and [3,4,-1,1] return 2.</p>
<p>Your algorithm should run in O(n) time and uses constant space.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//注意0不是正数,找出第一个缺失的正数</span></span><br><span class="line">    <span class="comment">//所以把1放到下标0的位置，2放到下标1，3放到下标2，。。。。。。</span></span><br><span class="line">    <span class="comment">//即把nums[i]放到nums[nums[i] - 1]的位置</span></span><br><span class="line">    <span class="comment">//然后从前往后遍历找出第一个缺失的正数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//注意交换过来的可能是一个正数，也不在其正确的位置上，所以我们需要用while而不是if</span></span><br><span class="line">            <span class="comment">//用while直到交换过来是负数或者大于nums.length的数</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums.length &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如[1,2,3]缺4</span></span><br><span class="line">        <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br>Given [1,2,0] ret]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Duplicate Letters]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-Remove-Duplicate-Letters/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-Remove-Duplicate-Letters/</id>
    <published>2016-07-02T03:46:27.000Z</published>
    <updated>2016-07-02T03:53:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p>Example:<br>Given “bcabc”<br>Return “abc”</p>
<p>Given “cbacdcbc”<br>Return “acdb”</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//时间复杂度为O(kn)，k为唯一字符的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)  count[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="comment">//题目要求字典序最小，如何贪心选择s[pos]</span></span><br><span class="line">        <span class="comment">//选择左边最小的字符，并且保证s[i...length]包含所有唯一的字符，</span></span><br><span class="line">        <span class="comment">//break条件是遇到词频最小的字符</span></span><br><span class="line">        <span class="comment">//贪心选择：假设词频最小的字符为s[i],那么贪心选择s[0...i]中最小的字符</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &lt; s.charAt(pos)) pos = i;</span><br><span class="line">            <span class="comment">//找到唯一字符或者词频最小的字符，循环终止</span></span><br><span class="line">            <span class="keyword">if</span>(--count[s.charAt(i) - <span class="string">'a'</span>] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//贪心选择后s.charAt(pos),如何构造新字符串</span></span><br><span class="line">        <span class="comment">//抛弃s[pos]左边的字符，移除s[pos+1...length]中为s[pos]的字符</span></span><br><span class="line">        <span class="keyword">return</span> s.length() == <span class="number">0</span> ? <span class="string">""</span> : s.charAt(pos) + removeDuplicateLetters(s.substring(pos+<span class="number">1</span>).replaceAll(<span class="string">""</span>+s.charAt(pos), <span class="string">""</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用栈</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//时间复杂度为O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) freq[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录字符是否在栈中</span></span><br><span class="line">        boolean[] visited = <span class="keyword">new</span> boolean[<span class="number">26</span>];</span><br><span class="line">        Stack&lt;Character&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            </span><br><span class="line">            freq[ch - <span class="string">'a'</span>]--;</span><br><span class="line">            <span class="comment">//已在栈中</span></span><br><span class="line">            <span class="keyword">if</span>(visited[ch-<span class="string">'a'</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//栈顶字符字符比当前字符大而且后面还有该字符，弹栈</span></span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty() &amp;&amp; <span class="built_in">stack</span>.peek() &gt; ch &amp;&amp; freq[<span class="built_in">stack</span>.peek() - <span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//弹栈并且设置为不在栈中false</span></span><br><span class="line">                visited[<span class="built_in">stack</span>.pop() - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="built_in">stack</span>.push(ch);</span><br><span class="line">            visited[ch - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//这样遍历栈相当于把栈逆过来：），意外发现</span></span><br><span class="line">        <span class="comment">// for(char ch : stack)&#123;</span></span><br><span class="line">        <span class="comment">//     sb.append(ch);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//return sb.toString();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty())&#123;</span><br><span class="line">            sb.append(<span class="built_in">stack</span>.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once an]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Copy List with Random Pointer]]></title>
    <link href="http://blog.noobsky.com/2016/07/01/LeetCode-Copy-List-with-Random-Pointer/"/>
    <id>http://blog.noobsky.com/2016/07/01/LeetCode-Copy-List-with-Random-Pointer/</id>
    <published>2016-07-01T12:34:32.000Z</published>
    <updated>2016-07-01T14:21:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<h2 id="代码">代码</h2><p>最简单的思路就是用HashMap存取node节点，第一遍将node存到HashMap中，第二遍遍历为每个节点的next和random赋值。时间复杂度为O(n)，空间复杂度为O(n)。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list with a random pointer.</span><br><span class="line"> * class RandomListNode &#123;</span><br><span class="line"> *     int label;</span><br><span class="line"> *     RandomListNode next, random;</span><br><span class="line"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    //使用HashMap，遍历两遍</span><br><span class="line">    //第一遍把所以节点加入到HashMap中</span><br><span class="line">    //第二遍给map中节点的next和random赋值</span><br><span class="line">    public RandomListNode copyRandomList(RandomListNode head) &#123;</span><br><span class="line">        if(head == null) return head;</span><br><span class="line">        </span><br><span class="line">        Map<span class="tag">&lt;RandomListNode, RandomListNode&gt;</span> map = new HashMap<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        </span><br><span class="line">        RandomListNode <span class="keyword">node</span><span class="identifier"> </span><span class="title">= head</span>;</span><br><span class="line">        while(<span class="keyword">node</span><span class="identifier"> </span><span class="title">!= null</span>)&#123;</span><br><span class="line">            map.put(<span class="keyword">node</span><span class="identifier"></span><span class="title">, new</span> RandomListNode(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">label</span>));</span><br><span class="line">            <span class="keyword">node</span><span class="identifier"> </span><span class="title">= node</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">node</span><span class="identifier"> </span><span class="title">= head</span>;</span><br><span class="line">        //为每个节点赋值next和random的指向</span><br><span class="line">        while(<span class="keyword">node</span><span class="identifier"> </span><span class="title">!= null</span>)&#123;</span><br><span class="line">            map.get(<span class="keyword">node</span><span class="identifier"></span><span class="title">).next</span> = map.get(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">next</span>);</span><br><span class="line">            map.get(<span class="keyword">node</span><span class="identifier"></span><span class="title">).random</span> = map.get(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">random</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">node</span><span class="identifier"> </span><span class="title">= node</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方法，包括三步：</p>
<ul>
<li><p>为每个原始节点复制一个副本节点，链接到原始节点之后</p>
</li>
<li><p>将每个原始节点的random指针赋值给副本节点的random指针，curr.next.random = curr.random.next;</p>
</li>
<li><p>将链表划分为两部分，一个为原始链表，一个为复制链表</p>
</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">public</span> RandomListNode copyRandomList(RandomListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        RandomListNode curr = head;</span><br><span class="line">        <span class="comment">//为每个节点复制一份副本链接到原始节点的后面</span></span><br><span class="line">        <span class="comment">//如A-&gt;B-&gt;C变为A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode <span class="keyword">copy</span> = <span class="keyword">new</span> RandomListNode(curr.label);</span><br><span class="line">            <span class="keyword">copy</span>.<span class="keyword">next</span> = curr.<span class="keyword">next</span>;</span><br><span class="line">            curr.<span class="keyword">next</span> = <span class="keyword">copy</span>;</span><br><span class="line">            </span><br><span class="line">            curr = <span class="keyword">copy</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="comment">//第二次遍历，将每个原始节点的random指针赋值给副本的random指针</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">                curr.<span class="keyword">next</span>.random = curr.random.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将链表分成两个，一个还原为原链表，一个就是复制的链表</span></span><br><span class="line">        curr = head;</span><br><span class="line">        RandomListNode newHead = head.<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">// while(curr != null &amp;&amp; curr.next != null)&#123;</span></span><br><span class="line">        <span class="comment">//     //这种写法比较tricky</span></span><br><span class="line">        <span class="comment">//     //写链接原始节点，接着副本节点，然后又原始节点，又副本节点。。。。</span></span><br><span class="line">        <span class="comment">//     RandomListNode temp = curr.next;</span></span><br><span class="line">        <span class="comment">//     curr.next = temp.next;</span></span><br><span class="line">        <span class="comment">//     curr = temp;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//复制节点</span></span><br><span class="line">            RandomListNode <span class="keyword">copy</span> = curr.<span class="keyword">next</span>;</span><br><span class="line">            </span><br><span class="line">            curr.<span class="keyword">next</span> = <span class="keyword">copy</span>.<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">copy</span>.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">copy</span>.<span class="keyword">next</span> = <span class="keyword">copy</span>.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Merge Intervals and Insert Interval]]></title>
    <link href="http://blog.noobsky.com/2016/07/01/LeetCode-Merge-Intervals-and-Insert-Interval/"/>
    <id>http://blog.noobsky.com/2016/07/01/LeetCode-Merge-Intervals-and-Insert-Interval/</id>
    <published>2016-07-01T07:03:24.000Z</published>
    <updated>2016-07-01T07:38:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Merge_Intervals">Merge Intervals</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,<br>Given [1,3],[2,6],[8,10],[15,18],<br>return [1,6],[8,10],[15,18].</p>
<h3 id="代码">代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for an interval.</span><br><span class="line"> * public class Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() &#123; start = 0; end = 0; &#125;</span><br><span class="line"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">//我们按interval的start升序来排序，然后将interval的end和下一个interval的start比较，看是否出现了overlap</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        </span><br><span class="line">        Collections.<span class="built_in">sort</span>(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> compare(Interval i1, Interval i2)&#123;</span><br><span class="line">                <span class="comment">//按start的升序排序，可以直接利用Integer的compare函数</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(i1.start, i2.start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> start = intervals.<span class="built_in">get</span>(<span class="number">0</span>).start;</span><br><span class="line">        <span class="comment">//上一interval的end</span></span><br><span class="line">        <span class="built_in">int</span> end = intervals.<span class="built_in">get</span>(<span class="number">0</span>).end;</span><br><span class="line">        <span class="keyword">for</span>(Interval interval : intervals)&#123;</span><br><span class="line">            <span class="comment">//当前interval的start小于上一个interval的end，说明出现overlap</span></span><br><span class="line">            <span class="keyword">if</span>(interval.start &lt;= end)&#123;</span><br><span class="line">                <span class="comment">//则end为上一个interval和当前interval的end的较大值</span></span><br><span class="line">                end = Math.<span class="built_in">max</span>(interval.end, end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">add</span>(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入最后一个Interval</span></span><br><span class="line">        res.<span class="built_in">add</span>(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Insert_Interval">Insert Interval</h2><h3 id="题目描述-1">题目描述</h3><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were <font color="red">initially sorted</font> according to their start times.</p>
<p>Example 1:<br>Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>
<p>Example 2:<br>Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].</p>
<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>
<h3 id="代码-1">代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先将那些与newInterval没有overlap的interval放入结果集中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).end &lt; newInterval.start)&#123;</span><br><span class="line">            res.<span class="built_in">add</span>(intervals.<span class="built_in">get</span>(i));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合并所有overlapping的intervals,赋值为newInterval</span></span><br><span class="line">        <span class="comment">//如果intervals.get(i).start &gt; newInterval.end说明已经没有Overlapping</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).start &lt;= newInterval.end)&#123;</span><br><span class="line">            newInterval = <span class="keyword">new</span> Interval(Math.<span class="built_in">min</span>(newInterval.start, intervals.<span class="built_in">get</span>(i).start), Math.<span class="built_in">max</span>(newInterval.end, intervals.<span class="built_in">get</span>(i).end));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将合并结果加入结果中</span></span><br><span class="line">        res.<span class="built_in">add</span>(newInterval);</span><br><span class="line">        <span class="comment">//将剩下的元素加入结果中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">add</span>(intervals.<span class="built_in">get</span>(i));</span><br><span class="line">            i++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实可以直接在原始的List上操作：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	<span class="comment">//在原始的List中直接操作</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//没有overlapping的直接跳过</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).end &lt; newInterval.start)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并具有overlapping的intervals</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).start &lt;= newInterval.end)&#123;</span><br><span class="line">            newInterval = <span class="keyword">new</span> Interval(Math.<span class="built_in">min</span>(newInterval.start, intervals.<span class="built_in">get</span>(i).start), Math.<span class="built_in">max</span>(newInterval.end, intervals.<span class="built_in">get</span>(i).end));</span><br><span class="line">            <span class="comment">//移除下标为i的元素</span></span><br><span class="line">            intervals.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.<span class="built_in">add</span>(i, newInterval);</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Merge_Intervals">Merge Intervals</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of intervals, merge all overlapping intervals.</p>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Burst Balloons]]></title>
    <link href="http://blog.noobsky.com/2016/07/01/LeetCode-Burst-Balloons/"/>
    <id>http://blog.noobsky.com/2016/07/01/LeetCode-Burst-Balloons/</id>
    <published>2016-07-01T01:38:48.000Z</published>
    <updated>2016-07-01T04:23:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.</p>
<p>Find the maximum coins you can collect by bursting the balloons wisely.</p>
<p><strong> Note: </strong><br>(1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</p>
<p><strong> Example: </strong></p>
<p>Given [3, 1, 5, 8]</p>
<p>Return 167</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>] --&gt; [<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>] --&gt;   [<span class="number">3</span>,<span class="number">8</span>]   --&gt;  [<span class="number">8</span>]  --&gt; []</span><br><span class="line">coins =  <span class="number">3</span>*<span class="number">1</span>*<span class="number">5</span>      +  <span class="number">3</span>*<span class="number">5</span>*<span class="number">8</span>    +  <span class="number">1</span>*<span class="number">3</span>*<span class="number">8</span>      + <span class="number">1</span>*<span class="number">8</span>*<span class="number">1</span>   = <span class="number">167</span></span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2><p>最自然的方法就是打掉一个气球然后将原问题划分成了两个子问题，分别为打掉气球的左边和右边的气球，但是它们相邻接，会对maxCoins造成影响。我们可以逆向思考，我们不是通过第一个打掉的气球来划分原问题，而是通过最后一个打掉的气球来划分。前者获得的分数为<code>nums[i-1]*nums[i]*nums[i+1]</code>，后者为<code>nums[-1]*nums[i]*nums[n]</code>。</p>
<p>dp[i][j]表示打破区间[i,j]中所有气球能得到的分数(coins)。<br>如果最后一个打破的气球为k，则可以获得的分数为：nums[i-1]*nums[k]*nums[j+1]。则状态转移方程为：<br>dp[i][j] = max(dp[i][j], nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j]), i &lt;= k &lt;= j<br>为了方便代码的书写，在数组的两端插入两个1，即nums[-1] = 1，nums[n] = 1</p>
<p>还可以将所有为0的气球先打破，因为它们不能带来任何分数，当然不做这个也是可以的。</p>
<ul>
<li>Divide And Conquer with Memoization</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] eNums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           eNums[i+<span class="number">1</span>] = nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        eNums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        eNums[nums.length + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>][nums.length + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> burst(eNums, dp, <span class="number">1</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带备忘的递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">burst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[][] dp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[left][right] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[left][right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i为最后打破的气球</span></span><br><span class="line">        <span class="comment">//dp[i][j] = max(dp[i][j], nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j]), i &lt;= k &lt;= j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            res = Math.max(res, nums[left-<span class="number">1</span>]*nums[i]*nums[right+<span class="number">1</span>] + burst(nums, dp, left, i-<span class="number">1</span>) + burst(nums, dp, i+<span class="number">1</span>, right));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[left][right] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>DP</li>
</ul>
<p>直接dp的话，类似最优二叉搜索树，见算法导论，可对比理解<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//直接dp的话，类似最优二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] eNums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           eNums[i+<span class="number">1</span>] = nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        eNums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        eNums[nums.length + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>][nums.length + <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先求长度为1、2、3.。。。n的区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= nums.length; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">1</span>; left &lt;= nums.length - len + <span class="number">1</span>; left++)&#123;</span><br><span class="line">                <span class="keyword">int</span> right = left + len - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//注意用扩展后的eNums数组</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = left; k &lt;= right; k++)&#123;</span><br><span class="line">                    dp[left][right] = Math.max(dp[left][right], eNums[left-<span class="number">1</span>]*eNums[k]*eNums[right+<span class="number">1</span>]+dp[left][k-<span class="number">1</span>] + dp[k+<span class="number">1</span>][right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][nums.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考">参考</h2><p><strong> Better idea </strong></p>
<p>We then think can we apply the divide and conquer technique? After all there seems to be many self similar sub problems from the previous analysis.</p>
<p>Well, the nature way to divide the problem is burst one balloon and separate the balloons into 2 sub sections one on the left and one one the right. However, in this problem the left and right become adjacent and have effects on the maxCoins in the future.</p>
<p>Then another interesting idea come up. Which is quite often seen in dp problem analysis. That is reverse thinking. Like I said the coins you get for a balloon does not depend on the balloons already burst. Therefore instead of divide the problem by the first balloon to burst, we divide the problem by the last balloon to burst.</p>
<p>Why is that? Because only the first and last balloons we are sure of their adjacent balloons before hand!</p>
<p>For the first we have nums[i-1]<em>nums[i]</em>nums[i+1] for the last we have nums[-1]<em>nums[i]</em>nums[n].</p>
<p>OK. Think about n balloons if i is the last one to burst, what now?</p>
<p>We can see that the balloons is again separated into 2 sections. But this time since the balloon i is the last balloon of all to burst, the left and right section now has well defined boundary and do not affect each other! Therefore we can do either recursive method with memoization or dp.</p>
<p>Final</p>
<p>Here comes the final solutions. Note that we put 2 balloons with 1 as boundaries and also burst all the zero balloons in the first round since they won’t give any coins. The algorithm runs in O(n^3) which can be easily seen from the 3 loops in dp solution.</p>
<p>详见<a href="https://leetcode.com/discuss/72216/share-some-analysis-and-explanations" target="_blank" rel="external">Share some analysis and explanations</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. Yo]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Intersection of Two Arrays I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Intersection-of-Two-Arrays-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Intersection-of-Two-Arrays-I-II/</id>
    <published>2016-06-26T07:10:50.000Z</published>
    <updated>2016-07-01T01:40:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Intersection_of_Two_Arrays_I">Intersection of Two Arrays I</h2><h3 id="题目描述">题目描述</h3><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong> Example: </strong><br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>
<p><strong> Note: </strong></p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
<h3 id="代码">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	 <span class="comment">//使用HashSet，分别遍历两个数组</span></span><br><span class="line">    <span class="comment">//首先把第一个数组加入到集合中</span></span><br><span class="line">    <span class="comment">//然后遍历第二个数组时判断集合中是否包含元素</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(n)，空间复杂度为O(n)</span></span><br><span class="line">    public <span class="built_in">int</span>[] intersection(<span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; <span class="literal">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//利用集合对交集进行去重</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; intersect = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num1: nums1)&#123;</span><br><span class="line">            <span class="literal">set</span>.add(num1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num2: nums2)&#123;</span><br><span class="line">            <span class="comment">//nums1中包含</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">set</span>.contains(num2))&#123;</span><br><span class="line">                intersect.add(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[intersect.size()];</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer <span class="built_in">num</span> : intersect)&#123;</span><br><span class="line">            res[i++] = <span class="built_in">num</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//另外还可以先排序然后使用tow pointers，类似merge array，时间复杂度为O(n)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">set</span>.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">set</span>.size()];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : <span class="built_in">set</span>)&#123;</span><br><span class="line">            res[k++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或者对一个数组排序，然后使用二分搜索在排序数组中搜索另一个数组的元素</span></span><br><span class="line">    <span class="comment">//时间复杂度都为O(nlgn)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Intersection_of_Two_Arrays_II">Intersection of Two Arrays II</h2><h3 id="题目描述-1">题目描述</h3><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong> Example: </strong><br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>
<p><strong> Note: </strong></p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p><strong> Follow up: </strong></p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<h3 id="代码-1">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Solution</span>&#123;</span><br><span class="line">	    //使用<span class="type">HashMap</span>，key为nums1中的元素，value为该元素出现的次数</span><br><span class="line">    //时间复杂度为O(n)，空间复杂度为O(n)</span><br><span class="line">    public <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> new <span class="type">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">Integer</span>, <span class="type">Integer</span>&gt; map = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; <span class="literal">result</span> = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num1 : nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num1))&#123;</span><br><span class="line">                map.put(num1, map.get(num1) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num1, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num2: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num2) &amp;&amp; map.get(num2) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="literal">result</span>.add(num2);</span><br><span class="line">                map.put(num2, map.get(num2) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] res = new <span class="type">int</span>[<span class="literal">result</span>.size()];</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Integer</span> num: <span class="literal">result</span>)&#123;</span><br><span class="line">            res[i++] = num;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Solution</span>&#123;</span><br><span class="line">	    //时间复杂度为O(nlgn)， 空间复杂度为O(n)</span><br><span class="line">    public <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> new <span class="type">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">Arrays</span>.sort(nums1);</span><br><span class="line">        <span class="type">Arrays</span>.sort(nums2);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; <span class="literal">result</span> = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="literal">result</span>.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] res = new <span class="type">int</span>[<span class="literal">result</span>.size()];</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Integer</span> num : <span class="literal">result</span>)&#123;</span><br><span class="line">            res[k++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution_to_3rd_follow-up_question">Solution to 3rd follow-up question</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What <span class="keyword">if</span> elements <span class="keyword">of</span> nums2 are stored <span class="function_start"><span class="keyword">on</span></span> disk, <span class="keyword">and</span> <span class="keyword">the</span> memory <span class="keyword">is</span> limited such <span class="keyword">that</span> you cannot load all elements <span class="keyword">into</span> <span class="keyword">the</span> memory <span class="keyword">at</span> once?</span><br></pre></td></tr></table></figure>
<ul>
<li><p>If only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</p>
</li>
<li><p>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), then read 2 elements from each array at a time in memory, record intersections.</p>
</li>
</ul>
<p>Thanks for the solution. I think the second part of the solution is impractical, if you read 2 elements at a time, this procedure will take forever. In principle, we want minimize the number of disk access during the run-time.</p>
<p>An improvement can be sort them using external sort, read (let’s say) 2G of each into memory and then using the 2 pointer technique, then read 2G more from the array that has been exhausted. Repeat this until no more data to read from disk.</p>
<p>But I am not sure this solution is good enough for an interview setting. Maybe the interviewer is expecting some solution using Map-Reduce paradigm.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Intersection_of_Two_Arrays_I">Intersection of Two Arrays I</h2><h3 id="题目描述">题目描述</h3><p>Given two arrays, write a function to compu]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Count of Smaller Numbers After Self and Count of Range Sum]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Count-of-Smaller-Numbers-After-Self-and-Count-of-Range-Sum/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Count-of-Smaller-Numbers-After-Self-and-Count-of-Range-Sum/</id>
    <published>2016-06-26T04:03:35.000Z</published>
    <updated>2016-06-26T04:03:35.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximum Gap]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Maximum-Gap/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Maximum-Gap/</id>
    <published>2016-06-26T03:01:25.000Z</published>
    <updated>2016-06-26T03:33:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Try to solve it in linear time/space.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>
<h2 id="代码">代码</h2><ul>
<li>解法一</li>
</ul>
<p>排序，依次计算相邻元素，时间复杂度不符合要求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//时间复杂度为O(nlgn)不符合要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxGap = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            maxGap = Math.max(maxGap, nums[i+<span class="number">1</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<p>[Thoughts]<br>Suppose there are N elements and they range from A to B.<br>Then the maximum gap will be no smaller than ceiling[(B - A) / (N - 1)]<br>Let the length of a bucket to be len = ceiling[(B - A) / (N - 1)], then we will have at most num = (B - A) / len + 1 of bucket<br>for any number K in the array, we can easily find out which bucket it belongs by calculating loc = (K - A) / len and therefore maintain the maximum and minimum elements in each bucket.<br>Since the maximum difference between elements in the same buckets will be at most len - 1, so the final answer will not be taken from two elements in the same buckets.<br>For each non-empty buckets p, find the next non-empty buckets q, then q.min - p.max could be the potential answer to the question. Return the maximum of all those values.</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">//时间复杂度为O(nlgn)不符合要求</span></span><br><span class="line">    <span class="comment">// public int maximumGap(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length &lt;= 1) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     Arrays.sort(nums);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int maxGap = Integer.MIN_VALUE;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length - 1; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         maxGap = Math.max(maxGap, nums[i+1] - nums[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return maxGap;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//桶排序</span></span><br><span class="line">    <span class="comment">//最大的gap必定是两个相邻桶的最小值和最大值之差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maximumGap(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">min</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//求数组中最大最小元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num: nums)&#123;</span><br><span class="line">            <span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, num);</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不然后面的gap会为0，/gap抛出除0异常</span></span><br><span class="line">        <span class="comment">//或者后面的gap至少为1，Math.max(1, ...);</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span> == <span class="built_in">max</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// the minimum possibale gap, ceiling of the integer division</span></span><br><span class="line">        <span class="comment">//也是桶的range</span></span><br><span class="line">        <span class="built_in">int</span> gap = (<span class="built_in">int</span>)Math.<span class="built_in">ceil</span>((<span class="keyword">double</span>)(<span class="built_in">max</span> - <span class="built_in">min</span>) / (nums.length - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> bucketLen = (<span class="built_in">max</span> - <span class="built_in">min</span>)/gap + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只保存桶的最大最小元素即可</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] bucketsMin = <span class="keyword">new</span> <span class="built_in">int</span>[bucketLen];</span><br><span class="line">        <span class="built_in">int</span>[] bucketsMax = <span class="keyword">new</span> <span class="built_in">int</span>[bucketLen];</span><br><span class="line">        </span><br><span class="line">        Arrays.<span class="built_in">fill</span>(bucketsMin, Integer.MAX_VALUE);</span><br><span class="line">        Arrays.<span class="built_in">fill</span>(bucketsMax, Integer.MIN_VALUE);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num: nums)&#123;</span><br><span class="line">            <span class="built_in">int</span> bucketIndex = (num - <span class="built_in">min</span>) / gap;</span><br><span class="line">            <span class="comment">//更新每个桶的最大最小值</span></span><br><span class="line">            bucketsMin[bucketIndex] = Math.<span class="built_in">min</span>(bucketsMin[bucketIndex], num);</span><br><span class="line">            bucketsMax[bucketIndex] = Math.<span class="built_in">max</span>(bucketsMax[bucketIndex], num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> maxGap = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//前一个桶的最大值</span></span><br><span class="line">        <span class="built_in">int</span> prev = <span class="built_in">min</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bucketLen; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucketsMin[i] == Integer.MAX_VALUE) <span class="keyword">continue</span>;<span class="comment">//empty bucket</span></span><br><span class="line">            maxGap = Math.<span class="built_in">max</span>(maxGap, bucketsMin[i] - prev);</span><br><span class="line">            prev = bucketsMax[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Tr]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sliding Window Maximum]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-Sliding-Window-Maximum/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-Sliding-Window-Maximum/</id>
    <published>2016-06-25T13:01:48.000Z</published>
    <updated>2016-06-25T16:33:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>] -<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [-<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span> [-<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>Therefore, return the max sliding window as [3,3,5,5,6,7].</p>
<p><strong> Note: </strong><br>You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong> Follow up: </strong><br>Could you solve it in linear time?</p>
<p><strong> Hint: </strong></p>
<ol>
<li>How about using a data structure such as deque (double-ended queue)?</li>
<li>The queue size need not be the same as the window’s size.</li>
<li>Remove redundant elements and the queue should store only elements that need to be considered.</li>
</ol>
<h2 id="代码">代码</h2><ul>
<li>解法一</li>
</ul>
<p>使用堆，维护一个大小为k的最大堆，堆中存放滑动窗口的中元素，时间复杂度为O(nlgk)，空间复杂度为O(k)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//维护一个最大堆，并维护堆的大小为k即窗口大小，则堆顶元素即为每个滑动窗口的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//Collections.reverseOrder()返回一个逆序的Comparator，则构建一个最大堆</span></span><br><span class="line">        <span class="comment">//Arrays.sort(arr, Collections.reverseOrder())</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//滑动窗口大小已经为k，删除窗口最左边的元素，为下一个元素腾空间</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) pq.remove(nums[i-k]);</span><br><span class="line">            pq.offer(nums[i]);</span><br><span class="line">            <span class="comment">//窗口大小已经为k</span></span><br><span class="line">            <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) res[i-k+<span class="number">1</span>] = pq.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>解法二</li>
</ul>
<p>使用双端队列，时间复杂度为O(n)，空间复杂度为O(k)。<br>当遍历到数组中一个新元素时，将该元素与队列中队尾元素相比较，如果末尾元素比新元素小，则移除末尾元素，直到该队列的末尾元素比新元素大或者队列为空时才停止。这样我们可以保证队头元素是窗口[i-(k-1), i]中最大的元素，其实队列中的窗口中元素降序。由于我们我们新加数的时候，已经把很多没用的元素移除了，无法正确的判断队列中滑动窗口的大小。这里比较tricky的就是在队列中保存元素在数组中下标，这样既能知道这个数的值，也能判断该数是不是窗口最左边的数。这里的均摊时间复杂度为O(n)，因为每个元素被加入队列和移除队列各一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//使用双端队列存元素在数组中的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//nums.length - k + 1个滑动窗口</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="comment">//dq.peek() == i-k</span></span><br><span class="line">            <span class="comment">//滑动窗口大小已经为k，删除窗口最左边的元素，为下一个元素腾空间</span></span><br><span class="line">            <span class="keyword">if</span>(!dq.isEmpty() &amp;&amp; dq.peek() &lt; i - k + <span class="number">1</span>)&#123;</span><br><span class="line">                dq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//我们将nums[i]加入队尾之前，如果队列中元素小于nums[i]，则可以删除，因为他们不可能是滑动窗口的最大值</span></span><br><span class="line">            <span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt; nums[i])&#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dq.offer(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) res[i-k+<span class="number">1</span>] = nums[dq.peek()];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the ve]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]One Edit Distance And Edit Distance]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-One-Edit-Distance-And-Edit-Distance/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-One-Edit-Distance-And-Edit-Distance/</id>
    <published>2016-06-25T04:00:10.000Z</published>
    <updated>2016-06-25T12:03:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="One_Edit_Distance">One Edit Distance</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Edit_Distance">Edit Distance</h2><h3 id="题目描述-1">题目描述</h3><p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
<h3 id="代码-1">代码</h3><p>dp[i][j]表示word1[0…i-1]转换到word2[0…j-1]的最少操作步数(编辑距离)。 下面来看状态转移方程。<br>边界情况：</p>
<ul>
<li><p>dp[i][0] = i</p>
</li>
<li><p>dp[0][j] = j </p>
</li>
</ul>
<p>这两个结论都很显然，比如word1[0…i-1]到空字符串””的编辑距离显然是i（i次删除）。</p>
<p>接下来看word1[0…i-1]到word2[0…j-1]，子问题就是word1[0…i-2]转换到word2[0…j-2]的编辑距离，也就是dp[i-1][j-1]。现在考虑word1[i-1]和word2[j-1]关系，如果它们相等，则dp[i][j] = dp[i-1][j-1]，如果word1[i-1]和word2[j-1]不相等，则有以下三种情况。</p>
<ol>
<li>替换：将word1[i-1]替换成word2[j-1]，则dp[i][j] = dp[i-1][j-1] + 1 </li>
<li>删除：将word1[i-1]删除后，则dp[i][j] = dp[i-1][j] + 1</li>
<li>插入：将word2[j-1]插入到word1[i-1]的后面，则dp[i][j] = dp[i][j-1] + 1</li>
</ol>
<p>所以，状态转移方程如下：</p>
<ol>
<li>dp[i][0] = i;</li>
<li>dp[0][j] = j;</li>
<li>dp[i][j] = dp[i-1][j-1] + 1, if word1[i-1] = word2[j-1]</li>
<li>dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1, dp[i][j-1] + 1), if word1[i-1] != word2[j-1]</li>
</ol>
<p>根据以上状态转移方程，可得如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word1 == null || word2 == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=n; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>, dp[i-<span class="number">1</span>][j] + <span class="number">1</span>), dp[i][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp[i][j]只跟dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]有关系，其实我们并不需要维护m*n的矩阵，维护一行或一列就可以了，空间复杂度能够降到O(m)或者O(n)。</p>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.geeksforgeeks.org/dynamic-programming-set-5-edit-distance/" target="_blank" rel="external">Dynamic Programming | Set 5 (Edit Distance)</a><br><a href="https://leetcode.com/discuss/43398/20ms-detailed-explained-c-solutions-o-n-space" target="_blank" rel="external">20ms Detailed Explained C++ Solutions (O(n) Space)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="One_Edit_Distance">One Edit Distance</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Edit_Distance">Edit Distance</h2><h3 id="]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Distinct Subsequences]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-Distinct-Subsequences/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-Distinct-Subsequences/</id>
    <published>2016-06-25T02:34:18.000Z</published>
    <updated>2016-06-25T03:25:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>Here is an example:<br>S = “rabbbit”, T = “rabbit”</p>
<p>Return 3.</p>
<h2 id="代码">代码</h2><p>dp[i][j]表示T[0…j-1]在S[0…i-1]中distinc subsequences的数量，则以S =”rabbbit”,T = “rabbit”为例）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    r a b b b i t</span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">r <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">a <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">i <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">t <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>所以状态转移方程为</p>
<p>dp[0][0] = 1; // T和S都是空串.<br>dp[0][1 … S.length() - 1] = 1; // T是空串，S只有一种子序列匹配。<br>dp[1 … T.length() - 1][0] = 0; // S是空串，T不是空串，S没有子序列匹配。<br>dp[i][j] = dp[i][j - 1] + (T[i - 1] == S[j - 1] ? dp[i - 1][j - 1] : 0).1 &lt;= i &lt;= T.length(), 1 &lt;= j &lt;= S.length()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(s.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return t.length() == 0 ? 1 : 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(t.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i-<span class="number">1</span>) == s.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[t.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a st]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Trapping Rain Water]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-Trapping-Rain-Water/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-Trapping-Rain-Water/</id>
    <published>2016-06-25T01:00:24.000Z</published>
    <updated>2016-06-25T01:39:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="http://articles.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt=""><br>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<h2 id="代码">代码</h2><p>对任意位置i，在i上的积水，由左右两边最高的bar：A[left] = max{A[j], j<i}, a[right]="max{A[j]," j="">i}决定。定义Hmin = min(A[left], A[right])，则积水量Si为：</i},></p>
<p>Hmin &lt;= A[i]时，Si = 0<br>Hmin &gt; A[i]时，Si = Hmin - A[i]</p>
<p>简单的说，对于某个值A[i]来说，能trapped的最多的water取决于在i之前最高海拔leftMostHeight[i]和i右边最高的海拔值rightMostHeight[i]。如果min(leftMostHeight[i], rightMostHeight[i]) &gt; A[i]，那么在i这个位置上能trapped的water就是min(leftMostHeight[i], rightMostHeight[i]) - A[i]。所以根据以上思想，进行两遍for循环，第一遍从左到右计算数组leftMostHeight，第二遍从右到左计算rightMostHeight同时也可以计算出i位置的结果。时间复杂度为O(n)，空间复杂度为O(n)。 </p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">// public int trap(int[] height) &#123;</span></span><br><span class="line">    <span class="comment">//     if(height == null || height.length == 0) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int res = 0;</span></span><br><span class="line">    <span class="comment">//     //非负数组，可以初始化为0，否则考虑height[0]</span></span><br><span class="line">    <span class="comment">//     int max = 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int[] leftMostHeight = new int[height.length];</span></span><br><span class="line">    <span class="comment">//     int[] rightMostHeight = new int[height.length];</span></span><br><span class="line">    <span class="comment">//     //leftMostHeight[i]为0~i-1中的最大值</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; height.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         leftMostHeight[i] = max;</span></span><br><span class="line">    <span class="comment">//         max = Math.max(max, height[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     max = 0;</span></span><br><span class="line">    <span class="comment">//     for(int i = height.length - 1; i &gt;= 0; i--)&#123;</span></span><br><span class="line">    <span class="comment">//         rightMostHeight[i] = max;</span></span><br><span class="line">    <span class="comment">//         max = Math.max(max, height[i]);</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">//         int container = Math.min(leftMostHeight[i], rightMostHeight[i]);</span></span><br><span class="line">    <span class="comment">//         res += container &gt; height[i] ? container - height[i] : 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其实rightMostHeight数组没必要存了，直接用max变量保存就可以了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> trap(<span class="built_in">int</span>[] <span class="variable">height</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">height</span> == <span class="keyword">null</span> || <span class="variable">height</span>.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//非负数组，可以初始化为0，否则考虑height[0]</span></span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] leftMostHeight = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="variable">height</span>.length];</span><br><span class="line">        <span class="comment">//leftMostHeight[i]为0~i-1中的最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="variable">height</span>.length; i++)&#123;</span><br><span class="line">            leftMostHeight[i] = <span class="built_in">max</span>;</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, <span class="variable">height</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="variable">height</span>.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> container = Math.<span class="built_in">min</span>(leftMostHeight[i], <span class="built_in">max</span>);</span><br><span class="line">            res += container &gt; <span class="variable">height</span>[i] ? container - <span class="variable">height</span>[i] : <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, <span class="variable">height</span>[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有更tricky的方法只扫描一遍即可，这里先贴上C++代码，有时间再研究一下：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> trap(<span class="built_in">int</span> A[], <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>; <span class="built_in">int</span> <span class="built_in">right</span>=n-<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> maxleft=<span class="number">0</span>, maxright=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[<span class="built_in">left</span>]&lt;=A[<span class="built_in">right</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[<span class="built_in">left</span>]&gt;=maxleft) maxleft=A[<span class="built_in">left</span>];</span><br><span class="line">                <span class="keyword">else</span> res+=maxleft-A[<span class="built_in">left</span>];</span><br><span class="line">                <span class="built_in">left</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[<span class="built_in">right</span>]&gt;=maxright) maxright= A[<span class="built_in">right</span>];</span><br><span class="line">                <span class="keyword">else</span> res+=maxright-A[<span class="built_in">right</span>];</span><br><span class="line">                <span class="built_in">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much wat]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Find the Duplicate Number]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Find-the-Duplicate-Number/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Find-the-Duplicate-Number/</id>
    <published>2016-06-21T10:02:00.000Z</published>
    <updated>2016-06-21T10:02:00.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Preorder/Inorder/Postorder Traversal]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/</id>
    <published>2016-06-21T06:20:02.000Z</published>
    <updated>2016-06-21T06:21:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Binary_Tree_Inorder_Traversal">Binary Tree Inorder Traversal</h2><h3 id="题目描述-1">题目描述</h3><h3 id="代码-1">代码</h3><h2 id="Binary_Tree_Postorder_Traversal">Binary Tree Postorder Traversal</h2><h3 id="题目描述-2">题目描述</h3><h3 id="代码-2">代码</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Binary_Tree_Ino]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Fraction to Recurring Decimal]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Fraction-to-Recurring-Decimal/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Fraction-to-Recurring-Decimal/</id>
    <published>2016-06-21T06:11:07.000Z</published>
    <updated>2016-06-21T06:12:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>For example,</p>
<ul>
<li>Given numerator = 1, denominator = 2, return “0.5”.</li>
<li>Given numerator = 2, denominator = 1, return “2”.</li>
<li>Given numerator = 2, denominator = 3, return “0.(6)”.</li>
</ul>
<p><strong> Hint: </strong></p>
<ol>
<li>No scary math, just apply elementary math knowledge. Still remember how to perform a long division?</li>
<li>Try a long division on 4/9, the repeating part is obvious. Now try 4/333. Do you see a pattern?</li>
<li>Be wary of edge cases! List out as many test cases as you can think of and test your code thoroughly.</li>
</ol>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分母为0</span></span><br><span class="line">        <span class="keyword">if</span>(denominator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"NaN"</span>;</span><br><span class="line">        <span class="keyword">if</span>(numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//异或为true说明符合相异</span></span><br><span class="line">        <span class="keyword">if</span>((numerator &gt; <span class="number">0</span>) ^ (denominator &gt; <span class="number">0</span>)) sb.append(<span class="string">"-"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//MIN_VALUE的绝对值会溢出，所以用long类型</span></span><br><span class="line">        <span class="keyword">long</span> num = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)numerator);</span><br><span class="line">        <span class="keyword">long</span> den = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)denominator);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//整数部分</span></span><br><span class="line">        sb.append(num/den);</span><br><span class="line">        </span><br><span class="line">        num = num % den;</span><br><span class="line">        <span class="comment">//能整除直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不能整除，存在小数部分，先加入小数点</span></span><br><span class="line">        sb.append(<span class="string">"."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//余数</span></span><br><span class="line">        <span class="keyword">long</span> remainder = num;</span><br><span class="line">        <span class="comment">//使用HashMap记录余数和在结果res中的下标，记录下标是因为出现循环小数要插入括号</span></span><br><span class="line">        <span class="comment">//key为余数，value为下标</span></span><br><span class="line">        <span class="comment">//当重复出现某一个余数时说明结果为循环小数</span></span><br><span class="line">        HashMap&lt;Long, Integer&gt; <span class="built_in">map</span>= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(remainder != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//出现重复余数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(remainder))&#123;</span><br><span class="line">                sb.insert(<span class="built_in">map</span>.get(remainder), <span class="string">"("</span>);</span><br><span class="line">                sb.append(<span class="string">")"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将余数加入map中</span></span><br><span class="line">            <span class="built_in">map</span>.put(remainder, sb.length());</span><br><span class="line">            <span class="comment">//并计算一位小数</span></span><br><span class="line">            remainder *= <span class="number">10</span>;</span><br><span class="line">            sb.append(remainder/den);</span><br><span class="line">            remainder = remainder % den;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Flatten Binary Tree to Linked List]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Flatten-Binary-Tree-to-Linked-List/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Flatten-Binary-Tree-to-Linked-List/</id>
    <published>2016-06-21T03:16:39.000Z</published>
    <updated>2016-06-21T05:24:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>The flattened tree should look like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong> Hints: </strong><br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
<h2 id="代码">代码</h2><p>直接先序遍历，从头到尾把节点链接起来：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">private</span> TreeNode lastVisited = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用先序遍历，top-down</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">flatten</span>(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">        TreeNode savedRight = root.right;</span><br><span class="line">        <span class="keyword">if</span>(lastVisited != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastVisited.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//在这里会修改上一访问节点的right指向，应该先保存</span></span><br><span class="line">            <span class="comment">//比如先序遍历到3时，lastVisited指向2（此时结果为1-&gt;2），然后在这里修改2的节点的left为null，right节点为3</span></span><br><span class="line">            <span class="comment">//遍历完3节点后，接着遍历节点4，但是如果我们不提前保存节点4，我们就找不到4了因为节点2的右节点已经被修改为3</span></span><br><span class="line">            <span class="comment">//这就是需要保存右节点的原因</span></span><br><span class="line">            lastVisited.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        lastVisited = root;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">flatten</span>(root.left);</span><br><span class="line">        <span class="keyword">flatten</span>(savedRight);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者采用前插构建单链表的形式，bottom-up方式</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//前序、中序、后序遍历好像都不是</span></span><br><span class="line">    <span class="comment">//这里引出一种新的遍历方式</span></span><br><span class="line">    <span class="comment">//先遍历右子树，然后左子树，根节点，有点类似后序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      1</span></span><br><span class="line">    <span class="comment">//     / \</span></span><br><span class="line">    <span class="comment">//    2   5</span></span><br><span class="line">    <span class="comment">//   / \   \</span></span><br><span class="line">    <span class="comment">//  3   4   6</span></span><br><span class="line">    <span class="comment">//比如题目中树采用该种遍历方式的结果为6、5、4、3、2、1相当于结果的逆序，但是如果我们采用前插构建单链表的方式</span></span><br><span class="line">    <span class="comment">//就可以把该结果反转过来，变成1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，这里讲left节点都置为空，就能将树退化为单链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null，prev开始指向null，然后指向6，然后指向5，然后指向4，然后指向3......</span></span><br><span class="line">    <span class="comment">//prev上一次遍历的节点</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">flatten</span>(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//先右子树</span></span><br><span class="line">        <span class="keyword">flatten</span>(root.right);</span><br><span class="line">        <span class="keyword">flatten</span>(root.left);</span><br><span class="line">        </span><br><span class="line">        root.right = prev;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//更新prev的指向</span></span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代的方式，暂时没咋研究，有时间再研究，好像跟Morris traversal有关系。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//迭代的方式</span></span><br><span class="line">    <span class="keyword">public</span> void flatten(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.<span class="keyword">left</span> != null) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> last = cur.<span class="keyword">left</span>;</span><br><span class="line">                <span class="keyword">while</span> (last.<span class="keyword">right</span> != null) last = last.<span class="keyword">right</span>;</span><br><span class="line">                last.<span class="keyword">right</span> = cur.<span class="keyword">right</span>;</span><br><span class="line">                cur.<span class="keyword">right</span> = cur.<span class="keyword">left</span>;</span><br><span class="line">                cur.<span class="keyword">left</span> = null;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.<span class="keyword">right</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlig]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
