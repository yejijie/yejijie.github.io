<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-07-05T12:28:43.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Different Ways to Add Parentheses]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Different-Ways-to-Add-Parentheses/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Different-Ways-to-Add-Parentheses/</id>
    <published>2016-07-05T12:22:15.000Z</published>
    <updated>2016-07-05T12:28:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.</p>
<p><strong> Example 1 </strong></p>
<p>Input: “2-1-1”.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((<span class="number">2</span>-<span class="number">1</span>)-<span class="number">1</span>) = <span class="number">0</span></span><br><span class="line">(<span class="number">2</span>-(<span class="number">1</span>-<span class="number">1</span>)) = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Output: [0, 2]</p>
<p><strong> Example 2 </strong></p>
<p>Input: “2<em>3-4</em>5”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>*(<span class="number">3</span>-(<span class="number">4</span>*<span class="number">5</span>))) = -<span class="number">34</span></span><br><span class="line">((<span class="number">2</span>*<span class="number">3</span>)-(<span class="number">4</span>*<span class="number">5</span>)) = -<span class="number">14</span></span><br><span class="line">((<span class="number">2</span>*(<span class="number">3</span>-<span class="number">4</span>))*<span class="number">5</span>) = -<span class="number">10</span></span><br><span class="line">(<span class="number">2</span>*((<span class="number">3</span>-<span class="number">4</span>)*<span class="number">5</span>)) = -<span class="number">10</span></span><br><span class="line">(((<span class="number">2</span>*<span class="number">3</span>)-<span class="number">4</span>)*<span class="number">5</span>) = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>Output: [-34, -14, -10, -10, 10]</p>
<h2 id="代码">代码</h2><p>这道题跟<a href="http://noobsky.com/2016/05/31/LeetCode-Unique-Binary-Search-Trees/" target="_blank" rel="external">Unique Binary Search Trees II</a>思路类似，都是利用分治的思想，可对照理解</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; diffWaysToCompute(<span class="keyword">String</span> input) &#123;</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || input.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//结果集</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++)&#123;</span><br><span class="line">            <span class="built_in">char</span> ch = input.charAt(i);</span><br><span class="line">            <span class="comment">//字符ch为+、-、*，可以采用分治的方法将input在ch分为左右两部分，递归计算</span></span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'-'</span> || ch == <span class="string">'+'</span> || ch == <span class="string">'*'</span>)&#123;</span><br><span class="line">                List&lt;Integer&gt; leftList = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; rightList = diffWaysToCompute(input.substring(i+<span class="number">1</span>));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> left : leftList)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> right : rightList)&#123;</span><br><span class="line">                        <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'-'</span>: res.<span class="built_in">add</span>(left - right);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'+'</span>: res.<span class="built_in">add</span>(left + right);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'*'</span>: res.<span class="built_in">add</span>(left * right);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数字</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>() == <span class="number">0</span>) res.<span class="built_in">add</span>(Integer.valueOf(input));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string of numbers and operators, return all possible results from computing all the different possible way]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Count Numbers with Unique Digits]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Count-Numbers-with-Unique-Digits/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Count-Numbers-with-Unique-Digits/</id>
    <published>2016-07-05T11:00:11.000Z</published>
    <updated>2016-07-05T11:37:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10<sup>n</sup>.</p>
<p>Example:<br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])</p>
<p><strong> Hint: </strong></p>
<ol>
<li>A direct way is to use the backtracking approach.</li>
<li>Backtracking should contains three states which are (the current number, number of steps to get that number and a bitmask which represent which number is marked as visited so far in the current number). Start with state (0,0,0) and count all valid number till we reach number of steps equals to 10n.</li>
<li>This problem can also be solved using a dynamic programming approach and some knowledge of combinatorics.</li>
<li>Let f(k) = count of numbers with unique digits with length equals k.</li>
<li>f(1) = 10, …, f(k) = 9 <em> 9 </em> 8 * … (9 - k + 2) [The first factor is 9 because a number cannot start with 0].</li>
</ol>
<h2 id="代码">代码</h2><p>给定一非负整数n，计算各位数都不同相同的数字x的个数，0 ≤ x &lt; 10<sup>n</sup></p>
<p>f(k)表示k位数各位数都不相同的数字的个数</p>
<p>f(1) = 10, (0,1,2,3,4,5,6,7,8,9)</p>
<p>f(2) = 9 * 9,第一位处0外都可以，有9种选择，第二位0可以但是不能是第一位的数字，也有9种选择</p>
<p>f(3) = 9 <em> 9 </em> 8 = f(2) * 8, 第三位有8种选择</p>
<p>…</p>
<p>f(10) = 9<em>9</em>8<em>7</em>6<em>…</em>1</p>
<p>f(11) = 0 = f(12) = f(13)</p>
<p>11位数以后肯定会出现重复，f(k) = 0 , k &gt;= 11</p>
<p>题目求0 ≤ x &lt; 10<sup>n</sup>区间满足条件的，所以总数为f(1)+f(2)+f(3)+…+f(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10以后的都没必要算了</span></span><br><span class="line">        n = Math.min(n, <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>, count = <span class="number">9</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            count = count * (<span class="number">9</span>-i+<span class="number">2</span>);</span><br><span class="line">            res += count;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> uniqueDigits = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> availableNumber = <span class="number">9</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用availableNumber &gt; 0来去掉那些多余的计算跟用Math.min(10,n);效果类似</span></span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">1</span> &amp;&amp; availableNumber &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            uniqueDigits = uniqueDigits * availableNumber;</span><br><span class="line">            res += uniqueDigits;</span><br><span class="line">            availableNumber--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10<sup>n</sup>.</p>
<p>E]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]ZigZag Conversion]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-ZigZag-Conversion/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-ZigZag-Conversion/</id>
    <published>2016-07-05T04:00:35.000Z</published>
    <updated>2016-07-05T08:16:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   <span class="keyword">H</span>   <span class="keyword">N</span></span><br><span class="line">A P <span class="keyword">L</span> S I I <span class="keyword">G</span></span><br><span class="line">Y   I   <span class="literal">R</span></span><br></pre></td></tr></table></figure>
<p>And then read line by line: “PAHNAPLSIIGYIR”<br>Write the code that will take a string and make this conversion given a number of rows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> text, <span class="keyword">int</span> nRows)</span></span>;</span><br></pre></td></tr></table></figure>
<p>convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.</p>
<h2 id="代码">代码</h2><p>这道题关键就是找出字符下标变化的规律</p>
<p>rows=2时，字符串下标变成zigzag的走法就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>rows=3时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>     <span class="number">4</span>     <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>     <span class="number">6</span>    <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>rows=4时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>      <span class="number">6</span>        <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>   <span class="number">5</span>  <span class="number">7</span>    <span class="number">11</span>  <span class="number">13</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">4</span>    <span class="number">8</span> <span class="number">10</span>     <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>      <span class="number">9</span>        <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>观察可知，我们第一行和最后一行相邻元素的下标相差为2*rows - 2，比如rows = 3时，第一行字符串下标为0、4、8，相邻元素相差2*rows - 2 = 4，可以验证其他也是符合的。接着我们来看除了第一行和最后一行的规律，其他行除了zigzag斜线上的字符，也是满足这个规律，比如1、3、5、7、9除了斜线上的3和7，1、5、9也是相差4，那么斜线上的字符下标跟前面一个字符相差多少？规律是相差2*rows-2 - 2*i（i是行的index），比如斜线上的3、7比前面的1、5都相差2*rows-2-2*i = 2，可以验证其他字符也是满足这个规律的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span> || numRows &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">            <span class="comment">//字符下标不能超过字符的长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.length(); j += step)&#123;</span><br><span class="line">                res.append(s.charAt(j));</span><br><span class="line">                <span class="comment">//如果不是第一行和最后一行，还要append斜线上字符</span></span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//斜线上的字符跟前一字符下标相差step-2i</span></span><br><span class="line">                    <span class="keyword">int</span> temp = j + step - <span class="number">2</span>*i;</span><br><span class="line">                    <span class="keyword">if</span>(temp &lt; s.length())&#123;</span><br><span class="line">                        res.append(s.charAt(temp));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种更直观更好理解的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//很好理解的一种写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span> || numRows &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//没一行都用一个StringBuilder存</span></span><br><span class="line">        StringBuilder[] sb = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) sb[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">            <span class="comment">//竖直方向遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numRows &amp;&amp; i &lt; len; j++)&#123;</span><br><span class="line">                sb[j].append(c[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//斜线方向遍历，总共有numRows-2个</span></span><br><span class="line">            <span class="comment">//从倒数第二行开始，到第二行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = numRows -<span class="number">2</span>; k &gt;=<span class="number">1</span> &amp;&amp; i &lt; len; k--)&#123;</span><br><span class="line">                sb[k].append(c[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把每一行拼接起来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt; numRows; idx++)&#123;</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[idx]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to d]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Valid Sudoku and Sudoku Solver]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Valid-Sudoku-and-Sudoku-Solver/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Valid-Sudoku-and-Sudoku-Solver/</id>
    <published>2016-07-05T01:44:33.000Z</published>
    <updated>2016-07-05T03:05:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Valid_Sudoku">Valid Sudoku</h2><h3 id="题目描述">题目描述</h3><p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx" target="_blank" rel="external">Sudoku Puzzles - The Rules</a>.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""></p>
<p>A partially filled sudoku which is valid.</p>
<p><strong> Note: </strong><br>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p>
<h3 id="代码">代码</h3><p>注意到题目中说的,只要当前已经填充的数字是合法的就可以,不一定要这个数独是有解.</p>
<p>因此，根据数独的游戏规则，我们只需要判断9<em>9网格中的每一行、每一列、每个小九宫格中某个数字（只能是1到9）是否重复出现了，如果没有就是合法的。比较tricky的一点就是如果九宫格按照行从0开始标号，那么数字board[i][j]位于第i/3\</em>3 + j/3个九宫格内。第 i 个九宫格里面的第 j 个元素在原矩阵的第 3*(i/3) + j/3 行，第 3*(i%3) + j%3）列，“/” 表示整数除法）。最直接的写法就是三个双重for循环，还可以更简洁一点，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == null || board.length != <span class="number">9</span> || board[<span class="number">0</span>].length != <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用于检查每一行</span></span><br><span class="line">        boolean[][] row= <span class="keyword">new</span> boolean[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="comment">//用于检查每一列</span></span><br><span class="line">        boolean[][] col = <span class="keyword">new</span> boolean[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="comment">//用于检查每一个小九宫格</span></span><br><span class="line">        boolean[][] box = <span class="keyword">new</span> boolean[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">//减1是下标从0开始</span></span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//第k个小九宫格</span></span><br><span class="line">                    <span class="keyword">int</span> k = i/<span class="number">3</span>*<span class="number">3</span> + j/<span class="number">3</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(row[i][num] || col[j][num] || box[k][num])&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    row[i][num] = col[j][num] = box[k][num] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sudoku_Solver">Sudoku Solver</h2><h3 id="题目描述-1">题目描述</h3><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>Empty cells are indicated by the character ‘.’.</p>
<p>You may assume that there will be only one unique solution.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""></p>
<p>A sudoku puzzle…</p>
<p><a href="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" target="_blank" rel="external"></a></p>
<p>…and its solution numbers marked in red.</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//思路挺简单的，用回溯法</span></span><br><span class="line">    <span class="comment">//双重for循环遍历每一个元素，如果当前格子的元素为'.'，则尝试放置1-9，如果找到一个有效的数字，递归调用</span></span><br><span class="line">    <span class="comment">//solveSudoku，如果能找到解，返回true，否则，回溯，继续搜索</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == null || board.length != <span class="number">9</span> || board[<span class="number">0</span>].length != <span class="number">9</span>) <span class="keyword">return</span>;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">//尝试1-9看能不能找到解</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> ch = <span class="string">'1'</span>; ch &lt;= <span class="string">'9'</span>; ch++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(isValid(board, i, j, ch))&#123;</span><br><span class="line">                            <span class="comment">//将[i][j]放置ch</span></span><br><span class="line">                            board[i][j] = ch;</span><br><span class="line">                            <span class="keyword">if</span>(solve(board))</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                board[i][j] = <span class="string">'.'</span>;<span class="comment">//回溯</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果该位置1到9都不行，说明无解</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断字符ch能不能放到board[i][j]中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断j列是否出现重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][j] == ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断i行是否出现重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断board[i][j]所属的九宫格是否出现重复</span></span><br><span class="line">        <span class="keyword">int</span> rowStart = i / <span class="number">3</span> * <span class="number">3</span>, colStart = j / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = rowStart; row &lt; rowStart + <span class="number">3</span>; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = colStart; col &lt; colStart + <span class="number">3</span>; col++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[row][col] == ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Valid_Sudoku">Valid Sudoku</h2><h3 id="题目描述">题目描述</h3><p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sum of Two Integers]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Sum-of-Two-Integers/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Sum-of-Two-Integers/</id>
    <published>2016-07-05T01:03:21.000Z</published>
    <updated>2016-07-05T01:04:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:<br>Given a = 1 and b = 2, return 3.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//举个例子：5+17 = 22 </span></span><br><span class="line">    <span class="comment">//0+0 = 0 ,1+1 = 0, 1+0 = 1, 0+1 = 1跟异或相同</span></span><br><span class="line">    <span class="comment">//先不考虑进位：5 + 17 = 101 + 10001 = 10100 = 20</span></span><br><span class="line">    <span class="comment">//再加上进位1+1才有进位1+1 = 10 = (1&amp;1) &lt;&lt; 1</span></span><br><span class="line">    <span class="comment">//在比如11+11的进位：11 + 11 = 110 = (11&amp;11) &lt;&lt; 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(b == 0) &#123;</span></span><br><span class="line">        <span class="comment">//     return a;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// int sum, carry;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sum = a ^ b;</span></span><br><span class="line">        <span class="comment">// carry = (a &amp; b) &lt;&lt; 1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// return getSum(sum, carry);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等价于</span></span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//迭代的形式</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum, carry;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum = a ^ b;</span><br><span class="line">            carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;<span class="keyword">while</span>(b != <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:<br]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Median of Two Sorted Arrays]]></title>
    <link href="http://blog.noobsky.com/2016/07/04/LeetCode-Median-of-Two-Sorted-Arrays/"/>
    <id>http://blog.noobsky.com/2016/07/04/LeetCode-Median-of-Two-Sorted-Arrays/</id>
    <published>2016-07-04T03:48:13.000Z</published>
    <updated>2016-07-04T08:52:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p><strong> Example 1: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">The median is <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p><strong> Example 2: </strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = <span class="comment">[1, 2]</span></span><br><span class="line">nums2 = <span class="comment">[3, 4]</span></span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<h2 id="解题思路">解题思路</h2><p>首先要明白中位数的用途，在统计学中<font color="red"><code>dividing a set into two equal length subsets, that one subset is always greater than the other.</code></font>这就告诉了我们大概的思路。</p>
<p>首先，将数组A在随机位置i上划分成两部分：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      left_A             |        right_A</span><br><span class="line">A<span class="string">[0]</span>, A<span class="string">[1]</span>, ..., A<span class="string">[i-1]</span>  |  A<span class="string">[i]</span>, A<span class="string">[i+1]</span>, ..., A<span class="string">[m-1]</span></span><br></pre></td></tr></table></figure>
<p>数组A有m个元素，所以i的取值有m+1（0~m）种选择来划分数组A，而且len(left_A) = i，len(right_A) = m-i。需要注意的是，如果i=0，则left_A为空；如果i=m，则right_A为空。</p>
<p>同理，我们在随机位置j上将数组B划分为两部分：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      left_B             |        right_B</span><br><span class="line">B<span class="string">[0]</span>, B<span class="string">[1]</span>, ..., B<span class="string">[j-1]</span>  |  B<span class="string">[j]</span>, B<span class="string">[j+1]</span>, ..., B<span class="string">[n-1]</span></span><br></pre></td></tr></table></figure>
<p>我们将left_A和left_B放到一个集合中，right_A和right_B放到另一个集合中，分别为left_part和right_part:</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      left_part          |        right_part</span><br><span class="line">A<span class="string">[0]</span>, A<span class="string">[1]</span>, ..., A<span class="string">[i-1]</span>  |  A<span class="string">[i]</span>, A<span class="string">[i+1]</span>, ..., A<span class="string">[m-1]</span></span><br><span class="line">B<span class="string">[0]</span>, B<span class="string">[1]</span>, ..., B<span class="string">[j-1]</span>  |  B<span class="string">[j]</span>, B<span class="string">[j+1]</span>, ..., B<span class="string">[n-1]</span></span><br></pre></td></tr></table></figure>
<p>所以我们只需要确保：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="function"><span class="title">len</span><span class="params">(left_part)</span></span> == <span class="function"><span class="title">len</span><span class="params">(right_part)</span></span></span><br><span class="line"><span class="number">2</span>) <span class="function"><span class="title">max</span><span class="params">(left_part)</span></span> &lt;= <span class="function"><span class="title">min</span><span class="params">(right_part)</span></span></span><br></pre></td></tr></table></figure></p>
<p>那么我们就能将全部元素划分为相等的两部分（或者相差1），并且一部分中的元素都小于另一部分的元素。那么中位数为<font color="red"><code>median = (max(left_part) + min(right_part))/2</code></font>。</p>
<p>为了确保以上两个条件，我们需要满足：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) i + j == <span class="keyword">m</span> - i + <span class="keyword">n</span> - j (or: <span class="keyword">m</span> - i + <span class="keyword">n</span> - j + 1)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">n</span> &gt;= <span class="keyword">m</span>, we just need to <span class="keyword">set</span>: i = 0 ~ <span class="keyword">m</span>, j = (<span class="keyword">m</span> + <span class="keyword">n</span> + 1)/2 - <span class="literal">i</span></span><br><span class="line">(2) B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]</span><br></pre></td></tr></table></figure>
<p>如果m+n为奇数时，两部分的长度相差1，所以i + j == m - i + n - j (or: m - i + n - j + 1,(m+n为奇数时))。而让n &gt;= m是因为i = 0~m, j=(m+n+1)/2-i，n &gt;= m能确保j不为负数。为了简单，我们这里先假设A[i-1],B[j-1],A[i],B[j] 都是有限的，我们在后面再讨论i=0/i=m/j=0/j=n的边界情况。</p>
<p>所以，我们需要做的是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Searching <span class="tag">i</span> <span class="keyword">in</span> [<span class="number">0</span>, m], to find an <span class="tag">object</span> `i` that:</span><br><span class="line">    B[j-<span class="number">1</span>] &lt;= A[i] and A[i-<span class="number">1</span>] &lt;= B[j], ( where j = (m + n + <span class="number">1</span>)/<span class="number">2</span> - <span class="tag">i</span> )</span><br></pre></td></tr></table></figure>
<p>因为数组是有序的，所以我们可以利用二分搜索来查找，伪代码如下：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">1</span>&gt; Set imin = <span class="number">0</span>, imax = m, then start searching in [imin, imax]</span><br><span class="line"></span><br><span class="line">&lt;<span class="number">2</span>&gt; Set i = (imin + imax)/<span class="number">2</span>, j = (m + n + <span class="number">1</span>)/<span class="number">2</span> - i</span><br><span class="line"></span><br><span class="line">&lt;<span class="number">3</span>&gt; Now we have len(left_part)==len(right_part). <span class="literal">And</span> there are only <span class="number">3</span> situations</span><br><span class="line"><span class="label">     that we may encounter:</span></span><br><span class="line">    &lt;<span class="literal">a</span>&gt; B[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i] <span class="literal">and</span> <span class="literal">A</span>[i-<span class="number">1</span>] &lt;= B[j]</span><br><span class="line">        Means we have found the object <span class="escape">`i</span><span class="escape">`,</span> so stop searching.</span><br><span class="line">    &lt;b&gt; B[j-<span class="number">1</span>] &gt; <span class="literal">A</span>[i]</span><br><span class="line">        Means <span class="literal">A</span>[i] is too small. We must <span class="escape">`a</span>just<span class="escape">` </span>i to get <span class="escape">`B</span>[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i]<span class="escape">`.</span></span><br><span class="line">        Can we <span class="escape">`i</span>ncrease<span class="escape">` </span>i?</span><br><span class="line">            Yes. Because when i is increased, j will be decreased.</span><br><span class="line">            So B[j-<span class="number">1</span>] is decreased <span class="literal">and</span> <span class="literal">A</span>[i] is increased, <span class="literal">and</span> <span class="escape">`B</span>[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i]<span class="escape">` </span>may</span><br><span class="line">            be satisfied.</span><br><span class="line">        Can we <span class="escape">`d</span>ecrease<span class="escape">` </span>i?</span><br><span class="line">            <span class="escape">`N</span>o!<span class="escape">` </span>Because when i is decreased, j will be increased.</span><br><span class="line">            So B[j-<span class="number">1</span>] is increased <span class="literal">and</span> <span class="literal">A</span>[i] is decreased, <span class="literal">and</span> B[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i] will</span><br><span class="line">            be never satisfied.</span><br><span class="line">        So we must <span class="escape">`i</span>ncrease<span class="escape">` </span>i. That is, we must ajust the searching range to</span><br><span class="line">        [i+<span class="number">1</span>, imax]. So, set imin = i+<span class="number">1</span>, <span class="literal">and</span> goto &lt;<span class="number">2</span>&gt;.</span><br><span class="line">    &lt;c&gt; <span class="literal">A</span>[i-<span class="number">1</span>] &gt; B[j]</span><br><span class="line">        Means <span class="literal">A</span>[i-<span class="number">1</span>] is too big. <span class="literal">And</span> we must <span class="escape">`d</span>ecrease<span class="escape">` </span>i to get <span class="escape">`A</span>[i-<span class="number">1</span>]&lt;=B[j]<span class="escape">`.</span></span><br><span class="line">        That is, we must ajust the searching range to [imin, i-<span class="number">1</span>].</span><br><span class="line">        So, set imax = i-<span class="number">1</span>, <span class="literal">and</span> goto &lt;<span class="number">2</span>&gt;.</span><br></pre></td></tr></table></figure>
<p>当我们找到下标i后，那么中位数为：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max<span class="list">(<span class="keyword">A</span>[i-1], B[j-1])</span> <span class="list">(<span class="keyword">when</span> m + n is odd)</span></span><br><span class="line">or <span class="list">(<span class="keyword">max</span><span class="list">(<span class="keyword">A</span>[i-1], B[j-1])</span> + min<span class="list">(<span class="keyword">A</span>[i], B[j])</span>)</span>/2 <span class="list">(<span class="keyword">when</span> m + n is even)</span></span><br></pre></td></tr></table></figure>
<p>下面来处理那些边界情况：i=0,i=m,j=0,j=n ，此时A[i-1],B[j-1],A[i],B[j]并不存在。</p>
<p>我们需要确保max(left_part) &lt;= min(right_part)，如果i和j不是边界值，那么我们需要检查B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]。如果A[i-1],B[j-1],A[i],B[j]有些不存在，那么B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]这两个条件我们可以不检查一个条件（或者两个都不用检查）。比如，如果i=0，那么A[i-1]不存在，则我们不需要检查A[i-1] &lt; B[j]。所以我们需要做的修改为：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Searching i <span class="keyword">in</span> [<span class="number">0</span>, m], <span class="keyword">to</span> find an object `i` <span class="keyword">that</span>:</span><br><span class="line">    (j == <span class="number">0</span> <span class="keyword">or</span> i == m <span class="keyword">or</span> B[j-<span class="number">1</span>] &lt;= A[i]) <span class="keyword">and</span></span><br><span class="line">    (i == <span class="number">0</span> <span class="keyword">or</span> j == n <span class="keyword">or</span> A[i-<span class="number">1</span>] &lt;= B[j])</span><br><span class="line">    <span class="keyword">where</span> j = (m + n + <span class="number">1</span>)/<span class="number">2</span> - i</span><br></pre></td></tr></table></figure>
<p>搜索过程中，我们会遇到以下三种情况：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt; (j == <span class="number">0</span> or <span class="tag">i</span> == m or B[j-<span class="number">1</span>] &lt;= A[i]) and</span><br><span class="line">    (<span class="tag">i</span> == <span class="number">0</span> or j = n or A[i-<span class="number">1</span>] &lt;= B[j])</span><br><span class="line">    Means <span class="tag">i</span> is perfect, we can stop searching.</span><br><span class="line"></span><br><span class="line">&lt;b&gt; j &gt; <span class="number">0</span> and <span class="tag">i</span> &lt; m and B[j - <span class="number">1</span>] &gt; A[i]</span><br><span class="line">    Means <span class="tag">i</span> is too small, we must increase it.</span><br><span class="line"></span><br><span class="line">&lt;c&gt; <span class="tag">i</span> &gt; <span class="number">0</span> and j &lt; n and A[<span class="tag">i</span> - <span class="number">1</span>] &gt; B[j]</span><br><span class="line">    Means <span class="tag">i</span> is too big, we must decrease it.</span><br></pre></td></tr></table></figure>
<p>所以代码如下(python)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    m, n = len(A), len(B)</span><br><span class="line">    <span class="keyword">if</span> m &gt; n:</span><br><span class="line">        A, B, m, n = B, A, n, m</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line">    imin, imax, half_len = <span class="number">0</span>, m, (m + n + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> imin &lt;= imax:</span><br><span class="line">        i = (imin + imax) / <span class="number">2</span></span><br><span class="line">        j = half_len - i</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; m <span class="keyword">and</span> B[j-<span class="number">1</span>] &gt; A[i]:</span><br><span class="line">            <span class="comment"># i is too small, must increase it</span></span><br><span class="line">            imin = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &lt; n <span class="keyword">and</span> A[i-<span class="number">1</span>] &gt; B[j]:</span><br><span class="line">            <span class="comment"># i is too big, must decrease it</span></span><br><span class="line">            imax = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># i is perfect</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: max_of_left = B[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>: max_of_left = A[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>: max_of_left = max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> max_of_left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == m: min_of_right = B[j]</span><br><span class="line">            <span class="keyword">elif</span> j == n: min_of_right = A[i]</span><br><span class="line">            <span class="keyword">else</span>: min_of_right = min(A[i], B[j])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (max_of_left + min_of_right) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>修改为Java版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(nums1 == null || nums2 == null) return 0.0;</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m &gt; n) <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = m;</span><br><span class="line">        <span class="comment">//j = (m+n+1)/2 - i前面一部分是固定，可以先算，不用再while中重复计算</span></span><br><span class="line">        <span class="keyword">int</span> halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> maxOfLeft;</span><br><span class="line">        <span class="keyword">int</span> minOfRight;</span><br><span class="line">        <span class="comment">//在[0,m]中二分搜索</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            i = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            j = halfLen - i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; nums2[j-<span class="number">1</span>] &gt; nums1[i])&#123;</span><br><span class="line">                left = i+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; nums1[i-<span class="number">1</span>] &gt; nums2[j])&#123;</span><br><span class="line">                right = i-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) maxOfLeft = nums2[j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) maxOfLeft = nums1[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> maxOfLeft = Math.max(nums1[i-<span class="number">1</span>], nums2[j-<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//m+n为奇数</span></span><br><span class="line">                <span class="keyword">if</span>((m + n) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> maxOfLeft;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i == m) minOfRight = nums2[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == n) minOfRight = nums1[i];</span><br><span class="line">                <span class="keyword">else</span> minOfRight = Math.min(nums1[i], nums2[j]);</span><br><span class="line">                <span class="keyword">return</span> (maxOfLeft + minOfRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Interleaving String]]></title>
    <link href="http://blog.noobsky.com/2016/07/03/LeetCode-Interleaving-String/"/>
    <id>http://blog.noobsky.com/2016/07/03/LeetCode-Interleaving-String/</id>
    <published>2016-07-03T01:54:30.000Z</published>
    <updated>2016-07-04T09:03:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Given:<br>s1 = “aabcc”,<br>s2 = “dbbca”,</p>
<p>When s3 = “aadbbcbcac”, return true.<br>When s3 = “aadbbbaccc”, return false.</p>
<h2 id="代码">代码</h2><p>dp[i][j]表示s1[0…i-1]和s2[0…j-1]能表示s3[0…i+j-1]，即s1的前i个字符和s2的前j个字符能按规则表示s3的前i+j个字符。则：</p>
<p>dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1] 或者 dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]</p>
<p>结果为：</p>
<p>dp[s1.length()][s2.length()]</p>
<p>边界情况：</p>
<p>i=0,j=0:dp[i][j] = true，表示s1、s2、s3都未空字符串<br>i=0 dp[i][j] = dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]<br>j=0 dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s1.length() + s2.length() != s3.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        boolean[][] dp = <span class="keyword">new</span> boolean[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//注意循环条件可以等于</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s2.length(); j++)&#123;</span><br><span class="line">                <span class="comment">//都为空字符串</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//s1为空字符串</span></span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] &amp;&amp; s2.charAt(j-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//s2为空字符</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] &amp;&amp; s1.charAt(i-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//有两种情况s3[i+j-1]取自s1[i-1]或者取自s2[j-1]</span></span><br><span class="line">                    dp[i][j] = (dp[i][j-<span class="number">1</span>] &amp;&amp; s2.charAt(j-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>)) || (dp[i-<span class="number">1</span>][j] &amp;&amp; s1.charAt(i-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Given:<br>s1 ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Merge k Sorted Lists]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-Merge-k-Sorted-Lists/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-Merge-k-Sorted-Lists/</id>
    <published>2016-07-02T13:40:00.000Z</published>
    <updated>2016-07-04T08:58:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<h2 id="代码">代码</h2><ul>
<li>利用优先级队列</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	 <span class="comment">//使用优先级队列存k个sorted lists的节点</span></span><br><span class="line">    <span class="comment">//队列大小初始化为k，初始化时从每个Sorted lists中放入一个节点到优先级队列中，找出最小值</span></span><br><span class="line">    <span class="comment">//然后加入最小值ListNode.next的节点</span></span><br><span class="line">    <span class="keyword">public</span> ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> compare(ListNode l1, ListNode l2)&#123;</span><br><span class="line">                <span class="comment">//按val的自然序排序</span></span><br><span class="line">                <span class="comment">//return l1.val - l2.val;</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(l1.val, l2.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(ListNode node : lists)&#123;</span><br><span class="line">            <span class="comment">//注意判空</span></span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.offer(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            curr.<span class="keyword">next</span> = pq.poll();</span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            <span class="comment">//出队列的节点有next节点，加入队列中</span></span><br><span class="line">            <span class="keyword">if</span>(curr.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.offer(curr.<span class="keyword">next</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlgk)</p>
<ul>
<li>利用Merge Two Sorted Lists</li>
</ul>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">	    //使用merge two Sorted List的方法</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode merge(ListNode l1, ListNode l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l1;</span><br><span class="line">                l1 = l1.<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l2;</span><br><span class="line">                l2 = l2.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curr.<span class="keyword">next</span> = l1 != <span class="literal">null</span> ? l1 : l2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode mergeKListsHelper(ListNode[] lists, int start, int <span class="keyword">end</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="keyword">end</span>) <span class="keyword">return</span> lists[start];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start &gt; <span class="keyword">end</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        int mid = start + (<span class="keyword">end</span> - start)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode l1 = mergeKListsHelper(lists, start, mid);</span><br><span class="line">        ListNode l2 = mergeKListsHelper(lists, mid+<span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">        //<span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeKListsHelper(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlgk)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the no]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Maximum Path Sum]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-Binary-Tree-Maximum-Path-Sum/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-Binary-Tree-Maximum-Path-Sum/</id>
    <published>2016-07-02T09:45:09.000Z</published>
    <updated>2016-07-04T08:57:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root.</p>
<p>For example:<br>Given the below binary tree,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Return 6.</p>
<h2 id="代码">代码</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree <span class="keyword">node</span>.<span class="identifier"></span><br><span class="line"> </span><span class="title">* public</span> class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//<span class="number">1</span>. <span class="keyword">Node</span><span class="identifier"> </span><span class="title">only</span></span><br><span class="line">//<span class="number">2</span>. L-sub + <span class="keyword">Node</span><span class="identifier"></span><br><span class="line"></span><span class="title">//3</span>. R-sub + <span class="keyword">Node</span><span class="identifier"></span><br><span class="line"></span><span class="title">//4</span>. L-sub + <span class="keyword">Node</span><span class="identifier"> </span><span class="title">+ R-sub</span></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    //Java中pass by value，不像C++的引用或者指针</span><br><span class="line">    //解决办法是用全局变量、数组、包装类，这里用全局变量</span><br><span class="line">    int max = Integer.MIN_VALUE;</span><br><span class="line">    //因为存在负数，所以最大值不一定是roog+l-sub+r-sub</span><br><span class="line">    public int maxPathSum(TreeNode root) &#123;</span><br><span class="line">        maxPathDown(root);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //该函数计算路径最高节点为<span class="keyword">node</span><span class="identifier"></span><span class="title">的最大路径和(返回值)，并更新全局最大值</span><br><span class="line">    //returns</span> the maximum sum of the path that can be extended to input <span class="keyword">node</span><span class="identifier"></span><span class="title">'s</span> parent.</span><br><span class="line">    //返回能扩展输入节点（<span class="keyword">node</span><span class="identifier"></span><span class="title">）的父节点的路径的最大和</span><br><span class="line">    //能扩展输入节点node</span>的父节点的路径只有三种情况：</span><br><span class="line">    //<span class="number">1</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">only</span></span><br><span class="line">    //<span class="number">2</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">+ l-sub</span></span><br><span class="line">    //<span class="number">3</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">+ r-sub</span></span><br><span class="line">    //而<span class="keyword">node</span><span class="identifier"></span><span class="title">+l-sub</span>+r-sub是不能扩展<span class="keyword">node</span><span class="identifier"></span><span class="title">的父节点的</span><br><span class="line">    // private</span> int maxPathDown(TreeNode <span class="keyword">node</span><span class="identifier"></span><span class="title">)&#123;</span><br><span class="line">    //     if</span>(<span class="keyword">node</span><span class="identifier"> </span><span class="title">== null</span>) return <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    //     int left = maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>);</span><br><span class="line">    //     int right = maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>);</span><br><span class="line">        </span><br><span class="line">    //     //表示通过<span class="keyword">node</span><span class="identifier"></span><span class="title">节点能到达node</span>的parent节点的最大和，作为返回值返回给父节点的函数调用</span><br><span class="line">    //     //因为更新全局最大值也要用到所以先用局部变量存起来，不用重复计算</span><br><span class="line">    //     int maxPathAcrossNodeToParent = Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    //     //更新全局最大值</span><br><span class="line">    //     max = Math.max(max, Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right, maxPathAcrossNodeToParent));</span><br><span class="line">    //     //return Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    //     return maxPathAcrossNodeToParent;</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    //其实maxPathDown的可以优化如下：</span><br><span class="line">    private int maxPathDown(TreeNode <span class="keyword">node</span><span class="identifier"></span><span class="title">)&#123;</span><br><span class="line">        if</span>(<span class="keyword">node</span><span class="identifier"> </span><span class="title">== null</span>) return <span class="number">0</span>;</span><br><span class="line">        //节点存在负数，如果为负数则对路径最大和没有任何帮助，抛弃即可</span><br><span class="line">        //left或right至少大于<span class="number">0</span>才对max有帮助</span><br><span class="line">        //这样处理后更新全局最大值时用max跟<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right比较即可</span><br><span class="line">        //<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right代表了<span class="keyword">node</span><span class="identifier"></span><span class="title">、node</span>+l-sub、<span class="keyword">node</span><span class="identifier"></span><span class="title">+r-sub</span>、<span class="keyword">node</span><span class="identifier"></span><span class="title">+l-sub</span>+r-sub最大值</span><br><span class="line">        int left = Math.max(<span class="number">0</span>,maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>));</span><br><span class="line">        int right = Math.max(<span class="number">0</span>, maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>));</span><br><span class="line">        </span><br><span class="line">        max = Math.max(max, <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right);</span><br><span class="line">        </span><br><span class="line">        return Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.geeksforgeeks.org/find-maximum-path-sum-in-a-binary-tree/" target="_blank" rel="external">Maximum Path Sum in a Binary Tree</a><br><a href="http://blog.csdn.net/fightforyourdream/article/details/16894069" target="_blank" rel="external"> Binary Tree Maximum Path Sum 二叉树最大路径和 @LeetCode</a><br><a href="https://leetcode.com/discuss/14190/accepted-short-solution-in-java" target="_blank" rel="external">Accepted short solution in Java</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of node]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]First Missing Positive]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-First-Missing-Positive/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-First-Missing-Positive/</id>
    <published>2016-07-02T05:22:11.000Z</published>
    <updated>2016-07-02T09:45:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br>Given [1,2,0] return 3,<br>and [3,4,-1,1] return 2.</p>
<p>Your algorithm should run in O(n) time and uses constant space.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//注意0不是正数,找出第一个缺失的正数</span></span><br><span class="line">    <span class="comment">//所以把1放到下标0的位置，2放到下标1，3放到下标2，。。。。。。</span></span><br><span class="line">    <span class="comment">//即把nums[i]放到nums[nums[i] - 1]的位置</span></span><br><span class="line">    <span class="comment">//然后从前往后遍历找出第一个缺失的正数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//注意交换过来的可能是一个正数，也不在其正确的位置上，所以我们需要用while而不是if</span></span><br><span class="line">            <span class="comment">//用while直到交换过来是负数或者大于nums.length的数</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums.length &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如[1,2,3]缺4</span></span><br><span class="line">        <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br>Given [1,2,0] ret]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Duplicate Letters]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-Remove-Duplicate-Letters/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-Remove-Duplicate-Letters/</id>
    <published>2016-07-02T03:46:27.000Z</published>
    <updated>2016-07-02T03:53:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p>Example:<br>Given “bcabc”<br>Return “abc”</p>
<p>Given “cbacdcbc”<br>Return “acdb”</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//时间复杂度为O(kn)，k为唯一字符的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)  count[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="comment">//题目要求字典序最小，如何贪心选择s[pos]</span></span><br><span class="line">        <span class="comment">//选择左边最小的字符，并且保证s[i...length]包含所有唯一的字符，</span></span><br><span class="line">        <span class="comment">//break条件是遇到词频最小的字符</span></span><br><span class="line">        <span class="comment">//贪心选择：假设词频最小的字符为s[i],那么贪心选择s[0...i]中最小的字符</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &lt; s.charAt(pos)) pos = i;</span><br><span class="line">            <span class="comment">//找到唯一字符或者词频最小的字符，循环终止</span></span><br><span class="line">            <span class="keyword">if</span>(--count[s.charAt(i) - <span class="string">'a'</span>] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//贪心选择后s.charAt(pos),如何构造新字符串</span></span><br><span class="line">        <span class="comment">//抛弃s[pos]左边的字符，移除s[pos+1...length]中为s[pos]的字符</span></span><br><span class="line">        <span class="keyword">return</span> s.length() == <span class="number">0</span> ? <span class="string">""</span> : s.charAt(pos) + removeDuplicateLetters(s.substring(pos+<span class="number">1</span>).replaceAll(<span class="string">""</span>+s.charAt(pos), <span class="string">""</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用栈</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//时间复杂度为O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) freq[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录字符是否在栈中</span></span><br><span class="line">        boolean[] visited = <span class="keyword">new</span> boolean[<span class="number">26</span>];</span><br><span class="line">        Stack&lt;Character&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            </span><br><span class="line">            freq[ch - <span class="string">'a'</span>]--;</span><br><span class="line">            <span class="comment">//已在栈中</span></span><br><span class="line">            <span class="keyword">if</span>(visited[ch-<span class="string">'a'</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//栈顶字符字符比当前字符大而且后面还有该字符，弹栈</span></span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty() &amp;&amp; <span class="built_in">stack</span>.peek() &gt; ch &amp;&amp; freq[<span class="built_in">stack</span>.peek() - <span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//弹栈并且设置为不在栈中false</span></span><br><span class="line">                visited[<span class="built_in">stack</span>.pop() - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="built_in">stack</span>.push(ch);</span><br><span class="line">            visited[ch - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//这样遍历栈相当于把栈逆过来：），意外发现</span></span><br><span class="line">        <span class="comment">// for(char ch : stack)&#123;</span></span><br><span class="line">        <span class="comment">//     sb.append(ch);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//return sb.toString();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty())&#123;</span><br><span class="line">            sb.append(<span class="built_in">stack</span>.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once an]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Copy List with Random Pointer]]></title>
    <link href="http://blog.noobsky.com/2016/07/01/LeetCode-Copy-List-with-Random-Pointer/"/>
    <id>http://blog.noobsky.com/2016/07/01/LeetCode-Copy-List-with-Random-Pointer/</id>
    <published>2016-07-01T12:34:32.000Z</published>
    <updated>2016-07-01T14:21:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<h2 id="代码">代码</h2><p>最简单的思路就是用HashMap存取node节点，第一遍将node存到HashMap中，第二遍遍历为每个节点的next和random赋值。时间复杂度为O(n)，空间复杂度为O(n)。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list with a random pointer.</span><br><span class="line"> * class RandomListNode &#123;</span><br><span class="line"> *     int label;</span><br><span class="line"> *     RandomListNode next, random;</span><br><span class="line"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    //使用HashMap，遍历两遍</span><br><span class="line">    //第一遍把所以节点加入到HashMap中</span><br><span class="line">    //第二遍给map中节点的next和random赋值</span><br><span class="line">    public RandomListNode copyRandomList(RandomListNode head) &#123;</span><br><span class="line">        if(head == null) return head;</span><br><span class="line">        </span><br><span class="line">        Map<span class="tag">&lt;RandomListNode, RandomListNode&gt;</span> map = new HashMap<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        </span><br><span class="line">        RandomListNode <span class="keyword">node</span><span class="identifier"> </span><span class="title">= head</span>;</span><br><span class="line">        while(<span class="keyword">node</span><span class="identifier"> </span><span class="title">!= null</span>)&#123;</span><br><span class="line">            map.put(<span class="keyword">node</span><span class="identifier"></span><span class="title">, new</span> RandomListNode(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">label</span>));</span><br><span class="line">            <span class="keyword">node</span><span class="identifier"> </span><span class="title">= node</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">node</span><span class="identifier"> </span><span class="title">= head</span>;</span><br><span class="line">        //为每个节点赋值next和random的指向</span><br><span class="line">        while(<span class="keyword">node</span><span class="identifier"> </span><span class="title">!= null</span>)&#123;</span><br><span class="line">            map.get(<span class="keyword">node</span><span class="identifier"></span><span class="title">).next</span> = map.get(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">next</span>);</span><br><span class="line">            map.get(<span class="keyword">node</span><span class="identifier"></span><span class="title">).random</span> = map.get(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">random</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">node</span><span class="identifier"> </span><span class="title">= node</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方法，包括三步：</p>
<ul>
<li><p>为每个原始节点复制一个副本节点，链接到原始节点之后</p>
</li>
<li><p>将每个原始节点的random指针赋值给副本节点的random指针，curr.next.random = curr.random.next;</p>
</li>
<li><p>将链表划分为两部分，一个为原始链表，一个为复制链表</p>
</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">public</span> RandomListNode copyRandomList(RandomListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        RandomListNode curr = head;</span><br><span class="line">        <span class="comment">//为每个节点复制一份副本链接到原始节点的后面</span></span><br><span class="line">        <span class="comment">//如A-&gt;B-&gt;C变为A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode <span class="keyword">copy</span> = <span class="keyword">new</span> RandomListNode(curr.label);</span><br><span class="line">            <span class="keyword">copy</span>.<span class="keyword">next</span> = curr.<span class="keyword">next</span>;</span><br><span class="line">            curr.<span class="keyword">next</span> = <span class="keyword">copy</span>;</span><br><span class="line">            </span><br><span class="line">            curr = <span class="keyword">copy</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="comment">//第二次遍历，将每个原始节点的random指针赋值给副本的random指针</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">                curr.<span class="keyword">next</span>.random = curr.random.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将链表分成两个，一个还原为原链表，一个就是复制的链表</span></span><br><span class="line">        curr = head;</span><br><span class="line">        RandomListNode newHead = head.<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">// while(curr != null &amp;&amp; curr.next != null)&#123;</span></span><br><span class="line">        <span class="comment">//     //这种写法比较tricky</span></span><br><span class="line">        <span class="comment">//     //写链接原始节点，接着副本节点，然后又原始节点，又副本节点。。。。</span></span><br><span class="line">        <span class="comment">//     RandomListNode temp = curr.next;</span></span><br><span class="line">        <span class="comment">//     curr.next = temp.next;</span></span><br><span class="line">        <span class="comment">//     curr = temp;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//复制节点</span></span><br><span class="line">            RandomListNode <span class="keyword">copy</span> = curr.<span class="keyword">next</span>;</span><br><span class="line">            </span><br><span class="line">            curr.<span class="keyword">next</span> = <span class="keyword">copy</span>.<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">copy</span>.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">copy</span>.<span class="keyword">next</span> = <span class="keyword">copy</span>.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Merge Intervals and Insert Interval]]></title>
    <link href="http://blog.noobsky.com/2016/07/01/LeetCode-Merge-Intervals-and-Insert-Interval/"/>
    <id>http://blog.noobsky.com/2016/07/01/LeetCode-Merge-Intervals-and-Insert-Interval/</id>
    <published>2016-07-01T07:03:24.000Z</published>
    <updated>2016-07-01T07:38:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Merge_Intervals">Merge Intervals</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,<br>Given [1,3],[2,6],[8,10],[15,18],<br>return [1,6],[8,10],[15,18].</p>
<h3 id="代码">代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for an interval.</span><br><span class="line"> * public class Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() &#123; start = 0; end = 0; &#125;</span><br><span class="line"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">//我们按interval的start升序来排序，然后将interval的end和下一个interval的start比较，看是否出现了overlap</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        </span><br><span class="line">        Collections.<span class="built_in">sort</span>(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> compare(Interval i1, Interval i2)&#123;</span><br><span class="line">                <span class="comment">//按start的升序排序，可以直接利用Integer的compare函数</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(i1.start, i2.start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> start = intervals.<span class="built_in">get</span>(<span class="number">0</span>).start;</span><br><span class="line">        <span class="comment">//上一interval的end</span></span><br><span class="line">        <span class="built_in">int</span> end = intervals.<span class="built_in">get</span>(<span class="number">0</span>).end;</span><br><span class="line">        <span class="keyword">for</span>(Interval interval : intervals)&#123;</span><br><span class="line">            <span class="comment">//当前interval的start小于上一个interval的end，说明出现overlap</span></span><br><span class="line">            <span class="keyword">if</span>(interval.start &lt;= end)&#123;</span><br><span class="line">                <span class="comment">//则end为上一个interval和当前interval的end的较大值</span></span><br><span class="line">                end = Math.<span class="built_in">max</span>(interval.end, end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">add</span>(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入最后一个Interval</span></span><br><span class="line">        res.<span class="built_in">add</span>(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Insert_Interval">Insert Interval</h2><h3 id="题目描述-1">题目描述</h3><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were <font color="red">initially sorted</font> according to their start times.</p>
<p>Example 1:<br>Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>
<p>Example 2:<br>Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].</p>
<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>
<h3 id="代码-1">代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先将那些与newInterval没有overlap的interval放入结果集中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).end &lt; newInterval.start)&#123;</span><br><span class="line">            res.<span class="built_in">add</span>(intervals.<span class="built_in">get</span>(i));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合并所有overlapping的intervals,赋值为newInterval</span></span><br><span class="line">        <span class="comment">//如果intervals.get(i).start &gt; newInterval.end说明已经没有Overlapping</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).start &lt;= newInterval.end)&#123;</span><br><span class="line">            newInterval = <span class="keyword">new</span> Interval(Math.<span class="built_in">min</span>(newInterval.start, intervals.<span class="built_in">get</span>(i).start), Math.<span class="built_in">max</span>(newInterval.end, intervals.<span class="built_in">get</span>(i).end));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将合并结果加入结果中</span></span><br><span class="line">        res.<span class="built_in">add</span>(newInterval);</span><br><span class="line">        <span class="comment">//将剩下的元素加入结果中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">add</span>(intervals.<span class="built_in">get</span>(i));</span><br><span class="line">            i++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实可以直接在原始的List上操作：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	<span class="comment">//在原始的List中直接操作</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//没有overlapping的直接跳过</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).end &lt; newInterval.start)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并具有overlapping的intervals</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals.<span class="built_in">get</span>(i).start &lt;= newInterval.end)&#123;</span><br><span class="line">            newInterval = <span class="keyword">new</span> Interval(Math.<span class="built_in">min</span>(newInterval.start, intervals.<span class="built_in">get</span>(i).start), Math.<span class="built_in">max</span>(newInterval.end, intervals.<span class="built_in">get</span>(i).end));</span><br><span class="line">            <span class="comment">//移除下标为i的元素</span></span><br><span class="line">            intervals.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.<span class="built_in">add</span>(i, newInterval);</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Merge_Intervals">Merge Intervals</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of intervals, merge all overlapping intervals.</p>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Burst Balloons]]></title>
    <link href="http://blog.noobsky.com/2016/07/01/LeetCode-Burst-Balloons/"/>
    <id>http://blog.noobsky.com/2016/07/01/LeetCode-Burst-Balloons/</id>
    <published>2016-07-01T01:38:48.000Z</published>
    <updated>2016-07-01T04:23:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.</p>
<p>Find the maximum coins you can collect by bursting the balloons wisely.</p>
<p><strong> Note: </strong><br>(1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</p>
<p><strong> Example: </strong></p>
<p>Given [3, 1, 5, 8]</p>
<p>Return 167</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>] --&gt; [<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>] --&gt;   [<span class="number">3</span>,<span class="number">8</span>]   --&gt;  [<span class="number">8</span>]  --&gt; []</span><br><span class="line">coins =  <span class="number">3</span>*<span class="number">1</span>*<span class="number">5</span>      +  <span class="number">3</span>*<span class="number">5</span>*<span class="number">8</span>    +  <span class="number">1</span>*<span class="number">3</span>*<span class="number">8</span>      + <span class="number">1</span>*<span class="number">8</span>*<span class="number">1</span>   = <span class="number">167</span></span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2><p>最自然的方法就是打掉一个气球然后将原问题划分成了两个子问题，分别为打掉气球的左边和右边的气球，但是它们相邻接，会对maxCoins造成影响。我们可以逆向思考，我们不是通过第一个打掉的气球来划分原问题，而是通过最后一个打掉的气球来划分。前者获得的分数为<code>nums[i-1]*nums[i]*nums[i+1]</code>，后者为<code>nums[-1]*nums[i]*nums[n]</code>。</p>
<p>dp[i][j]表示打破区间[i,j]中所有气球能得到的分数(coins)。<br>如果最后一个打破的气球为k，则可以获得的分数为：nums[i-1]*nums[k]*nums[j+1]。则状态转移方程为：<br>dp[i][j] = max(dp[i][j], nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j]), i &lt;= k &lt;= j<br>为了方便代码的书写，在数组的两端插入两个1，即nums[-1] = 1，nums[n] = 1</p>
<p>还可以将所有为0的气球先打破，因为它们不能带来任何分数，当然不做这个也是可以的。</p>
<ul>
<li>Divide And Conquer with Memoization</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] eNums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           eNums[i+<span class="number">1</span>] = nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        eNums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        eNums[nums.length + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>][nums.length + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> burst(eNums, dp, <span class="number">1</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带备忘的递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">burst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[][] dp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[left][right] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[left][right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i为最后打破的气球</span></span><br><span class="line">        <span class="comment">//dp[i][j] = max(dp[i][j], nums[i-1]*nums[k]*nums[j+1] + dp[i][k-1] + dp[k+1][j]), i &lt;= k &lt;= j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            res = Math.max(res, nums[left-<span class="number">1</span>]*nums[i]*nums[right+<span class="number">1</span>] + burst(nums, dp, left, i-<span class="number">1</span>) + burst(nums, dp, i+<span class="number">1</span>, right));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[left][right] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>DP</li>
</ul>
<p>直接dp的话，类似最优二叉搜索树，见算法导论，可对比理解<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//直接dp的话，类似最优二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] eNums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           eNums[i+<span class="number">1</span>] = nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        eNums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        eNums[nums.length + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">2</span>][nums.length + <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先求长度为1、2、3.。。。n的区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= nums.length; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">1</span>; left &lt;= nums.length - len + <span class="number">1</span>; left++)&#123;</span><br><span class="line">                <span class="keyword">int</span> right = left + len - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//注意用扩展后的eNums数组</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = left; k &lt;= right; k++)&#123;</span><br><span class="line">                    dp[left][right] = Math.max(dp[left][right], eNums[left-<span class="number">1</span>]*eNums[k]*eNums[right+<span class="number">1</span>]+dp[left][k-<span class="number">1</span>] + dp[k+<span class="number">1</span>][right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][nums.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考">参考</h2><p><strong> Better idea </strong></p>
<p>We then think can we apply the divide and conquer technique? After all there seems to be many self similar sub problems from the previous analysis.</p>
<p>Well, the nature way to divide the problem is burst one balloon and separate the balloons into 2 sub sections one on the left and one one the right. However, in this problem the left and right become adjacent and have effects on the maxCoins in the future.</p>
<p>Then another interesting idea come up. Which is quite often seen in dp problem analysis. That is reverse thinking. Like I said the coins you get for a balloon does not depend on the balloons already burst. Therefore instead of divide the problem by the first balloon to burst, we divide the problem by the last balloon to burst.</p>
<p>Why is that? Because only the first and last balloons we are sure of their adjacent balloons before hand!</p>
<p>For the first we have nums[i-1]<em>nums[i]</em>nums[i+1] for the last we have nums[-1]<em>nums[i]</em>nums[n].</p>
<p>OK. Think about n balloons if i is the last one to burst, what now?</p>
<p>We can see that the balloons is again separated into 2 sections. But this time since the balloon i is the last balloon of all to burst, the left and right section now has well defined boundary and do not affect each other! Therefore we can do either recursive method with memoization or dp.</p>
<p>Final</p>
<p>Here comes the final solutions. Note that we put 2 balloons with 1 as boundaries and also burst all the zero balloons in the first round since they won’t give any coins. The algorithm runs in O(n^3) which can be easily seen from the 3 loops in dp solution.</p>
<p>详见<a href="https://leetcode.com/discuss/72216/share-some-analysis-and-explanations" target="_blank" rel="external">Share some analysis and explanations</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. Yo]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Intersection of Two Arrays I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Intersection-of-Two-Arrays-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Intersection-of-Two-Arrays-I-II/</id>
    <published>2016-06-26T07:10:50.000Z</published>
    <updated>2016-07-01T01:40:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Intersection_of_Two_Arrays_I">Intersection of Two Arrays I</h2><h3 id="题目描述">题目描述</h3><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong> Example: </strong><br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>
<p><strong> Note: </strong></p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
<h3 id="代码">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	 <span class="comment">//使用HashSet，分别遍历两个数组</span></span><br><span class="line">    <span class="comment">//首先把第一个数组加入到集合中</span></span><br><span class="line">    <span class="comment">//然后遍历第二个数组时判断集合中是否包含元素</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(n)，空间复杂度为O(n)</span></span><br><span class="line">    public <span class="built_in">int</span>[] intersection(<span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; <span class="literal">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//利用集合对交集进行去重</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; intersect = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num1: nums1)&#123;</span><br><span class="line">            <span class="literal">set</span>.add(num1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num2: nums2)&#123;</span><br><span class="line">            <span class="comment">//nums1中包含</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">set</span>.contains(num2))&#123;</span><br><span class="line">                intersect.add(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[intersect.size()];</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer <span class="built_in">num</span> : intersect)&#123;</span><br><span class="line">            res[i++] = <span class="built_in">num</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//另外还可以先排序然后使用tow pointers，类似merge array，时间复杂度为O(n)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">set</span>.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">set</span>.size()];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : <span class="built_in">set</span>)&#123;</span><br><span class="line">            res[k++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或者对一个数组排序，然后使用二分搜索在排序数组中搜索另一个数组的元素</span></span><br><span class="line">    <span class="comment">//时间复杂度都为O(nlgn)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Intersection_of_Two_Arrays_II">Intersection of Two Arrays II</h2><h3 id="题目描述-1">题目描述</h3><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong> Example: </strong><br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>
<p><strong> Note: </strong></p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p><strong> Follow up: </strong></p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<h3 id="代码-1">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Solution</span>&#123;</span><br><span class="line">	    //使用<span class="type">HashMap</span>，key为nums1中的元素，value为该元素出现的次数</span><br><span class="line">    //时间复杂度为O(n)，空间复杂度为O(n)</span><br><span class="line">    public <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> new <span class="type">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">Integer</span>, <span class="type">Integer</span>&gt; map = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; <span class="literal">result</span> = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num1 : nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num1))&#123;</span><br><span class="line">                map.put(num1, map.get(num1) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num1, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num2: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num2) &amp;&amp; map.get(num2) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="literal">result</span>.add(num2);</span><br><span class="line">                map.put(num2, map.get(num2) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] res = new <span class="type">int</span>[<span class="literal">result</span>.size()];</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Integer</span> num: <span class="literal">result</span>)&#123;</span><br><span class="line">            res[i++] = num;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Solution</span>&#123;</span><br><span class="line">	    //时间复杂度为O(nlgn)， 空间复杂度为O(n)</span><br><span class="line">    public <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == null || nums2 == null || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> new <span class="type">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">Arrays</span>.sort(nums1);</span><br><span class="line">        <span class="type">Arrays</span>.sort(nums2);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; <span class="literal">result</span> = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="literal">result</span>.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] res = new <span class="type">int</span>[<span class="literal">result</span>.size()];</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Integer</span> num : <span class="literal">result</span>)&#123;</span><br><span class="line">            res[k++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution_to_3rd_follow-up_question">Solution to 3rd follow-up question</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What <span class="keyword">if</span> elements <span class="keyword">of</span> nums2 are stored <span class="function_start"><span class="keyword">on</span></span> disk, <span class="keyword">and</span> <span class="keyword">the</span> memory <span class="keyword">is</span> limited such <span class="keyword">that</span> you cannot load all elements <span class="keyword">into</span> <span class="keyword">the</span> memory <span class="keyword">at</span> once?</span><br></pre></td></tr></table></figure>
<ul>
<li><p>If only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</p>
</li>
<li><p>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), then read 2 elements from each array at a time in memory, record intersections.</p>
</li>
</ul>
<p>Thanks for the solution. I think the second part of the solution is impractical, if you read 2 elements at a time, this procedure will take forever. In principle, we want minimize the number of disk access during the run-time.</p>
<p>An improvement can be sort them using external sort, read (let’s say) 2G of each into memory and then using the 2 pointer technique, then read 2G more from the array that has been exhausted. Repeat this until no more data to read from disk.</p>
<p>But I am not sure this solution is good enough for an interview setting. Maybe the interviewer is expecting some solution using Map-Reduce paradigm.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Intersection_of_Two_Arrays_I">Intersection of Two Arrays I</h2><h3 id="题目描述">题目描述</h3><p>Given two arrays, write a function to compu]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Count of Smaller Numbers After Self and Count of Range Sum]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Count-of-Smaller-Numbers-After-Self-and-Count-of-Range-Sum/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Count-of-Smaller-Numbers-After-Self-and-Count-of-Range-Sum/</id>
    <published>2016-06-26T04:03:35.000Z</published>
    <updated>2016-06-26T04:03:35.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximum Gap]]></title>
    <link href="http://blog.noobsky.com/2016/06/26/LeetCode-Maximum-Gap/"/>
    <id>http://blog.noobsky.com/2016/06/26/LeetCode-Maximum-Gap/</id>
    <published>2016-06-26T03:01:25.000Z</published>
    <updated>2016-06-26T03:33:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Try to solve it in linear time/space.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>
<h2 id="代码">代码</h2><ul>
<li>解法一</li>
</ul>
<p>排序，依次计算相邻元素，时间复杂度不符合要求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//时间复杂度为O(nlgn)不符合要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxGap = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            maxGap = Math.max(maxGap, nums[i+<span class="number">1</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<p>[Thoughts]<br>Suppose there are N elements and they range from A to B.<br>Then the maximum gap will be no smaller than ceiling[(B - A) / (N - 1)]<br>Let the length of a bucket to be len = ceiling[(B - A) / (N - 1)], then we will have at most num = (B - A) / len + 1 of bucket<br>for any number K in the array, we can easily find out which bucket it belongs by calculating loc = (K - A) / len and therefore maintain the maximum and minimum elements in each bucket.<br>Since the maximum difference between elements in the same buckets will be at most len - 1, so the final answer will not be taken from two elements in the same buckets.<br>For each non-empty buckets p, find the next non-empty buckets q, then q.min - p.max could be the potential answer to the question. Return the maximum of all those values.</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">//时间复杂度为O(nlgn)不符合要求</span></span><br><span class="line">    <span class="comment">// public int maximumGap(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length &lt;= 1) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     Arrays.sort(nums);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int maxGap = Integer.MIN_VALUE;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length - 1; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         maxGap = Math.max(maxGap, nums[i+1] - nums[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return maxGap;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//桶排序</span></span><br><span class="line">    <span class="comment">//最大的gap必定是两个相邻桶的最小值和最大值之差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maximumGap(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">min</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//求数组中最大最小元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num: nums)&#123;</span><br><span class="line">            <span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">min</span>, num);</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不然后面的gap会为0，/gap抛出除0异常</span></span><br><span class="line">        <span class="comment">//或者后面的gap至少为1，Math.max(1, ...);</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span> == <span class="built_in">max</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// the minimum possibale gap, ceiling of the integer division</span></span><br><span class="line">        <span class="comment">//也是桶的range</span></span><br><span class="line">        <span class="built_in">int</span> gap = (<span class="built_in">int</span>)Math.<span class="built_in">ceil</span>((<span class="keyword">double</span>)(<span class="built_in">max</span> - <span class="built_in">min</span>) / (nums.length - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> bucketLen = (<span class="built_in">max</span> - <span class="built_in">min</span>)/gap + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只保存桶的最大最小元素即可</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] bucketsMin = <span class="keyword">new</span> <span class="built_in">int</span>[bucketLen];</span><br><span class="line">        <span class="built_in">int</span>[] bucketsMax = <span class="keyword">new</span> <span class="built_in">int</span>[bucketLen];</span><br><span class="line">        </span><br><span class="line">        Arrays.<span class="built_in">fill</span>(bucketsMin, Integer.MAX_VALUE);</span><br><span class="line">        Arrays.<span class="built_in">fill</span>(bucketsMax, Integer.MIN_VALUE);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num: nums)&#123;</span><br><span class="line">            <span class="built_in">int</span> bucketIndex = (num - <span class="built_in">min</span>) / gap;</span><br><span class="line">            <span class="comment">//更新每个桶的最大最小值</span></span><br><span class="line">            bucketsMin[bucketIndex] = Math.<span class="built_in">min</span>(bucketsMin[bucketIndex], num);</span><br><span class="line">            bucketsMax[bucketIndex] = Math.<span class="built_in">max</span>(bucketsMax[bucketIndex], num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> maxGap = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//前一个桶的最大值</span></span><br><span class="line">        <span class="built_in">int</span> prev = <span class="built_in">min</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bucketLen; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucketsMin[i] == Integer.MAX_VALUE) <span class="keyword">continue</span>;<span class="comment">//empty bucket</span></span><br><span class="line">            maxGap = Math.<span class="built_in">max</span>(maxGap, bucketsMin[i] - prev);</span><br><span class="line">            prev = bucketsMax[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Tr]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sliding Window Maximum]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-Sliding-Window-Maximum/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-Sliding-Window-Maximum/</id>
    <published>2016-06-25T13:01:48.000Z</published>
    <updated>2016-06-25T16:33:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>] -<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [-<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span> [-<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>Therefore, return the max sliding window as [3,3,5,5,6,7].</p>
<p><strong> Note: </strong><br>You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong> Follow up: </strong><br>Could you solve it in linear time?</p>
<p><strong> Hint: </strong></p>
<ol>
<li>How about using a data structure such as deque (double-ended queue)?</li>
<li>The queue size need not be the same as the window’s size.</li>
<li>Remove redundant elements and the queue should store only elements that need to be considered.</li>
</ol>
<h2 id="代码">代码</h2><ul>
<li>解法一</li>
</ul>
<p>使用堆，维护一个大小为k的最大堆，堆中存放滑动窗口的中元素，时间复杂度为O(nlgk)，空间复杂度为O(k)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//维护一个最大堆，并维护堆的大小为k即窗口大小，则堆顶元素即为每个滑动窗口的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//Collections.reverseOrder()返回一个逆序的Comparator，则构建一个最大堆</span></span><br><span class="line">        <span class="comment">//Arrays.sort(arr, Collections.reverseOrder())</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//滑动窗口大小已经为k，删除窗口最左边的元素，为下一个元素腾空间</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) pq.remove(nums[i-k]);</span><br><span class="line">            pq.offer(nums[i]);</span><br><span class="line">            <span class="comment">//窗口大小已经为k</span></span><br><span class="line">            <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) res[i-k+<span class="number">1</span>] = pq.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>解法二</li>
</ul>
<p>使用双端队列，时间复杂度为O(n)，空间复杂度为O(k)。<br>当遍历到数组中一个新元素时，将该元素与队列中队尾元素相比较，如果末尾元素比新元素小，则移除末尾元素，直到该队列的末尾元素比新元素大或者队列为空时才停止。这样我们可以保证队头元素是窗口[i-(k-1), i]中最大的元素，其实队列中的窗口中元素降序。由于我们我们新加数的时候，已经把很多没用的元素移除了，无法正确的判断队列中滑动窗口的大小。这里比较tricky的就是在队列中保存元素在数组中下标，这样既能知道这个数的值，也能判断该数是不是窗口最左边的数。这里的均摊时间复杂度为O(n)，因为每个元素被加入队列和移除队列各一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//使用双端队列存元素在数组中的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//nums.length - k + 1个滑动窗口</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="comment">//dq.peek() == i-k</span></span><br><span class="line">            <span class="comment">//滑动窗口大小已经为k，删除窗口最左边的元素，为下一个元素腾空间</span></span><br><span class="line">            <span class="keyword">if</span>(!dq.isEmpty() &amp;&amp; dq.peek() &lt; i - k + <span class="number">1</span>)&#123;</span><br><span class="line">                dq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//我们将nums[i]加入队尾之前，如果队列中元素小于nums[i]，则可以删除，因为他们不可能是滑动窗口的最大值</span></span><br><span class="line">            <span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt; nums[i])&#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dq.offer(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i - k + <span class="number">1</span> &gt;= <span class="number">0</span>) res[i-k+<span class="number">1</span>] = nums[dq.peek()];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the ve]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]One Edit Distance And Edit Distance]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-One-Edit-Distance-And-Edit-Distance/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-One-Edit-Distance-And-Edit-Distance/</id>
    <published>2016-06-25T04:00:10.000Z</published>
    <updated>2016-06-25T12:03:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="One_Edit_Distance">One Edit Distance</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Edit_Distance">Edit Distance</h2><h3 id="题目描述-1">题目描述</h3><p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
<h3 id="代码-1">代码</h3><p>dp[i][j]表示word1[0…i-1]转换到word2[0…j-1]的最少操作步数(编辑距离)。 下面来看状态转移方程。<br>边界情况：</p>
<ul>
<li><p>dp[i][0] = i</p>
</li>
<li><p>dp[0][j] = j </p>
</li>
</ul>
<p>这两个结论都很显然，比如word1[0…i-1]到空字符串””的编辑距离显然是i（i次删除）。</p>
<p>接下来看word1[0…i-1]到word2[0…j-1]，子问题就是word1[0…i-2]转换到word2[0…j-2]的编辑距离，也就是dp[i-1][j-1]。现在考虑word1[i-1]和word2[j-1]关系，如果它们相等，则dp[i][j] = dp[i-1][j-1]，如果word1[i-1]和word2[j-1]不相等，则有以下三种情况。</p>
<ol>
<li>替换：将word1[i-1]替换成word2[j-1]，则dp[i][j] = dp[i-1][j-1] + 1 </li>
<li>删除：将word1[i-1]删除后，则dp[i][j] = dp[i-1][j] + 1</li>
<li>插入：将word2[j-1]插入到word1[i-1]的后面，则dp[i][j] = dp[i][j-1] + 1</li>
</ol>
<p>所以，状态转移方程如下：</p>
<ol>
<li>dp[i][0] = i;</li>
<li>dp[0][j] = j;</li>
<li>dp[i][j] = dp[i-1][j-1] + 1, if word1[i-1] = word2[j-1]</li>
<li>dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1, dp[i][j-1] + 1), if word1[i-1] != word2[j-1]</li>
</ol>
<p>根据以上状态转移方程，可得如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word1 == null || word2 == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=n; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>, dp[i-<span class="number">1</span>][j] + <span class="number">1</span>), dp[i][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp[i][j]只跟dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]有关系，其实我们并不需要维护m*n的矩阵，维护一行或一列就可以了，空间复杂度能够降到O(m)或者O(n)。</p>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.geeksforgeeks.org/dynamic-programming-set-5-edit-distance/" target="_blank" rel="external">Dynamic Programming | Set 5 (Edit Distance)</a><br><a href="https://leetcode.com/discuss/43398/20ms-detailed-explained-c-solutions-o-n-space" target="_blank" rel="external">20ms Detailed Explained C++ Solutions (O(n) Space)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="One_Edit_Distance">One Edit Distance</h2><h3 id="题目描述">题目描述</h3><h3 id="代码">代码</h3><h2 id="Edit_Distance">Edit Distance</h2><h3 id="]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Distinct Subsequences]]></title>
    <link href="http://blog.noobsky.com/2016/06/25/LeetCode-Distinct-Subsequences/"/>
    <id>http://blog.noobsky.com/2016/06/25/LeetCode-Distinct-Subsequences/</id>
    <published>2016-06-25T02:34:18.000Z</published>
    <updated>2016-06-25T03:25:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>Here is an example:<br>S = “rabbbit”, T = “rabbit”</p>
<p>Return 3.</p>
<h2 id="代码">代码</h2><p>dp[i][j]表示T[0…j-1]在S[0…i-1]中distinc subsequences的数量，则以S =”rabbbit”,T = “rabbit”为例）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    r a b b b i t</span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">r <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">a <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">i <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">t <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>所以状态转移方程为</p>
<p>dp[0][0] = 1; // T和S都是空串.<br>dp[0][1 … S.length() - 1] = 1; // T是空串，S只有一种子序列匹配。<br>dp[1 … T.length() - 1][0] = 0; // S是空串，T不是空串，S没有子序列匹配。<br>dp[i][j] = dp[i][j - 1] + (T[i - 1] == S[j - 1] ? dp[i - 1][j - 1] : 0).1 &lt;= i &lt;= T.length(), 1 &lt;= j &lt;= S.length()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(s.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return t.length() == 0 ? 1 : 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(t.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i-<span class="number">1</span>) == s.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[t.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a st]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
