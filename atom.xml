<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-06-21T05:23:16.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Flatten Binary Tree to Linked List]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Flatten-Binary-Tree-to-Linked-List/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Flatten-Binary-Tree-to-Linked-List/</id>
    <published>2016-06-21T03:16:39.000Z</published>
    <updated>2016-06-21T05:23:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>The flattened tree should look like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong> Hints: </strong><br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
<h2 id="代码">代码</h2><p>直接先序遍历，从头到尾把节点链接起来：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">private</span> TreeNode lastVisited = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用先序遍历，top-down</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">flatten</span>(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">        TreeNode savedRight = root.right;</span><br><span class="line">        <span class="keyword">if</span>(lastVisited != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastVisited.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//在这里会修改上一访问节点的right指向，应该先保存</span></span><br><span class="line">            <span class="comment">//比如先序遍历到3时，lastVisited指向2（此时结果为1-&gt;2），然后在这里修改2的节点的left为null，right节点为3</span></span><br><span class="line">            <span class="comment">//遍历完3节点后，接着遍历节点4，但是如果我们不提前保存节点4，我们就找不到4了因为节点2的右节点已经被修改为3</span></span><br><span class="line">            <span class="comment">//这就是需要保存右节点的原因</span></span><br><span class="line">            lastVisited.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        lastVisited = root;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">flatten</span>(root.left);</span><br><span class="line">        <span class="keyword">flatten</span>(savedRight);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者采用前插构建单链表的形式，bottom-up方式</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//前序、中序、后序遍历好像都不是</span></span><br><span class="line">    <span class="comment">//这里引出一种新的遍历方式</span></span><br><span class="line">    <span class="comment">//先遍历右子树，然后左子树，根节点，有点类似后序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      1</span></span><br><span class="line">    <span class="comment">//     / \</span></span><br><span class="line">    <span class="comment">//    2   5</span></span><br><span class="line">    <span class="comment">//   / \   \</span></span><br><span class="line">    <span class="comment">//  3   4   6</span></span><br><span class="line">    <span class="comment">//比如题目中树采用该种遍历方式的结果为6、5、4、3、2、1相当于结果的逆序，但是如果我们采用前插构建单链表的方式</span></span><br><span class="line">    <span class="comment">//就可以把该结果反转过来，变成1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，这里讲left节点都置为空，就能将树退化为单链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null，prev开始指向null，然后指向6，然后指向5，然后指向4，然后指向3......</span></span><br><span class="line">    <span class="comment">//prev上一次遍历的节点</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">flatten</span>(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//先右子树</span></span><br><span class="line">        <span class="keyword">flatten</span>(root.right);</span><br><span class="line">        <span class="keyword">flatten</span>(root.left);</span><br><span class="line">        </span><br><span class="line">        root.right = prev;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//更新prev的指向</span></span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代的方式，暂时没咋研究，有时间再研究：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//迭代的方式</span></span><br><span class="line">    <span class="keyword">public</span> void flatten(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.<span class="keyword">left</span> != null) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> last = cur.<span class="keyword">left</span>;</span><br><span class="line">                <span class="keyword">while</span> (last.<span class="keyword">right</span> != null) last = last.<span class="keyword">right</span>;</span><br><span class="line">                last.<span class="keyword">right</span> = cur.<span class="keyword">right</span>;</span><br><span class="line">                cur.<span class="keyword">right</span> = cur.<span class="keyword">left</span>;</span><br><span class="line">                cur.<span class="keyword">left</span> = null;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.<span class="keyword">right</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<figure class="highlig]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Decode Ways]]></title>
    <link href="http://blog.noobsky.com/2016/06/21/LeetCode-Decode-Ways/"/>
    <id>http://blog.noobsky.com/2016/06/21/LeetCode-Decode-Ways/</id>
    <published>2016-06-21T00:10:11.000Z</published>
    <updated>2016-06-21T04:42:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//类似Climbing Stairs，只是多了一些限制条件</span></span><br><span class="line">    <span class="comment">//nums[i]：表示字符串s[0...i-1]的解码方式的总数</span></span><br><span class="line">    <span class="comment">//nums[i] = nums[i-1] if s[i-1] is valid char</span></span><br><span class="line">    <span class="comment">//or nums[i-1] + nums[i-2] if s[i-1] and s[i-2] to gether is still a valid char</span></span><br><span class="line">    <span class="comment">// public int numDecodings(String s) &#123;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(s == null || s.length() == 0) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int[] nums = new int[s.length() + 1];</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     //表示空字符串只有一种解码方式</span></span><br><span class="line">    <span class="comment">//     nums[0] = 1;</span></span><br><span class="line">    <span class="comment">//     //只含有s[0]一个字符的解码方式，如果是有效字符不为'0'则有一种方式，否则为零</span></span><br><span class="line">    <span class="comment">//     nums[1] = s.charAt(0) != '0' ? 1 : 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     for(int i = 2; i &lt;= s.length(); i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(isValid(s.substring(i-1,i)))&#123;</span></span><br><span class="line">    <span class="comment">//             nums[i] += nums[i-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">//         if(isValid(s.substring(i-2, i)))&#123;</span></span><br><span class="line">    <span class="comment">//             nums[i] += nums[i-2];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return nums[s.length()];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> value = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">1</span> &amp;&amp; value &lt;= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//表示空字符串只有一种解码方式</span></span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//只含有s[0]一个字符的解码方式，如果是有效字符不为'0'则有一种方式，否则为零</span></span><br><span class="line">        nums[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = Integer.parseInt(s.substring(i-<span class="number">1</span>, i));</span><br><span class="line">            <span class="keyword">int</span> second = Integer.parseInt(s.substring(i-<span class="number">2</span>, i));</span><br><span class="line">            <span class="keyword">if</span>(first &gt;= <span class="number">1</span> &amp;&amp; first &lt;= <span class="number">9</span>)&#123;</span><br><span class="line">                nums[i] += nums[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意second要大于等于10</span></span><br><span class="line">            <span class="keyword">if</span>(second &gt;= <span class="number">10</span> &amp;&amp; second &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                nums[i] += nums[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两种写法都是top down dp，我们还可以用bottom up dp的方式，从字符串尾部往前dp。nums[i]表示s[i…s.length]的解码方式。以’0’开头的字符串解码方式为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//空字符串的解码方式</span></span><br><span class="line">        nums[length] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        nums[length-<span class="number">1</span>] = s.charAt(length - <span class="number">1</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>) <span class="keyword">continue</span>;<span class="comment">//以0开头的字符串都是无效的字符串，解码方式为0，默认初始化为0，写nums[i] = 0也可以</span></span><br><span class="line">            <span class="keyword">else</span> nums[i] = Integer.parseInt(s.substring(i, i+<span class="number">2</span>)) &lt;= <span class="number">26</span> ? nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] : nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</spa]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Reverse Words in a String I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/20/LeetCode-Reverse-Words-in-a-String-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/20/LeetCode-Reverse-Words-in-a-String-I-II/</id>
    <published>2016-06-20T12:52:55.000Z</published>
    <updated>2016-06-20T13:55:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Reverse_Words_in_a_String_I">Reverse Words in a String I</h2><h3 id="题目描述">题目描述</h3><p>Given an input string, reverse the string word by word.</p>
<p>For example,<br>Given s = “the sky is blue”,<br>return “blue is sky the”.</p>
<p>Update (2015-02-12):<br>For C programmers: Try to solve it in-place in O(1) space.</p>
<h3 id="代码">代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	 <span class="comment">//使用split函数切割，然后逆序append起来即可</span></span><br><span class="line">    <span class="comment">//考虑前导空格、words之间多个空格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> reverseWords(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一个空格或多个空格split</span></span><br><span class="line">        <span class="keyword">String</span>[] strs = s.<span class="built_in">trim</span>().<span class="built_in">split</span>(<span class="string">"\\s+"</span>);</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = strs.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            sb.<span class="built_in">append</span>(strs[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.<span class="built_in">append</span>(strs[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法就是逆序遍历字符串，使用两个指针追踪words的开始和结尾，当我们遍历到words的开始时，将words append到结果中。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//j指针初始指向字符串最后一个字符的下一位置，在每一次迭代中j指向上一个遍历的空格</span></span><br><span class="line">        <span class="keyword">int</span> j = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//遍历到空格，更新j的指向，指向新的空格</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">' '</span>)&#123;<span class="comment">//charAt(i - 1) == ' '说明i当前指向某个word的开头，可以获取到该word</span></span><br><span class="line">                <span class="keyword">if</span>(sb.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                    sb.append(<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(s.substring(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//其他情况直接跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse_Words_in_a_String_II">Reverse Words in a String II</h2><h3 id="题目描述-1">题目描述</h3><p>Similar to Question [Reverse Words in a String], but with the following constraints:<br>“The input string does not contain leading or trailing spaces and the words are always separated by a single space.”<br>Could you do it in-place without allocating extra space?</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将整个字符串翻转，然后将每个word翻转</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] s)</span></span>&#123;</span><br><span class="line">       reverse(s, <span class="number">0</span>, s.length - <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//j指向每个word的开始</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i == s.length - <span class="number">1</span> || s[i] == <span class="string">' '</span> )&#123;</span><br><span class="line">               reverse(s, j, i);</span><br><span class="line">               j = i+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">           <span class="keyword">char</span> temp = s[end];</span><br><span class="line">           s[end] = s[start];</span><br><span class="line">           s[start] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Reverse_Words_in_a_String_I">Reverse Words in a String I</h2><h3 id="题目描述">题目描述</h3><p>Given an input string, reverse the string wor]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Divide Two Integers]]></title>
    <link href="http://blog.noobsky.com/2016/06/20/LeetCode-Divide-Two-Integers/"/>
    <id>http://blog.noobsky.com/2016/06/20/LeetCode-Divide-Two-Integers/</id>
    <published>2016-06-20T08:37:13.000Z</published>
    <updated>2016-06-20T11:49:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//最直接的方法就是不断用被除数减去除数，直到被除数小于除数，迭代次数为结果大小</span></span><br><span class="line">    <span class="comment">//这里介绍一种方法，用例子来说明：dividend = 15， divisor = 3</span></span><br><span class="line">    <span class="comment">//15-3 = 12，结果为整数，我们尝试减多一点，我们将3左移一位得6，15-6 = 9仍然是正数，我们还可以减更多一点</span></span><br><span class="line">    <span class="comment">//再讲3左移一位得12，15-12 = 3仍然大于0，我们尝试3再左移得24这回不可以了。所以最多减去12。12是除数3左移两位得到，4*3 = 12</span></span><br><span class="line">    <span class="comment">//那么我们怎么得到这个4，我们初始化为1，然后除数3左移时，1也左移。3左移两次1左移两次为4。我们将4加到相除的结果中（初始化</span></span><br><span class="line">    <span class="comment">//为0）。上面的过程就像 15 = 3*4 + 3。现在我们得到商为4，余数为3。</span></span><br><span class="line">    <span class="comment">//然后我们继续以上过程，新的被除数dividend = 3，除数divisor = 3，3 - 3 = 0。迭代结束，这次没有发生左移，所以结果中加上</span></span><br><span class="line">    <span class="comment">//1&lt;&lt;0 = 1，最后我们等到5。</span></span><br><span class="line">    <span class="comment">//我们还需要处理溢出，有以下情况:</span></span><br><span class="line">    <span class="comment">//1. divisor = 0；</span></span><br><span class="line">    <span class="comment">//2. dividend = Integer.MIN_VALUE，divisor = -1（因为 Math.abs(MIN_VALUE) = MAX_VALUE + 1）</span></span><br><span class="line">    <span class="comment">//最后还要考虑正负号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor == <span class="number">0</span> || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//除数和被除数符号相异时为负，否则为正，用异或</span></span><br><span class="line">        <span class="keyword">int</span> sign = ((dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换为整数处理，Integer.MIN_VALUE绝对值会溢出，用long类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> dvd = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)dividend);</span><br><span class="line">        <span class="keyword">long</span> dvs = Math.<span class="built_in">abs</span>((<span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环终止条件为被除数小于除数</span></span><br><span class="line">        <span class="keyword">while</span>(dvd &gt;= dvs)&#123;</span><br><span class="line">            <span class="keyword">long</span> temp = dvs, factor = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(dvd &gt;= (temp&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//左移一位</span></span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                factor &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dvd -= temp;</span><br><span class="line">            res += factor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sign == <span class="number">1</span> ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实用long也不是长久之计，如果输入时long类型，咱又用什么好，用BigInteger:)，那如果。。。其实主要的溢出就是Intege.MIN_VALUE，绝对值后会溢出，那么就对MIN_VALUE单独处理好了；还有temp左移可能溢出。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//其实用long也不是长久之计，如果输入时long类型，咱又用什么好，用BigInteger:)，那如果。。。</span></span><br><span class="line">    <span class="comment">//其实主要的溢出就是Intege.MIN_VALUE，绝对值后会溢出，那么就对MIN_VALUE单独处理好了</span></span><br><span class="line">    <span class="comment">//还有temp左移可能溢出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dividend == Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(divisor == <span class="number">1</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="comment">//奇数跟前者等价，偶数跟后者等价</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> ((divisor&amp;<span class="number">1</span>) == <span class="number">1</span>) ? divide(dividend + <span class="number">1</span>, divisor) : divide(dividend &gt;&gt; <span class="number">1</span>, divisor &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(divisor == Integer.MIN_VALUE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if(divisor == 1) return dividend;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//除数和被除数符号相异时为负，否则为正，用异或</span></span><br><span class="line">        <span class="keyword">int</span> sign = ((dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换为整数处理，Integer.MIN_VALUE绝对值会溢出，用long类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dvd = Math.<span class="built_in">abs</span>(dividend);</span><br><span class="line">        <span class="keyword">int</span> dvs = Math.<span class="built_in">abs</span>(divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环终止条件为被除数小于除数</span></span><br><span class="line">        <span class="keyword">while</span>(dvd &gt;= dvs)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dvs, factor = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//(temp &lt;&lt; 1) &gt; divisor是避免temp左移溢出造成死循环，溢出了(temp &lt;&lt; 1) &lt; divisor</span></span><br><span class="line">            <span class="comment">//比如dividend = Integer.MAX_VALUE, divisor = 1或2，死循环</span></span><br><span class="line">            <span class="keyword">while</span>(dvd &gt;= (temp &lt;&lt; <span class="number">1</span>) &amp;&amp; ((temp &lt;&lt; <span class="number">1</span>) &gt; dvs))&#123;</span><br><span class="line">                <span class="comment">//左移一位</span></span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                factor &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dvd -= temp;</span><br><span class="line">            res += factor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sign == <span class="number">1</span> ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(lgn)，空间复杂度为O(1)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Largest Number]]></title>
    <link href="http://blog.noobsky.com/2016/06/20/LeetCode-Largest-Number/"/>
    <id>http://blog.noobsky.com/2016/06/20/LeetCode-Largest-Number/</id>
    <published>2016-06-20T03:39:22.000Z</published>
    <updated>2016-06-20T07:54:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Largest_Number">Largest Number</h2><h3 id="题目描述">题目描述</h3><p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.</p>
<p>Note: The result may be very large, so you need to return a string instead of an integer.</p>
<h3 id="代码">代码</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">public</span> class Solution &#123;</span><br><span class="line">    //将nums转换为字符串数组，然后将字符串排序，这个排序比较讲究不是纯粹的升序或者降序，然后将字符串append起来即可</span><br><span class="line">    //因为越大的数字越在前面最后组成的数字越大</span><br><span class="line">    //但是这里需要注意的是两个字符串长度不相等，一个字符串又是另一个字符串的前缀的时候</span><br><span class="line">    //比如[<span class="string">"121"</span>, <span class="string">"12"</span>]如果按字典序降序(直接用return <span class="literal">s2</span>.compareTo(<span class="literal">s1</span>))排序结果为<span class="number">121</span>、<span class="number">12</span>，最后结果为<span class="string">"121"</span>+<span class="string">"12"</span>但是这个结果小于</span><br><span class="line">    //<span class="string">"12"</span>+<span class="string">"121"</span>，所以我们应该按<span class="literal">s1</span>+<span class="literal">s2</span>和<span class="literal">s2</span>+<span class="literal">s1</span>降序排即可</span><br><span class="line">    public <span class="keyword">String </span>largestNumber(int[] nums) &#123;</span><br><span class="line">        <span class="preprocessor">if</span>(nums == null <span class="title">||</span> nums.length == <span class="number">0</span>) return <span class="string">""</span><span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">String[] </span><span class="keyword">strs </span>= new <span class="keyword">String[nums.length];</span><br><span class="line"></span>        </span><br><span class="line">        for(int i = <span class="number">0</span><span class="comment">; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">            // <span class="keyword">strs[i] </span>= nums[i] + <span class="string">""</span><span class="comment">;</span></span><br><span class="line">            <span class="keyword">strs[i] </span>= <span class="keyword">String.valueOf(nums[i]);</span><br><span class="line"></span>        &#125;</span><br><span class="line">        </span><br><span class="line">        Comparator&lt;<span class="keyword">String&gt; </span>comp = new Comparator&lt;<span class="keyword">String&gt;()&#123;</span><br><span class="line"></span>            <span class="comment">@Override</span></span><br><span class="line">            public int compare(<span class="keyword">String </span><span class="literal">s1</span>, <span class="keyword">String </span><span class="literal">s2</span>)&#123;</span><br><span class="line">                //以下两句非常关键<span class="keyword">strs </span>= &#123;<span class="string">"121"</span>, <span class="string">"12"</span>&#125;<span class="comment">;</span></span><br><span class="line">                <span class="literal">s1</span> = <span class="literal">s1</span> + <span class="literal">s2</span><span class="comment">;</span></span><br><span class="line">                <span class="literal">s2</span> = <span class="literal">s2</span> + <span class="literal">s1</span><span class="comment">;</span></span><br><span class="line">                return <span class="literal">s2</span>.compareTo(<span class="literal">s1</span>)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        Arrays.sort(<span class="keyword">strs, </span>comp)<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        <span class="preprocessor">if</span>(<span class="keyword">strs[0].equals("0")) </span>return <span class="string">"0"</span><span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">StringBuilder </span><span class="literal">sb</span> = new <span class="keyword">StringBuilder();</span><br><span class="line"></span>        for(int i = <span class="number">0</span><span class="comment">; i &lt; strs.length; i++)&#123;</span></span><br><span class="line">            <span class="literal">sb</span>.append(<span class="keyword">strs[i]);</span><br><span class="line"></span>        &#125;</span><br><span class="line">        </span><br><span class="line">        return <span class="literal">sb</span>.toString()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外类似的题目还有从数中删除k位并且不改变数字的顺序使得留下的数字最大/最小，LeetCode上没有，LintCode上倒是有，之前面试也遇到了。</p>
<h2 id="Delete_Digits">Delete Digits</h2><h3 id="题目描述-1">题目描述</h3><p>Given string A representative a positive integer which has N digits, remove any k digits of the number, the remaining digits are arranged according to the original order to become a new positive integer.</p>
<p>Find the smallest integer after remove k digits.</p>
<p>N &lt;= 240 and k &lt;= N,</p>
<p><strong> Example </strong><br>Given an integer A = “178542”, k = 4</p>
<p>return a string “12”</p>
<h3 id="代码-1">代码</h3><p>其实这道题的思路和Largest Number的思路相似，都是贪婪算法，不同的是在Largest Number中，是较大的数在前，较小的数在后；这道题目中是较小的数在前，较大的数在后。因为我们要求最小的数，所以需要让排在最前的数字较小就可以，要做到这一点，我们依次比较两个相邻的数字，如果前一个数字比后一个数字大，则将前一个数字删除；如果前一个数字比后一个数字小，则不变，继续比较后面的数字。当进行到最后一个数字时，不需要再比较，直接将其删除即可。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *<span class="doctag">@param</span> A: A positive integer which has N digits, A is a string.</span><br><span class="line">     *<span class="doctag">@param</span> k: Remove k digits.</span><br><span class="line">     *<span class="doctag">@return</span>: A string</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> String DeleteDigits(String str, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span> || k &gt;= str.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="comment">//使用StringBuilder或者StringBuffer删除字符方便</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sb.length(); j++)&#123;</span><br><span class="line">                <span class="comment">//如果遍历到最后一个字符还没找到升序，说明整个数是降序的删除最后一个就可以了</span></span><br><span class="line">                <span class="keyword">if</span>(j == sb.length() - <span class="number">1</span> || sb.charAt(j) &gt; sb.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                    sb.deleteCharAt(j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除k个数字后可能有前导0，应该跳过</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sb.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.charAt(i) != <span class="string">'0'</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">return</span> sb.substring(i, sb.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理如果要删除k位使剩下的最大也是类似的，将上面代码中的<code>sb.charAt(j) &gt; sb.charAt(j+1)</code>改为<code>sb.charAt(j) &lt; sb.charAt(j+1)</code>。以上代码的时间复杂度为O(nk)，空间复杂度为O(1)。上面的代码的内层for循环每次都是从下标0开始往后比较，其实是多余的，已经比较过的数字就不用比较了。我们可以用j来记录上次的位置，这样相当于使用了两个pointers，优化之后最坏的时间复杂度为O(2n)，两个指针都从左至右走一遍。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *@param A: A positive integer which has N digits, A is a string.</span><br><span class="line">     *@param k: Remove k digits.</span><br><span class="line">     *@return: A string</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">DeleteDigits</span><span class="params">(String str, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == null || str.length() == <span class="number">0</span> || k &gt;= str.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="comment">//使用StringBuilder或者StringBuffer删除字符方便</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; sb.length(); j++)&#123;</span><br><span class="line">                <span class="comment">//如果遍历到最后一个字符还没找到升序，说明整个数是降序的删除最后一个就可以了</span></span><br><span class="line">                <span class="keyword">if</span>(j == sb.length() - <span class="number">1</span> || sb.charAt(j) &gt; sb.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                    sb.deleteCharAt(j);</span><br><span class="line">                    j--;<span class="comment">//回退一步就可以了</span></span><br><span class="line">                    <span class="comment">//j == 0时，j--为-1，越界，修正</span></span><br><span class="line">                    <span class="keyword">if</span>(j == -<span class="number">1</span>) j = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除k个数字后可能有前导0，应该跳过</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sb.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.charAt(i) != <span class="string">'0'</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.substring(i, sb.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.cnblogs.com/AndyJee/p/4527382.html" target="_blank" rel="external">(笔试题)删除K位数字</a><br><a href="http://www.geeksforgeeks.org/build-lowest-number-by-removing-n-digits-from-a-given-number/" target="_blank" rel="external">Build Lowest Number by Removing n digits from a given number</a><br><a href="http://www.jianshu.com/p/a0e0936ed93e" target="_blank" rel="external">Delete Digits</a><br><a href="http://codinggamestart.blogspot.com/2015/08/lintcode-delete-digits.html" target="_blank" rel="external">Lintcode: Delete Digits</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Largest_Number">Largest Number</h2><h3 id="题目描述">题目描述</h3><p>Given a list of non negative integers, arrange them such that they form]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Contains Duplicate I II III]]></title>
    <link href="http://blog.noobsky.com/2016/06/19/LeetCode-Contains-Duplicate-I-II-III/"/>
    <id>http://blog.noobsky.com/2016/06/19/LeetCode-Contains-Duplicate-I-II-III/</id>
    <published>2016-06-19T06:15:09.000Z</published>
    <updated>2016-06-20T02:42:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Contains_Duplicate_I">Contains Duplicate I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<h3 id="代码">代码</h3><ul>
<li>解法一</li>
</ul>
<p>直接遍历搜索，没遍历到某个元素nums[i]，逐一判断该元素跟前面的元素是否相等，时间复杂度为O(n<sup>2</sup>)， 超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == nums[i]) <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Time Limit Exceeded</span></span><br></pre></td></tr></table></figure>
<ul>
<li>解法二 </li>
</ul>
<p>排序后再遍历搜索，只有比较相邻元素就可，时间复杂度为O(nlgn)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>解法三（推荐）</li>
</ul>
<p>使用HashMap或HashSet，使用HashMap也可以但是value用不上，直接用HashSet（HashSet就是用HashMap实现的），HashSet的查找和插入都是O(1)的，所以总的时间复杂度为O(n)，不过需要O(n)的空间复杂度：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> containsDuplicate(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">    Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;(nums.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> x: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>.contains(x)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="built_in">set</span>.<span class="built_in">add</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果内存没什么限制的话，推荐使用这种方法。</p>
<h2 id="Contains_Duplicate_II">Contains Duplicate II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.</p>
<h3 id="代码-1">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - j; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]  == nums[i+j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力法，时间复杂度O(nk)，超时</p>
<ul>
<li>解法二 </li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> containsNearbyDuplicate(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Integer,Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(nums[i]))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-<span class="built_in">map</span>.<span class="built_in">get</span>(nums[i]) &lt;= k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果之前存在该key，但索引差不小于等于k，则覆盖掉之前的元素，如果不覆盖，后面有相等元素</span></span><br><span class="line">            <span class="comment">//跟之前的比会出现大于k的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>.put(nums[i],i);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用HashMap，key为数组元素，value为对应的index</p>
<ul>
<li>解法三（推荐）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tricky，利用HashSet维护一个窗口为k的滑动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">//窗口大小应该是k+1</span></span><br><span class="line">        <span class="comment">//[0...k]是符合的</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; k) <span class="built_in">set</span>.remove(nums[i-k-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">set</span>.add(nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//后面remove也可以</span></span><br><span class="line">        <span class="comment">//if(i &gt;= k) set.remove(nums[i-k]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Contains_Duplicate_III">Contains Duplicate III</h2><h3 id="题目描述-2">题目描述</h3><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.</p>
<h3 id="代码-2">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//在窗口k中找到[nums[i] - t, nums[i] + t]那么就返回true</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(nlgk)</span></span><br><span class="line">    <span class="comment">//利用TreeSet维护一个大小为K的滑动窗口，TreeSet寻找[nums[i] - t, nums[i] + t]的时间复杂度为O(lgk)</span></span><br><span class="line">    <span class="comment">//所以该程序的时间复杂度为O(nlgk)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">       TreeSet&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//寻找set中小于等于nums[i]+t的最大的数</span></span><br><span class="line">            <span class="comment">//虽然有nums[i]+t会发生溢出，但是遍历到后面某个数nums[j] - t还是能找到nums[i]的</span></span><br><span class="line">            Integer <span class="built_in">floor</span> = <span class="built_in">set</span>.<span class="built_in">floor</span>(nums[i] + t);<span class="comment">//lg(k)</span></span><br><span class="line">            <span class="comment">//寻找set中大于等于num[i]-t的最小的数</span></span><br><span class="line">            Integer <span class="built_in">ceil</span> = <span class="built_in">set</span>.ceiling(nums[i] - t);<span class="comment">//lg(k)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">floor</span> != null &amp;&amp; <span class="built_in">floor</span> &gt;= nums[i]) ||(<span class="built_in">ceil</span> != null &amp;&amp; <span class="built_in">ceil</span> &lt;= nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>.add(nums[i]);</span><br><span class="line">            <span class="comment">//[0...k]移除nums[0],为下一次循环做准备,下一次i=i+1=k+1，k+1 - 0 &gt; k了要移除一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) <span class="built_in">set</span>.remove(nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了引出下一种解法，我们先进行一些简单的推导：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果： | nums<span class="string">[i]</span> - nums<span class="string">[j]</span> | &lt;= t   式a</span><br><span class="line"></span><br><span class="line">等价： | nums<span class="string">[i]</span> / t - nums<span class="string">[j]</span> / t | &lt;= <span class="number">1</span>   式b</span><br><span class="line"></span><br><span class="line">推出： | floor(nums<span class="string">[i]</span> / t) - floor(nums<span class="string">[j]</span> / t) | &lt;= <span class="number">1</span>   式c</span><br><span class="line"></span><br><span class="line">​等价： floor(nums<span class="string">[j]</span> / t) ∈ &#123;floor(nums<span class="string">[i]</span> / t) - <span class="number">1</span>, floor(nums<span class="string">[i]</span> / t), floor(nums<span class="string">[i]</span> / t) + <span class="number">1</span>&#125; 式d</span><br></pre></td></tr></table></figure>
<p>其中式b是式c的充分非必要条件，因为逆否命题与原命题等价，所以：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果： floor(nums<span class="string">[j]</span> / t) ∉ &#123;floor(nums<span class="string">[i]</span> / t) - <span class="number">1</span>, floor(nums<span class="string">[i]</span> / t), floor(nums<span class="string">[i]</span> / t) + <span class="number">1</span>&#125; 非d</span><br><span class="line"></span><br><span class="line">推出： | nums<span class="string">[i]</span> - nums<span class="string">[j]</span> | &gt; t   非a</span><br></pre></td></tr></table></figure>
<p>因此只需要维护一个大小为k的窗口（字典）numDict，其中键为nums[i] / t，值为nums[i]。</p>
<p>遍历数组nums时，检查nums[i]与键集{floor(nums[i] / t) - 1, floor(nums[i] / t), floor(nums[i] / t) + 1}对应的值的差值即可。</p>
<p>根据以上分析，可得如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	 <span class="comment">//滑动窗口+桶</span></span><br><span class="line">    <span class="comment">//维护一个大小为t的桶，相差如果|nums[i] - num[j]| &lt;= t那么这两个数会被分配到同一个桶或者相邻的桶</span></span><br><span class="line">    <span class="comment">//分配都同一个桶的元素之差&lt;=t(元素是正数才满足)，但是分配到相邻桶的元素之差不一定是&lt;=</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//key为桶的编号，value为nums[i]</span></span><br><span class="line">        Map&lt;Long, Long&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//重新映射数组中元素全部转化为正数</span></span><br><span class="line">            <span class="keyword">long</span> remappedNum = (<span class="keyword">long</span>)nums[i] - Integer.MIN_VALUE;</span><br><span class="line">            <span class="comment">//将的桶的大小取为t+1是避免t为0时需要另外的代码,前面t为负数时已经直接返回了t+1不会为0</span></span><br><span class="line">            <span class="keyword">long</span> bucket = remappedNum / ((<span class="keyword">long</span>)t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//[-3, 3] k = 1, t = 4</span></span><br><span class="line">            <span class="comment">//如果不转换为正数的，对于以上测试用例会失败</span></span><br><span class="line">            <span class="comment">//-3和3都映射到同一个桶中，但是值之差并不小于等于t</span></span><br><span class="line">            <span class="comment">//下面的判断中分配到同一桶中的元素直接就默认小于等于t(对于正数来说是成立的)，所以前面全部转换为正数</span></span><br><span class="line">            <span class="comment">//那么-3和3分配到不同的桶中。其实不重新映射数组中的元素也是可以的，此时分配到同一个桶的元素也需要判断是否&lt;=t</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(bucket) || (<span class="built_in">map</span>.containsKey(bucket - <span class="number">1</span>) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket - <span class="number">1</span>) &lt;= t) || (<span class="built_in">map</span>.containsKey(bucket + <span class="number">1</span>) &amp;&amp; <span class="built_in">map</span>.get(bucket + <span class="number">1</span>) - remappedNum &lt;= t))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">map</span>.put(bucket, remappedNum);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)&#123;</span><br><span class="line">                <span class="keyword">long</span> lastBucket = ((<span class="keyword">long</span>) nums[i - k] - Integer.MIN_VALUE) / ((<span class="keyword">long</span>) t + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">map</span>.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码成功AC，我尝试了一下不对数组中的元素重新映射，当元素分配到同一个桶中时仍然检查它们的之差是否小于等于t，但是我没有把数组中的元素转化为long类型，导致两数相减时溢出导致判断错误，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> remappedNum = nums[i];<span class="comment">// - Integer.MIN_VALUE;</span></span><br><span class="line">            <span class="keyword">int</span> bucket = remappedNum / ( t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//不需要重新映射但还是应该要long类型，因为remappedNum - map.get(bucket)等会发生溢出</span></span><br><span class="line">            <span class="comment">//nums = [-1,2147483647] k = 1  t = 2147483647就因为发生溢出而判断为true，正确的应该为false</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">map</span>.containsKey(bucket) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket) &lt;= t)</span><br><span class="line">                    || (<span class="built_in">map</span>.containsKey(bucket - <span class="number">1</span>) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket - <span class="number">1</span>) &lt;= t)</span><br><span class="line">                    || (<span class="built_in">map</span>.containsKey(bucket + <span class="number">1</span>) &amp;&amp; <span class="built_in">map</span>.get(bucket + <span class="number">1</span>) - remappedNum &lt;= t))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.entrySet().size() &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">int</span> lastBucket = nums[i - k] / (t + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">map</span>.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>.put(bucket, remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将数组中的元素强制转行为long类型时成功AC，推荐下面完善后AC的代码：</p>
<ul>
<li>解法二(推荐)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//不重新映射，nums转换为long类型，但是相同的桶也需要比较值之差是否小于等于t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;Long, Long&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//不映射</span></span><br><span class="line">            <span class="keyword">long</span> remappedNum = (<span class="keyword">long</span>) nums[i];<span class="comment">// - Integer.MIN_VALUE;</span></span><br><span class="line">            <span class="keyword">long</span> bucket = remappedNum / ((<span class="keyword">long</span>) t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//要转换为long类型，是因为这里相减会发生溢出</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">map</span>.containsKey(bucket) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket) &lt;= t)</span><br><span class="line">                    || (<span class="built_in">map</span>.containsKey(bucket - <span class="number">1</span>) &amp;&amp; remappedNum - <span class="built_in">map</span>.get(bucket - <span class="number">1</span>) &lt;= t)</span><br><span class="line">                        || (<span class="built_in">map</span>.containsKey(bucket + <span class="number">1</span>) &amp;&amp; <span class="built_in">map</span>.get(bucket + <span class="number">1</span>) - remappedNum &lt;= t))</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.entrySet().size() &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastBucket = ((<span class="keyword">long</span>) nums[i - k]) / ((<span class="keyword">long</span>) t + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">map</span>.remove(lastBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>.put(bucket, remappedNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="https://leetcode.com/discuss/38206/ac-o-n-solution-in-java-using-buckets-with-explanation" target="_blank" rel="external">AC O(N) solution in Java using buckets with explanation</a><br><a href="http://bookshadow.com/weblog/2015/06/03/leetcode-contains-duplicate-iii/" target="_blank" rel="external">[LeetCode]Contains Duplicate III</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Contains_Duplicate_I">Contains Duplicate I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of integers, find if the array contains any ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Range Sum Query 1D/2D - Immutable/Mutable]]></title>
    <link href="http://blog.noobsky.com/2016/06/19/LeetCode-Range-Sum-Query-1D-2D-Immutable-Mutable/"/>
    <id>http://blog.noobsky.com/2016/06/19/LeetCode-Range-Sum-Query-1D-2D-Immutable-Mutable/</id>
    <published>2016-06-19T01:22:05.000Z</published>
    <updated>2016-06-19T06:12:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Range_Sum_Query_-_Immutable">Range Sum Query - Immutable</h2><h3 id="题目描述">题目描述</h3><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p><strong> Example: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">2</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">1</span></span><br><span class="line">sumRange(<span class="number">2</span>, <span class="number">5</span>) -&gt; -<span class="number">1</span></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">5</span>) -&gt; -<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong> Note: </strong></p>
<ol>
<li>You may assume that the array does not change.</li>
<li>There are many calls to sumRange function.</li>
</ol>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NumArray &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// private int[] nums;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// public NumArray(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     //在初始化的时候使用dp计算前i个数的和。自己的想法队了，但是使用的额外的数组，面试是可以问清楚是否可以更改nums数组中的元素</span></span><br><span class="line">    <span class="comment">//     for(int i = 1;i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         nums[i] = nums[i] + nums[i-1];</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     this.nums = nums;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int sumRange(int i, int j) &#123;</span></span><br><span class="line">    <span class="comment">//     //前i==0时登记与前i个数的和</span></span><br><span class="line">    <span class="comment">//     if(i == 0) return nums[j];</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return nums[j] - nums[i-1];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) sums[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> sums[i] = sums[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> sums[j];</span><br><span class="line">        <span class="keyword">return</span> sums[j] - sums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumArray numArray = new NumArray(nums);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(0, 1);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(1, 2);</span></span><br></pre></td></tr></table></figure>
<h2 id="Range_Sum_Query_-_Mutable">Range Sum Query - Mutable</h2><h3 id="题目描述-1">题目描述</h3><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p>The update(i, val) function modifies nums by updating the element at index i to val.<br><strong> Example: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">9</span></span><br><span class="line">update(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><strong> Note: </strong></p>
<ol>
<li>The array is only modifiable by the update function.</li>
<li>You may assume the number of calls to update and sumRange function is distributed evenly.</li>
</ol>
<h3 id="代码-1">代码</h3><p>暴力法会超时：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> sumRange(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = i; l &lt;= j; l++) &#123;</span><br><span class="line">        <span class="keyword">sum</span> += data[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> update(<span class="keyword">int</span> i, <span class="keyword">int</span> val) &#123;</span><br><span class="line">    nums[i] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用分段树，sumRange和update的时间复杂度都是O(lgn):</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Segment Tree，sumRange和update都是O(lgn)</span></span><br><span class="line">    <span class="comment">//叶子节点为数组中的元素，内部节点(非叶子节点)代表了该节点下叶子的和</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录该节点下叶子包含数组中[start, end]的元素</span></span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        <span class="comment">//nums[start...end]直接的元素之和</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">sum</span>;</span><br><span class="line">        <span class="comment">//左右孩子</span></span><br><span class="line">        SegmentTreeNode left, right;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">public</span> SegmentTreeNode(<span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SegmentTreeNode root = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> NumArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        root = buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用nums中[start...end]的元素构造SegmentTree</span></span><br><span class="line">    <span class="keyword">private</span> SegmentTreeNode buildTree(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            SegmentTreeNode node = <span class="keyword">new</span> SegmentTreeNode(start, end);</span><br><span class="line">            <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">                node.<span class="keyword">sum</span> = nums[start];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//进入这个分支，[start...end]起码有两个元素，node.left和node.right都不会为空</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">                node.left = buildTree(nums, start, mid);</span><br><span class="line">                node.right = buildTree(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">                <span class="comment">//左子树加上右子树的和</span></span><br><span class="line">                node.<span class="keyword">sum</span> = node.left.<span class="keyword">sum</span> + node.right.<span class="keyword">sum</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> update(<span class="keyword">int</span> i, <span class="keyword">int</span> val) &#123;</span><br><span class="line">        update(root, i, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> update(SegmentTreeNode root, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.start == root.end)&#123;</span><br><span class="line">            root.<span class="keyword">sum</span> = val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = root.start + (root.end - root.start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos &lt;= mid)&#123;<span class="comment">//在左子树中</span></span><br><span class="line">                update(root.left, pos, val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                update(root.right, pos, val);</span><br><span class="line">            &#125;</span><br><span class="line">            root.<span class="keyword">sum</span> = root.left.<span class="keyword">sum</span> + root.right.<span class="keyword">sum</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sumRange(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">return</span> sumRange(root, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sumRange(SegmentTreeNode root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.start == start &amp;&amp; root.end == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="keyword">sum</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//计算root.start和root.end的中间值</span></span><br><span class="line">            <span class="keyword">int</span> mid = root.start + (root.end - root.start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(end &lt;= mid)&#123;<span class="comment">//全部在左子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.left, start, end);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start &gt;= mid + <span class="number">1</span>)&#123;<span class="comment">//全部在右子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.right, start, end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//分散在左右子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.left, start, mid) + sumRange(root.right, mid+<span class="number">1</span>, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumArray numArray = new NumArray(nums);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(0, 1);</span></span><br><span class="line"><span class="comment">// numArray.update(1, 10);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(1, 2);</span></span><br></pre></td></tr></table></figure>
<p>分段树还能用来解决Range Minimum Query问题，详见<a href="http://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank" rel="external">Segment Tree | Set 2 (Range Minimum Query)</a></p>
<h2 id="Range_Sum_Query_2D_-_Immutable">Range Sum Query 2D - Immutable</h2><h3 id="题目描述-2">题目描述</h3><p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p>
<p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt=""><br>The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</p>
<h3 id="代码-2">代码</h3><p>sum[i+1][j+1]表示matrix[0][0]到matrix[i][j]构成的区域的和<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-----+-+-------+     +--------+-----+     +-----+---------+     +-----+--------+</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">     </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">        </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">     </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">        </span>|</span><br><span class="line">+-----+-+       |<span class="string">     +--------+     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     +-----+        </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">  =  </span>|<span class="string">              </span>|<span class="string">  +  </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">  -  </span>|<span class="string">              </span>|</span><br><span class="line">+-----+-+       |<span class="string">     </span>|<span class="string">              </span>|<span class="string">     +-----+         </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|<span class="string">     </span>|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|<span class="string">     </span>|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">+---------------+     +--------------+     +---------------+     +--------------+</span><br><span class="line"></span><br><span class="line">   sums[i][j]      =    sums[i-1][j]    +     sums[i][j-1]    -   sums[i-1][j-1]   +  </span><br><span class="line"></span><br><span class="line">                        matrix[i-1][j-1]</span><br></pre></td></tr></table></figure></p>
<p>所以本题的所求区域的面积为：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br><span class="line">|<span class="string">               </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">          </span>|</span><br><span class="line">|<span class="string">   (r1,c1)     </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">          </span>|</span><br><span class="line">|<span class="string">   +------+    </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   +---------+    </span>|<span class="string">   +---+          </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">      </span>|<span class="string">    </span>|<span class="string"> = </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string"> - </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string"> - </span>|<span class="string">      (r1,c2) </span>|<span class="string"> + </span>|<span class="string">   (r1,c1)    </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">      </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">   +------+    </span>|<span class="string">   +---------+    </span>|<span class="string">   +---+           </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">        (r2,c2)</span>|<span class="string">   </span>|<span class="string">       (r2,c2)</span>|<span class="string">   </span>|<span class="string">   (r2,c1)     </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br></pre></td></tr></table></figure></p>
<p>根据以上思路，可得以下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NumMatrix &#123;</span><br><span class="line">    <span class="comment">//构造一个二维数组，sum[row+1][col+1]，加多第0行和第0列可以避免检查边界情况</span></span><br><span class="line">    <span class="comment">//相当于在第0行加了一行全为0的元素，第0列加了一列全为0的元素</span></span><br><span class="line">    <span class="comment">//sum[i+1][j+1]表示matrix[0][0]到matrix[i][j]构成的区域的和</span></span><br><span class="line">    <span class="comment">//sum[i][j] = sum[i-1][j]+sum[i][j-1] - sum[i-1][j-1]+matrix[i-1][j-1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)&#123;</span><br><span class="line">                sum[i][j] = sum[i-<span class="number">1</span>][j] + sum[i][j-<span class="number">1</span>] - sum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//虽然题目中已经假设 row1 ≤ row2 and col1 ≤ col2.</span></span><br><span class="line">        <span class="comment">//可以确保一下</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">if</span>(row1 &gt; row2)&#123;</span><br><span class="line">            temp = row2;</span><br><span class="line">            row2 = row1;</span><br><span class="line">            row1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col1 &gt; col2)&#123;</span><br><span class="line">            temp = col2;</span><br><span class="line">            col2 = col1;</span><br><span class="line">            col1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - sum[row2+<span class="number">1</span>][col1]- sum[row1][col2+<span class="number">1</span>] + sum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumMatrix numMatrix = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(0, 1, 2, 3);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(1, 2, 3, 4);</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="https://en.wikipedia.org/wiki/Segment_tree" target="_blank" rel="external">Segment tree</a><br><a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank" rel="external">Segment Tree | Set 1 (Sum of given range)</a><br><a href="http://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank" rel="external">Segment Tree | Set 2 (Range Minimum Query)</a><br><a href="http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/" target="_blank" rel="external">Binary Indexed Tree or Fenwick tree</a>_<br><a href="https://leetcode.com/articles/range-sum-query-mutable/" target="_blank" rel="external">Range Sum Query - Mutable</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Range_Sum_Query_-_Immutable">Range Sum Query - Immutable</h2><h3 id="题目描述">题目描述</h3><p>Given an integer array nums, find the sum of ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Validate Binary Search Tree]]></title>
    <link href="http://blog.noobsky.com/2016/06/19/LeetCode-Validate-Binary-Search-Tree/"/>
    <id>http://blog.noobsky.com/2016/06/19/LeetCode-Validate-Binary-Search-Tree/</id>
    <published>2016-06-19T01:14:53.000Z</published>
    <updated>2016-06-19T01:17:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">2</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Binary tree [1,2,3], return false.</p>
<h2 id="代码">代码</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> isValidBST(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);</span></span><br><span class="line">        <span class="comment">//return isValidBST(root, null, null);</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这样写有bug，比如root.val = Integer.MAX_VALUE就判断错误了</span></span><br><span class="line">    <span class="comment">// public boolean isValidBST(TreeNode root, int minVal, int maxVal)&#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return true;</span></span><br><span class="line">    <span class="comment">//     if(root.val &gt;= maxVal || root.val &lt;= minVal) return false;</span></span><br><span class="line">    <span class="comment">//     return isValidBST(root.left, minVal, root.val) &amp;&amp; isValidBST(root.right, root.val, maxVal);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改进形参用对象Integer和非空指针来判断</span></span><br><span class="line">    <span class="comment">// public boolean isValidBST(TreeNode root, Integer min, Integer max)&#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return true;</span></span><br><span class="line">    <span class="comment">//     return (min == null || root.val &gt; min) &amp;&amp; (max == null || root.val &lt; max) &amp;&amp; isValidBST(root.left, min, root.val) &amp;&amp; isValidBST(root.right, root.val, max);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或者使用long类型，因为数的定义val是int类型的</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> isValidBST(TreeNode root, <span class="keyword">long</span> <span class="built_in">min</span>, <span class="keyword">long</span> <span class="built_in">max</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= <span class="built_in">min</span> || root.val &gt;= <span class="built_in">max</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, <span class="built_in">min</span>, root.val) &amp;&amp; isValidBST(root.right, root.val, <span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follow]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Longest Substring Without Repeating Characters]]></title>
    <link href="http://blog.noobsky.com/2016/06/18/LeetCode-Longest-Substring-Without-Repeating-Characters/"/>
    <id>http://blog.noobsky.com/2016/06/18/LeetCode-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2016-06-18T13:17:07.000Z</published>
    <updated>2016-06-18T13:18:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:</p>
<p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p>
<p>Given “bbbbb”, the answer is “b”, with the length of 1.</p>
<p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<h2 id="代码">代码</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用HashMap记住字符和它对应的index</span></span><br><span class="line">    <span class="comment">//然后使用两个指针left和right，初始时指向index为0的位置，然后移动right指针遍历string中的字符，同时更新HashMap</span></span><br><span class="line">    <span class="comment">//如果right指向的字符HashMap已经存在，说明出现重复字符了，需要把left指针指向该字符上一次出现位置的右边和现在位置中的大者</span></span><br><span class="line">    <span class="comment">//在这个过程中，不管更新最长无重复字符字符串的长度</span></span><br><span class="line">    <span class="keyword">public</span> int lengthOfLongestSubstring(<span class="type">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HashMap</span>&lt;<span class="type">Character</span>, <span class="type">Integer</span>&gt; <span class="built_in">map</span> = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int <span class="keyword">right</span> = <span class="number">0</span>; <span class="keyword">right</span> &lt; s.length(); <span class="keyword">right</span>++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(s.charAt(<span class="keyword">right</span>)))&#123;</span><br><span class="line">                <span class="comment">//这里需要注意，这样写不对，我们需要确保map.get(s.charAt(right))+1 &gt; left才能赋值</span></span><br><span class="line">                <span class="comment">//不然会出现left指针往回移动的情况,比如s="abba",让right指向最右边的a时，left=2</span></span><br><span class="line">                <span class="comment">//如果直接赋值left = 1,left后退了，b字符重复，造成结果不正确</span></span><br><span class="line">                <span class="comment">//left = map.get(s.charAt(right)) + 1;</span></span><br><span class="line">                <span class="keyword">left</span> = <span class="type">Math</span>.<span class="built_in">max</span>(<span class="keyword">left</span>, <span class="built_in">map</span>.<span class="keyword">get</span>(s.charAt(<span class="keyword">right</span>))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>.put(s.charAt(<span class="keyword">right</span>), <span class="keyword">right</span>);</span><br><span class="line">            maxLen = <span class="type">Math</span>.<span class="built_in">max</span>(maxLen, <span class="keyword">right</span>-<span class="keyword">left</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:</p>
<p>Giv]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximum Subarray And Maximum Product Subarray]]></title>
    <link href="http://blog.noobsky.com/2016/06/18/LeetCode-Maximum-Subarray-And-Maximum-Product-Subarray/"/>
    <id>http://blog.noobsky.com/2016/06/18/LeetCode-Maximum-Subarray-And-Maximum-Product-Subarray/</id>
    <published>2016-06-18T06:45:38.000Z</published>
    <updated>2016-06-18T11:46:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Maximum_Subarray">Maximum Subarray</h2><h3 id="题目描述">题目描述</h3><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p>
<p><strong> More practice: </strong><br>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<h3 id="代码">代码</h3><p>dp[i]:表示最后一个元素为nums[i]的子数组的最大和。那么：<br>dp[i] = max(dp[i-1] + num[i], nums[i])或者dp[i] = nums[i] + dp[i-1] &gt; 0 ? dp[i-1] : 0;<br>也就是说如果下标i之前的子数组和dp[i-1]大于0才对dp[i]有帮助，如果小于等于0的话，没有帮助甚至是负作用<br>那么最终的最大子数组和maxSum = max(dp[0], dp[1], dp[2]……dp[nums.length - 1])。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//dp[i]:表示最后一个元素为nums[i]的子数组的最大和。</span></span><br><span class="line">    <span class="comment">//dp[i] = max(dp[i-1] + num[i], nums[i])或者dp[i] = nums[i] + dp[i-1] &gt; 0 ? dp[i-1] : 0;</span></span><br><span class="line">    <span class="comment">//也就是说如果下标i之前的子数组和dp[i-1]大于0才对dp[i]有帮助，如果小于等于0的话，没有帮助甚至是负作用</span></span><br><span class="line">    <span class="comment">//那么最终的最大子数组和maxSum = max(dp[0], dp[1], dp[2]......dp[nums.length - 1]);</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxEndingHere = nums[<span class="number">0</span>], maxSoFar = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            maxEndingHere = Math.max(nums[i], maxEndingHere+nums[i]);</span><br><span class="line">            maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return maxSoFar;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面的变量虽然可读性好，但总觉得怪怪的:)</span></span><br><span class="line">    <span class="comment">//原始版本如下：</span></span><br><span class="line">    <span class="comment">//使用了O(n)的内存空间，其实这些空间是可以省掉，因为dp[i]只跟dp[i-1]有关系</span></span><br><span class="line">    <span class="comment">//所以我们用一个变量记住上次的dp结果就可以了，改进后就是上面的程序:)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Maximum_Product_Subarray">Maximum Product Subarray</h2><h3 id="题目描述-1">题目描述</h3><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p>
<h3 id="代码-1">代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">//max[i]：表示最后一个元素是nums[i]的子数组的最大乘积</span></span><br><span class="line">    <span class="comment">//min[i]：表示最后一个元素是nums[i]的子数组的最小乘积</span></span><br><span class="line">    <span class="comment">//max[i] = max(max[i-1]*nums[i], min[i-1]*nums[i], nums[i])</span></span><br><span class="line">    <span class="comment">//min[i] = min(max[i-1]*nums[i], min[i-1]*nums[i], nums[i])</span></span><br><span class="line">    <span class="comment">//最终的最大子数组乘积maxProduct = max(max[0], max[1],......, max[nums.length - 1])</span></span><br><span class="line">    <span class="comment">//这里既要维护最大值和维护最小值，因为乘法比假发特殊，负负得正，两个很小的负数相乘可能很大</span></span><br><span class="line">    <span class="comment">//有可能变成最大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maxProduct(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] <span class="built_in">max</span> = <span class="keyword">new</span> <span class="built_in">int</span>[nums.length];</span><br><span class="line">        <span class="built_in">int</span>[] <span class="built_in">min</span> = <span class="keyword">new</span> <span class="built_in">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">max</span>[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">min</span>[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> maxProduct = <span class="built_in">max</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="built_in">max</span>[i] = Math.<span class="built_in">max</span>(Math.<span class="built_in">max</span>(<span class="built_in">max</span>[i-<span class="number">1</span>]*nums[i], <span class="built_in">min</span>[i-<span class="number">1</span>]*nums[i]), nums[i]);</span><br><span class="line">            <span class="built_in">min</span>[i] = Math.<span class="built_in">min</span>(Math.<span class="built_in">min</span>(<span class="built_in">max</span>[i-<span class="number">1</span>]*nums[i], <span class="built_in">min</span>[i-<span class="number">1</span>]*nums[i]), nums[i]);</span><br><span class="line">            maxProduct = Math.<span class="built_in">max</span>(maxProduct, <span class="built_in">max</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面的程序我们使用了O(n)的内存空间，使用了两个额外的数组max和min，每个max[i]只与max[i-1]有关，</span></span><br><span class="line">    <span class="comment">//所以其实我们可以省掉这些内存空间，使用几个变量就可以了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maxProduct(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> maxHerePre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> minHerePre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> maxProduct = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> minHere, maxHere;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            maxHere = Math.<span class="built_in">max</span>(Math.<span class="built_in">max</span>(maxHerePre*nums[i], minHerePre*nums[i]), nums[i]);</span><br><span class="line">            minHere = Math.<span class="built_in">min</span>(Math.<span class="built_in">min</span>(maxHerePre*nums[i], minHerePre*nums[i]), nums[i]);</span><br><span class="line">            </span><br><span class="line">            maxProduct = Math.<span class="built_in">max</span>(maxProduct, maxHere);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录前一元素结尾的最大最小值为下次循环做准备</span></span><br><span class="line">            maxHerePre = maxHere;</span><br><span class="line">            minHerePre = minHere;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Maximum_Subarray">Maximum Subarray</h2><h3 id="题目描述">题目描述</h3><p>Find the contiguous subarray within an array (containing at least o]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Wiggle Sort I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/18/LeetCode-Wiggle-Sort-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/18/LeetCode-Wiggle-Sort-I-II/</id>
    <published>2016-06-18T03:25:22.000Z</published>
    <updated>2016-06-18T12:39:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Wiggle_Sort_I">Wiggle Sort I</h2><h3 id="题目描述">题目描述</h3><p>Given an unsorted array nums, reorder it in-place such that nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]….</p>
<p>For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4]. </p>
<h3 id="代码">代码</h3><p>这道题有一种比较直观的思路就是先把数组按升序排序，然后将第三个数与第二个数交互，第五个数与第四个数交换，直到数组末尾。用一个for循环即可，从下标2开始，step为2，每次让当前元素跟前一个元素swap即可。时间复杂度为O(nlgn)</p>
<ul>
<li>解法一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[i-<span class="number">1</span>];</span><br><span class="line">            nums[i-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二</li>
</ul>
<p>题目要求nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]…，可以总结出规律：</p>
<ul>
<li>当i为奇数时，nums[i] &gt;= nums[i - 1]</li>
<li>当i为偶数时，nums[i] &lt;= nums[i - 1]</li>
</ul>
<p>所以我们只要对每个元素，根据下标的奇偶性判断是否符合，不符合交换即可。时间复杂度为O(n)。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; nums[i] &lt; nums[i-<span class="number">1</span>]) || (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[i-<span class="number">1</span>];</span><br><span class="line">                nums[i-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Wiggle_Sort_II">Wiggle Sort II</h2><p>Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….</p>
<p><strong> Example: </strong><br>(1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6].<br>(2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].</p>
<p><strong> Note: </strong><br>You may assume all input has valid answer.</p>
<p><strong> Follow Up: </strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
<h3 id="题目描述-1">题目描述</h3><h3 id="代码-1">代码</h3><ul>
<li>解法一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//先排序数组，然后将数组的前半部分和后半部分merge起来</span></span><br><span class="line">    <span class="comment">//把更大的一般放到奇数下标中，更小的一半放到偶数下标中</span></span><br><span class="line">    <span class="comment">//比如nums=[1,2,3,4,5,6,7]</span></span><br><span class="line">    <span class="comment">//4 3 2 1</span></span><br><span class="line">    <span class="comment">// 7 6 5 = &gt; 4 7 3 6 2 5 1</span></span><br><span class="line">    <span class="comment">//该种解法只要输入中存在valid answer就能正确找到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        <span class="comment">//排序，分成两部分</span></span><br><span class="line">        Arrays.sort(copy);</span><br><span class="line">        <span class="comment">//left初始时指向中间元素的后一元素</span></span><br><span class="line">        <span class="keyword">int</span> right = nums.length, left = (nums.length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? copy[--left] : copy[--right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法二（太tricky了，不推荐）</li>
</ul>
<p>先放上链接，以后再搞吧。<br><a href="https://leetcode.com/discuss/95156/step-by-step-explanation-of-index-mapping-in-java" target="_blank" rel="external">Step by step explanation of index mapping in Java</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Wiggle_Sort_I">Wiggle Sort I</h2><h3 id="题目描述">题目描述</h3><p>Given an unsorted array nums, reorder it in-place such that nums[0] &lt;=]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Reorder List]]></title>
    <link href="http://blog.noobsky.com/2016/06/18/LeetCode-Reorder-List/"/>
    <id>http://blog.noobsky.com/2016/06/18/LeetCode-Reorder-List/</id>
    <published>2016-06-18T03:08:51.000Z</published>
    <updated>2016-06-18T03:13:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
<h2 id="代码">代码</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//基本思路就是反转单链表的后半部分</span></span><br><span class="line">    <span class="comment">//然后用两个指针分别指向前半部分单链表的头部(这里用slow)和后半部分的单链表的头部(这里用fast)</span></span><br><span class="line">    <span class="comment">//然后将slow和fast指向的节点链接起来，在这个过程中要借助单链表的中间节点，终止条件也是slow等于中间节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> reorderList(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//利用快慢指针，找出链表的中点</span></span><br><span class="line">        <span class="comment">//利用快慢指针找链表的中点有两种写法，只在循环条件不同</span></span><br><span class="line">        <span class="comment">//1. 循环条件为：fast.next != null &amp;&amp; fast.next.next != null</span></span><br><span class="line">        <span class="comment">//2. 循环条件为：fast != null &amp;&amp; fast.next != null</span></span><br><span class="line">        <span class="comment">//这两种写法在链表的节点数为奇数时效果是一样的，偶数时有点不一样：</span></span><br><span class="line">        <span class="comment">//循环结束时，第一种写法的slow指针指向两个中间节点偏左的节点，fast指向倒数第二个节点</span></span><br><span class="line">        <span class="comment">//第二种写法的slow指针指向两个中间节点偏右的中间节点，fast指向null节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; fast.<span class="keyword">next</span>.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//反转后半部分，即中间节点之后的节点，可以参考Reverse list II</span></span><br><span class="line">        ListNode middle = slow;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指向需要反转的子链表的头结点,start节点的next的节点就是需要被反转的节点</span></span><br><span class="line">        ListNode start = slow.<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">//反转后半部分链表就是把每个需要反转的节点交换链接到middle.next中</span></span><br><span class="line">        <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 to 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4</span></span><br><span class="line">        <span class="keyword">while</span>(start.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前需要反转的节点，把该节点链接到middle后面</span></span><br><span class="line">            ListNode <span class="keyword">reverse</span> = start.<span class="keyword">next</span>;</span><br><span class="line">            start.<span class="keyword">next</span> = <span class="keyword">reverse</span>.<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">reverse</span>.<span class="keyword">next</span> = middle.<span class="keyword">next</span>;</span><br><span class="line">            middle.<span class="keyword">next</span> = <span class="keyword">reverse</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//reorder</span></span><br><span class="line">        slow = head;</span><br><span class="line">        fast = middle.<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">//相当于特殊的merge list</span></span><br><span class="line">        <span class="comment">//每次循环将slow和fast指向的节点链接起来</span></span><br><span class="line">        <span class="keyword">while</span>(slow != middle)&#123;</span><br><span class="line">            middle.<span class="keyword">next</span> = fast.<span class="keyword">next</span>;</span><br><span class="line">            fast.<span class="keyword">next</span> = slow.<span class="keyword">next</span>;</span><br><span class="line">            slow.<span class="keyword">next</span> = fast;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//slow，fast指向下一个节点</span></span><br><span class="line">            slow = fast.<span class="keyword">next</span>;</span><br><span class="line">            fast = middle.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this i]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Rotate List]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Rotate-List/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Rotate-List/</id>
    <published>2016-06-17T13:37:17.000Z</published>
    <updated>2016-06-17T13:39:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,<br>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
<h2 id="代码">代码</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//k可能大于链表的长度length，所以我们需要知道链表的长度来取模得到正确的k</span></span><br><span class="line">    <span class="comment">//我们只需要将末尾k%length个节点移到链表的头部，这些节点处于第(length-k%length)th个节点之后</span></span><br><span class="line">    <span class="comment">//所以我们需要两个指针分别指向链表最后一个节点和第(length-k%length)th个节点</span></span><br><span class="line">    <span class="keyword">public</span> ListNode rotateRight(ListNode head, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.<span class="keyword">next</span> = head;</span><br><span class="line">        ListNode fast = dummy, slow = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="comment">//统计链表长度，顺便让fast指向最后一个节点</span></span><br><span class="line">        <span class="keyword">for</span>( length = <span class="number">0</span>; fast.<span class="keyword">next</span> != <span class="keyword">null</span>; length++)&#123;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让slow指针指向第length - k % length 个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = length - k % length; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//rotate</span></span><br><span class="line">        <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL，k = 2，fast指向5，slow指向3</span></span><br><span class="line">        </span><br><span class="line">        fast.<span class="keyword">next</span> = dummy.<span class="keyword">next</span>;</span><br><span class="line">        dummy.<span class="keyword">next</span> = slow.<span class="keyword">next</span>;</span><br><span class="line">        slow.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given 1-&g]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Word Search I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Word-Search-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Word-Search-I-II/</id>
    <published>2016-06-17T11:16:23.000Z</published>
    <updated>2016-06-17T12:42:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Word_Search_I">Word Search I</h2><h3 id="题目描述">题目描述</h3><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,</p>
<p>Given board =</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  ['A','B','C','E'],</span><br><span class="line">  ['S','F','C','S'],</span><br><span class="line">  ['A','D','E','E']</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == null || word.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(board == null || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfsSearch(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dfs搜索是否存在该word</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">dfsSearch</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == word.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word.charAt(index)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//标记为已经访问过，这里用字符要保证输入不会出现*字符</span></span><br><span class="line">        <span class="comment">//如果面试的时候可以跟面试官沟通用个不会出现的字符:)</span></span><br><span class="line">        <span class="comment">//还有不能保证的话的可以使用一个布尔数组标记是否访问过</span></span><br><span class="line">        <span class="comment">//这里还有一种很tricky的处理的方法，就是用异或</span></span><br><span class="line">        <span class="comment">//这里假设只会出现ASCII字符，当然面试时可以跟面试官沟通，也就是0~255，那么可以用256</span></span><br><span class="line">        <span class="comment">//java中char是两个字节的0~65535，注意用的2的16次方65536会溢出，需要用int</span></span><br><span class="line">        <span class="comment">//board[i][j] ^= 256;</span></span><br><span class="line">        board[i][j] = <span class="string">'*'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上下左右搜索下标index+1下的字符</span></span><br><span class="line">        boolean exist = dfsSearch(board, word, i-<span class="number">1</span>, j, index + <span class="number">1</span>)</span><br><span class="line">                        || dfsSearch(board, word, i, j-<span class="number">1</span>, index + <span class="number">1</span>)</span><br><span class="line">                        || dfsSearch(board, word, i, j+<span class="number">1</span>, index + <span class="number">1</span>)</span><br><span class="line">                        || dfsSearch(board, word, i+<span class="number">1</span>, j, index + <span class="number">1</span>);</span><br><span class="line">                        </span><br><span class="line">        <span class="comment">//回复board[i][j]，为下一次搜索准备</span></span><br><span class="line">        board[i][j] = word.charAt(index);</span><br><span class="line">        <span class="comment">//再次异或就恢复原始值，异或的性质</span></span><br><span class="line">        <span class="comment">//board[i][j] ^= 256;</span></span><br><span class="line">        <span class="keyword">return</span> exist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Word_Search_I">Word Search I</h2><h3 id="题目描述">题目描述</h3><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Letter Combinations of a Phone Number]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Letter-Combinations-of-a-Phone-Number/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Letter-Combinations-of-a-Phone-Number/</id>
    <published>2016-06-17T07:49:44.000Z</published>
    <updated>2016-06-17T11:22:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:Digit</span> <span class="built_in">string</span> <span class="string">"23"</span></span><br><span class="line">Outpu<span class="variable">t:</span> [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>
<p><strong> Note: </strong><br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<h2 id="代码">代码</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用队列的先进先出性质，根据字符串的长度来区别字符串</span></span><br><span class="line">    <span class="comment">//首先将空字符串加入res中，然后进入for循环，循环次数由digits的长度决定</span></span><br><span class="line">    <span class="comment">//当队列头部的字符串的长度跟循环次数i的下标相等，说明这个字符串还是上次放入队列中的，</span></span><br><span class="line">    <span class="comment">//取出该元素并与当前digits对应的字符分别组合，然后依次加入队列中</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; letterCombinations(<span class="keyword">String</span> digits) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用队列</span></span><br><span class="line">        LinkedList&lt;<span class="keyword">String</span>&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//将数字和可能的字母对应起来</span></span><br><span class="line">        <span class="keyword">String</span>[] <span class="built_in">map</span>= &#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//先加入空字符串</span></span><br><span class="line">        res.offer(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; digits.length(); i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> mapIndex = Character.getNumericValue(digits.charAt(i));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//挺tricky的！！！</span></span><br><span class="line">            <span class="keyword">while</span>(res.peek().length() == i)&#123;</span><br><span class="line">                <span class="comment">//取出头部元素，依次跟digits对应的字符组合，再加入队列中</span></span><br><span class="line">                <span class="keyword">String</span> last = res.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">char</span> ch: <span class="built_in">map</span>[mapIndex].toCharArray())&#123;</span><br><span class="line">                    res.offer(last + ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Longest Palindromic Substring]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Longest-Palindromic-Substring/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Longest-Palindromic-Substring/</id>
    <published>2016-06-17T04:20:13.000Z</published>
    <updated>2016-06-17T04:32:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
<h2 id="代码">代码</h2><p>我们可以从回文的中心不但向两边扩展回文字符串，并更新最长的回文字符串长度和开始位置。设字符串S的长度为n，则回文字符串的中心最多只有2n-1个，中心可以是n个字符和，或者两个字符的之间为中心，这样的情况有n-1，所以总共有2n-1个可能的回文中心位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//start为最长回文子字符串的开始下标，maxLen为最长长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start, maxLen;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            extendPalindromic(s, i, i);<span class="comment">//回文字符串长度为奇数，以某个字符为中心</span></span><br><span class="line">            extendPalindromic(s, i, i+<span class="number">1</span>);<span class="comment">//回文字符串长度为偶数，以两个字符为中心</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从中间不断的向两边找可能的回文字符串，并更新最长回文长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendPalindromic</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//left、right下标字符相等，继续扩展</span></span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(maxLen &lt; right - left - <span class="number">1</span>)&#123;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            maxLen = right - left - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Add Two Numbers]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Add-Two-Numbers/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Add-Two-Numbers/</id>
    <published>2016-06-17T03:36:33.000Z</published>
    <updated>2016-06-17T03:38:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>
<h2 id="代码">代码</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        ListNode p = l1, q = l2, curr = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//可以用||把为空的一方的加数置为0就可以</span></span><br><span class="line">        <span class="comment">//用&amp;&amp;也可以，后面再将不空链接到尾部就行了</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> || q != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = p != <span class="keyword">null</span> ? p.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = q != <span class="keyword">null</span> ? q.val : <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">sum</span> = x + y + carry;</span><br><span class="line">            carry = <span class="keyword">sum</span> / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(<span class="keyword">sum</span> % <span class="number">10</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">            <span class="keyword">if</span>(q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and e]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Restore IP Addresses]]></title>
    <link href="http://blog.noobsky.com/2016/06/17/LeetCode-Restore-IP-Addresses/"/>
    <id>http://blog.noobsky.com/2016/06/17/LeetCode-Restore-IP-Addresses/</id>
    <published>2016-06-17T02:53:13.000Z</published>
    <updated>2016-06-17T02:58:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given a <span class="type">string</span> containing only digits, restore <span class="keyword">it</span> <span class="keyword">by</span> <span class="keyword">returning</span> all possible valid IP address combinations.</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">Given <span class="string">"25525511135"</span>,</span><br><span class="line"><span class="command"></span><br><span class="line">return</span> [<span class="string">"255.255.11.135"</span>, <span class="string">"255.255.111.35"</span>]. (Order <span class="keyword">does</span> <span class="keyword">not</span> matter)</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//简单高效的方法</span></span><br><span class="line">    <span class="comment">//基本思想就是将字符串切割三次将字符串分成四部分，每部分至少一个字符，至多三个字符，而且必须小于255</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="comment">//三个for循环切割三次</span></span><br><span class="line">        <span class="comment">//至少一个字符，最多三个字符，对应substring(0, 1)，substring(0, 3),而且至少给后面留下三个字符</span></span><br><span class="line">        <span class="comment">//所以i &lt; len - 2,后面至少还有len - 3， len - 2， len - 1三个字符</span></span><br><span class="line">        <span class="comment">//这里i应该是小于4，i可以等于3但是substring(0, 3)是不包括下标3的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span> &amp;&amp; i &lt; length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//至少一个字符substring(i, i+1)...substring(i, i+3)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; i+<span class="number">4</span> &amp;&amp; j &lt; length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>; k &lt; j+<span class="number">4</span> &amp;&amp; k &lt; length; k++)&#123;</span><br><span class="line">                String s1 = s.substring(<span class="number">0</span>, i), s2 = s.substring(i, j), s3 = s.substring(j, k), s4 = s.substring(k, length);</span><br><span class="line">                    <span class="keyword">if</span>(isValid(s1) &amp;&amp; isValid(s2) &amp;&amp; isValid(s3) &amp;&amp; isValid(s4))&#123;</span><br><span class="line">                        res.add(s1 + <span class="string">"."</span> + s2 + <span class="string">"."</span> + s3 + <span class="string">"."</span> + s4);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里不能压缩ip地址，比如01，不能压缩成，001不能压缩成1,00压缩成0</span></span><br><span class="line">        <span class="comment">//所以需要 (s.charAt(0) == '0' &amp;&amp; s.length() &gt; 1)的条件</span></span><br><span class="line">        <span class="comment">//如果去掉：</span></span><br><span class="line">        <span class="comment">//Input:"010010"</span></span><br><span class="line">        <span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//["0.1.0.010","0.1.00.10","0.1.001.0","0.10.0.10","0.10.01.0","0.100.1.0","01.0.0.10","01.0.01.0","01.00.1.0","010.0.1.0"]</span></span><br><span class="line">        <span class="comment">//Expected:["0.10.0.10","0.100.1.0"]</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; <span class="number">3</span> || s.length() == <span class="number">0</span> || (s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; s.length() &gt; <span class="number">1</span>) || Integer.parseInt(s) &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先贴上DFS的代码吧</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">    List&lt;String&gt; solutions = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    restoreIp(s, solutions, <span class="number">0</span>, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> solutions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restoreIp</span><span class="params">(String ip, List&lt;String&gt; solutions, <span class="keyword">int</span> idx, String restored, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">4</span> &amp;&amp; idx == ip.length()) solutions.add(restored);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx+i &gt; ip.length()) <span class="keyword">break</span>;</span><br><span class="line">        String s = ip.substring(idx,idx+i);</span><br><span class="line">        <span class="keyword">if</span> ((s.startsWith(<span class="string">"0"</span>) &amp;&amp; s.length()&gt;<span class="number">1</span>) || (i==<span class="number">3</span> &amp;&amp; Integer.parseInt(s) &gt;= <span class="number">256</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        restoreIp(ip, solutions, idx+i, restored+s+(count==<span class="number">3</span>?<span class="string">""</span> : <span class="string">"."</span>), count+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Maximal Square And Maximal Rectangle]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Maximal-Square-And-Maximal-Rectangle/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Maximal-Square-And-Maximal-Rectangle/</id>
    <published>2016-06-16T13:30:34.000Z</published>
    <updated>2016-06-17T02:53:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return its area.</p>
<p>For example, given the following matrix:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Return 4.</p>
<h2 id="代码">代码</h2><p>使用动态规划方法，状态转移方程如下。</p>
<p>dp[i][j]表示在点matrix[i][j]最大的正方形的边长：</p>
<p>边界情况：<br>dp[i][j] = matrix[i][j], i=0 or j = 0</p>
<p>非边界(i &gt; 0, j &gt; 0)：<br>if matrix[i][j] == 0: dp[i][j] = 0, i &gt; 0, j &gt; 0<br>if matrix[i][j] == 1: 那么dp[i][j]由左边、上方、左上方的dp决定<br>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</p>
<p>根据上面的状态转移方程，我们不难得出以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//dp[i][j]表示在点matrix[i][j]最大的正方形的边长</span></span><br><span class="line">    <span class="comment">//边界：dp[i][j] = matrix[i][j], i=0 or j = 0</span></span><br><span class="line">    <span class="comment">//if matrix[i][j] == 0: dp[i][j] = 0, i &gt; 0, j &gt; 0</span></span><br><span class="line">    <span class="comment">//if matrix[i][j] == 1: 那么dp[i][j]由左边、上方、左上方的dp决定</span></span><br><span class="line">    <span class="comment">//dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="comment">//i == 0 || j == 0是边界情况</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//可以不写，java默认初始化为0</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新最长边长</span></span><br><span class="line">                maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码更简洁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//其实几个if-else也可以合并起来，代码更简洁一些，想不到也没关系，上面的代码可读性更好</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return its area.<]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Summary Ranges And Missing Ranges]]></title>
    <link href="http://blog.noobsky.com/2016/06/16/LeetCode-Summary-Ranges-And-Missing-Ranges/"/>
    <id>http://blog.noobsky.com/2016/06/16/LeetCode-Summary-Ranges-And-Missing-Ranges/</id>
    <published>2016-06-16T11:13:28.000Z</published>
    <updated>2016-06-16T12:37:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”].</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//找到每一个连续期间</span></span><br><span class="line">    <span class="comment">//使用for循环遍历数组，对每一个元素不断与右边的元素相比较，如果相差为1则还是同一个连续区间，</span></span><br><span class="line">    <span class="comment">//下标i++，直到与右边元素之差不唯一则找到了一个连续区间</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; summaryRanges(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span> &lt; nums.length &amp;&amp; nums[i+<span class="number">1</span>] - nums[i] == <span class="number">1</span>) i++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i] != temp)&#123;</span><br><span class="line">                res.add(temp + <span class="string">"-&gt;"</span> + nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(temp+<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目描述-1">题目描述</h2><p>Given a sorted integer array where the range of elements are [0, 99] inclusive, return its missing ranges.<br>For example, given [0, 1, 3, 50, 75], return [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”]</p>
<p>You should be able to extend the above cases not only for the range [0,99], but any arbitrary range [start, end].</p>
<h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; getMissingRanges(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        List&lt;String&gt; ranges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> prev = start - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = (i == nums.length) ? end + <span class="number">1</span> : nums[i];</span><br><span class="line">            <span class="keyword">if</span>(curr - prev &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ranges.add(getRange(prev + <span class="number">1</span>, curr - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ranges;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getRange</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from == to ? String.valueOf(from) : from + <span class="string">"-&gt;"</span> + to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given [0,1,]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
