<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-06-11T07:13:34.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Subsets I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/11/LeetCode-Subsets-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/11/LeetCode-Subsets-I-II/</id>
    <published>2016-06-11T03:20:59.000Z</published>
    <updated>2016-06-11T07:13:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Subsets_I">Subsets I</h2><h3 id="题目描述">题目描述</h3><p>Given a set of <font color="red">distinct</font> integers, nums, return all possible subsets.</p>
<p><strong> Note: </strong>The solution set must not contain duplicate subsets.</p>
<p>For example,<br>If nums = [1,2,3], a solution is:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><ul>
<li>位操作</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//位操作</span></span><br><span class="line">    <span class="comment">//[] =&gt; 000 [1] =&gt; 001 [2] =&gt; 010 ...... [1, 2, 3] =&gt; 111</span></span><br><span class="line">    <span class="comment">//所以逻辑很简单，二进制表示中代表i的比特位为1表示i在subset中，否则不在,比如001中代表1的比特位为1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">1</span> &lt;&lt; nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++)&#123;</span><br><span class="line">            <span class="keyword">List</span>&lt;Integer&gt; subSet = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="comment">//i&amp;(1 &lt;&lt; j)可以避免死循环，但其实这里没有负数</span></span><br><span class="line">                <span class="comment">//(i&gt;&gt;j) &amp; 1的写法也是可以的</span></span><br><span class="line">                <span class="keyword">if</span>((i &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) subSet.add(nums[j]);</span><br><span class="line">                <span class="comment">//if(((i &gt;&gt; j) &amp; 1) != 0) subSet.add(nums[j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.add(subSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>回溯法</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">	public List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.<span class="keyword">length</span> == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        List&lt;Integer&gt; <span class="sub"><span class="keyword">sub</span> = new ArrayList&lt;&gt;();</span></span><br><span class="line">        genSubsets(nums, <span class="number">0</span>, <span class="sub"><span class="keyword">sub</span>, res);</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void genSubsets(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;Integer&gt; <span class="sub"><span class="keyword">sub</span>, List&lt;List&lt;Integer&gt;&gt; res)&#123;</span></span><br><span class="line">        //一定要先新new一个</span><br><span class="line">        res.add(new ArrayList&lt;Integer&gt;(<span class="sub"><span class="keyword">sub</span>));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.<span class="keyword">length</span>; i++)&#123;</span><br><span class="line">            <span class="sub"><span class="keyword">sub</span>.add(nums[i]);</span></span><br><span class="line">            genSubsets(nums, i+<span class="number">1</span>, <span class="sub"><span class="keyword">sub</span>, res);</span></span><br><span class="line">            <span class="sub"><span class="keyword">sub</span>.remove(<span class="keyword">sub</span>.size() - 1);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代法<br>思路如下：</li>
</ul>
<ol>
<li>初始化：[[]]</li>
<li>将第一个数加入到所有已有的子集中：[[],[1]]</li>
<li>同理加入第二个数：[[], [1], [2], [1,2]]</li>
<li>加入第三个数：[[], [1], [2],[1,2], [3], [1,3], [2,3], [1,2,3]]</li>
</ol>
<p>显然规律为加入新元素nums[i]后，新增的subset为克隆现有的所有subset，并在它们后面都加上nums[i]。<br>代码如下：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">	public List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.<span class="keyword">length</span> == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        List&lt;Integer&gt; <span class="sub"><span class="keyword">sub</span> = new ArrayList&lt;&gt;();</span></span><br><span class="line">        res.add(<span class="sub"><span class="keyword">sub</span>);</span>//empty set</span><br><span class="line">        //Arrays.<span class="keyword">sort</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="keyword">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> size = res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">                <span class="regexp">//</span> NOTE: must create a new <span class="sub"><span class="keyword">sub</span> object, and add element to it.</span><br><span class="line">                //If you don't create a new object and directly add element in res.get(j), </span><br><span class="line">                //you will also change the value which has been set into res, </span><br><span class="line">                //since they are using the same reference.</span><br><span class="line">                <span class="keyword">sub</span> = new ArrayList&lt;Integer&gt;(res.get(j));</span></span><br><span class="line">                <span class="sub"><span class="keyword">sub</span>.add(nums[i]);</span></span><br><span class="line">                res.add(<span class="sub"><span class="keyword">sub</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Subsets_II">Subsets II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a collection of integers that might contain <font color="red">duplicates</font>, nums, return all possible subsets.</p>
<p><strong> Note: </strong>The solution set must not contain duplicate subsets.</p>
<p>For example,<br>If nums = [1,2,2], a solution is:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>比如重复元素出现两次[6,6],则我们对于6有三种选择：不加入元素6，加入1个6，加入2个6；如果重复元素出现三次[6,6,6],则我们对于6有四种选择，不加入6，加入1个6、2个6、3个6。所以可推知规律为如果重复元素出现了k次，那么对该重复元素有k+1种选择。设数组[a1,a2,a3,…,an],其中每个元素出现的次数为[k1,k2,k3,…,kn],则子集的个数为(k1+1)<em>(k2+1)</em>(k3+1)…(kn+1),上一题没有重复元素只是特例，每个元素只出现一次，则子集总数为2<em>2</em>2……</p>
<h3 id="代码-1">代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//比如重复元素出现两次[6,6],则我们对于6有三种选择：不加入元素6，加入1个6，加入2个6</span></span><br><span class="line">    <span class="comment">//如果重复元素出现三次[6,6,6],则我们对于6有四种选择，不加入6，加入1个6、2个6、3个6</span></span><br><span class="line">    <span class="comment">//所以可推知规律为如果重复元素出现了k次，那么对该重复元素有k+1种选择</span></span><br><span class="line">    <span class="comment">//设数组[a1,a2,a3,...,an],其中每个元素出现的次数为[k1,k2,k3,...,kn],则子集的个数为</span></span><br><span class="line">    <span class="comment">//(k1+1)*(k2+1)*(k3+1)...(kn+1),上一题没有重复元素只是特例，每个元素只出现一次，</span></span><br><span class="line">    <span class="comment">//则子集总数为2*2*2......</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());<span class="comment">//初始化，加入[]</span></span><br><span class="line">        <span class="comment">//必须，方便计算元素的出现次数</span></span><br><span class="line">        Arrays.<span class="keyword">sort</span>(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;)&#123;</span><br><span class="line">            <span class="comment">//用来统计每个元素出现的次数</span></span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((<span class="keyword">count</span>+i) &lt; nums.length &amp;&amp; nums[i+<span class="keyword">count</span>] == nums[i]) <span class="keyword">count</span>++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//上一次迭代时子集的总数</span></span><br><span class="line">            <span class="keyword">int</span> preSize = res.<span class="keyword">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; preSize; j++)&#123;</span><br><span class="line">                List&lt;Integer&gt; sub = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(res.get(j));</span><br><span class="line">                <span class="comment">//元素出现count，有count+1个选择，一种选择就是重复元素都不选，该选项在初始化[]已经做过，</span></span><br><span class="line">                <span class="comment">//所以还有count种选择，循环countci</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="keyword">count</span>; k++)&#123;</span><br><span class="line">                    sub.add(nums[i]);</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(sub));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//跳过重复元素，进行下一个元素的子集生成</span></span><br><span class="line">            i += <span class="keyword">count</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步观察可知，If we want to insert an element which is a dup, we can only insert it after the newly inserted elements from last step.所以可得如下代码：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; subsetsWithDup(<span class="built_in">int</span>[] <span class="built_in">num</span>) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    </span><br><span class="line">        Arrays.sort(<span class="built_in">num</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> size = <span class="number">0</span>, startIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">num</span>.length; i++) &#123;</span><br><span class="line">            startIndex = (i &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">num</span>[i] == <span class="built_in">num</span>[i - <span class="number">1</span>]) ? size : <span class="number">0</span>;</span><br><span class="line">            size = res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = startIndex; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="built_in">List</span>&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;(res.<span class="literal">get</span>(j));</span><br><span class="line">                temp.add(<span class="built_in">num</span>[i]);</span><br><span class="line">                res.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Subsets_I">Subsets I</h2><h3 id="题目描述">题目描述</h3><p>Given a set of <font color="red">distinct</font> integers, nums, return all possi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Verify Preorder Serialization of a Binary Tree]]></title>
    <link href="http://blog.noobsky.com/2016/06/11/LeetCode-Verify-Preorder-Serialization-of-a-Binary-Tree/"/>
    <id>http://blog.noobsky.com/2016/06/11/LeetCode-Verify-Preorder-Serialization-of-a-Binary-Tree/</id>
    <published>2016-06-11T02:31:03.000Z</published>
    <updated>2016-06-11T02:50:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    /   <span class="string">\</span></span><br><span class="line">   <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">  / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"> <span class="number">4</span>   <span class="number">1</span>  <span class="comment">#  6</span></span><br><span class="line">/ <span class="string">\</span> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="comment"># # # #   # #</span></span><br></pre></td></tr></table></figure></p>
<p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node.</p>
<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>
<p>Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p>
<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”.</p>
<p><strong> Example 1: </strong><br>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>Return true</p>
<p><strong> Example 2: </strong><br>“1,#”<br>Return false</p>
<p><strong> Example 3: </strong><br>“9,#,#,1”<br>Return false</p>
<p>将空节点当做影子叶子节点，则：</p>
<ul>
<li>除了根节点，所有非空节点提供2个出度和一个入度(2个子节点和一个父节点)</li>
<li>所有空节点提供0个出度和1个入度(0个子节点和一个父节点)<br>接着我们构造这棵树，在构造的过程中记录出度和入度之差<code>diff = outdegree - indegree</code>。当构造一个节点时，diff减1，因为该节点提供了一个入度。如果该节点非空我们还要将diff加2，因为该节点提供了两个出度。如果树的序列化正确，diff不会小于零而且最后会等于0</li>
</ul>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//diff = outdegree - indegree</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == null || preorder.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        String[] nodes = preorder.split(<span class="string">","</span>);</span><br><span class="line">        <span class="comment">//初始化为1</span></span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(String node: nodes)&#123;</span><br><span class="line">            <span class="comment">//除根节点每个节点都会提供一个入度，diff-1，如果小于0，错误</span></span><br><span class="line">            <span class="keyword">if</span>(--diff &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//非空节点，提供了两个出度diff+2</span></span><br><span class="line">            <span class="keyword">if</span>(!node.equals(<span class="string">"#"</span>)) diff += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Search in Rotated Sorted Array I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Search-in-Rotated-Sorted-Array-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Search-in-Rotated-Sorted-Array-I-II/</id>
    <published>2016-06-10T12:06:10.000Z</published>
    <updated>2016-06-11T02:33:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Search_in_Rotated_Sorted_Array_I">Search in Rotated Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p><font color="red">You may assume no duplicate exists in the array</font>.</p>
<h3 id="代码">代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以用Find Minimum in Rotated Sorted Array中的方法找出最小元素的下标，进而我们可以知道旋转数组旋转的步数rot</span></span><br><span class="line">    <span class="comment">//有了旋转步数我们就可以知道某个元素在旋转数组中真实位置</span></span><br><span class="line">    <span class="keyword">public</span> int search(int[] nums, int target) &#123;</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//nums[left...mid]有序，最小元素在右边，mid = left + 1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>]) <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">right</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束后，最小元素的下标为left，则旋转步数rot = left</span></span><br><span class="line">        int rot = <span class="keyword">left</span>;</span><br><span class="line">        <span class="keyword">left</span> = <span class="number">0</span>;<span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分搜索target</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt;= <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//计算真正的中间元素在数组中的位置</span></span><br><span class="line">            int realMid = (mid+rot) % nums.length;</span><br><span class="line">            <span class="keyword">if</span>(nums[realMid] == target) <span class="keyword">return</span> realMid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[realMid] &gt; target) <span class="keyword">right</span> = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法比较tricky，当然也可以用Search in Rotated Sorted Array II中的常规写法。</p>
<h2 id="Search_in_Rotated_Sorted_Array_II">Search in Rotated Sorted Array II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for “Search in Rotated Sorted Array”:<br>What if duplicates are allowed?</p>
<p>Would this affect the run-time complexity? How and why?</p>
<p>Write a function to determine if a given target is in the array.</p>
<h3 id="代码-1">代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> boolean search(int[] nums, int target) &#123;</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//左边有序，</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[<span class="keyword">left</span>] &amp;&amp; target &lt; nums[mid]) <span class="keyword">right</span> = mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">             <span class="comment">//右边有序   </span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[<span class="keyword">right</span>]) <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">right</span> = mid;</span><br><span class="line">            <span class="comment">//重复元素，无法判断哪边有序，但去掉两相等元素中的一个不影响后面的判断</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="keyword">left</span>] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种写法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> boolean search(int[] nums, int target)&#123;</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt;= <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//左半部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[<span class="keyword">left</span>] &amp;&amp; target &lt; nums[mid]) <span class="keyword">right</span> = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右半部分有序</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[<span class="keyword">right</span>]) <span class="keyword">left</span> = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">right</span> = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两种写法，参照二分搜索的两种正确写法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Search_in_Rotated_Sorted_Array_I">Search in Rotated Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Suppose a sorted array is rotated a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Perfect Squares]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Perfect-Squares/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Perfect-Squares/</id>
    <published>2016-06-10T11:46:46.000Z</published>
    <updated>2016-06-11T01:01:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p>
<p>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>
<h2 id="代码">代码</h2><p>使用动态规划，dp[i]表示正整数i最少能由多少个完全平方数之和组成，则状态转移方程为dp[i] = min(dp[i - j*j]) + 1，i - j*j &gt;= 0 &amp;&amp; j &gt;= 1 ==&gt; j &lt;= sqrt(i) &amp;&amp; j &gt;= 1，根据状态转移方程很容易写出以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//dp[i]表示正整数i最少能由多少个完全平方数之和组成</span></span><br><span class="line">    <span class="comment">//则dp[i] = min(dp[i - j\*j]) + 1，i - j\*j &gt;= 0 &amp;&amp; j &gt;= 1 ==&gt; j &lt;= sqrt(i) &amp;&amp; j &gt;= 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//全部元素初始化为最大值</span></span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i - j*j &gt;= <span class="number">0</span>; j++)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j*j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该题有数学解法，考察四平方和定理(Lagrange’s Four-Square Theorem)：所有自然数至多只要用四个数的平方和就可以表示。那么就是说返回结果只有1,2,3或4其中的一个，首先我们将数字化简一下，由于一个数如果含有因子4，那么我们可以把4都去掉，并不影响结果，比如2和8,3和12等等，返回的结果都相同，读者可自行举更多的例子。还有一个可以化简的地方就是，如果一个数除以8余7的话，那么肯定是由4个完全平方数组成，这些数学上都可以证明，但我也不会证明，读者可自行举例验证。那么做完两步后，一个很大的数有可能就会变得很小了，大大减少了运算时间，下面我们就来尝试的将其拆为两个平方数之和，如果拆成功了那么就会返回1或2，因为其中一个平方数可能为0. (注：由于输入的n是正整数，所以不存在两个平方数均为0的情况)。注意下面的!!a + !!b这个表达式，可能很多人不太理解这个的意思，其实很简单，感叹号!表示逻辑取反，那么一个正整数逻辑取反为0，再取反为1，所以用两个感叹号!!的作用就是看a和b是否为正整数，都为正整数的话返回2，只有一个是正整数的话返回1，参见代码如下(C代码)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">        n /= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">8</span> == <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a=<span class="number">0</span>; a*a&lt;=n; ++a) &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="built_in">sqrt</span>(n - a*a);</span><br><span class="line">        <span class="keyword">if</span> (a*a + b*b == n)</span><br><span class="line">            <span class="keyword">return</span> !!a + !!b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为Java代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n % <span class="number">4</span> == <span class="number">0</span>) n = n / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">8</span> == <span class="number">7</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a =<span class="number">0</span>; a * a &lt;= n; a++)&#123;</span><br><span class="line">            <span class="keyword">int</span> b = (<span class="keyword">int</span>)Math.<span class="built_in">sqrt</span>(n - a*a);</span><br><span class="line">            <span class="keyword">if</span>(a * a + b* b == n)&#123;</span><br><span class="line">                <span class="keyword">return</span> (a &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) + (b &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which su]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Duplicates from Sorted Array I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Remove-Duplicates-from-Sorted-Array-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Remove-Duplicates-from-Sorted-Array-I-II/</id>
    <published>2016-06-10T09:48:29.000Z</published>
    <updated>2016-06-10T10:48:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Remove_Duplicates_from_Sorted_Array_I">Remove Duplicates from Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// public int removeDuplicates(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int newLength = 1;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] != nums[i-1]) nums[newLength++] = nums[i];</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return newLength;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="comment">//第一个元素直接往里面放，后面nums[i]只要不跟前一个放进去的相等都能往里面放</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">1</span> || num != nums[i-<span class="number">1</span>])</span><br><span class="line">                nums[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove_Duplicates_from_Sorted_Array_II">Remove Duplicates from Sorted Array II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for “Remove Duplicates”:<br>What if duplicates are allowed at most twice?</p>
<p>For example,<br>Given sorted array nums = [1,1,1,2,2,3],</p>
<p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length.</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//前两个元素直接加入，后面的元素nums[i]只要不跟前面倒数第二个放进去的nums[i-2]相等都能往里面放</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">2</span> || num != nums[i-<span class="number">2</span>])</span><br><span class="line">                nums[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Remove_Duplicates_from_Sorted_Array_I">Remove Duplicates from Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Given a sorted array, rem]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]H-Index I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-H-Index-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-H-Index-I-II/</id>
    <published>2016-06-10T04:15:37.000Z</published>
    <updated>2016-06-10T07:48:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="H-Index_I">H-Index I</h2><h3 id="题目描述">题目描述</h3><p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”</p>
<p>For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.</p>
<p><strong> Note: </strong>If there are several possible values for h, the maximum one is taken as the h-index.</p>
<p><strong> Hint: </strong></p>
<pre><code>1. An easy approach is to sort the<span class="instruction"> array </span>first.
2. What are the possible values of h-index?
3. A faster approach is to use extra space.
</code></pre><p>一名科学家的h指数是指其发表的N篇论文中有h篇每篇至少被引用了h次，其余的N-h篇引用次数均不超过h次(小于或等于)。使用数组count记录引用次数在0~N的文章篇数，引用次数大于N文章也算做引用了N次的文章(h指数小于等于论文总数N)。然后从后往前遍历，并统计引用次数至少为i次文章数量。</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//一名科学家的h指数是指其发表的N篇论文中有h篇每篇至少被引用了h次，其余的N-h篇引用次数均不超过h次(小于或等于)</span></span><br><span class="line">    <span class="comment">//使用数组count记录引用次数在0~N的文章篇数，引用次数大于N文章也算做引用了N次的文章(h指数小于等于论文总数N)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(citations == null || citations.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = citations.length;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> citation: citations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(citation &gt; length) count[length]++;</span><br><span class="line">            <span class="keyword">else</span> count[citation]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//然后从后往前遍历，并统计引用次数至少为i次文章数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            total += count[i];</span><br><span class="line">            <span class="comment">//有total篇文章每篇至少被引用了i次，则h指数为i</span></span><br><span class="line">            <span class="comment">//total&gt;=i,所以肯定满足有i篇文章每篇至少被引用了i次</span></span><br><span class="line">            <span class="keyword">if</span>(total &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用排序的方法，但那样的时间复杂度为O(nlgn)。按文章引用次数升序排序代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(citations == null || citations.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line">        <span class="keyword">int</span> length = citations.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; citations.length; i++)&#123;</span><br><span class="line">            <span class="comment">// if(length &lt;= citations[i])&#123;</span></span><br><span class="line">            <span class="comment">//     return length;</span></span><br><span class="line">            <span class="comment">// &#125;else&#123;</span></span><br><span class="line">            <span class="comment">//     length--;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">//等价于</span></span><br><span class="line">            <span class="keyword">if</span>(citations[i] &gt;= length - i)</span><br><span class="line">                <span class="keyword">return</span> length - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="H-Index_I-1">H-Index I</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?</p>
<p><strong> Hint: </strong></p>
<pre><code><span class="number">1</span>. Expected runtime complexity is <span class="keyword">in</span> <span class="function"><span class="title">O</span><span class="params">(log n)</span></span> and the <span class="tag">input</span> is sorted.
</code></pre><h3 id="代码-1">代码</h3><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hIndex(<span class="built_in">int</span>[] citations) &#123;</span><br><span class="line">        <span class="keyword">if</span>(citations == <span class="literal">null</span> || citations.length == <span class="number">0</span>) return <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = citations.length - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> length = citations.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt;= <span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (<span class="built_in">right</span> - <span class="built_in">left</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(citations[<span class="built_in">mid</span>] == length - <span class="built_in">mid</span>) return length - <span class="built_in">mid</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(citations[<span class="built_in">mid</span>] &gt; length - <span class="built_in">mid</span>) <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">left</span> = <span class="built_in">mid</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return length - <span class="built_in">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="H-Index_I">H-Index I</h2><h3 id="题目描述">题目描述</h3><p>According to the definition of h-index on Wikipedia: “A scientist has index h if ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Find Peak Element]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Find-Peak-Element/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Find-Peak-Element/</id>
    <published>2016-06-10T04:03:06.000Z</published>
    <updated>2016-06-10T05:24:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array where <font color="red">num[i] ≠ num[i+1]</font>, find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that <font color="red">num[-1] = num[n] = -∞</font>.</p>
<p>For example, in array <font color="red">[1, 2, 3, 1]</font>, 3 is a peak element and your function should return the index number 2.</p>
<p><strong> Note: </strong><br>Your solution should be in logarithmic complexity.</p>
<p>local maximum就是一个peek，mid = (left + right)/2,mid1 = mid + 1<br>如果nums[mid] &lt; nums[mid1]，那么nums[mid1…right]一定有peek，为什么？因为相邻的数不能相等,那么mid1右边的数只能增加或者减少，如果mid1右边的数一直增加，则nums[right]就是peek，否则的话mid1右边的数出现下降的时候就会出现peek同理nums[mid] &gt; nums[mid1]，那么nums[left, mid]一定有peek，道理是一样的。因为相邻的数不能相等,那么mid左边的数只能增加或者减少，如果mid左边的数一直增加，则nums[left]就是peek，否则的话mid左边的数出现下降的时候就会出现peek。</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//local maximum就是一个peek</span></span><br><span class="line">    <span class="comment">//mid = (left + right)/2,mid1 = mid + 1</span></span><br><span class="line">    <span class="comment">//如果nums[mid] &lt; nums[mid1]，那么nums[mid1...right]一定有peek，为什么？</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid1右边的数只能增加或者减少，如果mid1右边的数一直增加，则nums[right]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid1右边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="comment">//同理nums[mid] &gt; nums[mid1]，那么nums[left, mid]一定有peek，道理是一样的</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid左边的数只能增加或者减少，如果mid左边的数一直增加，则nums[left]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid左边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> mid1 = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右边一定有peek</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid1])&#123;</span><br><span class="line">                left = mid1;</span><br><span class="line">            <span class="comment">//左边一定有peek</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="comment">//如果出现相等就不符合题目中相邻元素不相等，可以抛异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历的方法不符合时间复杂度，但是实现非常tricky，代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//遍历的方法不符合时间复杂度，但是实现非常tricky</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//右边有减小的话则peek出现</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>]) <span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则元素一直增大到最右边元素就是peek</span></span><br><span class="line">        <span class="keyword">return</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array where <font color="re]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Set Matrix Zeroes]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Set-Matrix-Zeroes/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Set-Matrix-Zeroes/</id>
    <published>2016-06-10T02:39:50.000Z</published>
    <updated>2016-06-10T02:44:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p><strong> Follow up: </strong><br>Did you use extra space?<br>A straight forward solution using O(mn) space is probably a bad idea.<br>A simple improvement uses O(m + n) space, but still not the best solution.<br>Could you devise a constant space solution?</p>
<p>mxn的矩阵，比较直接的思路就是用两个数组记录哪一列需要置为0，哪一行需要置为0。比如int[rows]、int[cols]或者用boolean数组也可以，这样的话我们需要O(m+n)的空间复杂度，其实我们可以省掉这些空间开销，只需要O(1)的空间复杂度，方法就是复用matrix数组的第0行和第0列，而matrix本身的第0行和第0列是否需要置为0，我们只要利用两个变量比如row0和col0记录下来就可以,其实也可以精简到只用一个变量col0就可以，我感觉那样做代码虽然精简但没有那么好理解，没必要为了节省一个变量和精简代码而牺牲代码可读性。</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//mxn的矩阵，比较直接的思路就是用两个数组记录哪一列需要置为0，哪一行需要置为0</span></span><br><span class="line">    <span class="comment">//int[rows]、int[cols]或者用boolean数组也可以，这样的话我们需要O(m+n)的空间复杂度，其实我们可以</span></span><br><span class="line">    <span class="comment">//省掉这些空间开销，只需要O(1)的空间复杂度，方法就是复用matrix数组的第0行和第0列，而matrix本身的</span></span><br><span class="line">    <span class="comment">//第0行和第0列是否需要置为0，我们只要利用两个变量比如row0和col0记录下来就可以,其实也可以精简到只用</span></span><br><span class="line">    <span class="comment">//一个变量col0就可以，我感觉那样做代码虽然精简但没有那么好理解，没必要为了节省一个变量和精简代码而牺牲代码可读性。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        boolean row0 = <span class="literal">false</span>, col0 = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果原始数组的第0行有元素为0，那么最终第0行也是要全部置为0，用row0 = true表示</span></span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>) row0 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//如果原始数组的第0列有元素为0，那么最终第0列也是要全部置为0，用row0 = true表示</span></span><br><span class="line">                    <span class="keyword">if</span>(j == <span class="number">0</span>) col0 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//第i行和第j列都要置为0，记录在matrix[i][0]和matrix[0][j]中</span></span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(row0)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(col0)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p><strong> Foll]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Peeking Iterator]]></title>
    <link href="http://blog.noobsky.com/2016/06/10/LeetCode-Peeking-Iterator/"/>
    <id>http://blog.noobsky.com/2016/06/10/LeetCode-Peeking-Iterator/</id>
    <published>2016-06-10T00:58:11.000Z</published>
    <updated>2016-06-10T01:07:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation – it essentially peek() at the element that will be returned by the next call to next().</p>
<p>Here is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3].</p>
<p>Call next() gets you 1, the first element in the list.</p>
<p>Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.</p>
<p>You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false.</p>
<p><strong> Hint: </strong></p>
<pre><code>1. Think of "looking ahead". You want to <span class="operator"><span class="keyword">cache</span> the <span class="keyword">next</span> <span class="keyword">element</span>.
<span class="number">2.</span> <span class="keyword">Is</span> one <span class="keyword">variable</span> sufficient? Why <span class="keyword">or</span> why <span class="keyword">not</span>?
<span class="number">3.</span> <span class="keyword">Test</span> your design <span class="keyword">with</span> <span class="keyword">call</span> <span class="keyword">order</span> <span class="keyword">of</span> peek() <span class="keyword">before</span> <span class="keyword">next</span>() vs <span class="keyword">next</span>() <span class="keyword">before</span> peek().
<span class="number">4.</span> <span class="keyword">For</span> a clean implementation, <span class="keyword">check</span> <span class="keyword">out</span> Google<span class="string">'s guava library source code.</span></span>
</code></pre><p>Follow up: How would you extend your design to be generic and work with all types, not just integer?</p>
<h2 id="代码">代码</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">Java</span> <span class="type">Iterator</span> <span class="keyword">interface</span> reference:</span><br><span class="line">// https://docs.oracle.com/javase/<span class="number">8</span>/docs/api/java/util/<span class="type">Iterator</span>.html</span><br><span class="line">//可以将next元素缓存起来，如果next为null则说明<span class="type">Iterator</span>没有元素了</span><br><span class="line">class <span class="type">PeekingIterator</span> implements <span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; &#123;</span><br><span class="line">    private <span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; iter;</span><br><span class="line">    private <span class="type">Integer</span> next = null;</span><br><span class="line">	public <span class="type">PeekingIterator</span>(<span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; <span class="keyword">iterator</span>) &#123;</span><br><span class="line">	    // initialize <span class="type">any</span> member here.</span><br><span class="line">	    iter = <span class="keyword">iterator</span>;</span><br><span class="line">	    <span class="keyword">if</span>(iter.hasNext())</span><br><span class="line">	        next = iter.next();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // <span class="type">Returns</span> the next element <span class="keyword">in</span> the iteration <span class="keyword">without</span> advancing the <span class="keyword">iterator</span>.</span><br><span class="line">	public <span class="type">Integer</span> peek() &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// hasNext() <span class="keyword">and</span> next() should behave the same <span class="keyword">as</span> <span class="keyword">in</span> the <span class="type">Iterator</span> <span class="keyword">interface</span>.</span><br><span class="line">	// <span class="type">Override</span> them <span class="keyword">if</span> needed.</span><br><span class="line">	@<span class="type">Override</span></span><br><span class="line">	public <span class="type">Integer</span> next() &#123;</span><br><span class="line">	    <span class="type">Integer</span> res = next;</span><br><span class="line">	    //更新next元素</span><br><span class="line">	    next = iter.hasNext() ? iter.next() : null;</span><br><span class="line">	    //返回前一next元素</span><br><span class="line">	    <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@<span class="type">Override</span></span><br><span class="line">	public boolean hasNext() &#123;</span><br><span class="line">	    <span class="keyword">return</span> next != null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Google’s_guava">Google’s guava</h2><p>guava的实现使用peekedElement记录peek元素，并使用一个标记位hasPeeked来判断是否有peek元素，Google’s guava的实现如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * <span class="type">Implementation</span> <span class="keyword">of</span> <span class="type">PeekingIterator</span> that avoids peeking unless necessary.</span><br><span class="line">   */</span><br><span class="line">  private <span class="keyword">static</span> class <span class="type">PeekingImpl</span>&lt;E&gt; implements <span class="type">PeekingIterator</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final <span class="type">Iterator</span>&lt;? extends E&gt; <span class="keyword">iterator</span>;</span><br><span class="line">    private boolean hasPeeked;</span><br><span class="line">    private E peekedElement;</span><br><span class="line"></span><br><span class="line">    public <span class="type">PeekingImpl</span>(<span class="type">Iterator</span>&lt;? extends E&gt; <span class="keyword">iterator</span>) &#123;</span><br><span class="line">      this.<span class="keyword">iterator</span> = checkNotNull(<span class="keyword">iterator</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">      <span class="keyword">return</span> hasPeeked || <span class="keyword">iterator</span>.hasNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    public E next() &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasPeeked) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">iterator</span>.next();</span><br><span class="line">      &#125;</span><br><span class="line">      E <span class="literal">result</span> = peekedElement;</span><br><span class="line">      hasPeeked = <span class="literal">false</span>;</span><br><span class="line">      peekedElement = null;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    public <span class="type">void</span> remove() &#123;</span><br><span class="line">      checkState(!hasPeeked, <span class="string">"Can't remove after you've peeked at next"</span>);</span><br><span class="line">      <span class="keyword">iterator</span>.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    public E peek() &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasPeeked) &#123;</span><br><span class="line">        peekedElement = <span class="keyword">iterator</span>.next();</span><br><span class="line">        hasPeeked = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> peekedElement;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Kth Largest Element in an Array]]></title>
    <link href="http://blog.noobsky.com/2016/06/08/LeetCode-Kth-Largest-Element-in-an-Array/"/>
    <id>http://blog.noobsky.com/2016/06/08/LeetCode-Kth-Largest-Element-in-an-Array/</id>
    <published>2016-06-08T06:32:43.000Z</published>
    <updated>2016-06-09T16:49:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given <font color="red">[3,2,1,5,6,4]</font> and k = 2, return 5.</p>
<p><strong> Note: </strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<h2 id="解题思路与代码">解题思路与代码</h2><h3 id="排序法">排序法</h3><p>将数组排序，然后返回第K大的数组元素<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span>(<span class="params"><span class="keyword">int</span>[] nums, <span class="keyword">int</span> k</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//if(nums == null || nums.length == 0) return -1;</span></span><br><span class="line">        <span class="comment">//check if 1&lt;= k &lt;= nums.length</span></span><br><span class="line">        <span class="comment">//排序，O(nlgn)</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的<font color="red">时间复杂度为O(nlgn)，空间复杂度为O(1)</font>。</p>
<h3 id="堆">堆</h3><p>维护k个元素的最小堆，遍历数组，将每个元素加入堆中，当堆的大小大于k时，删除堆顶元素，最后堆中为top k元素，堆顶最小，则为第k大元素</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	    <span class="comment">//维护k个元素的最小堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用优先级队列模拟堆，构造函数不提供Comparator函数，则优先级队列中元素以自然顺序排列</span></span><br><span class="line">        <span class="comment">//相当于最小堆，堆顶是堆中最小的元素</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">        <span class="comment">// for(int num: nums)&#123;</span></span><br><span class="line">        <span class="comment">//     if(pq.size() &lt; k)&#123;</span></span><br><span class="line">        <span class="comment">//         pq.offer(num);</span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//         if(num &gt; pq.peek())&#123;</span></span><br><span class="line">        <span class="comment">//             pq.offer(num);</span></span><br><span class="line">        <span class="comment">//             pq.poll();</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            pq.offer(num);</span><br><span class="line">            <span class="comment">//如果优先级队列中元素个数大于k，则删除堆顶元素（堆中最小）</span></span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k) pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时，堆中为top k元素，堆顶最小，则为第k大元素</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> pq.<span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆方法的<font color="red">时间复杂度为O(nlgk)，空间复杂度为O(k)</font>。</p>
<h3 id="快速选择算法(Quickselect)">快速选择算法(Quickselect)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="comment">//two pointers</span></span><br><span class="line">        <span class="comment">//小于等于枢纽（主元）的元素都往前放，从left下标开始</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//i左边的数即[left, i)都比pivot小，i&lt;=位置&lt;j的数即[i, j)都比pivot大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i位置为pivot最后的位置</span></span><br><span class="line">        swap(nums,i, right);</span><br><span class="line">        <span class="comment">//返回主元的位置,i左边的元素都比nums[i]小，右边都比nums[i]大</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//另一种partition的实现,特别容易写错，比如写成nums&lt;pivot和nums[j]&gt;pivot时，在nums[i] = nums[j]= pivot</span></span><br><span class="line">    <span class="comment">//会造成死循环，看看就好，以后不写这个版本的了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;right &amp;&amp; nums[i] &lt;= pivot) i++;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;left &amp;&amp; nums[j] &gt;= pivot) j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) swap(nums, i, j);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, right);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分函数的随机化版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomizedPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//nextInt(i)产生[0, i)中的随机数</span></span><br><span class="line">        <span class="comment">//nextInt(right - left)为[0, right - left+1) + left =&gt; [left, right]</span></span><br><span class="line">        <span class="keyword">int</span> randomIndex = random.nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        <span class="comment">//随机选择[left, right]中的元素有nums[right]交换，会nums[right]作为pivot，相当于随机选择一个元素作为pivot</span></span><br><span class="line">        swap(nums, randomIndex, right);</span><br><span class="line">        <span class="keyword">return</span> partition(nums, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回第k小的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//处理k的非法值</span></span><br><span class="line">        <span class="comment">//if(k &lt; 1 || k &gt; (right - left + 1)) return -1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivotIndex = randomizedPartition(nums, left, right);</span><br><span class="line">        <span class="keyword">int</span> s = pivotIndex - left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对三种情况进行处理：s = pivotIndex - left + 1</span></span><br><span class="line">        <span class="comment">//s == k: 即返回的主元就是我们要找的第k小的元素</span></span><br><span class="line">        <span class="comment">//s &lt; k : 那么接下来要到高区间nums[pivotIndex+1, right]寻找, 丢掉低区间</span></span><br><span class="line">        <span class="comment">//s &gt; k : 那么接下来要到低区间nums[left, pivotIndex - 1]寻找，丢掉高区间</span></span><br><span class="line">        <span class="keyword">if</span>(s == k) <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; k) <span class="keyword">return</span> quickSelect(nums, pivotIndex + <span class="number">1</span>, right, k - s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第k大，就是第nums.length - k + 1小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法叫快速选择，类似快速排序，但是快速选择只需处理一个子问题，而快排需要处理两个子问题。详见维基百科<a href="https://en.wikipedia.org/wiki/Quickselect" target="_blank" rel="external">Quickselect</a>。该算法<font color="red">最好情况的时间复杂度为O(n)，最坏情况下时间复杂度为O(n<sup>2</sup>)，平均时间复杂度为O(n)</font>。我们可以利用随机化版本的Partition函数大大降低最坏情况发生的概率,如上代码，应该也可以利用洗牌算法对数组进行洗牌（随机化)降低最坏情况发生的概率。如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//洗牌算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//每次让nums[i]和nums[0.....i]中随机一元素交换</span></span><br><span class="line">        <span class="comment">//i=0自己跟自己交换没必要循环了，jdk也类似这样写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            swap(nums, i, random.nextInt(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="comment">//two pointers</span></span><br><span class="line">        <span class="comment">//小于等于枢纽（主元）的元素都往前放，从left下标开始</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//i左边的数即[left, i)都比pivot小，i&lt;=位置&lt;j的数即[i, j)都比pivot大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i位置为pivot最后的位置</span></span><br><span class="line">        swap(nums,i, right);</span><br><span class="line">        <span class="comment">//返回主元的位置,i左边的元素都比nums[i]小，右边都比nums[i]大</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//返回第k小的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//处理k的非法值</span></span><br><span class="line">        <span class="comment">//if(k &lt; 1 || k &gt; (right - left + 1)) return -1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">int</span> s = pivotIndex - left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对三种情况进行处理：s = pivotIndex - left + 1</span></span><br><span class="line">        <span class="comment">//s == k: 即返回的主元就是我们要找的第k小的元素</span></span><br><span class="line">        <span class="comment">//s &lt; k : 那么接下来要到高区间nums[pivotIndex+1, right]寻找, 丢掉低区间</span></span><br><span class="line">        <span class="comment">//s &gt; k : 那么接下来要到低区间nums[left, pivotIndex - 1]寻找，丢掉高区间</span></span><br><span class="line">        <span class="keyword">if</span>(s == k) <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; k) <span class="keyword">return</span> quickSelect(nums, pivotIndex + <span class="number">1</span>, right, k - s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//第k大，就是第nums.length - k + 1小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以使用Median of medians算法，也叫BRPRT算法，详见维基百科<a href="https://en.wikipedia.org/wiki/Median_of_medians" target="_blank" rel="external">Median of medians</a>。该算法使用五分化中项的中项的方法来选择枢纽元素，该<font color="red">算法能保证快速选择算法最坏情况下时间复杂度也为O(n)</font>。虽然该算法理论上是O(n)的，但是这个算法n的系数实际上比较大，所以还是随机化快速选择更有实际意义，也更简单。另外，这个思路也可以应用到优化快速排序最坏情况的时间复杂度问题上去。我们还可以使用Introselect算法，详见维基百科<a href="https://en.wikipedia.org/wiki/Introselect" target="_blank" rel="external">Introselect</a>。使用BFBRT实现本题代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第k大，就是第nums.length - k + 1小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BFPRT(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//nums[left,...right]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">BFPRT</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> groupSize = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//nums中的元素个数小于等于5排序后直接返回第k个数</span></span><br><span class="line">        <span class="keyword">if</span>(size &lt;= <span class="number">5</span>)&#123;</span><br><span class="line">            Arrays.sort(nums, left, right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> nums[left + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算五分后有几组 或者groupNum = (size + groupSize - 1) / groupSize;</span></span><br><span class="line">        <span class="keyword">int</span> groupNum = size % groupSize &gt; <span class="number">0</span> ? size / groupSize + <span class="number">1</span> : size / groupSize;</span><br><span class="line">        <span class="comment">//对每组数进行排序找出中位数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; groupNum; i++)&#123;</span><br><span class="line">            <span class="comment">//每组数开始下标</span></span><br><span class="line">            <span class="keyword">int</span> subLeft = left + i * groupSize;</span><br><span class="line">            <span class="comment">//结束下标</span></span><br><span class="line">            <span class="keyword">int</span> subRight = subLeft + groupSize - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//最后一组有可能大于right</span></span><br><span class="line">            <span class="keyword">if</span>(subRight &gt; right)&#123;</span><br><span class="line">                subRight = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对每组数排序来求出该组的中位数，Arrays.sort函数</span></span><br><span class="line">            Arrays.sort(nums, subLeft, subRight + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//每组数中位数的下标(left + right) / 2 </span></span><br><span class="line">            <span class="keyword">int</span> median = subLeft + (subRight - subLeft) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//中位数移到数组的前面，对这些中位数递归调用BFPRT算法求得他们的中位数。</span></span><br><span class="line">            <span class="comment">//也可以另外用一个存中位数的数组medians，如果这样做虽然程序可能更简单，但是这样我们</span></span><br><span class="line">            <span class="comment">//只能知道中位数的中位数的值，传入到Partition后还需要遍历一下nums找出中位数的中位数的下标:(</span></span><br><span class="line">            swap(nums, left+i, median);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算中位数们的中位数的下标这里的right = left + groupNum - 1，则left + (right - left) / 2可得如下</span></span><br><span class="line">        <span class="keyword">int</span> pivotIndex = left + (groupNum - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">////不关心中位数的值，保证中位数在正确的位置,因为k从1开始算，groupNum/2是从0开始算的</span></span><br><span class="line">        <span class="comment">// IMPORTANT !!</span></span><br><span class="line">       <span class="comment">// Recurse to call and place the median on the pivot_index, without care about the median value</span></span><br><span class="line">       <span class="comment">// Because the value of pivot_index must be the median after select function recursive call.</span></span><br><span class="line">        BFPRT(nums, left, left + groupNum - <span class="number">1</span>, (groupNum+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> midIndex = partition(nums, left, right, pivotIndex);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s = midIndex - left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对三种情况进行处理：s = midIndex - left + 1</span></span><br><span class="line">        <span class="comment">//s == k: 即返回的主元就是我们要找的第k小的元素</span></span><br><span class="line">        <span class="comment">//s &lt; k : 那么接下来要到高区间nums[midIndex+1, right]寻找, 丢掉低区间</span></span><br><span class="line">        <span class="comment">//s &gt; k : 那么接下来要到低区间nums[left, midIndex - 1]寻找，丢掉高区间</span></span><br><span class="line">        <span class="keyword">if</span>(s == k) <span class="keyword">return</span> nums[midIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; k) <span class="keyword">return</span> BFPRT(nums, midIndex + <span class="number">1</span>, right, k - s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> BFPRT(nums, left, midIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> pivotIndex)</span></span>&#123;</span><br><span class="line">        swap(nums, pivotIndex, right);</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="comment">//two pointers</span></span><br><span class="line">        <span class="comment">//小于等于枢纽（主元）的元素都往前放，从left下标开始</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//i左边的数即[left, i)都比pivot小，i&lt;=位置&lt;j的数即[i, j)都比pivot大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i位置为pivot最后的位置</span></span><br><span class="line">        swap(nums,i, right);</span><br><span class="line">        <span class="comment">//返回主元的位置,i左边的元素都比nums[i]小，右边都比nums[i]大</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献">参考文献</h2><p><a href="https://en.wikipedia.org/wiki/Selection_algorithm" target="_blank" rel="external">Selection algorithm</a><br><a href="https://en.wikipedia.org/wiki/Quickselect" target="_blank" rel="external">Quickselect</a><br><a href="https://en.wikipedia.org/wiki/Median_of_medians" target="_blank" rel="external">Median of medians</a><br><a href="https://en.wikipedia.org/wiki/Introselect" target="_blank" rel="external">Introselect</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6370650" target="_blank" rel="external">程序员编程艺术：第三章、寻找最小的k个数</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6403777" target="_blank" rel="external">程序员编程艺术：第三章续、Top K算法问题的实现</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6431001" target="_blank" rel="external">十四、第三章再续：快速选择SELECT算法的深入分析与实现</a><br><a href="http://noalgo.info/466.html" target="_blank" rel="external">BFPRT算法</a><br><a href="http://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array-set-3-worst-case-linear-time/" target="_blank" rel="external">Kth Smallest/Largest Element in Unsorted Array | Set 3 (Worst Case Linear Time)
</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, no]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Increasing Triplet Subsequence]]></title>
    <link href="http://blog.noobsky.com/2016/06/07/LeetCode-Increasing-Triplet-Subsequence/"/>
    <id>http://blog.noobsky.com/2016/06/07/LeetCode-Increasing-Triplet-Subsequence/</id>
    <published>2016-06-07T10:40:19.000Z</published>
    <updated>2016-06-08T06:33:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Formally the function should:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Return <span class="constant">true</span> <span class="keyword">if</span> there exists i, j, k </span><br><span class="line">such <span class="keyword">that</span> arr[i] &lt; arr[j] &lt; arr[k] <span class="keyword">given</span> <span class="number">0</span> ≤ i &lt; j &lt; k ≤ n-<span class="number">1</span> <span class="keyword">else</span> <span class="constant">return</span> <span class="constant">false</span>.</span><br></pre></td></tr></table></figure>
<p>Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>
<p><strong> Examples: </strong><br>Given <font color="red">[1, 2, 3, 4, 5]</font>,<br>return <font color="red">true</font>.</p>
<p>Given <font color="red">[5, 4, 3, 2, 1]</font>,<br>return <font color="red">false</font>.</p>
<h2 id="代码">代码</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历数组，维护一个到目前为止最小的数first，second为至少有一个数比second小的所有候选者中最小的数，</span></span><br><span class="line">    <span class="comment">//我们可知first &lt; second,而且second是最小的大于first的数，是最优的递增三元子序列第二个候选元素。</span></span><br><span class="line">    <span class="comment">//如果数组元素小于等于first更新first，如果大于first但小于等于second，则更新second的值</span></span><br><span class="line">    <span class="comment">//如果出现大于second的数，则返回true</span></span><br><span class="line">    public boolean increasingTriplet(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> first = Integer.MAX_VALUE, second = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> <span class="built_in">num</span>: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">num</span> &lt;= first)&#123;</span><br><span class="line">                first = <span class="built_in">num</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">num</span> &lt;= second)&#123;</span><br><span class="line">                second = <span class="built_in">num</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//程序能执行到这说明存在first &lt; second &lt; num[i]</span></span><br><span class="line">                <span class="comment">//所以存在递增三元子序列，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Fo]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Longest Increasing Subsequence]]></title>
    <link href="http://blog.noobsky.com/2016/06/07/LeetCode-Longest-Increasing-Subsequence/"/>
    <id>http://blog.noobsky.com/2016/06/07/LeetCode-Longest-Increasing-Subsequence/</id>
    <published>2016-06-07T01:30:36.000Z</published>
    <updated>2016-06-07T07:20:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>For example,<br>Given [10, 9, 2, 5, 3, 7, 101, 18],<br>The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p>
<p>Your algorithm should run in O(n2) complexity.</p>
<p>Follow up: Could you improve it to O(n log n) time complexity?</p>
<h2 id="解法一：排序+LCS">解法一：排序+LCS</h2><p>这个问题可以转换为最长公共子序列问题。如数组A:[10, 9, 2, 5, 3, 7, 101, 18]，对该数组排序得到数组A’:[2, 3, 5, 7, 9, 10, 18, 101]，然后找出A和A’的最长公共子序列即可。这里的最长公共子序列就是[2, 3, 7, 18]或者[2, 3, 7, 101]。最长公共子序列（LCS）算法详见算法导论。其主要思想如下：<br>假定两个序列为X={x<sub>1</sub>, x<sub>2</sub>, …, x<sub>m</sub>}和Y={y<sub>1</sub>, y<sub>2</sub>, …, y<sub>n</sub>)，并设Z={z<sub>1</sub>, z<sub>2</sub>, …, z<sub>k</sub>}为X和Y的任意一个LCS。<br>1）如果x<sub>m</sub> = y<sub>n</sub>，则z<sub>k</sub> = x<sub>m</sub>=y<sub>n</sub>，且Z<sub>k-1</sub>是X<sub>m-1</sub>和Y<sub>n-1</sub>的一个LCS。<br>2）如果x<sub>m</sub> != y<sub>n</sub>, 则z<sub>k</sub> != x<sub>m</sub>意味着Z是X<sub>m-1</sub>和Y的一个LCS。<br>3）如果x<sub>m</sub> != y<sub>n</sub>, 则z<sub>k</sub> != y<sub>n</sub>意味着Z是X和Y<sub>n-1</sub>的一个LCS。<br>我们定义c[i, j]表示X<sub>i</sub>和Y<sub>j</sub>的LCS的长度，则可得以下公式：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/LCS_1.PNG" alt=""><br><img src="http://7xonwi.com1.z0.glb.clouddn.com/LCS_2.PNG" alt=""><br>但是如果有重复元素，用LCS的方法得到的结果不对，用LCS在LeetCode上AC不了，比如[2,2],LCS的长度为2，但是LIS的长度是1。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] numsCopy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        numsCopy = Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">        Arrays.sort(numsCopy);</span><br><span class="line">        <span class="comment">//System.arraycopy(nums, 0, numsCopy, 0, nums.length);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>][nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i-<span class="number">1</span>] == numsCopy[j-<span class="number">1</span>])&#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][nums.length];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二：动态规划（O(n2)）">解法二：动态规划（O(n<sup>2</sup>)）</h2><p>设长度为n的数组为{a0, a1, a2, … an-1}，以a[j]结尾的最长递增子序列为L(j)，则L(j) = {max(L(i))+1, i&lt;j且a[i]&lt;a[j]}，也就是说，我们需要遍历在j之前的所有位置i(从0到j-1)，找出满足条件a[i]&lt;a[j]的L(i)，求出max(L(i))+1即为L(j)的值。最后，我们遍历所有的L(j)（从0到n-1），找出最大值即为最大递增子序列。时间复杂度为O(n^2)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//dp[j] = max(dp[i]) + 1 i&lt;j&amp;&amp;nums[i] &lt; nums[j]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            dp[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt; nums[j]) dp[j] = Math.max(dp[j], dp[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res = Math.max(res, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法三：动态规划（O(nlgn)）">解法三：动态规划（O(nlgn)）</h2><p>解法二中的动态规划时间复杂度为O(n<sup>2</sup>)，原因是因为对于每一个新的位置j都需要遍历j之前的所以位置，找出之前位置最长递增子序列长度。那么我们是不是可以有一中方法能不用遍历之前所有的位置，而可以更快的确定i的位置呢？</p>
<p>我们使用数组ends，ends[i]记录的是最长递增子序列长度为i的序列的末尾元素的值，如果有多个递增子序列的长度都为i，那么ends[i]的值是这些长度为i的最长递增子序列的末尾元素的值中最小的元素（长度为i的那些LIS中的最小末尾）。则ends数组的长度就是所求最长递增子序列的长度。</p>
<p>假设存在一个序列d[1..9] ={ 2，1 ，5 ，3 ，6，4， 8 ，9， 7}，可以看出来它的LIS长度为5。下面一步一步试着求ends。</p>
<p>首先，把d[1]有序地放到ends里，令ends[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1</p>
<p>然后，把d[2]有序地放到ends里，令ends[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，很容易理解吧。这时Len=1</p>
<p>接着，d[3] = 5，d[3]&gt;ends[1]，所以令ends[1+1]=ends[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候ends[1..2] = 1, 5，Len＝2</p>
<p>再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候ends[1..2] = 1, 3，Len = 2</p>
<p>继续，d[5] = 6，它在3后面，因为ends[2] = 3, 而6在3后面，于是很容易可以推知ends[3] = 6, 这时ends[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。</p>
<p>第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到ends[3] = 4。ends[1..3] = 1, 3, 4， Len继续等于3</p>
<p>第7个, d[7] = 8，它很大，比4大，嗯。于是ends[4] = 8。Len变成4了</p>
<p>第8个, d[8] = 9，得到ends[5] = 9，嗯。Len继续增大，到5了。</p>
<p>最后一个, d[9] = 7，它在ends[3] = 4和ends[4] = 8之间，所以我们知道，最新的ends[4] =7，ends[1..5] = 1, 3, 4, 7, 9，Len = 5。</p>
<p>于是我们知道了LIS的长度为5。</p>
<p>注意，这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到ends[5], 9更新到ends[6]，得出LIS的长度为6。</p>
<p>然后应该发现一件事情了：在ends中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)。于是算法的时间复杂度就降低到了O(NlogN)！</p>
<p>简而言之，先建立一个数组ends，把首元素放进去，然后比较之后的元素，如果遍历到的新元素比ends数组中的首元素小的话，替换首元素为此新元素，如果遍历到的新元素比ends数组中的末尾元素还大的话，将此新元素添加到ends数组末尾(注意不覆盖原末尾元素)。如果遍历到的新元素比ends数组首元素大，比尾元素小时，此时用二分查找法找到第一个不小于此新元素的位置，覆盖掉位置的原来的数字，以此类推直至遍历完整个nums数组，此时ends数组的长度就是我们要求的LIS的长度，特别注意的是ends数组的值可能不是一个真实的LIS，比如若输入数组nums为{4, 2， 4， 5， 3， 7}，那么算完后的ends数组为{2， 3， 5， 7}，可以发现它不是一个原数组的LIS，只是长度相等而已，千万要注意这点。参见代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//1.排序后的序列和原序列求LCS最长公共子序列</span></span><br><span class="line">    <span class="comment">//2.dp (O(n*n))</span></span><br><span class="line">    <span class="comment">//3.dp (O(nlgn))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//二分搜索可以利用Arrays.binarySearch(int[] a, int fromIndex, int toIndex, int key),</span></span><br><span class="line">        <span class="comment">//该函数的返回值是这样的：如果a中存在key，则返回key在a中的index，不存在key返回-insertionpoint-1，所以</span></span><br><span class="line">        <span class="comment">//此时insertionpoint =  -(返回值+1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ret = Arrays.binarySearch(ends, <span class="number">0</span>, len, nums[i]);</span><br><span class="line">            <span class="comment">//小于0，不存在key，计算插入位置</span></span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) ret = -(ret+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//或者使用自己二分搜索函数</span></span><br><span class="line">            <span class="comment">//int ret = binarySearch(ends, 0, len, nums[i]);</span></span><br><span class="line">            ends[ret] = nums[i];</span><br><span class="line">            <span class="comment">//在ends尾部增加了一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(ret == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果不记得Arrays.binarySearch返回值的含义，可以自己写一个二分搜索函数，</span></span><br><span class="line">    <span class="comment">//如果存在key返回index，不存在时返回插入位置的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = fromIndex, right = toIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == key) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; key) right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题描述">问题描述</h2><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>For example,<br>Giv]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Combinations]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Combinations/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Combinations/</id>
    <published>2016-06-06T15:38:49.000Z</published>
    <updated>2016-06-06T15:41:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>For example,<br>If n = 4 and k = 2, a solution is:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        helper(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> void helper(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">List</span>&lt;Integer&gt; curr, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; i++)&#123;</span><br><span class="line">            curr.add(i);</span><br><span class="line">            helper(n, k-<span class="number">1</span>, i+<span class="number">1</span>, curr, res);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>For example,<br>If ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Search a 2D Matrix I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Search-a-2D-Matrix-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Search-a-2D-Matrix-I-II/</id>
    <published>2016-06-06T13:36:32.000Z</published>
    <updated>2016-06-06T14:57:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Search_a_2D_Matrix_I">Search a 2D Matrix I</h2><h3 id="题目描述">题目描述</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p>For example,</p>
<p>Consider the following matrix:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Given target = 3, return true.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;    </span><br><span class="line">    <span class="comment">//row*col矩阵转换为数组=&gt;matrix[i][j] =&gt; array[i * col + j] </span></span><br><span class="line">    <span class="comment">//数组转换为矩阵array[i] =&gt; matrix[i / col][i % col]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right - left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(matrix[mid/col][mid % col] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid/col][mid % col] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid/col][mid % col] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_a_2D_Matrix_II">Search a 2D Matrix II</h2><h3 id="题目描述-1">题目描述</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p>For example,</p>
<p>Consider the following matrix:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Given target = 5, return true.</p>
<p>Given target = 20, return false.</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//初始比较位置为右上角即matrix[0][col-1],如果target大于该值，那么target不可能在该row，因为每一row都是升序，可以排除该row</span></span><br><span class="line">    <span class="comment">//如果target小于该值，那么target不可能在该col，因为每一col都是升序的，可以排除该col，</span></span><br><span class="line">    <span class="comment">//如果相等，返回</span></span><br><span class="line">    <span class="comment">//时间复杂度O(m+n) </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[row][col])&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[row][col])&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Search_a_2D_Matrix_I">Search a 2D Matrix I</h2><h3 id="题目描述">题目描述</h3><p>Write an efficient algorithm that searches for a value in a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sort Colors]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Sort-Colors/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Sort-Colors/</id>
    <published>2016-06-06T11:44:14.000Z</published>
    <updated>2016-06-06T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note:<br>You are not suppose to use the library’s sort function for this problem.</p>
<h2 id="代码一">代码一</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//将0往左边放，2往右边放，1留中间</span></span><br><span class="line">    <span class="comment">//维护两个索引指针left、和right，left初始为0，right初始为nums.length-1</span></span><br><span class="line">    <span class="comment">//然后遍历数组，遇到0时交换到left位置，遇到2时交换到right位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环终止条件为i&lt;=right</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">                nums[left] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[right];</span><br><span class="line">                nums[right] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                <span class="comment">//交换过来的nums[right]有可能是0，i不能++</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码二">代码二</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Ugly Number I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Ugly-Number-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Ugly-Number-I-II/</id>
    <published>2016-06-06T07:22:02.000Z</published>
    <updated>2016-06-06T15:04:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Ugly_Number_I">Ugly Number I</h2><h3 id="题目描述">题目描述</h3><p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>) num = num / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>) num = num / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>) num = num / <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ugly_Number_II">Ugly Number II</h2><h3 id="题目描述-1">题目描述</h3><p>Write a program to find the n-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<p>Hint:</p>
<pre><code><span class="number">1.</span>The naive approach is <span class="built_in">to</span> call isUgly <span class="keyword">for</span> every <span class="built_in">number</span> <span class="keyword">until</span> you reach <span class="operator">the</span> nth <span class="constant">one</span>. Most numbers are <span class="operator">not</span> ugly. Try <span class="built_in">to</span> focus your effort <span class="command"><span class="keyword">on</span> <span class="title">generating</span> <span class="title">only</span> <span class="title">the</span> <span class="title">ugly</span> <span class="title">ones</span>.</span>
<span class="number">2.</span>An ugly <span class="built_in">number</span> must be multiplied <span class="keyword">by</span> either <span class="number">2</span>, <span class="number">3</span>, <span class="operator">or</span> <span class="number">5</span> <span class="built_in">from</span> <span class="operator">a</span> smaller ugly <span class="built_in">number</span>.
<span class="number">3.</span>The key is how <span class="built_in">to</span> maintain <span class="operator">the</span> order <span class="operator">of</span> <span class="operator">the</span> ugly numbers. Try <span class="operator">a</span> similar approach <span class="operator">of</span> merging <span class="built_in">from</span> <span class="constant">three</span> sorted lists: L1, L2, <span class="operator">and</span> L3.
<span class="number">4.</span>Assume you have Uk, <span class="operator">the</span> kth ugly <span class="built_in">number</span>. Then Uk+<span class="number">1</span> must be Min(L1 * <span class="number">2</span>, L2 * <span class="number">3</span>, L3 * <span class="number">5</span>).
</code></pre><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//ugly[0] = 1</span></span><br><span class="line">    <span class="comment">//ugly[1] = min(2*ugly[0], 3*ugly[0], 5*ugly[0])</span></span><br><span class="line">    <span class="comment">//ugly[2] = min(2*ugly[1], 3*ugly[0], 5*ugly[0])</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] ugly = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>, index3 = <span class="number">0</span>, index5 = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;i++)&#123;</span><br><span class="line">            ugly[i] = Math.min(Math.min(<span class="number">2</span> * ugly[index2], <span class="number">3</span> * ugly[index3]), <span class="number">5</span> * ugly[index5]);</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">2</span> * ugly[index2]) index2++;</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">3</span> * ugly[index3]) index3++;</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">5</span> * ugly[index5]) index5++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ugly[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Super_Ugly_Number">Super Ugly Number</h2><h3 id="题目描述-2">题目描述</h3><p>Write a program to find the nth super ugly number.</p>
<p>Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4.</p>
<p>Note:<br>(1) 1 is a super ugly number for any given primes.<br>(2) The given numbers in primes are in ascending order.<br>(3) 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000.</p>
<h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//思路类似，Ugly Number II，只是质数因子不是固定的三个，由primes数组提供，</span></span><br><span class="line">    <span class="comment">//则我们维护一个长度跟primes数组长度一样indexes数组即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] primes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] ugly = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] indexes = <span class="keyword">new</span> <span class="keyword">int</span>[primes.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ugly[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.length; j++)&#123;</span><br><span class="line">                ugly[i] = Math.min(ugly[i], primes[j]*ugly[indexes[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ugly[i] == primes[j]*ugly[indexes[j]])&#123;</span><br><span class="line">                    indexes[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ugly[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Ugly_Number_I">Ugly Number I</h2><h3 id="题目描述">题目描述</h3><p>Write a program to check whether a given number is an ugly number.</p>
<p]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Rotate Image]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Rotate-Image/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Rotate-Image/</id>
    <published>2016-06-06T05:18:34.000Z</published>
    <updated>2016-06-06T05:19:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Follow up:<br>Could you do this in-place?</p>
<h2 id="代码">代码</h2><figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    <span class="comment">//顺时针旋转90度，先转置然后左右翻转(y轴反转)</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    1 2 3    1 4 7    7 4 1</span><br><span class="line">    4 5 6 =&gt; 2 5 8 =&gt; 8 5 2</span><br><span class="line">    7 8 9    3 6 9    9 6 3</span><br><span class="line">    */</span></span><br><span class="line">    public void rotate(int[][] <span class="keyword">matrix</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">matrix</span> == null || <span class="keyword">matrix</span>.<span class="built_in">length</span> == <span class="number">0</span> || <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="built_in">length</span> == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        int <span class="built_in">length</span> = <span class="keyword">matrix</span>.<span class="built_in">length</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i+<span class="number">1</span>; j &lt; <span class="built_in">length</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[j][i];</span><br><span class="line">                <span class="keyword">matrix</span>[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="built_in">length</span>/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[i][<span class="built_in">length</span>-j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">matrix</span>[i][<span class="built_in">length</span>-j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逆时针旋转90度，先转置然后上下翻转(x轴对称)</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    1 2 3    1 4 7    3 6 9</span><br><span class="line">    4 5 6 =&gt; 2 5 8 =&gt; 2 5 8</span><br><span class="line">    7 8 9    3 6 9    1 4 7</span><br><span class="line">    */</span></span><br><span class="line">    public void rotate2(int[][] <span class="keyword">matrix</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">matrix</span> == null || <span class="keyword">matrix</span>.<span class="built_in">length</span> == <span class="number">0</span> || <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="built_in">length</span> == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        int <span class="built_in">length</span> = <span class="keyword">matrix</span>.<span class="built_in">length</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i+<span class="number">1</span>; j &lt; <span class="built_in">length</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[j][i];</span><br><span class="line">                <span class="keyword">matrix</span>[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="built_in">length</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[<span class="built_in">length</span>-i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">matrix</span>[<span class="built_in">length</span>-i-<span class="number">1</span>][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Search Tree Iterator]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Search-Tree-Iterator/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Search-Tree-Iterator/</id>
    <published>2016-06-06T02:38:37.000Z</published>
    <updated>2016-06-06T02:40:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//很自然的思路就是将所有的树节点放入array中，然后利用索引指针进行next和hashNext</span></span><br><span class="line"><span class="comment">//满足O(1)time但是不满足O(h)memory</span></span><br><span class="line"><span class="comment">//我们可以利用栈，首先将树的left branch压栈，此时栈顶元素为最小的元素，当调用next弹出栈顶元素</span></span><br><span class="line"><span class="comment">//后，最小元素并不在栈中，我们需要寻找到最小元素然后入栈。此时树中元素最小元素在弹出元素的右子树的left branch</span></span><br><span class="line"><span class="comment">//这一点是由BST的性质决定的，所以我们next之后需要将弹出元素的右子树的left branch入栈。</span></span><br><span class="line"><span class="comment">//此种解法满足O(h)memory,next O(1), hashNext的平均时间能达到O(1)</span></span><br><span class="line"><span class="comment">//我们用next遍历整颗树，则next函数会遍历每个节点，run time为O(n),所以对于整棵树来说，平均运行时间为O(n)/n=O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> BSTIterator &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">stack</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode temp = <span class="built_in">stack</span>.pop();</span><br><span class="line">        pushLeftBranch(temp.right);</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLeftBranch</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node != null)&#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your BSTIterator will be called like this:</span><br><span class="line"> * BSTIterator i = new BSTIterator(root);</span><br><span class="line"> * while (i.hasNext()) v[f()] = i.next();</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a B]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Right Side View]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Tree-Right-Side-View/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Tree-Right-Side-View/</id>
    <published>2016-06-06T01:21:29.000Z</published>
    <updated>2016-06-06T01:23:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>For example:<br>Given the following binary tree,</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span>            &lt;-<span class="comment">--</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;-<span class="comment">--</span></span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;-<span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>You should return [1, 3, 4].</p>
<h2 id="代码">代码</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; res = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rightView(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一层就取一个，而且是最右边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> rightView(TreeNode root, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; res, int currHeight)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//tricky，因为一层就取一个（最右边的），当res.size()==currHeight时，说明该元素就是该层最右边的元素</span></span><br><span class="line">        <span class="keyword">if</span>(res<span class="built_in">.</span>size() == currHeight) res<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//右边优先</span></span><br><span class="line">        rightView(root<span class="built_in">.</span>right, res, currHeight+<span class="number">1</span>);</span><br><span class="line">        rightView(root<span class="built_in">.</span>left, res, currHeight+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Spiral Matrix I,II]]></title>
    <link href="http://blog.noobsky.com/2016/06/05/LeetCode-Spiral-Matrix-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/05/LeetCode-Spiral-Matrix-I-II/</id>
    <published>2016-06-05T08:52:49.000Z</published>
    <updated>2016-06-05T09:47:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Spiral_Matrix_I">Spiral Matrix I</h2><h3 id="题目描述">题目描述</h3><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>Given the following matrix:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>You should return [1,2,3,6,9,8,7,4,5].</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//matrix[0][0]、matrix[0][1]</span></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置为-1比较好</span></span><br><span class="line">        <span class="keyword">int</span> col = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当m或者n等于0时终止循环</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//col初始值为-1，for循环结束后col刚好为下一次循环的起始值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                res.add(matrix[row][++col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已经少了一行(row),所以m--</span></span><br><span class="line">            m--;</span><br><span class="line">            <span class="comment">//如果m==0终止循环</span></span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//等价于if(--m == 0) break;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                res.add(matrix[++row][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上面的for循环后，会减少一列，所以n--</span></span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                res.add(matrix[row][--col]);</span><br><span class="line">            &#125;</span><br><span class="line">            m--;</span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                res.add(matrix[--row][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spiral_Matrix_II">Spiral Matrix II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p>For example,<br>Given n = 3,</p>
<p>You should return the following matrix:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//if(n &lt;= 0) return new int[0][0];</span></span><br><span class="line">        <span class="keyword">int</span> rowLen = n;</span><br><span class="line">        <span class="keyword">int</span> colLen = n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colLen; i++)&#123;</span><br><span class="line">                matrix[row][++col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加上小于是防止n=0的情况，或者直接在前面判断特殊情况</span></span><br><span class="line">            <span class="keyword">if</span>(--rowLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowLen; i++)&#123;</span><br><span class="line">                matrix[++row][col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(--colLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colLen; i++)&#123;</span><br><span class="line">                matrix[row][--col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(--rowLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowLen; i++)&#123;</span><br><span class="line">                matrix[--row][col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(--colLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Spiral_Matrix_I">Spiral Matrix I</h2><h3 id="题目描述">题目描述</h3><p>Given a matrix of m x n elements (m rows, n columns), return all elem]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
