<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-10-07T07:51:41.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[HTTP]]></title>
    <link href="http://blog.noobsky.com/2016/10/07/HTTP/"/>
    <id>http://blog.noobsky.com/2016/10/07/HTTP/</id>
    <published>2016-10-07T02:30:19.000Z</published>
    <updated>2016-10-07T07:51:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="网络基础TCP/IP">网络基础TCP/IP</h2><h3 id="TCP/IP的分层管理">TCP/IP的分层管理</h3><p>TCP/IP协议族重要的一点就是分层。分为以下四层：应用层、传输层、网络层、数据链路层。</p>
<p><strong>应用层</strong><br>应用层决定了向用户提供应用服务时通信的活动</p>
<p>应用服务包括FTP、DNS、HTTP等</p>
<p><strong>传输层</strong></p>
<p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。<br>传输层协议包括TCP（传输控制协议）和UDP（用户数据报协议）</p>
<p><strong>网络层</strong><br>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。</p>
<p>网络层所起的作用就是在众多的选项内选择一条传输路线。</p>
<p><strong>链路层</strong><br>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p>
<h3 id="TCP/IP通信传输流">TCP/IP通信传输流</h3><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p>以HTTP举例来说：<br>首先作为发送端的客户端在应用层（HTTP协议）发送一个想看某个Web页面的HTTP请求。</p>
<p>接着为了传输方便，在传输层（TCP协议）把从应用层收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号即端口号后转发给网络层。</p>
<p>在网络层(IP协议)，增加作为通信目的地的MAC地址后转发给链路层。</p>
<p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客服端发送过来的HTTP请求。发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，没经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装。</p>
<h3 id="与HTTP关系密切的协议：IP、TCP和DNS">与HTTP关系密切的协议：IP、TCP和DNS</h3><h4 id="负责传输的IP协议">负责传输的IP协议</h4><p>IP协议位于网络层。作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要条件是IP地址和MAC地址。</p>
<p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变，但MAC地址一般不变。</p>
<p><strong>利用ARP协议获取MAC地址进行通信</strong></p>
<p>IP间的通信依赖MAC地址。网络上，通信双方在同一局域网内的情况很少，通常经过多台计算机和网络设备中转才能连接对方。而在中转时，利用MAC地址搜索下一个中转目标。利用ARP协议（地址解析协议）可以根据通信方的IP地址获取对应的MAC地址。</p>
<h4 id="确保可靠性的TCP协议">确保可靠性的TCP协议</h4><p>TCP位于传输层，提供可靠的字节流服务。<br>字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。</p>
<p><strong>确保数据能到达目标</strong></p>
<p>为了准确无误地将数据送达目标，TCP协议采用了三次握手策略。发送端首先发送一个带有SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表握手结束。</p>
<h3 id="负责域名解析的DNS服务">负责域名解析的DNS服务</h3><p>DNS服务位于应用层，提供域名到IP地址之间的解析服务。</p>
<h2 id="简单的HTTP协议">简单的HTTP协议</h2><h3 id="HTTP协议用于客户端和服务端之间的通信">HTTP协议用于客户端和服务端之间的通信</h3><p>请求访问的文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。</p>
<h3 id="通过请求和响应交换达成通信">通过请求和响应交换达成通信</h3><h3 id="HTTP是不保存状态的协议">HTTP是不保存状态的协议</h3><p>HTTP是无状态协议，也就说HTTP协议对于发送过的请求或响应都不做持久化处理。</p>
<p>HTTP为了实现保存状态的功能引入了Cookie技术。</p>
<h3 id="请求URI定位资源">请求URI定位资源</h3><h3 id="告知服务器意图的HTTP方法">告知服务器意图的HTTP方法</h3><ul>
<li><p>GET：获取资源</p>
</li>
<li><p>POST：传输实体主体</p>
</li>
<li><p>PUT：传输文件</p>
</li>
<li><p>HEAD：获取报文首部</p>
</li>
<li><p>DELETE：删除文件</p>
</li>
<li><p>OPTIONS：询问支持的方法</p>
</li>
<li><p>TRACE：追踪路径</p>
</li>
<li><p>CONNECT：要求用隧道协议连接代理</p>
</li>
</ul>
<h3 id="持久连接节省通信量">持久连接节省通信量</h3><p><strong>持久连接</strong></p>
<p>持久连接（HTTP Persistent Connections也称为HTTP keep-alive或者HTTP connection reuse）的方法。持久连接的特点是只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p>
<p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>
<p><strong>管线化</strong><br>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。以前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p>
<p>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应。</p>
<h3 id="使用Cookie的状态管理">使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p>
<p>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
<p>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<h2 id="HTTP报文">HTTP报文</h2><h3 id="请求报文">请求报文</h3><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。报文的一般格式如下：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;request-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;blank line&gt;</span><br><span class="line"></span><br><span class="line"><span class="annotation">[&lt;request-body&gt;]</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>请求行</li>
</ul>
<p>请求行由请求方法、URL字段和HTTP协议版本3个字段组成，由空格分隔。例如：GET /index.html HTTP/1.1。<br>HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p>
<ul>
<li><p>请求头部<br>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：<br>User-Agent: 产生请求的浏览器类型<br>Accept: 客户端可识别的内容类型列表。<br>Host: 请求主机名，允许多个域名同处于一个IP地址，即虚拟主机。</p>
</li>
<li><p>空行<br>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
</li>
<li><p>请求数据</p>
</li>
</ul>
<p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>
<h3 id="响应报文">响应报文</h3><p>HTTP响应也由三个部分组成，分别是：状态行、消息报头、空行和响应正文。格式如下：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;status-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;blank line&gt;</span><br><span class="line"></span><br><span class="line"><span class="annotation">[&lt;response-body&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p>
<p>状态行格式如下：</p>
<p>HTTP-Version Status-Code Reason-Phrase CRLF</p>
<p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p>
<p>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。</p>
<p>常见状态代码、状态描述的说明如下。</p>
<ul>
<li>200 OK：客户端请求成功。</li>
<li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li>
<li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li>
<li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li>
<li>500 Internal Server Error：服务器发生不可预期的错误。</li>
<li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<h2 id="编码提升传输速率">编码提升传输速率</h2><h3 id="压缩传输的内容编码">压缩传输的内容编码</h3><h3 id="分割发送的分块传输编码">分割发送的分块传输编码</h3><h2 id="HTTP状态码">HTTP状态码</h2><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">类别</th>
<th style="text-align:left">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">Informational（信息性状态码）</td>
<td style="text-align:left">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">Success （成功状态码）</td>
<td style="text-align:left">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">Redirection（重定向状态码）</td>
<td style="text-align:left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">Client Error（客户端错误状态码）</td>
<td style="text-align:left">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">Server Error（服务器错误状态码）</td>
<td style="text-align:left">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h2 id="确保Web安全的HTTPS">确保Web安全的HTTPS</h2><h3 id="HTTP的缺点">HTTP的缺点</h3><ul>
<li>通信使用明文（不加密），内容可能会被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭篡改</li>
</ul>
<h3 id="HTTP+加密+认证+完整性保护=HTTPS">HTTP+加密+认证+完整性保护=HTTPS</h3><h4 id="HTTP加上加密处理和认证以及完整性保护后即是HTTPS">HTTP加上加密处理和认证以及完整性保护后即是HTTPS</h4><h4 id="HTTPS是身披SSL外壳的HTTP">HTTPS是身披SSL外壳的HTTP</h4><p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。</p>
<p>通常HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。</p>
<h4 id="相互交换密钥的公开密钥加密技术">相互交换密钥的公开密钥加密技术</h4><ul>
<li>共享密钥加密（对称加密）的困境<br>加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也叫对称密钥加密。</li>
</ul>
<p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？因为只要拿到密钥任何人都能破解密码。</p>
<ul>
<li>使用两把密钥的公开密钥加密（非对称加密）</li>
</ul>
<p>公开密钥加密方式可以很好地解决共享密钥加密的困难。<br>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。私钥需要自行进行保护！公钥可以随便分享。</p>
<p>同时，生成的这个“私钥-公钥”对还有个强大的功能就是，使用私钥加密的信息，只能由该私钥对应的公钥才能解密，使用公钥加密的信息，只能由该公钥对应的私钥才能解密！</p>
<ul>
<li>HTTPS采用混合加密机制</li>
</ul>
<p>HTTPS采用共享密钥（对称）加密和公开密钥加密（非对称）两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p>
<p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立的通信交换报文阶段则使用共享密钥加密方式。</p>
<h4 id="证明公开密钥正确性的证书">证明公开密钥正确性的证书</h4><p>公开密钥加密方式存在的问题是无法证明公开密钥本身就是货真价实的公开密钥。公开密钥传输途中，可能被攻击者替换掉。</p>
<p>为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。</p>
<p>首先,服务器的 运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构 在判明提出申请者的身份之后,会对已申请的公开密钥做数字签名,然 后分配这个已签名的公开密钥,并将该公开密钥放入公钥证书后绑定在一起。</p>
<p>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户 端,以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接 称为证书。</p>
<p>接到证书的客户端可使用数字证书认证机构的公开密钥,对那张证 书上的数字签名进行验证,一旦验证通过,客户端便可明确两件事: 一,认证服务器的公开密钥的是真实有效的数字证书认证机构。二,服务器的公开密钥是值得信赖的。</p>
<p>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式 时,如何安全转交是一件很困难的事,因此,多数浏览器开发商发布版 本时,会事先在内部植入常用认证机关的公开密钥。</p>
<p><img src="http://7xonwi.com1.z0.glb.clouddn.com/https.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="网络基础TCP/IP">网络基础TCP/IP</h2><h3 id="TCP/IP的分层管理">TCP/IP的分层管理</h3><p>TCP/IP协议族重要的一点就是分层。分为以下四层：应用层、传输层、网络层、数据链路层。</p>
<p><strong>应用层</]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 8 新特性]]></title>
    <link href="http://blog.noobsky.com/2016/10/06/Java-8-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://blog.noobsky.com/2016/10/06/Java-8-新特性/</id>
    <published>2016-10-06T09:33:30.000Z</published>
    <updated>2016-10-06T14:38:40.000Z</updated>
    <content type="html"><![CDATA[<p>Java 8是Java 5（2004年发行）以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。本文会一一简要介绍。</p>
<h2 id="Java语言新特性">Java语言新特性</h2><h3 id="Lambda表达式和Functional接口">Lambda表达式和Functional接口</h3><p>Lambda表达式可以理解为简洁地传递匿名函数的一种方式（将函数作为一个方法的参数）。它没有名称，但它可以有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。写过函数式编程语言的程序员对这个概念一定并不陌生。</p>
<p>Java中Lambda表达式由逗号分隔的参数列表、-&gt;符号和函数体三部分组成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; System.out.println(e) );</span><br></pre></td></tr></table></figure>
<p>请注意参数e的类型是由编译器推测出来的。同时，你也可以通过把参数类型与参数包括在括号中的形式直接给出参数的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( ( String e ) -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure></p>
<p>在某些情况下lambda的函数体会更加复杂，这时可以把函数体放到在一对花括号中，就像在Java中定义普通函数一样。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; &#123;</span><br><span class="line">    System.out.print(e);</span><br><span class="line">    System.out.print(<span class="string">","</span>);</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<p>Lambda可以引用类的成员变量与局部变量（如果这些变量不是final的话，它们会被隐含的转为final，这样效率更高）。例如，下面两个代码片段是等价的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach(</span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach(</span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure></p>
<p>Lambda可能会返回一个值。返回值的类型也是由编译器推测出来的。如果lambda的函数体只有一行的话，那么没有必要显式使用return语句。下面两个代码片段是等价的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> result = e1.compareTo( e2 );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<p>如果表达式没有参数，你扔可以提供一对空的小括号，如同不含参数的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#125; doWork();</span><br></pre></td></tr></table></figure></p>
<p>语言设计者投入了大量精力来思考如何使现有的函数友好地支持lambda。最终采取的方法是：增加函数式接口的概念。对于只包含一个抽象方法的接口(除了隐含的Object对象的公共方法)，可以通过lambda表达式来创建该接口的对象。这种接口被称为函数式接口。像这样的接口，可以被隐式转换为lambda表达式。java.lang.Runnable与java.util.concurrent.Callable是函数式接口最典型的两个例子。在实际使用过程中，函数式接口是容易出错的：如有某个人在接口定义中增加了另一个方法，这时，这个接口就不再是函数式的了，并且编译过程也会失败。为了克服函数式接口的这种脆弱性并且能够明确声明接口作为函数式接口的意图，Java 8增加了一种特殊的注解@FunctionalInterface（Java 8中所有类库的已有接口都添加了@FunctionalInterface注解）。让我们看一下这种函数式接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要记住的一件事是：默认方法与静态方法并不影响函数式接口的契约，可以任意使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionalDefaultMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口的默认方法与静态方法">接口的默认方法与静态方法</h3><p>如果某个接口比如Collection添加了新方法，例如forEach，那么每个实现了Collection接口的自定义类就必须都实现该方法。这在Java中是完全无法接受的。</p>
<p>Java设计者们通过允许接口包含带有具体实现的方法（称为默认方法）来解决这个问题，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"Jaye"</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认方法终结了以前一种经典模式，即提供一个接口，以及一个实现接口的大多数或全部方法的抽象类，例如Collection/AbstractCollection，现在直接在接口中实现即可。</p>
<p>如果一个接口中定义了一个默认方法，而另外一个父类或者接口中又定义了一个同名的方法，选择方法的规则如下：</p>
<ol>
<li>选择父类中的方法。如果一个父类提供了具体的实现方法，那么接口中具有相同名称和参数的默认方法会被忽略。</li>
<li>接口冲突。如果一个父接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数类型的方法（不管该方法是否是默认方法），那么你必须通过覆盖该方法来解决冲突。</li>
</ol>
<p>某个类继承了某个父类并实现了某个接口，父类和接口有一个同名的方法，此时，只有父类中的方法会起作用，这是“类优先”规则。</p>
<p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。例如：</p>
<h3 id="方法引用">方法引用</h3><p>如果想传递给其他代码的操作已经有实现的方法，可以使用方法引用。</p>
<p>如果你希望不区分大小写地对字符串进行排序，那么可以传入方法引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings, String::compareToIgnoreCase)</span><br></pre></td></tr></table></figure></p>
<p>::操作符将方法名和对象或类的名字分隔开来。以下是三种主要的使用情况：</p>
<ul>
<li>对象::实例方法</li>
<li>类::静态方法</li>
<li>类::实例方法</li>
</ul>
<p>方法引用等同于提供方法参数的lambda表达式。<br>System.out::println等同于System.out.println(x)。相似的，Math::pow等同于(x, y) -&gt; Math.pow(x, y)。</p>
<p>在Arrays.sort(strings, String::compareToIgnoreCase)中第一个参数会成为执行方法的对象。例如：String::compareToIgnoreCase等同于(x, y) -&gt; x.compareToIgnoreCase(y)</p>
<p>还可以捕获方法中的this参数。例如this::equals就等同于x -&gt; this.equals(x)。也可以使用super对象。super::实例方法会使用this作为执行方法的对象，并调用父类中指定方法。</p>
<h3 id="重复注解">重复注解</h3><h3 id="更好的类型推测机制">更好的类型推测机制</h3><h3 id="扩展注解的支持">扩展注解的支持</h3><h2 id="Java编译器的新特性">Java编译器的新特性</h2><h3 id="参数名字">参数名字</h3><p>在Java 8中把这个获取参数名字的功能添加到语言层面（通过反射API与Parameter.getName()方法）与字节码文件（通过新版的javac的–parameters选项）中。</p>
<h2 id="Java类库的新特性">Java类库的新特性</h2><h3 id="Optional">Optional</h3><h3 id="Stream">Stream</h3><h3 id="Date/Time_API">Date/Time API</h3><h3 id="JavaScript引擎Nashorn">JavaScript引擎Nashorn</h3><h3 id="Base64">Base64</h3><h3 id="并行数组">并行数组</h3><h3 id="并发">并发</h3><h2 id="新的Java工具">新的Java工具</h2><p>Java 8带来了一些新的命令行工具。</p>
<h3 id="Nashorn引擎：jjs">Nashorn引擎：jjs</h3><h3 id="类依赖分析器jdeps">类依赖分析器jdeps</h3><h2 id="JVM的新特性">JVM的新特性</h2><p>PermGen空间被移除了，取而代之的是Metaspace（JEP 122）。JVM选项-XX:PermSize与-XX:MaxPermSize分别被-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。</p>
<h2 id="参考资料">参考资料</h2><p><a href="http://colobu.com/2014/10/28/secrets-of-java-8-functional-interface/" target="_blank" rel="external">Java 8函数式接口functional interface的秘密</a><br><a href="http://www.importnew.com/11908.html" target="_blank" rel="external">Java 8新特性终极指南</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java 8是Java 5（2004年发行）以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。本文会一一简要介绍。</p>
<h2 id="Java语言新特性">Java语言新特性</h2><h3 id="Lambda表达式和]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 8 CompletableFuture: 组合式异步编程]]></title>
    <link href="http://blog.noobsky.com/2016/10/06/Java-8-CompletableFuture-%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.noobsky.com/2016/10/06/Java-8-CompletableFuture-组合式异步编程/</id>
    <published>2016-10-06T08:52:54.000Z</published>
    <updated>2016-10-06T09:16:19.000Z</updated>
    <content type="html"><![CDATA[<p>Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。</p>
<p>虽然Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无畏的CPU资源，而且也不能及时得到计算结果。为什么不能使用观察者设计模式当计算结果完成及时通知监听者呢？</p>
<p>Nodejs采用回调的方式实现异步编程。Netty扩展了Java的Future接口提供了addListener等多个扩展方法。</p>
<p>Java 8中，新增加了一个包含50个方法左右的类：CompletableFuture，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p>
<p><a href="http://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="external"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。</p>
<p>虽然Future以及相关使用方法提供了异步执行任务的能]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8之杂项改进]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8%E4%B9%8B%E6%9D%82%E9%A1%B9%E6%94%B9%E8%BF%9B/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8之杂项改进/</id>
    <published>2016-10-05T13:48:48.000Z</published>
    <updated>2016-10-06T02:03:14.000Z</updated>
    <content type="html"><![CDATA[<p>要点包括：</p>
<ul>
<li>用分隔符连接字符串的至简方法</li>
<li>Integer类现在支持无符号数学运算</li>
<li>Math类现在有了检测整数是否溢出的方法</li>
<li>使用Math.floorMod(x, n)代替x % n来处理x可能是负数的情况</li>
<li>Collocation(removeIf)和List(replaceAll, sort)中提供了很多新的方法</li>
<li>Files.lines可以延迟读取一个包含文件行的流</li>
<li>Files.list可以延迟列举目录下的项目，而且Files.walk可以递归遍历它们</li>
<li>对Base64提供了官方支持</li>
<li>Objects类中提供了对null参数的检查</li>
</ul>
<h2 id="字符串">字符串</h2><p>将多个字符串通过分隔符组合起来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String joined = String.join(<span class="string">"/"</span>, <span class="string">"usr"</span>, <span class="string">"local"</span>, <span class="string">"bin"</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="数字类">数字类</h2><p>7种数字类型的包装类提供了一个BYTES字段，以byte为单位来表示该类型的长度</p>
<p>8种原始类型包装类提供了静态的hashCode方法</p>
<p>Short、Integer、Long、Float和Double提供了sum、max和min，用来在流操作中作为聚合函数使用<br>Boolean包含了静态方法logicalAnd、logicalOr、logicalXor</p>
<p>Integer类实现了支持无符号数学运算。<br>。。。</p>
<h2 id="新的数学函数">新的数学函数</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>要点包括：</p>
<ul>
<li>用分隔符连接字符串的至简方法</li>
<li>Integer类现在支持无符号数学运算</li>
<li>Math类现在有了检测整数是否溢出的方法</li>
<li>使用Math.floorMod(x, n)代替x % n来处理x可能是]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8之并发增强]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%A2%9E%E5%BC%BA/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8之并发增强/</id>
    <published>2016-10-05T13:03:08.000Z</published>
    <updated>2016-10-05T13:48:43.000Z</updated>
    <content type="html"><![CDATA[<p>要点包括：</p>
<ul>
<li>使用updateAndGet/accumulateAndGet方法可以更容易地更新原子变量</li>
<li>在激烈得竞争环境下，LongAccumulator/DoubleAccumulator比AtomicLong/AtomicDouble效率更高</li>
<li>使用compute和merge方法可以更容易地更新ConcurrentHashMap中的元素项</li>
<li>ConcurrentHashMap提供了对键、值、键值对及元素项的各类操作，例如search、reduce和forEach</li>
<li>集合视图允许你将ConcurrentHashMap作为一个Set来使用</li>
<li>Arrays类提供了排序、填充及前缀操作的并行方法</li>
<li>完善的Future类允许你创建异步的操作</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>要点包括：</p>
<ul>
<li>使用updateAndGet/accumulateAndGet方法可以更容易地更新原子变量</li>
<li>在激烈得竞争环境下，LongAccumulator/DoubleAccumulator比AtomicLong/AtomicDo]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8之新的日期和时间API]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8%E4%B9%8B%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8之新的日期和时间API/</id>
    <published>2016-10-05T12:31:58.000Z</published>
    <updated>2016-10-05T12:50:52.000Z</updated>
    <content type="html"><![CDATA[<p>要点包括：</p>
<ul>
<li>所有java.time对象都是不可变的</li>
<li>一个瞬间(Instant)是时间线上的一个点(与Date类似)</li>
<li>在Java时间中，每天都是86400秒（即没有闰秒）</li>
<li>持续时间(Duration)是两个瞬间之间的时间</li>
<li>LocalDateTime没有时区信息</li>
<li>TemporalAdjuster的方法可以处理常用的日历计算，例如找到某个月的第一个星期二</li>
<li>ZonedDateTime是指时区中的某一个时间点(类似于Gregorian Calendar)</li>
<li>当处理带时区的时间时，请使用时段(Period)，而非Duration，以便将夏令时的变化考虑在内</li>
<li>使用DateTimeFormatter来格式化和解析日期和时间</li>
</ul>
<h2 id="时间线">时间线</h2><h2 id="本地日期">本地日期</h2><h2 id="日期校正器">日期校正器</h2><h2 id="本地时间">本地时间</h2><h2 id="带时区的时间">带时区的时间</h2><h2 id="格式化和解析">格式化和解析</h2><h2 id="与遗留代码互操作">与遗留代码互操作</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>要点包括：</p>
<ul>
<li>所有java.time对象都是不可变的</li>
<li>一个瞬间(Instant)是时间线上的一个点(与Date类似)</li>
<li>在Java时间中，每天都是86400秒（即没有闰秒）</li>
<li>持续时间(Duratio]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8 之lambda表达式]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8-%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8-之lambda表达式/</id>
    <published>2016-10-05T04:11:48.000Z</published>
    <updated>2016-10-05T08:45:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="lambda表达式的语法">lambda表达式的语法</h2><p>检查某个字符串的长度是否小于另一个字符串长度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line">  -&gt; Integer.compare(first.length(), second.length())</span><br></pre></td></tr></table></figure></p>
<p>Java中lambda表达式的格式：参数、箭头 -&gt;，以及一个表达式。如果负责计算的代码无法用一个表达式表示，那么可以用编写方法的方式来编写：即用{}包裹代码并明确使用return语句，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果表达式没有参数，你扔可以提供一对空的小括号，如同不含参数的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#125; doWork();</span><br></pre></td></tr></table></figure></p>
<p>如果lambda表达式的参数类型可以被推导，那么就可以省略它们的类型，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp</span><br><span class="line">  = (first, second)</span><br><span class="line">    -&gt; Integer.compare(first.length(), second.length());</span><br></pre></td></tr></table></figure></p>
<p>这里编译器会推导出first和second必须是字符串，因为lambda表达式被赋值给了一个字符串比较器</p>
<p>如果某个方法只含有一个参数，并且该参数的类型可以被推导出来，你甚至可以省略小括号：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventHandler&lt;ActionEvent&gt; listener = event -&gt;</span><br><span class="line">  System.out.println(<span class="string">"Thanks for clicking"</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以像对待方法参数一样向lambda表达式的参数添加注解或者final修饰符，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">final</span> String name) -&gt; ...</span><br><span class="line">(<span class="annotation">@NonNull</span> String name) -&gt; ...</span><br></pre></td></tr></table></figure></p>
<p>不需要为一个lambda表达式执行返回类型，它总是会从上下文中被推导出来，表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; Integer.compare(first.length(), second.length())</span><br></pre></td></tr></table></figure></p>
<p>可以被使用在期望结果类型为int 的上下文中。</p>
<p>在lambda表达式中，只在某些分支中返回值（其他分支没有返回值）是不合法的。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> x) -&gt; &#123;<span class="keyword">if</span>(x &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>是不合法的。</p>
<h2 id="函数式接口">函数式接口</h2><p>java中有许多已有的接口都需要封装代码块，例如Runnable或者Comparator。lambda表达式与这些接口是向后兼容的。</p>
<p>对于只包含一个抽象方法的接口，可以通过lambda表达式来创建该接口的对象。这种接口被称为函数式接口。</p>
<p>函数式接口转换,lambda表达式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words,</span><br><span class="line">  (first,second) -&gt; Integer.compare(first.length(), second.length()));</span><br></pre></td></tr></table></figure></p>
<p>Arrays.sort方法会接收一个实现了Comparator<string>接口的类的实例。调用该对象的compare方法会执行lambda表达式中的代码。这些对象和类的管理完全依赖于如何实现，因此比传统的内部类效率更高。</string></p>
<p>事实上，函数式接口的转换是你在Java中使用lambda表达式能做的唯一一件事。</p>
<p>当一个lambda表达式被转换成一个函数式接口的实例时，请注意处理检查期异常。如果lambda表达式中可能会抛出一个检查期异常，那么该异常需要在目标接口的抽象方法中进行声明。</p>
<h2 id="方法引用">方法引用</h2><p>如果想传递给其他代码的操作已经有实现的方法，可以使用方法引用。</p>
<p>如果你希望不区分大小写地对字符串进行排序，那么可以传入方法引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings, String::compareToIgnoreCase)</span><br></pre></td></tr></table></figure></p>
<p>::操作符将方法名和对象或类的名字分隔开来。以下是三种主要的使用情况：</p>
<ul>
<li>对象::实例方法</li>
<li>类::静态方法</li>
<li>类::实例方法</li>
</ul>
<p>方法引用等同于提供方法参数的lambda表达式。<br>System.out::println等同于System.out.println(x)。相似的，Math::pow等同于(x, y) -&gt; Math.pow(x, y)。</p>
<p>在Arrays.sort(strings, String::compareToIgnoreCase)中第一个参数会成为执行方法的对象。例如：String::compareToIgnoreCase等同于(x, y) -&gt; x.compareToIgnoreCase(y)</p>
<p>还可以捕获方法中的this参数。例如this::equals就等同于x -&gt; this.equals(x)。也可以使用super对象。super::实例方法会使用this作为执行方法的对象，并调用父类中指定方法。</p>
<h2 id="构造器引用">构造器引用</h2><p>构造器引用类似方法引用，不同的是在构造器引用中方法名是new。如Button::new表示Button类的构造器引用。</p>
<p>可以使用数组类型来编写构造器引用。如int[]::new是一个含有一个参数的构造器引用，这个参数就是数组的长度。它等同于lambda表达式x -&gt; new int[x]。</p>
<h2 id="变量作用域">变量作用域</h2><p>lambda表达式的闭合方法或类中访问其他的变量，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">  Runnable r = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++ ) &#123;</span><br><span class="line">      System.out.println(text);</span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设有以下调用：<br>repeatMessage(“Hello”, 1000);//在另一个线程中打印Hello一千次</p>
<p>注意看lambda表达式中的变量count和text，它们并没有在lambda表达式中被定义，而是方法repeatMessage的参数变量。lambda表达式可能会在repeatMessage返回之后才运行，此时参数变量已经消失了。</p>
<p>lambda表达式包含三个部分：</p>
<ul>
<li>一段代码</li>
<li>参数</li>
<li>自由变量的值，这里的“自由”指的是那些不是参数并且没有在代码中定义的变量。</li>
</ul>
<p>上面的text和count就是lambda表达式的自由变量。数据结构表示lambda表达式必须存储这两个变量的值。其实含有自由变量的代码块被称之为”闭包”。</p>
<p>Java的lambda表达式中，被引用的变量的值不可以被更改。例如，下面表达式不合法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">  Runnable r = () -&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      count--;</span><br><span class="line">      System.out.println(text);</span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>做出这个约束的原因是更改lambda表达式中的变量不是线程安全的。</p>
<h2 id="默认方法">默认方法</h2><p>Java8允许接口包含带有具体实现的方法(称为默认方法)。</p>
<p>如果一个接口中定义了一个默认方法，而另外一个父类或者接口中又定义了一个同名的方法，选择方法的规则如下：</p>
<ol>
<li>选择父类中的方法。如果一个父类提供了具体的实现方法，那么接口中具有相同名称和参数的默认方法会被忽略。</li>
<li>接口冲突。如果一个父接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数类型的方法（不管该方法是否是默认方法），那么你必须通过覆盖该方法来解决冲突。</li>
</ol>
<p>某个类继承了某个父类并实现了某个接口，父类和接口有一个同名的方法，此时，只有父类中的方法会起作用，这是“类优先”规则。</p>
<h2 id="接口中的静态方法">接口中的静态方法</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="lambda表达式的语法">lambda表达式的语法</h2><p>检查某个字符串的长度是否小于另一个字符串长度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span]]>
    </summary>
    
      <category term="lambda" scheme="http://blog.noobsky.com/tags/lambda/"/>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之数据库]]></title>
    <link href="http://blog.noobsky.com/2016/10/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://blog.noobsky.com/2016/10/02/Redis设计与实现之数据库/</id>
    <published>2016-10-02T13:18:54.000Z</published>
    <updated>2016-10-02T16:12:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="服务器中的数据库">服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">  redisDb *db;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//服务器的数据库数量</span></span><br><span class="line">  int dbnum;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dbnum属性的值有服务器的database选项决定，默认情况下，该选项的值为16，所以redis服务器默认会创建19个数据库。</p>
<h2 id="切换数据库">切换数据库</h2><p>每个Redis客户端都有自己的目标数据库，每当客服端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。</p>
<p>默认情况，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p>
<p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">//记录客户端当前正在使用的数据库</span></span><br><span class="line">  redisDb *db;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;redisClient</span><br></pre></td></tr></table></figure></p>
<p>通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能–这就是SELECT命令的实现原理。</p>
<h2 id="数据库键空间">数据库键空间</h2><p>Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">  dict *dict;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键也就是数据库的键，每个键都是一个字符串对象</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li>
</ul>
<h3 id="添加新键">添加新键</h3><p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</p>
<h3 id="删除键">删除键</h3><h3 id="更新键">更新键</h3><h3 id="对键取值">对键取值</h3><h3 id="其他键空间操作">其他键空间操作</h3><h2 id="设置键的生存时间或过期时间">设置键的生存时间或过期时间</h2><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live, TTL）,在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p>
<p>还可通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间。</p>
<p>TTL命令和PTT命令返回键的剩余生存时间。</p>
<h3 id="设置过期时间">设置过期时间</h3><ul>
<li>EXPIRE <key> <ttl> 生存时间为ttl秒</ttl></key></li>
<li>PEXPIRE <key> <ttl> 生存时间为ttl毫秒</ttl></key></li>
<li>EXPIREAT <key> <timestamp> 过期时间为timestamp所指定的秒数时间戳</timestamp></key></li>
<li>PEXPIREAT <key> <timestamp> 过期时间为timestamp所指定的毫秒数时间戳</timestamp></key></li>
</ul>
<p>实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的。</p>
<h3 id="保存过期时间">保存过期时间</h3><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）</li>
<li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间（毫秒精度的时间戳）</li>
</ul>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">  dict *expires</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移除过期时间">移除过期时间</h3><p>PERSIST命令可以移除一个键的过期时间</p>
<p>该命令会在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p>
<h3 id="计算并返回剩余生存时间">计算并返回剩余生存时间</h3><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间</p>
<h3 id="过期键的判定">过期键的判定</h3><ul>
<li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间</li>
<li>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期</li>
</ul>
<h2 id="过期键删除策略">过期键删除策略</h2><h3 id="定时删除">定时删除</h3><p>在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</p>
<p>该策略对内存友好，可以保证过期键尽可能快地被删除，并释放过期键所占用的内存</p>
<p>缺点是对CPU时间是不友好的，在过期键多时删除过期键的行为可能会占用相当一部分CPU时间，会对服务器的响应时间和吞吐量造成影响。</p>
<p>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式–无序链表，查找时间复杂度为O(n)，不能高效地处理大量时间事件。</p>
<h3 id="惰性删除">惰性删除</h3><p>放任键过期不管，但每次从键空间获取键时，都检查取得的键是否过期，如果过期，则删除；如果没有过期，就返回该键。</p>
<p>对CPU友好，对内存不友好，内存泄漏</p>
<h3 id="定期删除">定期删除</h3><ul>
<li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li>
<li>惰性删除浪费太多内存，有内存泄漏的危险</li>
</ul>
<p>定期删除策略是前两种策略的一种整合和折中：</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
<li>通过定期删除过期键有效地减少了因为过期键而带来的内存浪费</li>
</ul>
<p>合理设置删除操作的执行时长和执行频率</p>
<h2 id="Redis的过期键删除策略">Redis的过期键删除策略</h2><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>
<h3 id="生成RDB文件">生成RDB文件</h3><p>执行SAVE命令或者BGSAVE命令时，程序会对数据库中的键进行检查，忽略已经过期的键</p>
<h3 id="载入RDB文件">载入RDB文件</h3><ul>
<li>服务器是主服务器时，载入RDB文件时，忽略过期的键</li>
<li>从服务器，载入RDB文件时，不论是否过期都会被载入数据库中</li>
</ul>
<h3 id="AOF文件写入">AOF文件写入</h3><p>键过期，但没有被惰性删除或者定期删除，那么AOF文件没有影响<br>当过期键被惰性删除或者定期删除时，程序会向AOF文件追加一条DEL命令</p>
<h3 id="AOF重写">AOF重写</h3><p>过期的键不会被保存到重写后的AOF中</p>
<h3 id="复制">复制</h3><h2 id="数据库通知">数据库通知</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="服务器中的数据库">服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：<br><f]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之对象]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之对象/</id>
    <published>2016-09-30T12:56:57.000Z</published>
    <updated>2016-10-02T13:17:54.000Z</updated>
    <content type="html"><![CDATA[<p>前面我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。</p>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<p>通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</p>
<p>除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制：当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p>
<p>最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。</p>
<h2 id="对象的类型与编码">对象的类型与编码</h2><p>Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> \*ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<h3 id="类型">类型</h3><p>对象的type属性记录了对象的类型，这个属性可以是下表列出的常量的其中一个。<br>| 类型常量 | 对象的名称     |<br>| :————- | :————- |<br>| REDIS_STRING       | 字符串对象       |<br>| REDIS_LIST       | 列表对象       |<br>| REDIS_HASH       | 哈希对象       |<br>| REDIS_SET       | 集合对象       |<br>| REDIS_ZSET       | 有序集合对象       |</p>
<p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；</li>
<li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，</li>
</ul>
<h3 id="编码和底层实现">编码和底层实现</h3><p>对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。</p>
<p>encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是下表列出的常量的其中一个。</p>
<table>
<thead>
<tr>
<th style="text-align:left">编码常量</th>
<th style="text-align:left">编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">REDIS_ENCODING_INT</td>
<td style="text-align:left">long 类型的整数</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_EMBSTR</td>
<td style="text-align:left">embstr 编码的简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_RAW</td>
<td style="text-align:left">简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_HT</td>
<td style="text-align:left">字典</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_LINKEDLIST</td>
<td style="text-align:left">双端链表</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_ZIPLIST</td>
<td style="text-align:left">压缩列表</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_INTSET</td>
<td style="text-align:left">整数集合</td>
</tr>
<tr>
<td style="text-align:left">REDIS_ENCODING_SKIPLIST</td>
<td style="text-align:left">跳跃表和字典</td>
</tr>
</tbody>
</table>
<h2 id="字符串常量">字符串常量</h2><p>字符串对象的编码可以是int、raw或者embstr。</p>
<p>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。</p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 32 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。</p>
<p>embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构，</p>
<p>embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的， 但使用 embstr 编码的字符串对象来保存短字符串值有以下好处：</p>
<ul>
<li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。</li>
<li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ul>
<p>最后要说的是， 可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。</p>
<p>最后要说的是， 可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。</p>
<p>在有需要的时候， 程序会将保存在字符串对象里面的字符串值转换回浮点数值， 执行某些操作， 然后再将执行操作所得的浮点数值转换回字符串值， 并继续保存在字符串对象里面。</p>
<p>字符串对象保存各类型值的编码方式如下：<br>| 值 | 编码 |<br>| :————- | :————- |<br>| 可以用long类型保存的整数       | int       |<br>| 可以用long double类型保存的浮点数       | embstr或者raw       |<br>| 字符串值，或者因为长度太大而没办法用long类型表示的整数，又或者因为长度太大而没有办法用long double类型表示的浮点数       | embstr 或者 raw       |</p>
<h3 id="编码的转换">编码的转换</h3><p>int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。</p>
<p>对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。</p>
<p>另外， 因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>
<h3 id="字符串命令的实现">字符串命令的实现</h3><h2 id="列表对象">列表对象</h2><p>列表对象的编码可以是ziplist或者linkedlist。</p>
<p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点(entry)保存了一个列表元素。</p>
<p>另一方面，linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p>
<p>注意， linkedlist 编码的列表对象在底层的双端链表结构中包含了多个字符串对象， 这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现， 字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。</p>
<h3 id="编码转换">编码转换</h3><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li>
<li>列表对象保存的元素数量小于 512 个；<br>不能满足这两个条件的列表对象需要使用 linkedlist 编码。</li>
</ul>
<p>注意<br>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 list-max-ziplist-value 选项和 list-max-ziplist-entries 选项的说明。</p>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面， 对象的编码也会从 ziplist 变为 linkedlist 。</p>
<h3 id="列表命令的实现">列表命令的实现</h3><h2 id="哈希对象">哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable。</p>
<p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ul>
<p>另一方面， hashtable 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
<h3 id="编码转换-1">编码转换</h3><p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li>
<li>哈希对象保存的键值对数量小于 512 个；<br>不能满足这两个条件的哈希对象需要使用 hashtable 编码。</li>
</ul>
<p>注意：<br>这两个条件的上限值是可以修改的， 具体请看配置文件中关于 hash-max-ziplist-value 选项和 hash-max-ziplist-entries 选项的说明。</p>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 ziplist 变为 hashtable 。</p>
<h3 id="哈希命令的实现">哈希命令的实现</h3><h2 id="哈希对象-1">哈希对象</h2><p>集合对象的编码可以是 intset 或者 hashtable 。</p>
<p>intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。</p>
<p>另一方面， hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 。</p>
<h3 id="编码转换-2">编码转换</h3><p>当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码：</p>
<p>集合对象保存的所有元素都是整数值；<br>集合对象保存的元素数量不超过 512 个；<br>不能满足这两个条件的集合对象需要使用 hashtable 编码。</p>
<p>注意</p>
<p>第二个条件的上限值是可以修改的， 具体请看配置文件中关于 set-max-intset-entries 选项的说明。</p>
<p>对于使用 intset 编码的集合对象来说， 当使用 intset 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 intset 变为 hashtable 。</p>
<h3 id="集合命令的实现">集合命令的实现</h3><h2 id="有序集合对象">有序集合对象</h2><p>有序集合的编码可以是ziplist或者skiplist。</p>
<p>有序集合的编码可以是 ziplist 或者 skiplist 。</p>
<p>ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。</p>
<p>skiplist 编码的有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zset &#123;</span><br><span class="line"></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></p>
<p>zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 object 属性保存了元素的成员， 而跳跃表节点的 score 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</p>
<p>除此之外， zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。</p>
<p>有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 double 类型的浮点数。 值得一提的是， 虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p>
<p>为什么有序集合需要同时使用跳跃表和字典来实现？</p>
<p>在理论上来说， 有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现， 但无论单独使用字典还是跳跃表， 在性能上对比起同时使用字典和跳跃表都会有所降低。</p>
<p>举个例子， 如果我们只使用字典来实现有序集合， 那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留， 但是， 因为字典以无序的方式来保存集合元素， 所以每次在执行范围型操作 —— 比如 ZRANK 、 ZRANGE 等命令时， 程序都需要对字典保存的所有元素进行排序， 完成这种排序需要至少 O(NlogN) 时间复杂度， 以及额外的 O(N) 内存空间 （因为要创建一个数组来保存排序后的元素）。</p>
<p>另一方面， 如果我们只使用跳跃表来实现有序集合， 那么跳跃表执行范围型操作的所有优点都会被保留， 但因为没有了字典， 所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(log N) 。</p>
<p>因为以上原因， 为了让有序集合的查找和范围型操作都尽可能快地执行， Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p>
<h3 id="编码的转换-1">编码的转换</h3><p>当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码：</p>
<p>有序集合保存的元素数量小于 128 个；<br>有序集合保存的所有元素成员的长度都小于 64 字节；<br>不能满足以上两个条件的有序集合对象将使用 skiplist 编码。</p>
<p>注意</p>
<p>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 zset-max-ziplist-entries 选项和 zset-max-ziplist-value 选项的说明。</p>
<p>对于使用 ziplist 编码的有序集合对象来说， 当使用 ziplist 编码所需的两个条件中的任意一个不能被满足时， 程序就会执行编码转换操作， 将原本储存在压缩列表里面的所有集合元素转移到 zset 结构里面， 并将对象的编码从 ziplist 改为 skiplist 。</p>
<h3 id="有序集合命令的实现">有序集合命令的实现</h3><h2 id="类型检查与命令多态">类型检查与命令多态</h2><p>Redis中用于操作键的命令基本上可以分为两种类型。<br>其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。</p>
<p>而另一种命令只能对特定类型的键执行， 比如说：</p>
<ul>
<li>SET 、 GET 、 APPEND 、 STRLEN 等命令只能对字符串键执行；</li>
<li>HDEL 、 HSET 、 HGET 、 HLEN 等命令只能对哈希键执行；</li>
<li>RPUSH 、 LPOP 、 LINSERT 、 LLEN 等命令只能对列表键执行；</li>
<li>SADD 、 SPOP 、 SINTER 、 SCARD 等命令只能对集合键执行；</li>
<li>ZADD 、 ZCARD 、 ZRANK 、 ZSCORE 等命令只能对有序集合键执行</li>
</ul>
<h3 id="类型检查的实现">类型检查的实现</h3><p>从上面发生类型错误的代码示例可以看出， 为了确保只有指定类型的键可以执行某些特定的命令， 在执行一个类型特定的命令之前， Redis 会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。</p>
<p>类型特定命令所进行的类型检查是通过 redisObject 结构的 type 属性来实现的：</p>
<ul>
<li>在执行一个类型特定命令之前， 服务器会先检查输入数据库键的值对象是否为执行命令所需的类型， 如果是的话， 服务器就对键执行指定的命令；</li>
<li>否则， 服务器将拒绝执行命令， 并向客户端返回一个类型错误。</li>
</ul>
<h3 id="多态命令的实现">多态命令的实现</h3><p>Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外， 还会根据值对象的编码方式， 选择正确的命令实现代码来执行命令。</p>
<p>举个例子， 在前面介绍列表对象的编码时我们说过， 列表对象有 ziplist 和 linkedlist 两种编码可用， 其中前者使用压缩列表 API 来实现列表命令， 而后者则使用双端链表 API 来实现列表命令。</p>
<p>现在， 考虑这样一个情况， 如果我们对一个键执行 LLEN 命令， 那么服务器除了要确保执行命令的是列表键之外， 还需要根据键的值对象所使用的编码来选择正确的 LLEN 命令实现：</p>
<ul>
<li>如果列表对象的编码为 ziplist ， 那么说明列表对象的实现为压缩列表， 程序将使用 ziplistLen 函数来返回列表的长度；</li>
<li>如果列表对象的编码为 linkedlist ， 那么说明列表对象的实现为双端链表， 程序将使用 listLength 函数来返回双端链表的长度；</li>
</ul>
<p>借用面向对象方面的术语来说， 我们可以认为 LLEN 命令是多态（polymorphism）的： 只要执行 LLEN 命令的是列表键， 那么无论值对象使用的是 ziplist 编码还是 linkedlist 编码， 命令都可以正常执行。</p>
<h2 id="内存回收">内存回收</h2><p>因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。</p>
<p>每个对象的引用计数信息由 redisObject 结构的 refcount 属性记录：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    int refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时， 引用计数的值会被初始化为 1 ；</li>
<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。</li>
</ul>
<p>下表列出了修改对象引用计数的 API ， 这些 API 分别用于增加、减少、重置对象的引用计数。<br>| 函数 | 作用 |<br>| :————- | :————- |<br>| incrRefCount | 将对象的引用计数数值增一 |<br>| decrRefCount | 将对象的引用计数数值增一，当对象的引用计数值等于0时，释放对象 |<br>| resetRefCount | 将对象的引用计数数值设置为0，但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。 |</p>
<p>对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。</p>
<p>作为例子， 以下代码展示了一个字符串对象从创建到释放的整个过程：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象 s ，对象的引用计数为 1</span></span><br><span class="line">robj *s = <span class="function"><span class="title">createStringObject</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象 s 执行各种操作 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象 s 的引用计数减一，使得对象的引用计数变为 0</span></span><br><span class="line"><span class="comment">// 导致对象 s 被释放</span></span><br><span class="line"><span class="function"><span class="title">decrRefCount</span><span class="params">(s)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其他不同类型的对象也会经历类似的过程。</p>
<h2 id="对象共享">对象共享</h2><p>除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有对象共享的作用。</p>
<p>举个例子， 假设键 A 创建了一个包含整数值 100 的字符串对象作为值对象，</p>
<p>如果这时键 B 也要创建一个同样保存了整数值 100 的字符串对象作为值对象， 那么服务器有以下两种做法：</p>
<p>为键 B 新创建一个包含整数值 100 的字符串对象；<br>让键 A 和键 B 共享同一个字符串对象；<br>以上两种方法很明显是第二种方法更节约内存。</p>
<p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ul>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。</li>
</ul>
<p>共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存。</p>
<p>比如说， 假设数据库中保存了整数值 100 的键不只有键 A 和键 B 两个， 而是有一百个， 那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存的数据。</p>
<p>目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>
<p>注意</p>
<p>创建共享字符串对象的数量可以通过修改 redis.h/REDIS_SHARED_INTEGERS 常量来修改。</p>
<p>另外， 这些共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（linkedlist 编码的列表对象、 hashtable 编码的哈希对象、 hashtable 编码的集合对象、以及 zset 编码的有序集合对象）都可以使用这些共享对象。</p>
<p>为什么 Redis 不共享包含字符串的对象？</p>
<p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p>
<ul>
<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>
<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>
<li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。<br>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。</li>
</ul>
<h2 id="对象的空转时长">对象的空转时长</h2><p>除了前面介绍过的 type 、 encoding 、 ptr 和 refcount 四个属性之外， redisObject 结构包含的最后一个属性为 lru 属性， 该属性记录了对象最后一次被命令程序访问的时间：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; <span class="keyword">SET</span> msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 等待一小段时间</span></span><br><span class="line">redis&gt; <span class="built_in">OBJECT</span> IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 等待一阵子</span></span><br><span class="line">redis&gt; <span class="built_in">OBJECT</span> IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">180</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 访问 msg 键的值</span></span><br><span class="line">redis&gt; <span class="keyword">GET</span> msg</span><br><span class="line"><span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 键处于活跃状态，空转时长为 0</span></span><br><span class="line">redis&gt; <span class="built_in">OBJECT</span> IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>注意</p>
<p>OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 lru 属性。</p>
<p>除了可以被 OBJECT IDLETIME 命令打印出来之外， 键的空转时长还有另外一项作用： 如果服务器打开了 maxmemory 选项， 并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru ， 那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>
<p>配置文件的 maxmemory 选项和 maxmemory-policy 选项的说明介绍了关于这方面的更多信息。</p>
<h2 id="重点回顾">重点回顾</h2><ul>
<li>Redis 数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。</li>
<li>Redis 会共享值为 0 到 9999 的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面我们陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。</p>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、]]>
    </summary>
    
      <category term="Redis设计与实现" scheme="http://blog.noobsky.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Redis" scheme="http://blog.noobsky.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之压缩列表]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之压缩列表/</id>
    <published>2016-09-30T11:52:52.000Z</published>
    <updated>2016-09-30T12:56:25.000Z</updated>
    <content type="html"><![CDATA[<p>压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p>
<p>同理，当一个哈希键只包含少量键值对，而且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</p>
<h2 id="压缩列表的构成">压缩列表的构成</h2><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。压缩列表的各个组成部分如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">---------------------------------------------------------------------</span><br><span class="line">| zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend |</span><br><span class="line">---------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">长度</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">zlbytes</td>
<td style="text-align:left">uint32_t</td>
<td style="text-align:left">4字节</td>
<td style="text-align:left">记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</td>
</tr>
<tr>
<td style="text-align:left">zltail</td>
<td style="text-align:left">uint32_t</td>
<td style="text-align:left">4字节</td>
<td style="text-align:left">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td style="text-align:left">zllen</td>
<td style="text-align:left">uint16_t</td>
<td style="text-align:left">2字节</td>
<td style="text-align:left">记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td style="text-align:left">entryX</td>
<td style="text-align:left">列表节点</td>
<td style="text-align:left">不定</td>
<td style="text-align:left">压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td style="text-align:left">zlend</td>
<td style="text-align:left">uint8_t</td>
<td style="text-align:left">1字节</td>
<td style="text-align:left">特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td>
</tr>
</tbody>
</table>
<h2 id="压缩列表节点的构成">压缩列表节点的构成</h2><p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中， 字节数组可以是以下三种长度的其中一种：</p>
<ul>
<li>长度小于等于 63 （2^{6}-1）字节的字节数组；</li>
<li>长度小于等于 16383 （2^{14}-1） 字节的字节数组；</li>
<li>长度小于等于 4294967295 （2^{32}-1）字节的字节数组；</li>
</ul>
<p>而整数值则可以是以下六种长度的其中一种：</p>
<ul>
<li>4 位长，介于 0 至 12 之间的无符号整数；</li>
<li>1 字节长的有符号整数；</li>
<li>3 字节长的有符号整数；</li>
<li>int16_t 类型整数；</li>
<li>int32_t 类型整数；</li>
<li>int64_t 类型整数。</li>
</ul>
<p>每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成， 如下所示。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">----------------------------------------------</span><br><span class="line">| previous_entry_length | encoding | content |</span><br><span class="line">----------------------------------------------</span></span><br></pre></td></tr></table></figure></p>
<h3 id="previous_entry_length">previous_entry_length</h3><p>节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</p>
<p>previous_entry_length 属性的长度可以是 1 字节或者 5 字节：</p>
<ul>
<li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p>因为节点的 previous_entry_length 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。</p>
<p>举个例子， 如果我们有一个指向当前节点起始地址的指针 c ， 那么我们只要用指针 c 减去当前节点 previous_entry_length 属性的值， 就可以得出一个指向前一个节点起始地址的指针 p。</p>
<p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的： 只要我们拥有了一个指向某个节点起始地址的指针， 那么通过这个指针以及这个节点的 previous_entry_length 属性， 程序就可以一直向前一个节点回溯， 最终到达压缩列表的表头节点。</p>
<h3 id="encoding">encoding</h3><p>节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度：</p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</li>
<li>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</li>
</ul>
<h3 id="content">content</h3><p>节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定。</p>
<h2 id="连锁更新">连锁更新</h2><h2 id="重点回顾">重点回顾</h2><ul>
<li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li>
<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p>
<p>同理，当一个哈希键只包含少量键值对，而且每个键值对的键和值]]>
    </summary>
    
      <category term="Redis设计与实现" scheme="http://blog.noobsky.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Redis" scheme="http://blog.noobsky.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之整数集合]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之整数集合/</id>
    <published>2016-09-30T09:27:52.000Z</published>
    <updated>2016-09-30T11:52:23.000Z</updated>
    <content type="html"><![CDATA[<p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素时，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p>
<h2 id="整数集合的实现">整数集合的实现</h2><p>整数集合(intset)是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p>
<p>每个intset.h/intset结构表示一个整数集合：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> intset &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p>
<p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数据项(item)，各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</p>
<p>length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。</p>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：</p>
<ul>
<li>如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT32 ， 那么 contents 就是一个 int32_t 类型的数组， 数组里的每个项都是一个 int32_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT64 ， 那么 contents 就是一个 int64_t 类型的数组， 数组里的每个项都是一个 int64_t 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）。</li>
</ul>
<h2 id="升级">升级</h2><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ul>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ul>
<h2 id="升级的好处">升级的好处</h2><p>整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。</p>
<h3 id="提升灵活性">提升灵活性</h3><p>因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>
<p>比如说， 我们一般只使用 int16_t 类型的数组来保存 int16_t 类型的值， 只使用 int32_t 类型的数组来保存 int32_t 类型的值， 诸如此类。</p>
<p>但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 int16_t 、 int32_t 或者 int64_t 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</p>
<h3 id="节约内存">节约内存</h3><p>当然， 要让一个数组可以同时保存 int16_t 、 int32_t 、 int64_t 三种类型的值， 最简单的做法就是直接使用 int64_t 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 int16_t 类型或者 int32_t 类型的值， 数组都需要使用 int64_t 类型的空间去保存它们， 从而出现浪费内存的情况。</p>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<p>比如说， 如果我们一直只向整数集合添加 int16_t 类型的值， 那么整数集合的底层实现就会一直是 int16_t 类型的数组， 只有在我们要将 int32_t 类型或者 int64_t 类型的值添加到集合时， 程序才会对数组进行升级。</p>
<h2 id="降级">降级</h2><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<h2 id="重点回顾">重点回顾</h2><ul>
<li>整数集合是集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素时，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p>
<h2 id="整数集合的实现">整数集合的实现</h2><p>整数集合(intset)是Redis用于保存]]>
    </summary>
    
      <category term="Redis设计与实现" scheme="http://blog.noobsky.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Redis" scheme="http://blog.noobsky.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之跳跃表]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之跳跃表/</id>
    <published>2016-09-30T07:35:58.000Z</published>
    <updated>2016-09-30T09:25:49.000Z</updated>
    <content type="html"><![CDATA[<p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所有有不少程序都使用跳跃表来代替平衡树。</p>
<p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表作为有序集合键的底层实现。</p>
<p>Reids只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p>
<h2 id="跳跃表节点">跳跃表节点</h2><p>跳跃表节点的实现由redis.h/zskiplistNode结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 跳跃表节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="keyword">struct</span> zskiplistNode *backward;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="keyword">struct</span> zskiplistNode *forward;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p>
<h3 id="层">层</h3><p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p>
<h3 id="前进指针">前进指针</h3><p>每个层都有一个指向表尾方向的前进指针（level[i].forward 属性）， 用于从表头向表尾方向访问节点。</p>
<h3 id="跨度">跨度</h3><p>层的跨度（level[i].span 属性）用于记录两个节点之间的距离：</p>
<ul>
<li>两个节点之间的跨度越大， 它们相距得就越远。</li>
<li>指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。</li>
</ul>
<p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p>
<h3 id="后退指针">后退指针</h3><p>节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p>
<h3 id="分值和成员">分值和成员</h3><p>节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p>
<p>节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p>
<p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p>
<h2 id="跳跃表">跳跃表</h2><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表。但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息</p>
<p>zskiplist结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 跳跃表</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
<p>header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</p>
<p>通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</p>
<p>level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。</p>
<h2 id="重点回顾">重点回顾</h2><ul>
<li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。</li>
<li>Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成， 其中 zskiplist 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示跳跃表节点。</li>
<li>每个跳跃表节点的层高都是 1 至 32 之间的随机数。</li>
<li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下，跳跃表的效]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之字典]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AD%97%E5%85%B8/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之字典/</id>
    <published>2016-09-30T02:09:52.000Z</published>
    <updated>2016-09-30T07:41:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="字典的实现">字典的实现</h2><h3 id="哈希表">哈希表</h3><p>Redis字典所使用的哈希表由dict.h/dictht结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span><br><span class="line"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 哈希表</span><br><span class="line"> *</span><br><span class="line"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p>
<p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</p>
<p>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</p>
<p>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</p>
<h3 id="哈希表节点">哈希表节点</h3><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 哈希表节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="keyword">struct</span> dictEntry *next;</span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</p>
<p>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</p>
<h3 id="字典">字典</h3><p>Redis 中的字典由 dict.h/dict 结构表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 字典</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p>
<p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
<li>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 字典类型特定函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictType &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p>
<p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p>
<h2 id="哈希算法">哈希算法</h2><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis 计算哈希值和索引值的方法如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line"><span class="title">hash</span> = dict-&gt;<span class="typedef"><span class="keyword">type</span>-&gt;hashFunction<span class="container">(<span class="title">key</span>)</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="preprocessor"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line"><span class="title">index</span> = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>
<h2 id="解决键冲突">解决键冲突</h2><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p>因为 dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面。</p>
<h2 id="rehash">rehash</h2><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li><p>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）：</p>
<ul>
<li>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；</li>
<li>如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</li>
</ul>
</li>
<li><p>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</p>
</li>
<li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<h3 id="哈希表的扩展与收缩">哈希表的扩展与收缩</h3><p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ul>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；<br>其中哈希表的负载因子可以通过公式：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span></span><br><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>
<p>根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p>
<p>另一方面， 当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。</p>
<h2 id="渐进式rehash">渐进式rehash</h2><p>扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>
<p>这样做的原因在于， 如果 ht[0] 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ul>
<li>为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li>
</ul>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<h3 id="渐进式rehash执行期间的哈希表操作">渐进式rehash执行期间的哈希表操作</h3><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<h2 id="重点回顾">重点回顾</h2><ul>
<li>字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。</li>
<li>Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。</li>
<li>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</li>
<li>哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。</li>
<li>在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="字典的实现">字典的实现</h2><h3 id="哈希表">哈希表</h3><p>Redis字典所使用的哈希表由dict.h/dictht结构定义：<br><figure class="highlight c"><table><tr><td class="gutt]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之链表]]></title>
    <link href="http://blog.noobsky.com/2016/09/30/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://blog.noobsky.com/2016/09/30/Redis设计与实现之链表/</id>
    <published>2016-09-29T16:18:29.000Z</published>
    <updated>2016-09-30T02:01:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="链表和链表节点的实现">链表和链表节点的实现</h2><p>每个链表节点使用一个adlist.h/listNode结构来表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 双端链表节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="keyword">struct</span> listNode *prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="keyword">struct</span> listNode *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>
<p>链表结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 双端链表结构</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">list</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p>list 结构为链表提供了表头指针 head 、表尾指针 tail ， 以及链表长度计数器 len ， 而 dup 、 free 和 match 成员则是用于实现多态链表所需的类型特定函数：</p>
<ul>
<li>dup 函数用于复制链表节点所保存的值；</li>
<li>free 函数用于释放链表节点所保存的值；</li>
<li>match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li>
</ul>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双端：链表节点带有prev和next指针， 获取某个节点的前置节点和后置节点的复杂度都是O(1) 。</li>
<li>无环： 表头节点的prev指针和表尾节点的next指针都指向NULL ， 对链表的访问以NULL为终点。</li>
<li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</li>
<li>多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h2 id="链表和链表节点的API">链表和链表节点的API</h2><h2 id="重点回顾">重点回顾</h2><ul>
<li>链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。</li>
<li>每个链表节点由一个 listNode 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。</li>
<li>每个链表使用一个 list 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。</li>
<li>因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL ， 所以 Redis 的链表实现是无环链表。</li>
<li>通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="链表和链表节点的实现">链表和链表节点的实现</h2><p>每个链表节点使用一个adlist.h/listNode结构来表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><s]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis设计与实现之简单动态字符串]]></title>
    <link href="http://blog.noobsky.com/2016/09/29/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://blog.noobsky.com/2016/09/29/Redis设计与实现之简单动态字符串/</id>
    <published>2016-09-29T04:00:39.000Z</published>
    <updated>2016-09-30T01:38:40.000Z</updated>
    <content type="html"><![CDATA[<p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串(simple dynamic string, SDS)的抽象类型，并将SDS用作Redis的默认字符表示。</p>
<h2 id="SDS的定义">SDS的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 保存字符串对象的结构</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> sdshdr &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。</p>
<h2 id="SDS与C字符串的区别">SDS与C字符串的区别</h2><p>根据传统， C 语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串， 并且字符数组的最后一个元素总是空字符 ‘\0’ 。<br>C 语言使用的这种简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求， 本节接下来的内容将详细对比 C 字符串和 SDS 之间的区别， 并说明 SDS 比 C 字符串更适用于 Redis 的原因。</p>
<h3 id="常数复杂度获取字符串长度">常数复杂度获取字符串长度</h3><p>C字符串并不记录自身的长度信息，获取长度需遍历整个字符串，时间复杂度为O(n)。而SDS获取字符串的长度可以直接访问SDS的len属性即可获得字符串的长度，时间复杂度为O(1)</p>
<h3 id="杜绝缓冲区溢出">杜绝缓冲区溢出</h3><p>SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。</p>
<h3 id="减少修改字符串时带来的内存重分配次数">减少修改字符串时带来的内存重分配次数</h3><p>在 SDS 中， buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 free 属性记录。</p>
<p>通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。</p>
<ul>
<li>空间预分配</li>
</ul>
<p>空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。</p>
<ul>
<li>惰性空间释放</li>
</ul>
<p>惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。</p>
<h3 id="二进制安全">二进制安全</h3><h3 id="兼容部分C字符串函数">兼容部分C字符串函数</h3><p>虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 <string.h> 库定义的函数。</string.h></p>
<h2 id="总结">总结</h2><table>
<thead>
<tr>
<th style="text-align:left">C字符串</th>
<th style="text-align:left">SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">获取字符串长度的复杂度为 O(N)</td>
<td style="text-align:left">获取字符串长度的复杂度为 O(1)</td>
</tr>
<tr>
<td style="text-align:left">API 是不安全的，可能会造成缓冲区溢出</td>
<td style="text-align:left">API 是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td style="text-align:left">修改字符串长度 N 次必然需要执行 N 次内存重分配</td>
<td style="text-align:left">修改字符串长度 N 次最多需要执行 N 次内存重分配</td>
</tr>
<tr>
<td style="text-align:left">只能保存文本数据</td>
<td style="text-align:left">可以保存文本或者二进制数据</td>
</tr>
<tr>
<td style="text-align:left">可以使用所有 <string.h> 库中的函数</string.h></td>
<td style="text-align:left">可以使用一部分 <string.h> 库中的函数</string.h></td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串(simple dynamic string, SDS)的抽象类型，并将SDS用作Redis的默认字符表示。</p>
<h2 id="SDS的定义">SDS的定义</]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之动态规划问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/09/28/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/09/28/面试算法之动态规划问题集锦/</id>
    <published>2016-09-28T01:57:10.000Z</published>
    <updated>2016-09-29T13:29:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="计算数组下标i与j之间的元素之和">计算数组下标i与j之间的元素之和</h2><p>用sum[i]来存储0到i之间元素的和，0到j的和减去0到i-1的和(即sum[j]-sum[i-1])即为所求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumArray</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) sums[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> sums[i] = sums[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> sums[j];</span><br><span class="line">        <span class="keyword">return</span> sums[j] - sums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="计算二维矩阵矩形区域的值">计算二维矩阵矩形区域的值</h2><p><img src="https://leetcode.com/static/images/courses/range_sum_query_2d.png" alt=""></p>
<p>sum[i+1][j+1]表示matrix[0][0]到matrix[i][j]构成的区域的和<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-----+-+-------+     +--------+-----+     +-----+---------+     +-----+--------+</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">     </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">        </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">     </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">        </span>|</span><br><span class="line">+-----+-+       |<span class="string">     +--------+     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">     +-----+        </span>|</span><br><span class="line">|<span class="string">     </span>|<span class="string"> </span>|<span class="string">       </span>|<span class="string">  =  </span>|<span class="string">              </span>|<span class="string">  +  </span>|<span class="string">     </span>|<span class="string">         </span>|<span class="string">  -  </span>|<span class="string">              </span>|</span><br><span class="line">+-----+-+       |<span class="string">     </span>|<span class="string">              </span>|<span class="string">     +-----+         </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|<span class="string">     </span>|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|<span class="string">     </span>|<span class="string">               </span>|<span class="string">     </span>|<span class="string">              </span>|</span><br><span class="line">+---------------+     +--------------+     +---------------+     +--------------+</span><br><span class="line"></span><br><span class="line">   sums[i][j]      =    sums[i-1][j]    +     sums[i][j-1]    -   sums[i-1][j-1]   +  </span><br><span class="line"></span><br><span class="line">                        matrix[i-1][j-1]</span><br></pre></td></tr></table></figure></p>
<p>所以区域和的计算方法如下图：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br><span class="line">|<span class="string">               </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">          </span>|</span><br><span class="line">|<span class="string">   (r1,c1)     </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">          </span>|</span><br><span class="line">|<span class="string">   +------+    </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   +---------+    </span>|<span class="string">   +---+          </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">      </span>|<span class="string">    </span>|<span class="string"> = </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string"> - </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string"> - </span>|<span class="string">      (r1,c2) </span>|<span class="string"> + </span>|<span class="string">   (r1,c1)    </span>|</span><br><span class="line">|<span class="string">   </span>|<span class="string">      </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">         </span>|<span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">   +------+    </span>|<span class="string">   +---------+    </span>|<span class="string">   +---+           </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">|<span class="string">        (r2,c2)</span>|<span class="string">   </span>|<span class="string">       (r2,c2)</span>|<span class="string">   </span>|<span class="string">   (r2,c1)     </span>|<span class="string">   </span>|<span class="string">              </span>|<span class="string">   </span>|<span class="string">              </span>|</span><br><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造一个二维数组，sum[row+1][col+1]，加多第0行和第0列可以避免检查边界情况</span></span><br><span class="line">    <span class="comment">//相当于在第0行加了一行全为0的元素，第0列加了一列全为0的元素</span></span><br><span class="line">    <span class="comment">//sum[i+1][j+1]表示matrix[0][0]到matrix[i][j]构成的区域的和</span></span><br><span class="line">    <span class="comment">//sum[i][j] = sum[i-1][j]+sum[i][j-1] - sum[i-1][j-1]+matrix[i-1][j-1]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)&#123;</span><br><span class="line">                sum[i][j] = sum[i-<span class="number">1</span>][j] + sum[i][j-<span class="number">1</span>] - sum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//虽然题目中已经假设 row1 ≤ row2 and col1 ≤ col2.</span></span><br><span class="line">        <span class="comment">//可以确保一下</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">if</span>(row1 &gt; row2)&#123;</span><br><span class="line">            temp = row2;</span><br><span class="line">            row2 = row1;</span><br><span class="line">            row1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col1 &gt; col2)&#123;</span><br><span class="line">            temp = col2;</span><br><span class="line">            col2 = col1;</span><br><span class="line">            col1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - sum[row2+<span class="number">1</span>][col1]- sum[row1][col2+<span class="number">1</span>] + sum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumMatrix numMatrix = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(0, 1, 2, 3);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(1, 2, 3, 4);</span></span><br></pre></td></tr></table></figure>
<h2 id="Range_Sum_Query_-_Mutable">Range Sum Query - Mutable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Segment Tree，sumRange和update都是O(lgn)</span></span><br><span class="line">    <span class="comment">//叶子节点为数组中的元素，内部节点(非叶子节点)代表了该节点下叶子的和</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录该节点下叶子包含数组中[start, end]的元素</span></span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        <span class="comment">//nums[start...end]直接的元素之和</span></span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="comment">//左右孩子</span></span><br><span class="line">        SegmentTreeNode left, right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SegmentTreeNode</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SegmentTreeNode root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        root = buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用nums中[start...end]的元素构造SegmentTree</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SegmentTreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            SegmentTreeNode node = <span class="keyword">new</span> SegmentTreeNode(start, end);</span><br><span class="line">            <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">                node.sum = nums[start];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//进入这个分支，[start...end]起码有两个元素，node.left和node.right都不会为空</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">                node.left = buildTree(nums, start, mid);</span><br><span class="line">                node.right = buildTree(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">                <span class="comment">//左子树加上右子树的和</span></span><br><span class="line">                node.sum = node.left.sum + node.right.sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update(root, i, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(SegmentTreeNode root, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.start == root.end)&#123;</span><br><span class="line">            root.sum = val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = root.start + (root.end - root.start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos &lt;= mid)&#123;<span class="comment">//在左子树中</span></span><br><span class="line">                update(root.left, pos, val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                update(root.right, pos, val);</span><br><span class="line">            &#125;</span><br><span class="line">            root.sum = root.left.sum + root.right.sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sumRange(root, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(SegmentTreeNode root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.start == start &amp;&amp; root.end == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//计算root.start和root.end的中间值</span></span><br><span class="line">            <span class="keyword">int</span> mid = root.start + (root.end - root.start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(end &lt;= mid)&#123;<span class="comment">//全部在左子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.left, start, end);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start &gt;= mid + <span class="number">1</span>)&#123;<span class="comment">//全部在右子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.right, start, end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//分散在左右子树中</span></span><br><span class="line">                <span class="keyword">return</span> sumRange(root.left, start, mid) + sumRange(root.right, mid+<span class="number">1</span>, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumArray numArray = new NumArray(nums);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(0, 1);</span></span><br><span class="line"><span class="comment">// numArray.update(1, 10);</span></span><br><span class="line"><span class="comment">// numArray.sumRange(1, 2);</span></span><br></pre></td></tr></table></figure>
<h2 id="House_Robber">House Robber</h2><p>相邻的房子只能抢一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以不使用O(n)的空间复杂度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = Math.max(pre+nums[i], curr);</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="House_Robber_II">House Robber II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//房子首尾相连形成了一个圈，所以i间房子和i+1间房子只能有一间抢，或者两者都不抢</span></span><br><span class="line">    <span class="comment">//如果假设第i间不抢，则我们可以打断该圈，比如1-&gt;2-&gt;3-&gt;1则变成了2-&gt;3如果1不抢，</span></span><br><span class="line">    <span class="comment">//我们假设第i间房子不抢，剩下的房子组成的连续序列用House Robber的方法求解出最大值max1</span></span><br><span class="line">    <span class="comment">//然后假设第i+1间房子不抢，剩下的房子组成的连续序列用House Robber的方法求解出最大值max2，max1和max2的较大者即为所求</span></span><br><span class="line">    <span class="comment">//为了编程简单，我们选择i=n，i+1=0，也就是说我们把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后比较两个值取</span></span><br><span class="line">    <span class="comment">//取其中的最大值即为所求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(robHelper(nums, <span class="number">0</span>, nums.length-<span class="number">2</span>), robHelper(nums, <span class="number">1</span>, nums.length-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robHelper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = Math.max(pre+nums[i], curr);</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Climbing_Stairs">Climbing Stairs</h2><p>爬楼梯，每次只能走一步或者二步，求不同的方法数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">  res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  res[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">      res[i] = res[i-<span class="number">2</span>] + res[i-<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//前一级阶梯不同路径数</span></span><br><span class="line">    <span class="keyword">int</span> oneStep = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//前两级阶梯的不同路径数</span></span><br><span class="line">    <span class="keyword">int</span> twoStep = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> allWays = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        allWays = oneStep + twoStep;</span><br><span class="line">        twoStep = oneStep;</span><br><span class="line">        oneStep = allWays;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allWays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Minimum_Path_Sum">Minimum Path Sum</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态转移方程：sum[i][j] = grid[i][j]+min(sum[i-1][j], sum[i][j-1])</span></span><br><span class="line"><span class="comment">//注意处理边界情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length;</span><br><span class="line">    <span class="keyword">if</span>(row == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实sum数组可以省掉，直接在grid数组上进行</span></span><br><span class="line">    <span class="keyword">int</span> sum[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) sum[i][j] = grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) sum[i][j] = sum[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) sum[i][j] = sum[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> sum[i][j] = Math.min(sum[i-<span class="number">1</span>][j], sum[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Unique_Paths">Unique Paths</h2><p>左上到右下，只能往右或往下走，求不同的路径数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a[m][n] = a[m-1][n]+a[m][n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//grid[0][1] = 1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            grid[i][j] = (i == <span class="number">0</span> || j == <span class="number">0</span>) ? <span class="number">1</span> : grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//a[m][n] = a[m-1][n]+a[m][n-1]</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">     <span class="comment">//第一排和第一列都为1</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">         grid[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">         grid[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">             grid[i][j] = grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique_Paths_II">Unique Paths II</h2><p>类似Unique Paths，但是如果值为1表示为障碍不能通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> grid[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) grid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">0</span> : grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) grid[<span class="number">0</span>][j] = (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) ? <span class="number">0</span> : grid[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                grid[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以但是不够好理解</span></span><br><span class="line">    <span class="comment">// public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span></span><br><span class="line">    <span class="comment">//     int m = obstacleGrid.length;</span></span><br><span class="line">    <span class="comment">//     if(m == 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int n = obstacleGrid[0].length;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int grid[][] = new int[m+1][n+1];</span></span><br><span class="line">    <span class="comment">//     grid[0][1] = 1;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt;= m; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 1; j &lt;= n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             grid[i][j] = obstacleGrid[i-1][j-1] == 1 ? 0 : grid[i-1][j]+grid[i][j-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return grid[m][n];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Guess_Number_Higher_or_Lower_II">Guess Number Higher or Lower II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> solve(dp, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//top-down，效率不高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[][] dp, <span class="keyword">int</span> left , <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[left][right] != <span class="number">0</span>) <span class="keyword">return</span> dp[left][right];</span><br><span class="line"></span><br><span class="line">        dp[left][right] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            dp[left][right] = Math.min(dp[left][right], i + Math.max(solve(dp, left, i-<span class="number">1</span>), solve(dp, i+<span class="number">1</span>, right)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[left][right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bottom-up</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int len = 1; len &lt; n; len++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int i = 1; i &lt;= n-len; i++)&#123;</span></span><br><span class="line">        <span class="comment">//         int j = i + len;</span></span><br><span class="line">        <span class="comment">//         int min = Integer.MAX_VALUE;</span></span><br><span class="line">        <span class="comment">//         for(int k = i; k &lt; j; k++)&#123;</span></span><br><span class="line">        <span class="comment">//             int temp = k + Math.max(dp[i][k-1], dp[k+1][j]);</span></span><br><span class="line">        <span class="comment">//             min = Math.min(min, temp);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         dp[i][j] = min;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n-len; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; j; k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], k + Math.max(dp[i][k-<span class="number">1</span>], dp[k+<span class="number">1</span>][j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Largest_Divisible_Subset">Largest Divisible Subset</h2><p>每一对(Si, Sj)都满足Si%Sj=0或者Sj%Si=0，类似LIS<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要排序，排序后相当于求最大递增子序列</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//dp数组dp[i]表示最大元素为num[i]的longest divisible subset的长度</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//为了得到序列我们需要记录每个nums[i]的前驱元素，所以我们prev数组来记录nums[i]前驱元素的下标</span></span><br><span class="line">        <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录largest divisible subset的最大长度</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最大长度最大元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//如果j = i开始，不用写dp[i] = 1;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span> &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//记录前驱元素的下标</span></span><br><span class="line">                    prev[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//dp[i]大于maxLen则更新最大长度和下标</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxLen)&#123;</span><br><span class="line">                maxLen = dp[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据prev数组找出largest divisible subset的所以元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++)&#123;</span><br><span class="line">            <span class="comment">//res.add(nums[maxIndex]);//这样添加其实是元素的逆序，但题目中也没有要求是顺序的</span></span><br><span class="line">            <span class="comment">//如果要求需要按顺序，当然这里顺序也不是原始数组的顺序，是排序后的顺序</span></span><br><span class="line">            res.add(<span class="number">0</span>, nums[maxIndex]);</span><br><span class="line">            maxIndex = prev[maxIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Decode_Ways">Decode Ways</h2><p>字母A-Z分别对应1-26，使用这个映射对信息进行编码。给定一个编码后的信息求不同的解码数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类似Climbing Stairs，只是多了一些限制条件</span></span><br><span class="line">    <span class="comment">//nums[i]：表示字符串s[0...i-1]的解码方式的总数</span></span><br><span class="line">    <span class="comment">//nums[i] = nums[i-1] if s[i-1] is valid char</span></span><br><span class="line">    <span class="comment">//or nums[i-1] + nums[i-2] if s[i-1] and s[i-2] to gether is still a valid char</span></span><br><span class="line">    <span class="comment">// public int numDecodings(String s) &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     if(s == null || s.length() == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int[] nums = new int[s.length() + 1];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //表示空字符串只有一种解码方式</span></span><br><span class="line">    <span class="comment">//     nums[0] = 1;</span></span><br><span class="line">    <span class="comment">//     //只含有s[0]一个字符的解码方式，如果是有效字符不为'0'则有一种方式，否则为零</span></span><br><span class="line">    <span class="comment">//     nums[1] = s.charAt(0) != '0' ? 1 : 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     for(int i = 2; i &lt;= s.length(); i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(isValid(s.substring(i-1,i)))&#123;</span></span><br><span class="line">    <span class="comment">//             nums[i] += nums[i-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         if(isValid(s.substring(i-2, i)))&#123;</span></span><br><span class="line">    <span class="comment">//             nums[i] += nums[i-2];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return nums[s.length()];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> value = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">return</span> value &gt;= <span class="number">1</span> &amp;&amp; value &lt;= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表示空字符串只有一种解码方式</span></span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//只含有s[0]一个字符的解码方式，如果是有效字符不为'0'则有一种方式，否则为零</span></span><br><span class="line">        nums[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = Integer.parseInt(s.substring(i-<span class="number">1</span>, i));</span><br><span class="line">            <span class="keyword">int</span> second = Integer.parseInt(s.substring(i-<span class="number">2</span>, i));</span><br><span class="line">            <span class="comment">//0开头，比如类似01，下面两个if都不会执行</span></span><br><span class="line">            <span class="keyword">if</span>(first &gt;= <span class="number">1</span> &amp;&amp; first &lt;= <span class="number">9</span>)&#123;</span><br><span class="line">                nums[i] += nums[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意second要大于等于10</span></span><br><span class="line">            <span class="keyword">if</span>(second &gt;= <span class="number">10</span> &amp;&amp; second &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                nums[i] += nums[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上两种写法都是top down dp，我们还可以用bottom up dp的方式，从字符串尾部往前dp</span></span><br><span class="line">    <span class="comment">//nums[i]表示s[i...s.length]的解码方式</span></span><br><span class="line">    <span class="comment">//以'0'开头的字符串解码方式为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings2</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//空字符串的解码方式</span></span><br><span class="line">        nums[length] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        nums[length-<span class="number">1</span>] = s.charAt(length - <span class="number">1</span>) != <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>) <span class="keyword">continue</span>;<span class="comment">//以0开头的字符串都是无效的字符串，解码方式为0，默认初始化为0，写nums[i] = 0也可以</span></span><br><span class="line">            <span class="keyword">else</span> nums[i] = Integer.parseInt(s.substring(i, i+<span class="number">2</span>)) &lt;= <span class="number">26</span> ? nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] : nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique_Binary_Search_Trees">Unique Binary Search Trees</h2><p>节点数为n的不同BST的数量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//G(n): the number of unique BST for a sequence of length n,序列长度为n的不同BST的数量</span></span><br><span class="line">    <span class="comment">//F(i, n), 1 &lt;= i &lt;= n: the number of unique BST, where the number i is the root of BST,</span></span><br><span class="line">    <span class="comment">//and the sequence ranges from 1 to n.i为根节点，序列为1到n，不同BST的数量</span></span><br><span class="line">    <span class="comment">//则G(n) = F(1,n) + F(2,n)+F(3,n)+......+F(n,n);G(0) = 1(空树),G(1) = 1</span></span><br><span class="line">    <span class="comment">//F(i,n) = G(i-1)*G(n-i)</span></span><br><span class="line">    <span class="comment">//G(n) = G(0)*G(n-1)+G(1)*G(n-2)+......+G(n-1)G(0)</span></span><br><span class="line">    <span class="comment">//G(2) = G(0)G(1) + G(1)G(0)</span></span><br><span class="line">    <span class="comment">//G(3) = G(0)(2)+G(1)G(1)+G(2)G(0)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] G = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                G[i] += G[j-<span class="number">1</span>]*G[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique_Binary_Search_Trees_II">Unique Binary Search Trees II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> genTreeList(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分治算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">genTreeList</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次用[start, end]之间数为根</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">//然后递归求解根i左边[start, i-1]形成的左子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftList = genTreeList(start, i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//递归求解根i右边[i+1, end]区间形成的右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; rightList = genTreeList(i+<span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//左子树中的每个节点都能作为根节点的左孩子</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left : leftList)&#123;</span><br><span class="line">                <span class="comment">//右子树中的每个节点都能作为根节点的右孩子</span></span><br><span class="line">                <span class="comment">//所以将所有的不同的组合加入结果集中</span></span><br><span class="line">                <span class="keyword">for</span>(TreeNode right: rightList)&#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = left;</span><br><span class="line">                    root.right = right;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Count_Numbers_with_Unique_Digits">Count Numbers with Unique Digits</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//10以后的都没必要算了</span></span><br><span class="line">        n = Math.min(n, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>, count = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            count = count * (<span class="number">9</span>-i+<span class="number">2</span>);</span><br><span class="line">            res += count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> uniqueDigits = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> availableNumber = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用availableNumber &gt; 0来去掉那些多余的计算跟用Math.min(10,n);效果类似</span></span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">1</span> &amp;&amp; availableNumber &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            uniqueDigits = uniqueDigits * availableNumber;</span><br><span class="line">            res += uniqueDigits;</span><br><span class="line">            availableNumber--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Perfect_Squares">Perfect Squares</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i]表示正整数i最少能由多少个完全平方数之和组成</span></span><br><span class="line">    <span class="comment">//则dp[i] = min(dp[i - j*j]) + 1，i - j*j &gt;= 0 &amp;&amp; j &gt;= 1 ==&gt; j &lt;= sqrt(i) &amp;&amp; j &gt;= 1</span></span><br><span class="line">    <span class="comment">// public int numSquares(int n) &#123;</span></span><br><span class="line">    <span class="comment">//     if(n &lt;= 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int[] dp = new int[n+1];</span></span><br><span class="line">    <span class="comment">//     //全部元素初始化为最大值</span></span><br><span class="line">    <span class="comment">//     Arrays.fill(dp, Integer.MAX_VALUE);</span></span><br><span class="line">    <span class="comment">//     dp[0] = 0;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt;= n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 1; i - j*j &gt;= 0; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             dp[i] = Math.min(dp[i], dp[i - j*j] + 1);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return dp[n];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n % <span class="number">4</span> == <span class="number">0</span>) n = n / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">8</span> == <span class="number">7</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a =<span class="number">0</span>; a * a &lt;= n; a++)&#123;</span><br><span class="line">            <span class="keyword">int</span> b = (<span class="keyword">int</span>)Math.sqrt(n - a*a);</span><br><span class="line">            <span class="keyword">if</span>(a * a + b* b == n)&#123;</span><br><span class="line">                <span class="keyword">return</span> (a &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) + (b &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ugly_Number_II">Ugly Number II</h2><p>第n个丑数，丑数是素数因子只包含2，3，5的正整数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ugly[0] = 1</span></span><br><span class="line">    <span class="comment">//ugly[1] = min(2*ugly[0], 3*ugly[0], 5*ugly[0])</span></span><br><span class="line">    <span class="comment">//ugly[2] = min(2*ugly[1], 3*ugly[0], 5*ugly[0])</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ugly = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>, index3 = <span class="number">0</span>, index5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;i++)&#123;</span><br><span class="line">            ugly[i] = Math.min(Math.min(<span class="number">2</span> * ugly[index2], <span class="number">3</span> * ugly[index3]), <span class="number">5</span> * ugly[index5]);</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">2</span> * ugly[index2]) index2++;</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">3</span> * ugly[index3]) index3++;</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">5</span> * ugly[index5]) index5++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ugly[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Maximal_Square">Maximal Square</h2><p>给定二维二进制矩阵（值为1或0），找到只包含1的最大的正方形并返回其面积<br>比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>返回4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]表示在点matrix[i][j]最大的正方形的边长</span></span><br><span class="line">    <span class="comment">//边界：dp[i][j] = matrix[i][j], i=0 or j = 0</span></span><br><span class="line">    <span class="comment">//if matrix[i][j] == 0: dp[i][j] = 0, i &gt; 0, j &gt; 0</span></span><br><span class="line">    <span class="comment">//if matrix[i][j] == 1: 那么dp[i][j]由左边、上方、左上方的dp决定</span></span><br><span class="line">    <span class="comment">//dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="comment">//i == 0 || j == 0是边界情况</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//可以不写，java默认初始化为0</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新最长边长</span></span><br><span class="line">                maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实几个if-else也可以合并起来，代码更简洁一些，想不到也没关系，上面的代码可读性更好</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare1</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Integer_Break">Integer Break</h2><p>将一个正整数拆成至少两个整数使得这些整数乘积最大，并返回乘积<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2 = 1+1,1</span></span><br><span class="line">    <span class="comment">//3 = 1+2,2</span></span><br><span class="line">    <span class="comment">//4 = 2+2,4</span></span><br><span class="line">    <span class="comment">//5 = 2+3,6</span></span><br><span class="line">    <span class="comment">//6 = 3+3,9</span></span><br><span class="line">    <span class="comment">//7 = 3+4,12</span></span><br><span class="line">    <span class="comment">//8 = 2+3+3,18</span></span><br><span class="line">    <span class="comment">//9 = 3+3+3,27</span></span><br><span class="line">    <span class="comment">//10 = 3+3+2+2,36</span></span><br><span class="line">    <span class="comment">//11 = 3*3*3*2</span></span><br><span class="line">    <span class="comment">//12 = 3*3*3*3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            product *= <span class="number">3</span>;</span><br><span class="line">            n = n -<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        product *= n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[n] = max(max(i,dp[i])*max(n-i,dp[n-i])),i = 1..n/2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j,dp[j])*Math.max(i-j,dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Maximum_Subarray">Maximum Subarray</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        sum = Math.max(sum+nums[i], nums[i]);</span><br><span class="line"></span><br><span class="line">        maxSum = Math.max(maxSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//max[i]：表示最后一个元素是nums[i]的子数组的最大乘积</span></span><br><span class="line">    <span class="comment">//min[i]：表示最后一个元素是nums[i]的子数组的最小乘积</span></span><br><span class="line">    <span class="comment">//max[i] = max(max[i-1]*nums[i], min[i-1]*nums[i], nums[i])</span></span><br><span class="line">    <span class="comment">//min[i] = min(max[i-1]*nums[i], min[i-1]*nums[i], nums[i])</span></span><br><span class="line">    <span class="comment">//最终的最大子数组乘积maxProduct = max(max[0], max[1],......, max[nums.length - 1])</span></span><br><span class="line">    <span class="comment">//这里既要维护最大值和维护最小值，因为乘法比假发特殊，负负得正，两个很小的负数相乘可能很大</span></span><br><span class="line">    <span class="comment">//有可能变成最大</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProduct = max[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//max[i]的最大值也可能是nums[i]，比如[0,2]时max[1]就为2</span></span><br><span class="line">            max[i] = Math.max(Math.max(max[i-<span class="number">1</span>]*nums[i], min[i-<span class="number">1</span>]*nums[i]), nums[i]);</span><br><span class="line">            <span class="comment">//max[i] = Math.max(max[i-1]*nums[i], min[i-1]*nums[i]);</span></span><br><span class="line"></span><br><span class="line">            min[i] = Math.min(Math.min(max[i-<span class="number">1</span>]*nums[i], min[i-<span class="number">1</span>]*nums[i]), nums[i]);</span><br><span class="line">            <span class="comment">//min[i] = Math.min(max[i-1]*nums[i], min[i-1]*nums[i]);</span></span><br><span class="line"></span><br><span class="line">            maxProduct = Math.max(maxProduct, max[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面的程序我们使用了O(n)的内存空间，使用了两个额外的数组max和min，每个max[i]只与max[i-1]有关，</span></span><br><span class="line">    <span class="comment">//所以其实我们可以省掉这些内存空间，使用几个变量就可以了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxHerePre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> minHerePre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProduct = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minHere, maxHere;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            maxHere = Math.max(Math.max(maxHerePre*nums[i], minHerePre*nums[i]), nums[i]);</span><br><span class="line">            minHere = Math.min(Math.min(maxHerePre*nums[i], minHerePre*nums[i]), nums[i]);</span><br><span class="line"></span><br><span class="line">            maxProduct = Math.max(maxProduct, maxHere);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录前一元素结尾的最大最小值为下次循环做准备</span></span><br><span class="line">            maxHerePre = maxHere;</span><br><span class="line">            minHerePre = minHere;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Counting_Bits">Counting Bits</h2><p>给定一个非负整数num，计算[0,num]中每个数二进制中1的个数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// //bits[i] = bits[i/2] + i%2;</span></span><br><span class="line">    <span class="comment">// //i/2相当于将i(i&gt;=0)右移一位，对于奇数(最右边的比特位为1,&amp;1一定为1)来说,少了一个为1的比特位，需要加1（i%2或者i&amp;1），</span></span><br><span class="line">    <span class="comment">// //对于偶数来说(最右边的比特位为0，&amp;1一定为0)来说，为1的比特位不变</span></span><br><span class="line">    <span class="comment">// public int[] countBits(int num) &#123;</span></span><br><span class="line">    <span class="comment">//     int[] bits = new int[num+1];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt;= num; i++) bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1);</span></span><br><span class="line">    <span class="comment">//     return bits;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bits[i] = bits[i &amp; (i-1)] + 1;</span></span><br><span class="line">    <span class="comment">//i &amp; (i-1)的结果就是讲i最右边为1的比特位置为0，使i的比特位减少1，加上1即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) bits[i] = bits[i &amp; (i-<span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Coin_Change">Coin Change</h2><p>给定不同面值的硬币和一个总额，计算最小的硬币个数来组合成总额，如果组合不出来返回-1。注意每个硬币可以使用多次。</p>
<p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>
<p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i]表示组合成总额为i需要的最少的硬币数量</span></span><br><span class="line">    <span class="comment">//dp[i] = min(dp[i-coins[j]] + 1), coins[j] &lt;= i, 0 &lt;= j &lt; coins.length</span></span><br><span class="line">    <span class="comment">//返回dp[i]即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化为最大值为amount+1，总额为amount至多需要硬币amount个硬币</span></span><br><span class="line">        <span class="comment">//不能初始化为Integer.MAX_VALUE，因为状态转移方程有dp[i] + 1，会溢出:(</span></span><br><span class="line">        <span class="comment">//Arrays.fill(dp, Integer.MAX_VALUE);</span></span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= amount; i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = 0; j &lt; coins.length; j++)&#123;</span></span><br><span class="line">        <span class="comment">//         if(coins[j] &lt;= i)&#123;</span></span><br><span class="line">        <span class="comment">//             dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin: coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt;= amount; i++)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Distinct_Subsequences">Distinct Subsequences</h2><p>给定字符串S和T，计算S中包含不同的子序列T的数目，S = “rabbbit”, T = “rabbit”，返回3<br>空串是任何字符串的子序列<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  S 0123....j</span><br><span class="line">T +----------+</span><br><span class="line">  |<span class="string">1111111111</span>|</span><br><span class="line">0 |<span class="string">0         </span>|</span><br><span class="line">1 |<span class="string">0         </span>|</span><br><span class="line">2 |<span class="string">0         </span>|</span><br><span class="line">. |<span class="string">0         </span>|</span><br><span class="line">. |<span class="string">0         </span>|</span><br><span class="line">i |<span class="string">0         </span>|</span><br></pre></td></tr></table></figure></p>
<p>java代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(s.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return t.length() == 0 ? 1 : 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(t.length() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//dp[i+1][j+1] means that S[0..j] contains T[0..i] that many times as distinct subsequences.</span></span><br><span class="line">        <span class="comment">//Therefor the result will be dp[T.length()][S.length()].</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[t.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//空串是任何字符串的子序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i-<span class="number">1</span>) == s.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[t.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="计算数组下标i与j之间的元素之和">计算数组下标i与j之间的元素之和</h2><p>用sum[i]来存储0到i之间元素的和，0到j的和减去0到i-1的和(即sum[j]-sum[i-1])即为所求。<br><figure class="highlight java]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法]]></title>
    <link href="http://blog.noobsky.com/2016/09/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.noobsky.com/2016/09/26/排序算法/</id>
    <published>2016-09-25T17:54:40.000Z</published>
    <updated>2016-09-25T17:57:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="快速排序">快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int i = left-1;</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, right);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            quickSort(nums, left, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//int[] nums = &#123;1,2,3,4,5,6&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> QuickSort().quickSort(nums,<span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            System.out.println(num + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapsize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left(i);</span><br><span class="line">        <span class="keyword">int</span> r = right(i);</span><br><span class="line">        <span class="keyword">int</span> largest = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l &lt; heapsize &amp;&amp; heap[l] &gt; heap[largest])</span><br><span class="line">            largest = l;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; heapsize &amp;&amp; heap[r] &gt; heap[largest])</span><br><span class="line">            largest = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(largest != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = heap[i];</span><br><span class="line">            heap[i] = heap[largest];</span><br><span class="line">            heap[largest] = temp;</span><br><span class="line">            maxHeapify(largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.heap = nums;</span><br><span class="line">        <span class="keyword">this</span>.heapsize = heap.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapsize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        buildMaxHeap(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heap.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = heap[i];</span><br><span class="line">            heap[i] = heap[<span class="number">0</span>];</span><br><span class="line">            heap[<span class="number">0</span>] = temp;</span><br><span class="line"></span><br><span class="line">            heapsize--;</span><br><span class="line">            maxHeapify(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        HeapSort hs =<span class="keyword">new</span> HeapSort();</span><br><span class="line">        hs.heapSort(nums);</span><br><span class="line"></span><br><span class="line">        nums = hs.heap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            mergeSort(nums, left, mid);</span><br><span class="line">            mergeSort(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">            merge(nums, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> r = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= middle &amp;&amp; r &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[r])&#123;</span><br><span class="line">                temp[index++] = nums[l++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = nums[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= middle)&#123;</span><br><span class="line">            temp[index++] = nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt;= right)&#123;</span><br><span class="line">            temp[index++] = nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right)&#123;</span><br><span class="line">            nums[i] = temp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        MergeSort.mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序">冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/9/26.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        BubbleSort.bubbleSort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="快速排序">快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之链表问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/09/25/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/09/25/面试算法之链表问题集锦/</id>
    <published>2016-09-25T13:49:35.000Z</published>
    <updated>2016-09-27T02:37:21.000Z</updated>
    <content type="html"><![CDATA[<p>链表操作是面试中很基础也很重要的算法问题，链表问题涉及大量的指针操作，操作很灵活，很考查编程基础。链表问题虽然比较基础，但在高压的面试环境中，要写对链表的问题也不是那么的容易啊：(，博主是有血的教训的。本文我将常见的链表问题总结一下。</p>
<p>下面是本文所用到的节点的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">       val = x;</span><br><span class="line">       next = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="判断链表是否有环">判断链表是否有环</h2><p>使用快慢指针，如果链表有环，慢指针必然会追上慢指针。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="找到单链表环的起始点，如果没有环，返回null">找到单链表环的起始点，如果没有环，返回null</h2><p>同理使用快慢指针，如果慢指针追上了快指针时，将快指针或者慢指针重新指向链表的头结点，然后以相同速度遍历，如果它们再次相遇时即为环的起始点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast )&#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;              </span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转单链表">反转单链表</h2><p>最常见的思路是遍历单链表然后通过前插构建单链表就能构建单链表，但是思路不清晰一时半会也写不出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = newHead;</span><br><span class="line">    newHead = head;</span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实要是写不对上面那个，可以用栈来反转，这个很容易写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack.push(head);</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode curr = dummy;</span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    ListNode temp = stack.pop();</span><br><span class="line">    <span class="comment">//要将原节点切断，不然会形成环</span></span><br><span class="line">    temp.next = <span class="keyword">null</span>;</span><br><span class="line">    curr.next = temp;</span><br><span class="line">    curr = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递归和栈很多时候可以相互转化，而且通过递归实现的代码很简洁，递归写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* recursive solution */</span></span><br><span class="line">    <span class="keyword">return</span> reverseListInt(head, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseListInt</span><span class="params">(ListNode head, ListNode newHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = newHead;</span><br><span class="line">    <span class="keyword">return</span> reverseListInt(next, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转单链表中m到n的之间的节点">反转单链表中m到n的之间的节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//pre用于指向需要反转子链表的头结点的前一个节点</span></span><br><span class="line">  ListNode pre = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    pre = pre.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//start指向需要反转的第一个节点</span></span><br><span class="line">  ListNode start = pre.next;</span><br><span class="line">  ListNode then = start.next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反转m到n之间的节点，只需要将m+1到n之间的节点前插到pre的后面即可</span></span><br><span class="line">  <span class="comment">//所以只需要循环n-m次即可</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++)&#123;</span><br><span class="line">    start.next = then.next;</span><br><span class="line"></span><br><span class="line">    then.next = pre.next;</span><br><span class="line">    pre.next = then;</span><br><span class="line"></span><br><span class="line">    then = start.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表的题目就要多用笔在草稿上多画画</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">//pre用来标记需要反转子链表头节点的前一节点</span></span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) pre = pre.next;</span><br><span class="line">    <span class="comment">//start节点指向需要反转的子链表的头结点</span></span><br><span class="line">    ListNode start = pre.next;</span><br><span class="line">    <span class="comment">//指向将被反转的结点</span></span><br><span class="line">    ListNode then = start.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6, m = 2, n = 4, pre = 1, start = 2, then = 3</span></span><br><span class="line">    <span class="comment">//dummy-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们需要将2-&gt;3-&gt;4有三个节点的子链表反转成dummy-&gt;1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;6</span></span><br><span class="line">    <span class="comment">//我们只需要进行n-m=2次交换：首先把3交互到pre.next的位置变成dum-&gt;1-&gt;3-&gt;2-&gt;4-&gt;5-&gt;6</span></span><br><span class="line">    <span class="comment">//然后将4交互到pre.next的位置变成dummy-&gt;1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++)&#123;</span><br><span class="line">        start.next = then.next;</span><br><span class="line">        then.next = pre.next;</span><br><span class="line">        pre.next = then;</span><br><span class="line">        <span class="comment">//下一个需要反转的节点</span></span><br><span class="line">        then = start.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断链表是否为回文结构">判断链表是否为回文结构</h2><p>判断链表是否为回文，可以反转后一半然后跟前一半相比较即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断回文的一种有效方法就是反转后一半然后跟前一半相比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="comment">//fast != null 和判断fast.next != null的方式比较直接</span></span><br><span class="line">        <span class="comment">//当总节点数为偶数时，当循环结束时，fast处于尾节点的后一节点（即指向null），而slow指向n/2+1的位置，即后一半的开头节点</span></span><br><span class="line">        <span class="comment">//当总结点数为奇数时，fast节点处于尾节点，slow处于中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//奇数情况，</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = reverseList(slow);</span><br><span class="line">        <span class="comment">//总结点数为奇数时，slow指向的后一半为比前一半少1个节点，循环结束条件应该用slow</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow.val != head.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="归并两个有序的链表">归并两个有序的链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode temp = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">            temp.next = l1;</span><br><span class="line">            temp = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp.next = l2;</span><br><span class="line">            temp = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回或者删除链表的倒数第k个节点">返回或者删除链表的倒数第k个节点</h2><p>返回倒数第k个节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">theKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode slow = head, fast = head;</span><br><span class="line">  <span class="keyword">int</span> i = k;</span><br><span class="line">  <span class="keyword">for</span>(;i &gt; <span class="number">0</span> &amp;&amp; fast != <span class="keyword">null</span>; i--)&#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//k大于链表的长度</span></span><br><span class="line">  <span class="keyword">if</span>(i &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除倒数第k个节点，相当于要找到倒数第k-1个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//为了处理特殊情况，比如删除最后一个元素，用一个虚拟头结点</span></span><br><span class="line">      ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">      dummy.next = head;</span><br><span class="line">      ListNode first = dummy,second = dummy;</span><br><span class="line">      <span class="comment">//找出倒数第k-1个节点（参考找出倒数第k个节点的题目）</span></span><br><span class="line">      <span class="comment">//第一个指针先向前走k-2步后指向k-1个节点</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;i++)&#123;</span><br><span class="line">          first = first.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//然后第二个指针跟第一个指针同时前进，当第一个指针指向最后一个元素时，第二个指针指向倒数第n-1个元素</span></span><br><span class="line">      <span class="keyword">while</span>(first.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">          first = first.next;</span><br><span class="line">          second = second.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      second.next = second.next.next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="O(1)时间删除链表节点">O(1)时间删除链表节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此种做法要求删除的节点不能是尾节点</p>
<h2 id="交换单链表两两相邻节点">交换单链表两两相邻节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    ListNode current = dummyHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current.next != <span class="keyword">null</span> &amp;&amp; current.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode first = current.next;</span><br><span class="line">        ListNode second = current.next.next;</span><br><span class="line"></span><br><span class="line">        first.next = second.next;</span><br><span class="line">        current.next = second;</span><br><span class="line">        second.next = first;<span class="comment">//或者是current.next.next = first;</span></span><br><span class="line"></span><br><span class="line">        current = current.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个相交单链表的第一个公共节点">两个相交单链表的第一个公共节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode a = headA, b = headB;</span><br><span class="line">    <span class="comment">//当每一个链表的指针到达链表的尾部时，让指针指向另一链表的头指针，当每一个链表的指针都指向过另</span></span><br><span class="line">    <span class="comment">//一链表的头指针后，他们最终会相遇于公共节点，因为他们走过的路程相等，都等于len(链表A) + len(链表B) - 公共部分的长度</span></span><br><span class="line">    <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">        a = a == <span class="keyword">null</span> ? headB : a.next;</span><br><span class="line">        b = b == <span class="keyword">null</span> ? headA : b.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除单链表中等于某个值的所有节点">删除单链表中等于某个值的所有节点</h2><p>从前往后遍历单链表，current指针指向当前遍历节点，删除节点需要用到前一个节点，所以用pre指向current节点的前一个节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  ListNode pre = dummy, current = head;</span><br><span class="line">  <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(current.val == val)&#123;</span><br><span class="line">      pre.next = current.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除有序单链表中的重复节点I">删除有序单链表中的重复节点I</h2><p>删除重复节点，使每个元素只出现一次，比如给定1-&gt;1-&gt;2-&gt;3-&gt;3，返回1-&gt;2-&gt;3。因为单链表有序，所以重复节点都相邻，我们可以遍历单链表判断当前节点和下一个节点的是否相等，相等删除下一个节点即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.next != <span class="keyword">null</span> &amp;&amp; curr.val == curr.next.val)&#123;</span><br><span class="line">      curr.next = curr.next.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除有序单链表中的重复节点II">删除有序单链表中的重复节点II</h2><p>删除单链表中重复元素的所有节点。比如给定1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5，返回1-&gt;2-&gt;5。使用pre指针指向上一个不重复的元素。当出现重复元素时，找到最右边的重复元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  ListNode pre = dummy;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//出现重复元素时，找到最右边的一个重复元素</span></span><br><span class="line">    <span class="keyword">while</span>(curr.next != <span class="keyword">null</span> &amp;&amp; curr.next.val == curr.val)&#123;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有重复元素时，pre和curr相邻</span></span><br><span class="line">    <span class="keyword">if</span>(pre.next == curr)&#123;</span><br><span class="line">      pre = curr;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//出现重复节点，且curr已经指向了最右边的的重复元素</span></span><br><span class="line">      pre.next = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重新排序单链表">重新排序单链表</h2><p>将原始单链表 L: L0→L1→…→Ln-1→Ln，重新排序为L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>基本思路就是反转单链表的后半部分，然后用两个指针分别指向前半部分单链表的头部(这里用slow)和后半部分的单链表的头部(这里用fast)，然后将slow和fast指向的节点链接起来，在这个过程中要借助单链表的中间节点，终止条件也是slow等于中间节点。</p>
<h2 id="Partition_List">Partition List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">//维护两个临时链表，然后遍历一个原链表，将val小于x的存到第一个临时链表中，</span></span><br><span class="line">   <span class="comment">//其他的存到第二个临时链表中，然后将两个临时链接起来即可</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//维护虚拟头结点</span></span><br><span class="line">       ListNode dummy1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>), dummy2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       ListNode curr1 = dummy1, curr2 = dummy2;</span><br><span class="line">       <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">               curr1.next = head;</span><br><span class="line">               curr1 = head;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               curr2.next = head;</span><br><span class="line">               curr2 = head;</span><br><span class="line">           &#125;</span><br><span class="line">           head = head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2，最后curr2指向5，curr2.next指向2，</span></span><br><span class="line">       <span class="comment">//我们需要将curr2.next置为null，不然会出现circle</span></span><br><span class="line">       curr2.next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//将第一个链表跟第二个链表链接起来</span></span><br><span class="line">       curr1.next = dummy2.next;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> dummy1.next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sort_List">Sort List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将list分为两部分</span></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找链表中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分为两部分，pre为空说明slow前面前面没有元素，前半部分单链表为空</span></span><br><span class="line">        <span class="comment">// if(pre != null) pre.next = null;</span></span><br><span class="line">        <span class="comment">// else head = null;</span></span><br><span class="line">        <span class="comment">//这里因为前面if(head == null || head.next == null) return head;保证了起码有两个元素才会往下运行</span></span><br><span class="line">        <span class="comment">//则保证会进入while循环，则pre一定不会为空(前半部分单链表不可能为空)，写成上面先判空也可以</span></span><br><span class="line">        <span class="comment">//置为空，将链表割断</span></span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode l1 = sortList(head);</span><br><span class="line">        ListNode l2 = sortList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l1 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l2 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l2;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将有序单链表转换为BST">将有序单链表转换为BST</h2><p>将升序单链表转换为高度平衡的BST。思路是找出中间节点为根，然后中间节点左右两部分分别用来递归构造左右子树。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode slow = head;</span><br><span class="line">  ListNode fast = head;</span><br><span class="line">  <span class="comment">//pre指向slow前一节点，记录slow前面是否有节点</span></span><br><span class="line">  ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    pre = slow;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//打断链表</span></span><br><span class="line">  <span class="comment">//pre != null意味着slow前面有节点</span></span><br><span class="line">  <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.next = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//pre</span></span><br><span class="line">  <span class="keyword">else</span> head = <span class="keyword">null</span>;</span><br><span class="line">  TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">  root.left = sortedListToBST(head);</span><br><span class="line">  root.right = sortedListToBST(slow.next);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="计算链表表示的两数之和">计算链表表示的两数之和</h2><p>给定两个链表分别代表两个非负整数。数位以倒序存储，并且每一个节点包含一位数字。将两个数字相加并以链表形式返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode p = l1, q = l2, curr = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(p != <span class="keyword">null</span> || q != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> x = p != <span class="keyword">null</span> ? p.val : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = q != <span class="keyword">null</span> ? q.val : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line"></span><br><span class="line">    carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">    curr = curr.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用插入排序排序链表">使用插入排序排序链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  ListNode pre = dummy;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//每次从头开始在有序部分查找插入位置</span></span><br><span class="line">    pre = dummy;</span><br><span class="line">    <span class="keyword">while</span>(pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt;= curr.val)&#123;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode next = curr.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将curr元素插入到pre和pre.next之间</span></span><br><span class="line">    curr.next = pre.next;</span><br><span class="line">    pre.next = curr;</span><br><span class="line"></span><br><span class="line">    curr = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序单链表">排序单链表</h2><p>要求时间复杂度为O(nlgn)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将链表划分为两部分</span></span><br><span class="line">  ListNode slow = head, fast = head;</span><br><span class="line">  ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//寻找链表中间节点</span></span><br><span class="line">  <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    pre = slow;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//if(pre != null) pre.next = null;</span></span><br><span class="line">  <span class="comment">//else head = null;</span></span><br><span class="line">  <span class="comment">//打断单链表</span></span><br><span class="line">  pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode l1 = sortList(head);</span><br><span class="line">  ListNode l2 = sortList(slow);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">      current.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      current.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">  current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="归并k个有序单链表">归并k个有序单链表</h2><p>利用最小堆进行k路归并<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  Queue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.compare(l1.val, l2.val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ListNode node : lists)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">      pq.offer(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode curr = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">    curr.next = pq.poll();</span><br><span class="line"></span><br><span class="line">    curr = curr.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(curr.next != <span class="keyword">null</span>) pq.offer(curr.next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可使用Merge Two Sorted List的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode curr = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            curr.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curr.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curr.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKListsHelper</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) <span class="keyword">return</span> lists[start];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    ListNode l1 = mergeKListsHelper(lists, start, mid);</span><br><span class="line">    ListNode l2 = mergeKListsHelper(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if(lists == null || lists.length == 0) return null;</span></span><br><span class="line">    <span class="keyword">return</span> mergeKListsHelper(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse_Nodes_in_k-Group">Reverse Nodes in k-Group</h2><p>比如：<br>给定单链表1-&gt;2-&gt;3-&gt;4-&gt;5<br>当k=2时，返回：2-&gt;1-&gt;4-&gt;3-&gt;5<br>当k=3时，返回：3-&gt;2-&gt;1-&gt;4-&gt;5<br>最直接的思路就是k个节点反转，然后再k个节点反转一次，直至不足k个节点。<br>或者可以使用递归的解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//找到第k+1个节点</span></span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; count != k)&#123;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">    curr = reverseKGroup(curr, k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时head为没有反转部分的头结点</span></span><br><span class="line">    <span class="comment">//curr是已经反转部分的头结点</span></span><br><span class="line">    <span class="comment">//我们需要将head为头结点的k个节点反转后，将curr指向的已经反转的部分链接到head反转后的后面</span></span><br><span class="line">    <span class="comment">//举个例子原始链表为1-&gt;2-&gt;3-&gt;4-&gt;5, k = 2</span></span><br><span class="line">    <span class="comment">//此时为1-&gt;2-&gt;4-&gt;3-&gt;5，此时head指向1，curr指向4，我们要变成2-&gt;1-&gt;4-&gt;3-&gt;5</span></span><br><span class="line">    <span class="comment">//k-- &gt; 0</span></span><br><span class="line">    <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">      ListNode temp = head.next;</span><br><span class="line">      <span class="comment">//将head指向的节点前插入到curr指向的链表中</span></span><br><span class="line">      head.next = curr;</span><br><span class="line">      curr = head;</span><br><span class="line"></span><br><span class="line">      head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="深拷贝带有随机指针的链表">深拷贝带有随机指针的链表</h2><p>随机指针可以指向任何节点或者null。链表定义如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> label;</span><br><span class="line">     RandomListNode next, random;</span><br><span class="line">     RandomListNode(<span class="keyword">int</span> x) &#123; <span class="keyword">this</span>.label = x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>简单的方法可以使用HashMap，遍历两遍。第一遍将所有节点加入到HashMap中，key为原节点，value为新节点。<br>第二遍给map中节点的next和random赋值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  RandomListNode node = head;</span><br><span class="line">  <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">    map.put(node, <span class="keyword">new</span> RandomListNode(node.label));</span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  node = head;</span><br><span class="line">  <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">    map.get(node).next = map.get(node.next);</span><br><span class="line">    map.get(node).random = map.get(node.random);</span><br><span class="line"></span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>链表操作是面试中很基础也很重要的算法问题，链表问题涉及大量的指针操作，操作很灵活，很考查编程基础。链表问题虽然比较基础，但在高压的面试环境中，要写对链表的问题也不是那么的容易啊：(，博主是有血的教训的。本文我将常见的链表问题总结一下。</p>
<p>下面是本文所用到的节点的]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试基础问题]]></title>
    <link href="http://blog.noobsky.com/2016/09/24/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.noobsky.com/2016/09/24/面试基础问题/</id>
    <published>2016-09-24T02:26:06.000Z</published>
    <updated>2016-09-24T02:55:53.000Z</updated>
    <content type="html"><![CDATA[<p>进程间通信方式：</p>
<p>管道<br>命名管道<br>信号<br>信号量<br>消息队列<br>共享内存<br>套接字</p>
<p>线程间通信方式<br>锁机制：互斥锁、临界区、<br>信号量<br>信号</p>
<p>进程与线程的区别：<br>进程是程序执行时的实例，而线程是进程的某条执行路径</p>
<p>进程有独立的地址空间，线程共享进程的地址空间和资源，线程有自己的堆栈和局部变量</p>
<p>进程是资源分配的基本单位，而线程是cpu调度的基本单位</p>
<p>进程的切换代价大，线程切换代价小</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>进程间通信方式：</p>
<p>管道<br>命名管道<br>信号<br>信号量<br>消息队列<br>共享内存<br>套接字</p>
<p>线程间通信方式<br>锁机制：互斥锁、临界区、<br>信号量<br>信号</p>
<p>进程与线程的区别：<br>进程是程序执行时的实]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Plus One]]></title>
    <link href="http://blog.noobsky.com/2016/09/17/LeetCode-Plus-One/"/>
    <id>http://blog.noobsky.com/2016/09/17/LeetCode-Plus-One/</id>
    <published>2016-09-17T02:59:15.000Z</published>
    <updated>2016-09-17T03:06:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<h2 id="解题思路及代码">解题思路及代码</h2><p>从数字低位往高位循环，如果某位小于9则该位加1后直接返回。否则该位置为0（该位等于9加1进位）继续下一轮循环。如果从低位往高位循环完后程序没有返回，说明程序一直进位，即为9999……，则原来的digits数组已经存不下，需要申请digits.length + 1长度的数组，然后将下标为0的置为1即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public int[] plusOne(int[] digits) &#123;</span></span><br><span class="line">    <span class="comment">//     if(digits == null || digits.length == 0) return null;</span></span><br><span class="line">    <span class="comment">//     int length = digits.length;</span></span><br><span class="line">    <span class="comment">//     for(int i = length -1; i &gt;= 0; i--)&#123;</span></span><br><span class="line">    <span class="comment">//         //遇到第一位小于9的时，该位+1，然后程序返回</span></span><br><span class="line">    <span class="comment">//         if(digits[i] &lt; 9)&#123;</span></span><br><span class="line">    <span class="comment">//             digits[i]++;</span></span><br><span class="line">    <span class="comment">//             return digits;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         //该位等于9，置为0，进行下一轮循环</span></span><br><span class="line">    <span class="comment">//         digits[i] = 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //程序能走到这里的话，则digits中为99999...加1后digits已经存不下。。。</span></span><br><span class="line">    <span class="comment">//     int[] res = new int[digits.length+1];</span></span><br><span class="line">    <span class="comment">//     //最高位置为1，其他位默认初始为0</span></span><br><span class="line">    <span class="comment">//     res[0] = 1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits)&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="keyword">null</span> || digits.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> length = digits.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] &lt; <span class="number">9</span>)&#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are store]]>
    </summary>
    
      <category term="Array" scheme="http://blog.noobsky.com/tags/Array/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="Math" scheme="http://blog.noobsky.com/tags/Math/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
