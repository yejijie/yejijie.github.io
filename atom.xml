<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-07-11T06:20:13.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Add and Search Word - Data structure design]]></title>
    <link href="http://blog.noobsky.com/2016/07/11/LeetCode-Add-and-Search-Word-Data-structure-design/"/>
    <id>http://blog.noobsky.com/2016/07/11/LeetCode-Add-and-Search-Word-Data-structure-design/</id>
    <published>2016-07-11T06:12:10.000Z</published>
    <updated>2016-07-11T06:20:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Design a data structure that supports the following two operations:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">addWord</span><span class="params">(word)</span></span></span><br><span class="line">bool <span class="function"><span class="title">search</span><span class="params">(word)</span></span></span><br></pre></td></tr></table></figure></p>
<p>search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p>
<p>For example:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"bad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"dad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"mad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"pad"</span>)</span></span> -&gt; false</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"bad"</span>)</span></span> -&gt; true</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">".ad"</span>)</span></span> -&gt; true</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"b.."</span>)</span></span> -&gt; true</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>You may assume that all words are consist of lowercase letters a-z.</p>
<h2 id="代码">代码</h2><p>直接使用前缀树（trie树）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isWord = <span class="keyword">false</span>;</span><br><span class="line">        TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="comment">// Adds a word into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : word.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) node.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line">    <span class="comment">// contain the dot character '.' to represent any one letter.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match(word, <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//match函数，看根节点为node的trie树是否匹配word.substring(index);</span></span><br><span class="line">    <span class="comment">//分为两种情况一种是.，我们要遍历node的所有子节点，若子节点不为空且沿着该子节点能匹配，则返回true，如果遍历了26个子节点</span></span><br><span class="line">    <span class="comment">//都不匹配，返回false</span></span><br><span class="line">    <span class="comment">//如果字符不为.，判断node的子节点是否存在该字符，存在则递归判断否则返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String word, <span class="keyword">int</span> index, TrieNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= word.length()) <span class="keyword">return</span> node.isWord;</span><br><span class="line">        <span class="keyword">char</span> ch = word.charAt(index);</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="comment">//如果children节点有不为空可以继续往下搜索</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node.children.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.children[i] != <span class="keyword">null</span> &amp;&amp; match(word, index+<span class="number">1</span>, node.children[i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.children[ch - <span class="string">'a'</span>] != <span class="keyword">null</span> &amp;&amp; match(word, index + <span class="number">1</span>, node.children[ch - <span class="string">'a'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// WordDictionary wordDictionary = new WordDictionary();</span></span><br><span class="line"><span class="comment">// wordDictionary.addWord("word");</span></span><br><span class="line"><span class="comment">// wordDictionary.search("pattern");</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Design a data structure that supports the following two operations:<br><figure class="highlight stylus"><table><tr]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Water and Jug Problem]]></title>
    <link href="http://blog.noobsky.com/2016/07/11/LeetCode-Water-and-Jug-Problem/"/>
    <id>http://blog.noobsky.com/2016/07/11/LeetCode-Water-and-Jug-Problem/</id>
    <published>2016-07-11T04:42:17.000Z</published>
    <updated>2016-07-11T05:36:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.</p>
<p>If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.</p>
<p>Operations allowed:</p>
<ul>
<li>Fill any of the jugs completely with water.</li>
<li>Empty any of the jugs.</li>
<li>Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.</li>
</ul>
<p><strong>Example 1:</strong> (From the famous “Die Hard” example)</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">x = 3, y = 5, z = 4</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="string">True</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">x = 2, y = 6, z = 5</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="string">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><p>这是一个数学问题，主要运用贝祖定理，贝祖定理见维基百科<a href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity" target="_blank" rel="external">Bézout’s identity</a>和百度百科<a href="http://baike.baidu.com/view/1008375.htm" target="_blank" rel="external">贝祖定理</a>。主要内容如下：</p>
<figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="keyword">and</span> b <span class="keyword">be</span> nonzero integers <span class="keyword">and</span> <span class="keyword">let</span> d <span class="keyword">be</span> their greatest common divisor. Then there exist integers x</span><br><span class="line"><span class="keyword">and</span> y <span class="keyword">such</span> <span class="keyword">that</span> ax+<span class="keyword">by</span>=d</span><br><span class="line"></span><br><span class="line">In addition, the greatest common divisor d <span class="keyword">is</span> the smallest positive integer <span class="keyword">that</span> can <span class="keyword">be</span> written <span class="keyword">as</span> ax + <span class="keyword">by</span></span><br><span class="line"></span><br><span class="line">every integer <span class="keyword">of</span> the form ax + <span class="keyword">by</span> <span class="keyword">is</span> a multiple <span class="keyword">of</span> the greatest common divisor d.</span><br></pre></td></tr></table></figure>
<p>也就是说整数a和b和它们的最大公约数d，对于任意的整数x，y，ax+by都一定是d的倍数。所以基本的算法为使用贝祖定理，检查z是否为x和y最大公约数的倍数。在本题中如果a或b是负数，意味着我们把x容量或y容量的水倒掉。如果a或b是正数，意味着我们每次将x容量或者y容量的杯子装满水。</p>
<p>比如x = 4，y = 6，z = 8<br>GCD(4, 6) = 2，8是2的倍数，所以该输入时有效的，因为有：<br>-1<em>4 + 6 </em> 2 = 8</p>
<p>说明我们获得该解可以通过将容量为6的杯子两次充满水，将容量为4的杯子中水倒掉一次。具体过程为，将容量为6的杯子装满水，然后倒进4升水到容量为4的杯子，然后将容量为4的杯子中的水倒掉，然后将容量为6的杯子剩下的2升水导入容量为4的杯子中。然后将容量为6的杯子装满水，即得到8升水。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果x+y &lt; z return false</span></span><br><span class="line">        <span class="comment">//z == 0这个条件不能去掉</span></span><br><span class="line">        <span class="comment">//因为我们要防止GCD(x,y)==0,会发生除0异常</span></span><br><span class="line">        <span class="comment">//要使得GCD(x,y)==0，只能是x = 0,y = 0</span></span><br><span class="line">        <span class="comment">//而条件x + y &gt;= z使得只剩下x = 0, y = 0，z=0这种情况</span></span><br><span class="line">        <span class="comment">//加上z == 0就可以过滤掉</span></span><br><span class="line">        <span class="keyword">return</span> z == <span class="number">0</span> || x + y &gt;= z &amp;&amp; z % GCD(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求最大公约数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = b;</span><br><span class="line">            b = a % b;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的测试用例好像比较弱，x + y没有发生溢出，如果要防止溢出的话可以用long类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//求最大公约数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = b;</span><br><span class="line">            b = a % b;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的测试用例好像比较弱，x + y没有发生溢出，如果要防止溢出的话可以用long类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果x+y &lt; z return false</span></span><br><span class="line">        <span class="comment">//z == 0这个条件不能去掉</span></span><br><span class="line">        <span class="comment">//因为我们要防止GCD(x,y)==0,会发生除0异常</span></span><br><span class="line">        <span class="comment">//要使得GCD(x,y)==0，只能是x = 0,y = 0</span></span><br><span class="line">        <span class="comment">//而条件x + y &gt;= z使得只剩下x = 0, y = 0，z=0这种情况</span></span><br><span class="line">        <span class="comment">//加上z == 0就可以过滤掉</span></span><br><span class="line">        <span class="keyword">return</span> z == <span class="number">0</span> || (<span class="keyword">long</span>)x + y &gt;= z &amp;&amp; z % GCD(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Simplify Path]]></title>
    <link href="http://blog.noobsky.com/2016/07/10/LeetCode-Simplify-Path/"/>
    <id>http://blog.noobsky.com/2016/07/10/LeetCode-Simplify-Path/</id>
    <published>2016-07-10T15:41:39.000Z</published>
    <updated>2016-07-10T15:45:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”</p>
<p><strong>Corner Cases:</strong></p>
<ul>
<li>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.</li>
<li>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.<br>In this case, you should ignore redundant slashes and return “/home/foo”.</li>
</ul>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//想法挺tricky的，遇到有效的文件名（不是"",".",".."）则压入栈中，遇到"..",弹出栈顶元素，因为".."代表上一层</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath1</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; skip = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">".."</span>, <span class="string">"."</span>,<span class="string">""</span>));</span><br><span class="line">        <span class="keyword">for</span>(String dir : path.split(<span class="string">"/"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">".."</span>.equals(dir) &amp;&amp; !stack.isEmpty()) stack.pop();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!skip.contains(dir)) stack.push(dir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String res = "";</span></span><br><span class="line">        <span class="comment">// for(String dir: stack)&#123;</span></span><br><span class="line">        <span class="comment">//     res = "/" + dir + res;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(stack.peekLast() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.append(<span class="string">"/"</span>);</span><br><span class="line">            res.append(stack.pollLast());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//return res.length() == 0 ? "/" : res;</span></span><br><span class="line">        <span class="keyword">return</span> res.length() == <span class="number">0</span> ? <span class="string">"/"</span> : res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集合也可以不使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//其实集合也可以不使用</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Set&lt;String&gt; skip = new HashSet&lt;&gt;(Arrays.asList("..", ".",""));</span></span><br><span class="line">    <span class="keyword">for</span>(String dir : path.split(<span class="string">"/"</span>))&#123;</span><br><span class="line">        <span class="comment">// if("..".equals(dir) &amp;&amp; !stack.isEmpty()) stack.pop();</span></span><br><span class="line">        <span class="comment">// else if(!skip.contains(dir)) stack.push(dir);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">".."</span>.equals(dir))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty()) stack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="string">""</span>.equals(dir) &amp;&amp; !<span class="string">"."</span>.equals(dir))&#123;</span><br><span class="line">            stack.push(dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(String dir: stack)&#123;</span><br><span class="line">        res = <span class="string">"/"</span> + dir + res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res.length() == <span class="number">0</span> ? <span class="string">"/"</span> : res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt; “/home”]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Design Twitter]]></title>
    <link href="http://blog.noobsky.com/2016/07/10/LeetCode-Design-Twitter/"/>
    <id>http://blog.noobsky.com/2016/07/10/LeetCode-Design-Twitter/</id>
    <published>2016-07-10T11:21:25.000Z</published>
    <updated>2016-07-10T11:24:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods:</p>
<pre><code><span class="number">1</span>. postTweet(userId, tweetId): Compose a new tweet.
<span class="number">2</span>. getNewsFeed(userId): Retrieve the <span class="number">10</span> most recent tweet ids <span class="operator">in</span> the user's news feed. Each item <span class="operator">in</span> the news feed must be posted by users who the <span class="keyword">user</span> <span class="title">followed</span> <span class="operator">or</span> by the <span class="keyword">user</span> <span class="title">herself</span>. Tweets must be ordered from most recent to least recent.
<span class="number">3</span>. follow(followerId, followeeId): Follower follows a followee.
<span class="number">4</span>. unfollow(followerId, followeeId): Follower unfollows a followee.
</code></pre><p><strong>Example:</strong><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Twitter twitter = new Twitter();</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span> posts a new tweet (id = <span class="number">5</span>).</span><br><span class="line">twitter.postTweet(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span>'s news feed should return a list with <span class="number">1</span> tweet id -&gt; [<span class="number">5</span>].</span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span> follows <span class="keyword">user</span> <span class="title">2</span>.</span><br><span class="line">twitter.follow(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">2</span> posts a new tweet (id = <span class="number">6</span>).</span><br><span class="line">twitter.postTweet(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span>'s news feed should return a list with <span class="number">2</span> tweet ids -&gt; [<span class="number">6</span>, <span class="number">5</span>].</span><br><span class="line">// Tweet id <span class="number">6</span> should precede tweet id <span class="number">5</span> because it is posted after tweet id <span class="number">5</span>.</span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span> unfollows <span class="keyword">user</span> <span class="title">2</span>.</span><br><span class="line">twitter.unfollow(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// <span class="keyword">User</span> <span class="title">1</span>'s news feed should return a list with <span class="number">1</span> tweet id -&gt; [<span class="number">5</span>],</span><br><span class="line">// since <span class="keyword">user</span> <span class="title">1</span> is no longer following <span class="keyword">user</span> <span class="title">2</span>.</span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间戳，发推文的使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> timeStamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存用户，key为用户id，value为对应的user</span></span><br><span class="line">    <span class="comment">//用HashMap存，可以非常容易判断用户是否存在</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, User&gt; userMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//推文，推文使用单链表链接起来</span></span><br><span class="line">    <span class="comment">//当我们获取某个人的推文时可以快速获取到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span></span>&#123;</span><br><span class="line">        <span class="comment">//推文id</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="comment">//发表时间，用时间戳表示</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> time;</span><br><span class="line">        <span class="comment">//指向下一条推文</span></span><br><span class="line">        <span class="keyword">public</span> Tweet next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            time = timeStamp++;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="comment">//用户id</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户followed的用户集合</span></span><br><span class="line">        <span class="keyword">public</span> Set&lt;Integer&gt; followed;</span><br><span class="line">        <span class="comment">//用户发的推文</span></span><br><span class="line">        <span class="keyword">public</span> Tweet tweetHead;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            followed = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">//用户肯定第一个先Follow自己</span></span><br><span class="line">            follow(id);</span><br><span class="line"></span><br><span class="line">            tweetHead = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            followed.add(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            followed.remove(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            <span class="comment">//生成一条推文</span></span><br><span class="line">            Tweet tweet = <span class="keyword">new</span> Tweet(id);</span><br><span class="line">            <span class="comment">//每次发推文时，将推文插入到推文链表的头部</span></span><br><span class="line">            tweet.next = tweetHead;</span><br><span class="line">            tweetHead = tweet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(userId))&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User(userId);</span><br><span class="line">            userMap.put(userId, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userMap.get(userId).post(tweetId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(userId)) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取userId用户的followed的用户（包括自己）</span></span><br><span class="line">        Set&lt;Integer&gt; users = userMap.get(userId).followed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将推文加入</span></span><br><span class="line">        PriorityQueue&lt;Tweet&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(users.size(), <span class="keyword">new</span> Comparator&lt;Tweet&gt;()&#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tweet a, Tweet b)</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> b.time - a.time;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> user : users)&#123;</span><br><span class="line">            Tweet t = userMap.get(user).tweetHead;</span><br><span class="line">            <span class="keyword">if</span>(t != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.offer(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty() &amp;&amp; n &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            Tweet t = pq.poll();</span><br><span class="line">            res.add(t.id);</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">if</span>(t.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.add(t.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(followerId))&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User(followerId);</span><br><span class="line">            userMap.put(followerId, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(followeeId))&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User(followeeId);</span><br><span class="line">            userMap.put(followeeId, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userMap.get(followerId).follow(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!userMap.containsKey(followerId) || followerId == followeeId)&#123;</span><br><span class="line">            <span class="keyword">return</span>;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userMap.get(followerId).unfollow(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your Twitter object will be instantiated and called as such:</span><br><span class="line"> * Twitter obj = new Twitter();</span><br><span class="line"> * obj.postTweet(userId,tweetId);</span><br><span class="line"> * List&lt;Integer&gt; param_2 = obj.getNewsFeed(userId);</span><br><span class="line"> * obj.follow(followerId,followeeId);</span><br><span class="line"> * obj.unfollow(followerId,followeeId);</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to se]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Multiply Strings]]></title>
    <link href="http://blog.noobsky.com/2016/07/09/LeetCode-Multiply-Strings/"/>
    <id>http://blog.noobsky.com/2016/07/09/LeetCode-Multiply-Strings/</id>
    <published>2016-07-09T14:44:07.000Z</published>
    <updated>2016-07-09T15:09:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The numbers can be arbitrarily large and are non-negative.</li>
<li>Converting the input string to integer is NOT allowed.</li>
<li>You should NOT use internal library such as BigInteger.</li>
</ul>
<h2 id="代码">代码</h2><p>规律是： <code>num1[i] * num2[j]</code> will be placed at indices <code>[i + j</code>, <code>i + j + 1]</code> ，如下图：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/multiply.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//num1[i]*num2[j]的乘积位于结果中的下标[i+j, i+j+1]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">        <span class="comment">//数的低位位于字符串的后面，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> mul = (num1.charAt(i) - <span class="string">'0'</span>) * (num2.charAt(j) - <span class="string">'0'</span>);</span><br><span class="line">                <span class="comment">//记得加上res[i+j+1]</span></span><br><span class="line">                <span class="keyword">int</span> sum = mul + res[i+j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                res[i+j+<span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//不要漏了res[i+j]本身的部分</span></span><br><span class="line">                <span class="comment">//因为有多个i和j的组合num1[i]和num2[j]乘积会有一部分位于res[i+j]</span></span><br><span class="line">                res[i+j] = res[i+j] + sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// int i = 0;</span></span><br><span class="line">        <span class="comment">// for(i = 0; i &lt; m+n; i++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(res[i] != 0) break;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// for(int j = i; j &lt; m+n; j++)&#123;</span></span><br><span class="line">        <span class="comment">//     sb.append(res[j]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return sb.length() == 0 ? "0" : sb.toString();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> digit : res)&#123;</span><br><span class="line">            <span class="comment">//sb.length() != 0 || digit != 0</span></span><br><span class="line">            <span class="keyword">if</span>(!(sb.length() == <span class="number">0</span> &amp;&amp; digit == <span class="number">0</span>)) sb.append(digit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">"0"</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p><strong>Note:</]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Basic Calculator I II III]]></title>
    <link href="http://blog.noobsky.com/2016/07/08/LeetCode-Basic-Calculator-I-II/"/>
    <id>http://blog.noobsky.com/2016/07/08/LeetCode-Basic-Calculator-I-II/</id>
    <published>2016-07-08T13:49:45.000Z</published>
    <updated>2016-07-09T12:31:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Basic_Calculator_I">Basic Calculator I</h2><h3 id="题目描述">题目描述</h3><p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1 + 1"</span> = <span class="number">2</span></span><br><span class="line"><span class="string">" 2-1 + 2 "</span> = <span class="number">3</span></span><br><span class="line"><span class="string">"(1+(4+5+2)-3)+(6+8)"</span> = <span class="number">23</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong> Do not use the eval built-in library function.</p>
<h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始结果</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始符号</span></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//如果是多位数字字符，转化为数值</span></span><br><span class="line">                <span class="comment">//这样写是对的，1+1这样才不会跳过+号</span></span><br><span class="line">                <span class="comment">//先判断再进入，才不会让i多加一次，详见后面III</span></span><br><span class="line">                <span class="keyword">while</span>(i + <span class="number">1</span> &lt; len &amp;&amp; Character.isDigit(s.charAt(i+<span class="number">1</span>)))&#123;</span><br><span class="line">                    sum = sum * <span class="number">10</span> + s.charAt(i+<span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将转化后的数值加入到结果中</span></span><br><span class="line">                result += sign * sum;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span>)&#123;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'-'</span>)&#123;</span><br><span class="line">                sign = -<span class="number">1</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="comment">//将左括号前面部分的计算结果压入栈中</span></span><br><span class="line">                stack.push(result);</span><br><span class="line">                <span class="comment">//将左括号前面的正负号压入栈中</span></span><br><span class="line">                stack.push(sign);</span><br><span class="line">                <span class="comment">//并重新初始化result和sign</span></span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="comment">//先从栈中弹出的是符号，接着是前面部分的结果</span></span><br><span class="line">                result = result * stack.pop() + stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的tricky之处在左括号和右括号的处理，下面说说个人理解。<br><code>s.charAt(i) == &#39;-&#39;</code>:</p>
<p>遇到(时将左括号之前计算的结果和符号(即左括号前的加减号，加号为1减号为-1)压入栈中，后面遇到右括号时再取出来合并。比如(1+(4+5+2)-3)+(6+8)，第一个左括号时，即1前面的左括号，将前面的计算结果和符号0和1压入栈中，此时相当于在前面加上0+，表达式变成0+(1+(4+5+2)-3)+(6+8)，不影响结果。当遇到第二个左括号时即4前面的左括号时，将该左括号前面表达式的计算结果1和符号1压入栈中，结合下面右括号的分析就能领会到程序的tricky之处了。</p>
<p><code>s.charAt(i) == &#39;)&#39;</code>:</p>
<p>当遇到右括号时，从栈中取出遇到与该右括号配对的左括号时压入的左括号前面部分计算结果和符号进行结果的合并。比如当我们遇到2后面的右括号，当前的计算结果result为4+5+2=11，此时我们取出与2后面的右括号配对的左括号即4前面的左括号压入栈中的结果和符号，即符号1和结果1（其中符号1代表4前面的左括号前面为加号），然后进行合并，即我们将当前的结果11乘以符号1加上前面的结果1，也即是11<em>1 + 1 = 12。同理我们再来分析一下3后面的右括号，此时的计算结果result=12-3=9，我们取出与3后面右括号配对的1前面的左括号压入栈中的结果0和符号1，然后进行合并，即result </em> stack.pop() + stack.pop();–&gt;9 * 1 + 0 = 9。</p>
<p>下面的思想类似，但是注意的地方比较多<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录字符的数字值</span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//保存结果</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//代表符号</span></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(ch))&#123;</span><br><span class="line">                number = number * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'+'</span>)&#123;</span><br><span class="line">                <span class="comment">//说明前面的数字已经完了，我们可以将number加到结果中去,开始新的number的计算</span></span><br><span class="line">                result += sign * number;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'-'</span>)&#123;</span><br><span class="line">                result += sign * number;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                sign = -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'('</span>)&#123;</span><br><span class="line">                stack.push(result);</span><br><span class="line">                stack.push(sign);</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="comment">//右括号也代表一个数字的结束</span></span><br><span class="line">                result += sign * number;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                result = result * stack.pop() + stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后要记得计算最后一个number</span></span><br><span class="line">        <span class="keyword">if</span>(number != <span class="number">0</span>) result += sign * number;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Basic_Calculator_II">Basic Calculator II</h2><h3 id="问题描述">问题描述</h3><p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"3+2*2"</span> = <span class="number">7</span></span><br><span class="line"><span class="string">" 3/2 "</span> = <span class="number">1</span></span><br><span class="line"><span class="string">" 3+5 / 2 "</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong> Do not use the eval built-in library function.</p>
<h3 id="代码-1">代码</h3><p>这里没有括号只有加减乘除和空格，除法舍弃掉小数部分。思路就是就是用一个符号sign表示每个number前面的符号，当我们在s中遇到一个符号时，说明数字部分已经结束，可以根据number前面的符号sign来对number进行计算了。比如如果number前面的符号为+，则将number压入栈中；如果前面的符号为-则将-number压入栈中；如果是*，则从栈中pop出一个元素和该number相乘后结果压入栈中；如果是/,则从栈中pop出一个元素和该number相除后将结果压入栈中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里没有括号只有加减乘除和空格，除法舍弃掉小数部分</span></span><br><span class="line">    <span class="comment">// 思路就是就是用一个符号sign表示每个number前面的符号，当我们在s中遇到一个符号时，说明数字部分已经结束</span></span><br><span class="line">    <span class="comment">// 可以根据number前面的符号sign来对number进行计算了，比如如果number前面的符号为+，则将number压入栈中；</span></span><br><span class="line">    <span class="comment">// 如果前面的符号为-则将-number压入栈中；如果是*，则从栈中pop出一个元素和该number相乘后结果压入栈中；如果是/,</span></span><br><span class="line">    <span class="comment">// 则从栈中pop出一个元素和该number相除后将结果压入栈中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化为+相当于在表达式前面增加了一个+号，不影响结果</span></span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(ch))&#123;</span><br><span class="line">                number = number * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是+、-、*、/</span></span><br><span class="line">            <span class="comment">//或者是最后一个字符，进入该if</span></span><br><span class="line">            <span class="comment">//说明number已经结束，可以根据number前面的符号进行运算了</span></span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(ch) &amp;&amp; <span class="string">' '</span> != ch || i == length -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//number前面为加号</span></span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'+'</span>)&#123;</span><br><span class="line">                    stack.push(number);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">'-'</span>)&#123;</span><br><span class="line">                    stack.push(-number);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    stack.push(stack.pop() * number);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">'/'</span>)&#123;</span><br><span class="line">                    stack.push(stack.pop() / number);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新当前遇到的符号为下一个number前面的符号</span></span><br><span class="line">                sign = ch;</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : stack)&#123;</span><br><span class="line">            result += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Basic_Calculator_III">Basic Calculator III</h2><h3 id="题目描述-1">题目描述</h3><p>自己出的题：），结合I和II进行表达式求值，即有+、-、*、/、空格和括号。</p>
<h3 id="代码-2">代码</h3><ul>
<li>解法一</li>
</ul>
<p>先将中缀表达式转化为后缀表达式（逆波兰式），然后进行计算。可以参见<a href="http://www.cnblogs.com/yinger/archive/2011/07/01/2095500.html" target="_blank" rel="external">表达式求值</a>。但其实我们可以在中缀转后缀的过程中同时表达式的值。见下面的解法二。</p>
<ul>
<li>解法二</li>
</ul>
<p>利用Shunting-yard algorithm算法，详见维基百科<a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm" target="_blank" rel="external">Shunting-yard algorithm</a>和geeksforgeeks的<a href="http://www.geeksforgeeks.org/expression-evaluation/" target="_blank" rel="external">Expression Evaluation</a>，算法如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> While there are still tokens <span class="built_in">to</span> be <span class="built_in">read</span> <span class="operator">in</span>,</span><br><span class="line">   <span class="number">1.1</span> Get <span class="operator">the</span> next <span class="keyword">token</span>.</span><br><span class="line">   <span class="number">1.2</span> If <span class="operator">the</span> <span class="keyword">token</span> is:</span><br><span class="line">       <span class="number">1.2</span><span class="number">.1</span> A <span class="built_in">number</span>: push <span class="keyword">it</span> onto <span class="operator">the</span> <span class="built_in">value</span> stack.</span><br><span class="line">       <span class="number">1.2</span><span class="number">.2</span> A <span class="built_in">variable</span>: <span class="built_in">get</span> its <span class="built_in">value</span>, <span class="operator">and</span> push onto <span class="operator">the</span> <span class="built_in">value</span> stack.</span><br><span class="line">       <span class="number">1.2</span><span class="number">.3</span> A left parenthesis: push <span class="keyword">it</span> onto <span class="operator">the</span> operator stack.</span><br><span class="line">       <span class="number">1.2</span><span class="number">.4</span> A <span class="constant">right</span> parenthesis:</span><br><span class="line">         <span class="number">1</span> While <span class="operator">the</span> thing <span class="command"><span class="keyword">on</span> <span class="title">top</span> <span class="title">of</span> <span class="title">the</span> <span class="title">operator</span> <span class="title">stack</span> <span class="title">is</span> <span class="title">not</span> <span class="title">a</span></span></span><br><span class="line">           left parenthesis,</span><br><span class="line">             <span class="number">1</span> Pop <span class="operator">the</span> operator <span class="built_in">from</span> <span class="operator">the</span> operator stack.</span><br><span class="line">             <span class="number">2</span> Pop <span class="operator">the</span> <span class="built_in">value</span> stack twice, getting <span class="constant">two</span> operands.</span><br><span class="line">             <span class="number">3</span> Apply <span class="operator">the</span> operator <span class="built_in">to</span> <span class="operator">the</span> operands, <span class="operator">in</span> <span class="operator">the</span> correct order.</span><br><span class="line">             <span class="number">4</span> Push <span class="operator">the</span> <span class="built_in">result</span> onto <span class="operator">the</span> <span class="built_in">value</span> stack.</span><br><span class="line">         <span class="number">2</span> Pop <span class="operator">the</span> left parenthesis <span class="built_in">from</span> <span class="operator">the</span> operator stack, <span class="operator">and</span> discard <span class="keyword">it</span>.</span><br><span class="line">       <span class="number">1.2</span><span class="number">.5</span> An operator (call <span class="keyword">it</span> thisOp):</span><br><span class="line">         <span class="number">1</span> While <span class="operator">the</span> operator stack is <span class="operator">not</span> <span class="constant">empty</span>, <span class="operator">and</span> <span class="operator">the</span> top thing <span class="command"><span class="keyword">on</span> <span class="title">the</span></span></span><br><span class="line">           operator stack has <span class="operator">the</span> same <span class="operator">or</span> greater precedence <span class="keyword">as</span> thisOp,</span><br><span class="line">           <span class="number">1</span> Pop <span class="operator">the</span> operator <span class="built_in">from</span> <span class="operator">the</span> operator stack.</span><br><span class="line">           <span class="number">2</span> Pop <span class="operator">the</span> <span class="built_in">value</span> stack twice, getting <span class="constant">two</span> operands.</span><br><span class="line">           <span class="number">3</span> Apply <span class="operator">the</span> operator <span class="built_in">to</span> <span class="operator">the</span> operands, <span class="operator">in</span> <span class="operator">the</span> correct order.</span><br><span class="line">           <span class="number">4</span> Push <span class="operator">the</span> <span class="built_in">result</span> onto <span class="operator">the</span> <span class="built_in">value</span> stack.</span><br><span class="line">         <span class="number">2</span> Push thisOp onto <span class="operator">the</span> operator stack.</span><br><span class="line"><span class="number">2.</span> While <span class="operator">the</span> operator stack is <span class="operator">not</span> <span class="constant">empty</span>,</span><br><span class="line">    <span class="number">1</span> Pop <span class="operator">the</span> operator <span class="built_in">from</span> <span class="operator">the</span> operator stack.</span><br><span class="line">    <span class="number">2</span> Pop <span class="operator">the</span> <span class="built_in">value</span> stack twice, getting <span class="constant">two</span> operands.</span><br><span class="line">    <span class="number">3</span> Apply <span class="operator">the</span> operator <span class="built_in">to</span> <span class="operator">the</span> operands, <span class="operator">in</span> <span class="operator">the</span> correct order.</span><br><span class="line">    <span class="number">4</span> Push <span class="operator">the</span> <span class="built_in">result</span> onto <span class="operator">the</span> <span class="built_in">value</span> stack.</span><br><span class="line"><span class="number">3.</span> At this point <span class="operator">the</span> operator stack should be <span class="constant">empty</span>, <span class="operator">and</span> <span class="operator">the</span> <span class="built_in">value</span></span><br><span class="line">   stack should have only <span class="constant">one</span> <span class="built_in">value</span> <span class="operator">in</span> <span class="keyword">it</span>, which is <span class="operator">the</span> final <span class="built_in">result</span>.</span><br></pre></td></tr></table></figure>
<p>总结一下就是：</p>
<p>使用两个栈stack，一个存数字一个存操作符，如果是数字直接存到数字stack中；如果是操作符(+、-、*、/)，有以下几种情况：</p>
<ol>
<li>当前操作符比上一个操作符（即操作符栈栈顶符号）优先级高，比如*高于+，那么直接进栈</li>
<li>当前操作符优先级低于或者等于上一个，那么就要把所有在操作符栈中高于等于当前操作符的全部计算完，再将当前操作符压入栈中。</li>
<li>当前符号是”(“，直接压入操作符栈中</li>
<li>当前符号是”)”，就要把所有”)”之前和与它配对的”(“之后的操作符全部计算完。就是不断计算直到操作符栈顶为”(“，并把左括号出栈。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作数栈</span></span><br><span class="line">        Stack&lt;Integer&gt; values = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//操作符栈，栈中只会有+、-、*、/和(</span></span><br><span class="line">        Stack&lt;Character&gt; ops = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//ch &gt;= '0' &amp;&amp; ch &lt;= '9'</span></span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(ch))&#123;</span><br><span class="line">                <span class="comment">// int number = 0;</span></span><br><span class="line">                <span class="comment">// 用s.charAt(i)不容易出错</span></span><br><span class="line">                <span class="comment">// ！！！不能这样写，这样写的话比如1+1时，会跳过+号，相当于i++了多了一次</span></span><br><span class="line">                <span class="comment">// while(i &lt; length &amp;&amp; Character.isDigit(s.charAt(i)))&#123;</span></span><br><span class="line">                <span class="comment">//     number = number * 10 + s.charAt(i) - '0';</span></span><br><span class="line">                <span class="comment">//     i++;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="keyword">int</span> number = s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//这样写比如1+1时i+1 = 1时为+号不会进入while循环，i也就不会++，不会跳过+号</span></span><br><span class="line">                <span class="keyword">while</span>(i+<span class="number">1</span> &lt; length &amp;&amp; Character.isDigit(s.charAt(i+<span class="number">1</span>)))&#123;</span><br><span class="line">                    number = number * <span class="number">10</span> + s.charAt(i+<span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                values.push(number);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'('</span>)&#123;</span><br><span class="line">                ops.push(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="comment">//一直计算，直到操作符栈顶为左括号</span></span><br><span class="line">                <span class="comment">//就是将一对括号()中的运算算完</span></span><br><span class="line">                <span class="keyword">while</span> (ops.peek() != <span class="string">'('</span>)&#123;</span><br><span class="line">                    values.push(calc(ops.pop(), values.pop(), values.pop()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将栈顶中左括号弹栈</span></span><br><span class="line">                ops.pop();</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'+'</span> || ch == <span class="string">'-'</span> || ch == <span class="string">'*'</span> || ch == <span class="string">'/'</span>)&#123;</span><br><span class="line">                <span class="comment">//操作符栈不为空，且栈顶操作符的优先级大于等于当前的优先级</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.empty() &amp;&amp; hasPrecedence(ch , ops.peek()))&#123;</span><br><span class="line">                    values.push(calc(ops.pop(), values.pop(), values.pop()));</span><br><span class="line">                &#125;</span><br><span class="line">                ops.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//s已经解析完，继续计算ops中的操作符</span></span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty())&#123;</span><br><span class="line">            values.push(calc(ops.pop(), values.pop(), values.pop()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果操作符op2比操作符op1有更高或者相同的优先级返回true</span></span><br><span class="line">    <span class="comment">//否则返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPrecedence</span><span class="params">(<span class="keyword">char</span> op1, <span class="keyword">char</span> op2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意遇到括号也不用继续计算了</span></span><br><span class="line">        <span class="keyword">if</span>(op2 == <span class="string">'('</span> || op2 == <span class="string">')'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//op1有更高的优先级</span></span><br><span class="line">        <span class="keyword">if</span>((op1 == <span class="string">'*'</span> || op1 == <span class="string">'/'</span>) &amp;&amp; (op2 == <span class="string">'+'</span> || op2 == <span class="string">'-'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算a op b</span></span><br><span class="line">    <span class="comment">//b为第二操作数，先从栈中弹出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">char</span> op, <span class="keyword">int</span> b, <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                <span class="keyword">return</span> a - b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">return</span> a * b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"cannot divide by zero"</span>);</span><br><span class="line">                <span class="keyword">return</span> a / b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Basic_Calculator_I">Basic Calculator I</h2><h3 id="题目描述">题目描述</h3><p>Implement a basic calculator to evaluate a simple expression st]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Reconstruct ltinerary]]></title>
    <link href="http://blog.noobsky.com/2016/07/08/LeetCode-Reconstruct-ltinerary/"/>
    <id>http://blog.noobsky.com/2016/07/08/LeetCode-Reconstruct-ltinerary/</id>
    <published>2016-07-08T02:02:47.000Z</published>
    <updated>2016-07-08T02:34:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p>
<p><strong>Note:</strong></p>
<pre><code><span class="number">1.</span> If there are multiple valid itineraries, you should <span class="constant">return</span> <span class="operator">the</span> itinerary that has <span class="operator">the</span> smallest lexical order when <span class="built_in">read</span> <span class="keyword">as</span> <span class="operator">a</span> single <span class="keyword">string</span>. For example, <span class="operator">the</span> itinerary [<span class="string">"JFK"</span>, <span class="string">"LGA"</span>] has <span class="operator">a</span> smaller lexical order than [<span class="string">"JFK"</span>, <span class="string">"LGB"</span>].
<span class="number">2.</span> All airports are represented <span class="keyword">by</span> <span class="constant">three</span> capital letters (IATA code).
<span class="number">3.</span> You may assume all tickets form <span class="keyword">at</span> least <span class="constant">one</span> valid itinerary.
</code></pre><p><strong>Example 1:</strong><br>tickets = [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]<br>Return [“JFK”, “MUC”, “LHR”, “SFO”, “SJC”].</p>
<p><strong>Example 2:</strong><br>tickets = [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]<br>Return [“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”].<br>Another possible reconstruction is [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”]. But it is larger in lexical order.</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//邻接表</span></span><br><span class="line">    <span class="comment">//在这里key为出发地，value为优先级队列，队列中是从key能抵达的目的地</span></span><br><span class="line">    <span class="comment">//采用优先级队列是因为题目中要求字典序最小的解，所以这里把优先级队列用作最小堆</span></span><br><span class="line">    <span class="comment">//每次都先访问字典序最小的邻接点</span></span><br><span class="line">    Map&lt;String, PriorityQueue&lt;String&gt;&gt; flights = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存路线</span></span><br><span class="line">    List&lt;String&gt; route = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tickets == <span class="keyword">null</span> || tickets.length == <span class="number">0</span>) <span class="keyword">return</span> route;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(String[] ticket : tickets)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flights.containsKey(ticket[<span class="number">0</span>])) flights.put(ticket[<span class="number">0</span>], <span class="keyword">new</span> PriorityQueue&lt;String&gt;());</span><br><span class="line">            flights.get(ticket[<span class="number">0</span>]).offer(ticket[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="string">"JFK"</span>);</span><br><span class="line">        <span class="keyword">return</span> route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String departure)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取出发地departure能到达的目的地</span></span><br><span class="line">        PriorityQueue&lt;String&gt; arrivals = flights.get(departure);</span><br><span class="line">        <span class="keyword">while</span>(arrivals != <span class="keyword">null</span> &amp;&amp; !arrivals.isEmpty())&#123;</span><br><span class="line">            dfs(arrivals.poll());    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往队列头部加入路线节点，否则结果是逆序的</span></span><br><span class="line">        <span class="comment">//也可以使用addFirst()方法</span></span><br><span class="line">        route.add(<span class="number">0</span>, departure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为迭代的形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//存路线</span></span><br><span class="line">        List&lt;String&gt; route = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(tickets == <span class="keyword">null</span> || tickets.length == <span class="number">0</span>) <span class="keyword">return</span> route;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, PriorityQueue&lt;String&gt;&gt; flights = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//构建邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(String[] ticket : tickets)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flights.containsKey(ticket[<span class="number">0</span>])) flights.put(ticket[<span class="number">0</span>], <span class="keyword">new</span> PriorityQueue&lt;String&gt;());</span><br><span class="line">            flights.get(ticket[<span class="number">0</span>]).offer(ticket[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="string">"JFK"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(flights.containsKey(stack.peek()) &amp;&amp; !flights.get(stack.peek()).isEmpty())&#123;</span><br><span class="line">                stack.push(flights.get(stack.peek()).poll());</span><br><span class="line">            &#125;</span><br><span class="line">            route.add(<span class="number">0</span>, stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Evaluate Reverse Polish Notation]]></title>
    <link href="http://blog.noobsky.com/2016/07/07/LeetCode-Evaluate-Reverse-Polish-Notation/"/>
    <id>http://blog.noobsky.com/2016/07/07/LeetCode-Evaluate-Reverse-Polish-Notation/</id>
    <published>2016-07-07T14:49:49.000Z</published>
    <updated>2016-07-07T14:54:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Some examples:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"+"</span>, <span class="string">"3"</span>, <span class="string">"*"</span>]<span class="function"> -&gt;</span> <span class="function"><span class="params">((<span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span>)</span> -&gt;</span> <span class="number">9</span></span><br><span class="line">[<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>]<span class="function"> -&gt;</span> <span class="function"><span class="params">(<span class="number">4</span> + (<span class="number">13</span> / <span class="number">5</span>))</span> -&gt;</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><p>后缀表达式，即逆波兰式计算规则为：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p>
<p>这里没有考虑不合法的表达式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String token : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"+"</span>.equals(token))&#123;</span><br><span class="line">                stack.push(stack.pop() + stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"-"</span>.equals(token))&#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(token))&#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"/"</span>.equals(token))&#123;</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                stack.push(b / a);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Clone Graph]]></title>
    <link href="http://blog.noobsky.com/2016/07/07/LeetCode-Clone-Graph/"/>
    <id>http://blog.noobsky.com/2016/07/07/LeetCode-Clone-Graph/</id>
    <published>2016-07-07T13:14:55.000Z</published>
    <updated>2016-07-07T13:17:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p><strong>OJ’s undirected graph serialization:</strong><br>Nodes are labeled uniquely.</p>
<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.<br>As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p>
<pre><code><span class="number">1</span>. First <span class="keyword">node</span><span class="identifier"> </span><span class="title">is</span> labeled as <span class="number">0</span>. Connect <span class="keyword">node</span><span class="identifier"> </span><span class="title">0</span> to both nodes <span class="number">1</span> <span class="operator">and</span> <span class="number">2</span>.
<span class="number">2</span>. Second <span class="keyword">node</span><span class="identifier"> </span><span class="title">is</span> labeled as <span class="number">1</span>. Connect <span class="keyword">node</span><span class="identifier"> </span><span class="title">1</span> to <span class="keyword">node</span><span class="identifier"> </span><span class="title">2</span>.
<span class="number">3</span>. Third <span class="keyword">node</span><span class="identifier"> </span><span class="title">is</span> labeled as <span class="number">2</span>. Connect <span class="keyword">node</span><span class="identifier"> </span><span class="title">2</span> to <span class="keyword">node</span><span class="identifier"> </span><span class="title">2</span> (itself), thus forming a self-cycle.
</code></pre><p>Visually, the graph looks like the following:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line">  / <span class="string">\</span></span><br><span class="line"> /   <span class="string">\</span></span><br><span class="line"><span class="number">0</span> --- <span class="number">2</span></span><br><span class="line">     / <span class="string">\</span></span><br><span class="line">     <span class="string">\_/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for undirected graph.</span><br><span class="line"> * class UndirectedGraphNode &#123;</span><br><span class="line"> *     int label;</span><br><span class="line"> *     List&lt;UndirectedGraphNode&gt; neighbors;</span><br><span class="line"> *     UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key为图节点的label，value为图节点</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(node.label)) <span class="keyword">return</span> map.get(node.label);</span><br><span class="line"></span><br><span class="line">        UndirectedGraphNode clone = <span class="keyword">new</span> UndirectedGraphNode(node.label);</span><br><span class="line"></span><br><span class="line">        map.put(clone.label, clone);</span><br><span class="line">        <span class="comment">//DFS拷贝node的neighbors节点</span></span><br><span class="line">        <span class="keyword">for</span>(UndirectedGraphNode neighbor : node.neighbors)&#123;</span><br><span class="line">            clone.neighbors.add(cloneGraph(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p><strong>OJ’]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Additive Number]]></title>
    <link href="http://blog.noobsky.com/2016/07/07/LeetCode-Additive-Number/"/>
    <id>http://blog.noobsky.com/2016/07/07/LeetCode-Additive-Number/</id>
    <published>2016-07-07T09:03:11.000Z</published>
    <updated>2016-07-07T11:14:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>
<p><strong>For example:</strong><br>“112358” is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.</p>
<p>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8<br>“199100199” is also an additive number, the additive sequence is: 1, 99, 100, 199.<br>1 + 99 = 100, 99 + 100 = 199<br>Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p>
<p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.</p>
<p><strong>Follow up:</strong><br>How would you handle overflow for very large input integers?</p>
<h2 id="代码">代码</h2><p>采用暴力解法，第一个数字从一位、两位…，第二个数字也从一位、两位，往高位搜索。两个数字确定以后，相加计算它们的和，判断它们的和是否是剩下的数字的前缀，如果不是说明该两个数字的组合不是additive sequence，尝试下一对组合；如果是，说明该组合有可能是additive sequence，那么取出上一次计算的第二个数和和作为新一次迭代的第一和第二个数，继续进行上面的判断，以此类推，直到两个数字的和长度不小于原字符串的长度，返回true。如果尝试了所有的组合后都不是，则返回false。第一个数字的长度的取值范围为[1, n/2]，n为字符串的长度，因为第二个数字的长度跟第一个数字的长度相等。两个数字的和的长度大于等于两个数字长度的最大值。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAdditiveNumber</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个数字长度取值范围为[0, n/2]</span></span><br><span class="line">        <span class="comment">//i表示第一个数字的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//j表示第二个数字的长度</span></span><br><span class="line">            <span class="comment">//两个数字的和也就是剩下的字符串的长度n - i -j要大于等于两个数字长度的较大值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>; Math.max(i, j) &lt;= n - i - j; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isValid(i, j, num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//题中说了两位数以上不能以0开头</span></span><br><span class="line">        <span class="comment">//如果第一个数字以0开头，而且长度还大于1的话无效，直接返回false；</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(num.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; i &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//第二个字符无效</span></span><br><span class="line">        <span class="keyword">if</span>(num.charAt(i) == <span class="string">'0'</span> &amp;&amp; j &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Long x1 = Long.parseLong(num.substring(<span class="number">0</span>, i));</span><br><span class="line">        Long x2 = Long.parseLong(num.substring(i, i+j));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不断的跟剩下的字符串比较</span></span><br><span class="line">        <span class="comment">//剩下的字符串为substring(i+j, num.length)</span></span><br><span class="line">        <span class="comment">//下一次剩下的字符串为i+j + sum.length()</span></span><br><span class="line">        <span class="comment">//x1+x2</span></span><br><span class="line">        String sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = i+j; start &lt; num.length(); start += sum.length())&#123;</span><br><span class="line">            <span class="comment">//两个数之和是下一次迭代的第二个数</span></span><br><span class="line">            x2 = x1 + x2;</span><br><span class="line">            x1 = x2 - x1;</span><br><span class="line">            <span class="comment">//将和转化为字符串，然后跟剩下的字符串比较，</span></span><br><span class="line">            sum = x2.toString();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//只要和是剩下字符串的前缀，就能继续往下比较，否则直接返回false</span></span><br><span class="line">            <span class="comment">//剩下的字符串为num.substring(start);</span></span><br><span class="line">            <span class="comment">//判断和是否是剩下字符串的前缀可以用startsWith(sum)</span></span><br><span class="line">            <span class="comment">//num.substring(start).startsWith(sum)等价于num.startsWith(sum, start);</span></span><br><span class="line">            <span class="keyword">if</span>(!num.substring(start).startsWith(sum)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果对于Follow up中输入特别大的数的话，java可以使用BigInteger，修改如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAdditiveNumber</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个数字长度取值范围为[0, n/2]</span></span><br><span class="line">        <span class="comment">//i表示第一个数字的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//j表示第二个数字的长度</span></span><br><span class="line">            <span class="comment">//两个数字的和也就是剩下的字符串的长度n - i -j要大于等于两个数字长度的较大值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>; Math.max(i, j) &lt;= n - i - j; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isValid(i, j, num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//题中说了两位数以上不能以0开头</span></span><br><span class="line">        <span class="comment">//如果第一个数字以0开头，而且长度还大于1的话无效，直接返回false；</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(num.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; i &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//第二个字符无效</span></span><br><span class="line">        <span class="keyword">if</span>(num.charAt(i) == <span class="string">'0'</span> &amp;&amp; j &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        BigInteger x1 = <span class="keyword">new</span> BigInteger(num.substring(<span class="number">0</span>, i));</span><br><span class="line">        BigInteger x2 = <span class="keyword">new</span> BigInteger(num.substring(i, i+j));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不断的跟剩下的字符串比较</span></span><br><span class="line">        <span class="comment">//剩下的字符串为substring(i+j, num.length)</span></span><br><span class="line">        <span class="comment">//下一次剩下的字符串为i+j + sum.length()</span></span><br><span class="line">        <span class="comment">//x1+x2</span></span><br><span class="line">        String sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = i+j; start &lt; num.length(); start += sum.length())&#123;</span><br><span class="line">            <span class="comment">//两个数之和是下一次迭代的第二个数</span></span><br><span class="line">            x2 = x1.add(x2);</span><br><span class="line">            x1 = x2.subtract(x1);</span><br><span class="line">            <span class="comment">//将和转化为字符串，然后跟剩下的字符串比较，</span></span><br><span class="line">            sum = x2.toString();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//只要和是剩下字符串的前缀，就能继续往下比较，否则直接返回false</span></span><br><span class="line">            <span class="comment">//剩下的字符串为num.substring(start);</span></span><br><span class="line">            <span class="comment">//判断和是否是剩下字符串的前缀可以用startsWith(sum)</span></span><br><span class="line">            <span class="comment">//num.substring(start).startsWith(sum)等价于num.startsWith(sum, start);</span></span><br><span class="line">            <span class="keyword">if</span>(!num.substring(start).startsWith(sum)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence should conta]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Implement Trie(Prefix Tree)]]></title>
    <link href="http://blog.noobsky.com/2016/07/07/LeetCode-Implement-Trie-Prefix-Tree/"/>
    <id>http://blog.noobsky.com/2016/07/07/LeetCode-Implement-Trie-Prefix-Tree/</id>
    <published>2016-07-07T07:52:59.000Z</published>
    <updated>2016-07-07T08:43:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement a trie with insert, search, and startsWith methods.</p>
<p><strong>Note:</strong><br>You may assume that all inputs are consist of lowercase letters a-z.</p>
<h2 id="代码">代码</h2><p>实现前缀树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示该TrieNode的节点是否代表是一个word的结束</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">    <span class="comment">// 本题假设输入只包含a-z的26个小写字母</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ws初始指向根节点</span></span><br><span class="line">        TrieNode ws = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="comment">//使用ch-'a'来计算children的位置</span></span><br><span class="line">            <span class="comment">//children的下标与它代表的字符是一一对应的</span></span><br><span class="line">            <span class="keyword">if</span>(ws.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                ws.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ws指向children节点，进入下一次循环</span></span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个节点代表一个word的结束</span></span><br><span class="line">        ws.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode ws = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ws.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ws.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode ws = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ws.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里跟search不同，只要prefix的每个字符在Trie树上出现，就是true</span></span><br><span class="line">        <span class="comment">//而search要求还要是一个word的结束才代表是一个word否则是一个prefix</span></span><br><span class="line">        <span class="comment">//其实search和startsWith函数代码非常相似，可以进行进一步的封装，减少冗余</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Trie trie = new Trie();</span></span><br><span class="line"><span class="comment">// trie.insert("somestring");</span></span><br><span class="line"><span class="comment">// trie.search("key");</span></span><br></pre></td></tr></table></figure>
<p>搜索时间复杂度为O(m)，m为搜索字符串的长度，空间复杂度为O(1)。代码还可以进一步封装一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示该TrieNode的节点是否代表是一个word的结束</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">    <span class="comment">// 本题假设输入只包含a-z的26个小写字母</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ws初始指向根节点</span></span><br><span class="line">        TrieNode ws = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="comment">//使用ch-'a'来计算children的位置</span></span><br><span class="line">            <span class="comment">//children的下标与它代表的字符是一一对应的</span></span><br><span class="line">            <span class="keyword">if</span>(ws.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                ws.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ws指向children节点，进入下一次循环</span></span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个节点代表一个word的结束</span></span><br><span class="line">        ws.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TrieNode ws = root;</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; word.length(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     char ch = word.charAt(i);</span></span><br><span class="line">        <span class="comment">//     if(ws.children[ch - 'a'] == null) return false;</span></span><br><span class="line">        <span class="comment">//     ws = ws.children[ch - 'a'];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return ws.isWord;</span></span><br><span class="line">        TrieNode ws = searchHelper(word);</span><br><span class="line">        <span class="keyword">return</span> ws != <span class="keyword">null</span> &amp;&amp; ws.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TrieNode ws = root;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; prefix.length(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     char ch = prefix.charAt(i);</span></span><br><span class="line">        <span class="comment">//     if(ws.children[ch - 'a'] == null) return false;</span></span><br><span class="line">        <span class="comment">//     ws = ws.children[ch - 'a'];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// //这里跟search不同，只要prefix的每个字符在Trie树上出现，就是true</span></span><br><span class="line">        <span class="comment">// //而search要求还要是一个word的结束才代表是一个word否则是一个prefix</span></span><br><span class="line">        <span class="comment">// //其实search和startsWith函数代码非常相似，可以进行进一步的封装，减少冗余</span></span><br><span class="line">        <span class="comment">// return true;</span></span><br><span class="line">        <span class="keyword">return</span> searchHelper(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">searchHelper</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        TrieNode ws = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length() &amp;&amp; ws != <span class="keyword">null</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = key.charAt(i);</span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ws;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Trie trie = new Trie();</span></span><br><span class="line"><span class="comment">// trie.insert("somestring");</span></span><br><span class="line"><span class="comment">// trie.search("key");</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement a trie with insert, search, and startsWith methods.</p>
<p><strong>Note:</strong><br>You may assume that]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Permutation Sequence]]></title>
    <link href="http://blog.noobsky.com/2016/07/07/LeetCode-Permutation-Sequence/"/>
    <id>http://blog.noobsky.com/2016/07/07/LeetCode-Permutation-Sequence/</id>
    <published>2016-07-07T04:47:43.000Z</published>
    <updated>2016-07-07T05:20:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for n = 3):</p>
<ol>
<li>“123”</li>
<li>“132”</li>
<li>“213”</li>
<li>“231”</li>
<li>“312”</li>
<li>“321”</li>
</ol>
<p>Given n and k, return the kth permutation sequence.</p>
<p><strong>Note:</strong> Given n will be between 1 and 9 inclusive.</p>
<h2 id="代码">代码</h2><p>下面用例子说明一下算法的思想：</p>
<p>n = 4, 排列元素为{1,2,3,4},总共有4!=24种排列，分别为<br>1 + permutation(2,3,4)：6种排列<br>2 + permutation(1,3,4)：6种排列<br>3 + permutation(1,2,4)：6种排列<br>4 + permutation(1,2,3)：6种排列<br>比如要找第14个排列，那么k从0开始的话k=13，为了确定一个元素的下标，我们可以用k除以剩下元素全排列的数量，这里{1，2，3，4}就是k/(n-1)!=13/6=2，也就是说第一个元素的下标为2，即元素3。同理我们利用同样的方法找到剩下的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; num = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) num.add(i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] fact = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//求n!存到fact[n]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) fact[i] = fact[i-<span class="number">1</span>] * i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换为从0开始</span></span><br><span class="line">        k = k -<span class="number">1</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//计算元素index</span></span><br><span class="line">            <span class="keyword">int</span> index = k / fact[i-<span class="number">1</span>];</span><br><span class="line">            k = k % fact[i-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//理论上get操作时间复杂度为O(n)</span></span><br><span class="line">            sb.append(num.get(index));</span><br><span class="line">            <span class="comment">//Linkedlist的remove为O(1)</span></span><br><span class="line">            num.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutat]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Next Permutation]]></title>
    <link href="http://blog.noobsky.com/2016/07/07/LeetCode-Next-Permutation/"/>
    <id>http://blog.noobsky.com/2016/07/07/LeetCode-Next-Permutation/</id>
    <published>2016-07-07T01:16:29.000Z</published>
    <updated>2016-07-07T02:37:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h2 id="代码">代码</h2><p>算法如下：</p>
<ul>
<li>从后往前，找到第一个nums[i-1] &lt; nums[i]。也就是说nums[i]到nums[n-1]是单调递减序列。</li>
<li>从nums[n-1]到num[i]找到第一个比num[i-1]大的数，也就是说在num[i]到num[n-1]中找到比num[i-1]大的数中最小的一个数。</li>
<li>交互这两个数，并且把num[i]到nums[n-1]从小到大排序。(其实此时后面这部分仍然是逆序的，reverse一下即可)</li>
</ul>
<p>简单说一下背后的原理，因为num[i]到num[n-1]是逆序，也就是说num[i]到nums[n-1]已经从完全的顺序（第一个字典序）排列到了完全逆序（最后一个字典序），已经没有下一个字典序了。那么nums的下一个字典序是什么？答案就是从num[i]s到nums[n-1]逆序中找到一个最小的比num[i-1]大的数与nums[i-1]交互，然后将nums[i]到nums[n-1]从小到大排序即nums[i]到nums[n-1]的排列是第一个字典序。代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(;i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// //没找到，说明完全逆序，完全逆序比如4-3-2-1的下一个应该是1-2-3-4</span></span><br><span class="line">        <span class="comment">// if(i == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     reverse(nums, 0, nums.length - 1);</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//       //i!=0 -&gt;i &gt;= 1</span></span><br><span class="line">        <span class="comment">//      //存在，否则是完全逆序，已经是最后一个permutation</span></span><br><span class="line">        <span class="comment">//     for(int j = nums.length - 1; j &gt;= i; j--)&#123;</span></span><br><span class="line">        <span class="comment">//         if(nums[j] &gt; nums[i-1]) &#123;</span></span><br><span class="line">        <span class="comment">//             swap(nums, i-1, j);</span></span><br><span class="line">        <span class="comment">//             break;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     reverse(nums, i, nums.length-1);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//其实上面只写一个reverse就可以了</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt;= i; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, i-<span class="number">1</span>, j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverse(nums, i, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            swap(nums, start, end);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of number]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Minimum Height Trees]]></title>
    <link href="http://blog.noobsky.com/2016/07/06/LeetCode-Minimum-Height-Trees/"/>
    <id>http://blog.noobsky.com/2016/07/06/LeetCode-Minimum-Height-Trees/</id>
    <published>2016-07-06T14:28:37.000Z</published>
    <updated>2016-07-06T15:47:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>
<p><em>Format</em><br>The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).</p>
<p>You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<p><strong>Example 1:</strong></p>
<p>Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span></span><br><span class="line">  |</span><br><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>return [1]</p>
<p><strong>Example 2:</strong></p>
<p>Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"> \ | /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line">   |</span><br><span class="line">   <span class="number">4</span></span><br><span class="line">   |</span><br><span class="line">   <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>return [3, 4]</p>
<p><strong>Hint:</strong></p>
<pre><code><span class="number">1.</span>How many MHTs can <span class="operator">a</span> graph have <span class="keyword">at</span> most?
</code></pre><p><strong>Note:</strong></p>
<p>(1) According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”</p>
<p>(2) The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>
<h2 id="代码">代码</h2><p>我们先考虑特例，即path graph，<a href="https://discuss.leetcode.com/topic/30572/share-some-thoughts" target="_blank" rel="external">path graph</a>详见维基百科。举个简单例子：1-2-3-4-5-6就是path graph，很明显path graph的minimum height trees的根节点为中间节点，如果节点总数为奇数，则为正中间节点，如果节点总数为偶数，则为中间两个节点。从这，我们可以得到的想法就是不断的删去叶子节点，直到剩下一个或者两个节点。<br><img src="http://s32.postimg.org/3vi3z4dad/1463645059503_1214297289.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一个节点0</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> Collections.singletonList(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里用集合主要不是为了去重，而是为了后面删除邻接节点能在O(1)时间内完成</span></span><br><span class="line">        List&lt;Set&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n; i++) adj.add(<span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用edges构造邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">            adj.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">            adj.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; leaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//只有一个邻接节点就为叶子</span></span><br><span class="line">            <span class="keyword">if</span>(adj.get(i).size() == <span class="number">1</span>)&#123;</span><br><span class="line">                leaves.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            n -= leaves.size();</span><br><span class="line">            List&lt;Integer&gt; newLeaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//删除叶子节点，即将叶子节点从其邻接节点的邻接表中移除</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> leave: leaves)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//其实叶子节点只有一个邻接节点</span></span><br><span class="line">                <span class="comment">//叶子节点的邻接节点</span></span><br><span class="line">                <span class="keyword">int</span> j = adj.get(leave).iterator().next();</span><br><span class="line">                <span class="comment">//集合的删除操作为O(1)</span></span><br><span class="line">                adj.get(j).remove(leave);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果删除邻接节点后成为叶子节点，加入叶子节点list中</span></span><br><span class="line">                <span class="keyword">if</span>(adj.get(j).size() == <span class="number">1</span>) newLeaves.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">            leaves = newLeaves;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leaves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想每次新new一个newLeaves，可以使用队列，新的叶子节点加入队列即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//只有一个节点0</span></span><br><span class="line">      <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> Collections.singletonList(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//这里用集合主要不是为了去重，而是为了后面删除邻接节点能在O(1)时间内完成</span></span><br><span class="line">      List&lt;Set&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n; i++) adj.add(<span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//利用edges构造邻接矩阵</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">          adj.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">          adj.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回类型为List，所以不能用Queue</span></span><br><span class="line">      LinkedList&lt;Integer&gt; leaves = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">          <span class="comment">//只有一个邻接节点就为叶子</span></span><br><span class="line">          <span class="keyword">if</span>(adj.get(i).size() == <span class="number">1</span>)&#123;</span><br><span class="line">              leaves.offer(i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(n &gt; <span class="number">2</span>)&#123;</span><br><span class="line">          <span class="keyword">int</span> numLeaf = leaves.size();</span><br><span class="line">          n -= numLeaf;</span><br><span class="line">          <span class="comment">//List&lt;Integer&gt; newLeaves = new ArrayList&lt;&gt;();</span></span><br><span class="line">          <span class="comment">//删除叶子节点，即将叶子节点从其邻接节点的邻接表中移除</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>; k &lt; numLeaf; k++)&#123;</span><br><span class="line">              <span class="keyword">int</span> leave = leaves.poll();</span><br><span class="line">              <span class="comment">//其实叶子节点只有一个邻接节点</span></span><br><span class="line">              <span class="comment">//叶子节点的邻接节点</span></span><br><span class="line">              <span class="keyword">int</span> j = adj.get(leave).iterator().next();</span><br><span class="line">              <span class="comment">//集合的删除操作为O(1)</span></span><br><span class="line">              adj.get(j).remove(leave);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//如果删除邻接节点后成为叶子节点，加入叶子节点list中</span></span><br><span class="line">              <span class="keyword">if</span>(adj.get(j).size() == <span class="number">1</span>) leaves.offer(j);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//leaves = newLeaves;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> leaves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a r]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Course Schedule I II]]></title>
    <link href="http://blog.noobsky.com/2016/07/06/LeetCode-Course-Schedule-I-II/"/>
    <id>http://blog.noobsky.com/2016/07/06/LeetCode-Course-Schedule-I-II/</id>
    <published>2016-07-06T08:43:27.000Z</published>
    <updated>2016-07-06T12:35:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Course_Schedule_I">Course Schedule I</h2><h3 id="题目描述">题目描述</h3><p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>For example:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>, <span class="string">[[1,0]]</span></span><br></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<p><strong>Note:</strong><br>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank" rel="external">how a graph is represented</a>.</p>
<p><strong>Hints:</strong><br>  1.This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.<br>  2.Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.<br>  3.Topological sort could also be done via BFS.</p>
<h3 id="代码">代码</h3><p>这道题其本质是拓扑排序，拓扑排序详见维基百科<a href="https://en.wikipedia.org/wiki/Topological_sorting" target="_blank" rel="external">Topological sorting</a>和博文<a href="http://blog.csdn.net/dm_vincent/article/details/7714519" target="_blank" rel="external">拓扑排序的原理及其实现</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//题目中图的表示是边的列表，我们需要转换为邻接矩阵或者邻接表</span></span><br><span class="line">        <span class="comment">//这里使用邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses][numCourses];<span class="comment">// i-&gt;j</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录每个节点的入度</span></span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; prerequisites.length; i++)&#123;</span><br><span class="line">            <span class="comment">//边的起始节点</span></span><br><span class="line">            <span class="keyword">int</span> start = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//终止节点</span></span><br><span class="line">            <span class="keyword">int</span> end = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//防止重复边出现</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[start][end] == <span class="number">0</span>)</span><br><span class="line">                indegree[end]++;</span><br><span class="line">            matrix[start][end] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将所有入度为0的节点加入队列中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计输出顶点的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">                <span class="comment">//如果course和i相邻接，i节点的入度减1，入度变为0要加入队列中</span></span><br><span class="line">                <span class="keyword">if</span>(matrix[course][i] != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span>(--indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.offer(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是以上使用邻接矩阵内存消耗太大，其实邻接矩阵是不必要使用的，改进后的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//不用使用邻接矩阵</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//统计每个节点的入度</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">          indegree[pair[<span class="number">0</span>]]++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">          <span class="comment">//不使用额外的变量count来统计也是可以的</span></span><br><span class="line">          numCourses--;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">              <span class="keyword">if</span>(pair[<span class="number">1</span>] == course)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(--indegree[pair[<span class="number">0</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                      queue.offer(pair[<span class="number">0</span>]);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的算法时间复杂度为O(V*E)，但是节省了邻接表或者邻接矩阵的内存空间。也可以使用邻接表，时间复杂度可以降为O(V+E)，但是空间复杂度会上升，空间复杂度比邻接矩阵低，代码如下，非本人所写，风格不一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        ArrayList[] graph = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">        <span class="keyword">int</span>[] degree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Queue queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">            degree[prerequisites[i][<span class="number">1</span>]]++;</span><br><span class="line">            graph[prerequisites[i][<span class="number">0</span>]].add(prerequisites[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;degree.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> course = (<span class="keyword">int</span>)queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph[course].size();i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> pointer = (<span class="keyword">int</span>)graph[course].get(i);</span><br><span class="line">                degree[pointer]--;</span><br><span class="line">                <span class="keyword">if</span>(degree[pointer] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(pointer);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == numCourses)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS也放上代码，以后有时间再研究吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">            ArrayList[] graph = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)</span><br><span class="line">                graph[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">                graph[prerequisites[i][<span class="number">1</span>]].add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(graph,visited,i))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(ArrayList[] graph, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> course)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[course])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                visited[course] = <span class="keyword">true</span>;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph[course].size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(graph,visited,(<span class="keyword">int</span>)graph[course].get(i)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[course] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Course_Schedule_II">Course Schedule II</h2><h3 id="题目描述-1">题目描述</h3><p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>For example:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>, <span class="string">[[1,0]]</span></span><br></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure></p>
<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p>
<p><strong>Note:</strong><br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</p>
<h3 id="代码-1">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//统计每个节点的入度</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">          indegree[pair[<span class="number">0</span>]]++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">          res[count++] = course;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">              <span class="keyword">if</span>(pair[<span class="number">1</span>] == course)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(--indegree[pair[<span class="number">0</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                      queue.offer(pair[<span class="number">0</span>]);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(numCourses == count)&#123;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Course_Schedule_I">Course Schedule I</h2><h3 id="题目描述">题目描述</h3><p>There are a total of n courses you have to take, labeled from 0 t]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Zigzag Level/Level Order Traversal I II]]></title>
    <link href="http://blog.noobsky.com/2016/07/06/LeetCode-Binary-Tree-Zigzag-Level-Level-Order-Traversal-I-II/"/>
    <id>http://blog.noobsky.com/2016/07/06/LeetCode-Binary-Tree-Zigzag-Level-Level-Order-Traversal-I-II/</id>
    <published>2016-07-06T07:41:31.000Z</published>
    <updated>2016-07-06T07:49:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Binary_Tree_Level_Order_Traversal_I">Binary Tree Level Order Traversal I</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its level order traversal as:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">    <span class="comment">//对一般的分层遍历稍加改进，就能实现分行打印每一层</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">        <span class="comment">//先不急着出队列，记录队列的大小，相当于每层元素的个数</span></span><br><span class="line">        int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//一般的分层遍历都是每次循环从队列头中取出一个元素然后将其左右节点分别入队列，</span></span><br><span class="line">        <span class="comment">//改进后就是每次从队列头中取出levelNumber个元素,</span></span><br><span class="line">        <span class="comment">//然后将每个元素的左右节点分别入队列。</span></span><br><span class="line">        f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">            <span class="comment">//使用peek可以节省一个局部变量</span></span><br><span class="line">            <span class="comment">// if(queue.peek().left != null) queue.add(queue.peek().left);</span></span><br><span class="line">            <span class="comment">// if(queue.peek().right != null) queue.add(queue.peek().right);</span></span><br><span class="line">            <span class="comment">// subList.add(queue.poll().val);</span></span><br><span class="line">            <span class="comment">//使用局部变量,测试发现速度能稍微快一点</span></span><br><span class="line">            TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">            subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">            <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>left);</span><br><span class="line">            <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>right);</span><br><span class="line">        &#125;</span><br><span class="line">        res<span class="built_in">.</span>add(subList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们也可以使用DFS的思想，代码如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(level &gt;= res<span class="built_in">.</span>size())&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res<span class="built_in">.</span>get(level)<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level+<span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Binary_Tree_Level_Order_Traversal_II">Binary Tree Level Order Traversal II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>return its bottom-up level order traversal as:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码-1">代码</h3><p>使用BFS思想:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//使用LinkedList，不使用ArrayList，原因见后面</span></span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//将root加入队列中</span></span><br><span class="line">        <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">        <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">            int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">            LinkedList&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> LinkedList();</span><br><span class="line">            f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">                subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>left);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//总是在0索引的位置插入每一层的遍历结果，最后遍历res的时候结果就是反过来的，即从下往上分层遍历</span></span><br><span class="line">            <span class="comment">//这里之所以使用LinkedList的原因是ArrayList的底层是数组，插入元素时需要移动大量的元素，效率低</span></span><br><span class="line">            <span class="comment">//而LinkedList的底层是链表，插入操作非常高效</span></span><br><span class="line">            res<span class="built_in">.</span>add(<span class="number">0</span>,subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用DFS思想：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrderBottom(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res<span class="built_in">.</span>size() &lt;= level)&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="number">0</span>, <span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res<span class="built_in">.</span>get(res<span class="built_in">.</span>size()-<span class="number">1</span><span class="attribute">-level</span>)<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level + <span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_Zigzag_Level_Order_Traversal">Binary Tree Zigzag Level Order Traversal</h2><h3 id="题目描述-2">题目描述</h3><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its zigzag level order traversal as:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码-2">代码</h3><p>DFS:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	<span class="comment">//DFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; zigzagLevelOrder1(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res<span class="built_in">.</span>size() &lt;= level)&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; subList = res<span class="built_in">.</span>get(level);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//偶数层，从左往右</span></span><br><span class="line">        <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">0</span>) subList<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        <span class="comment">//奇数层，从右往左</span></span><br><span class="line">        <span class="keyword">else</span> subList<span class="built_in">.</span>add(<span class="number">0</span>, root<span class="built_in">.</span>val);</span><br><span class="line">        </span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level + <span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BFS:</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	<span class="comment">//BFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; zigzagLevelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">        <span class="comment">//从左往右</span></span><br><span class="line">        <span class="built_in">boolean</span> isLeftToRight = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">            <span class="comment">//每层的节点个数</span></span><br><span class="line">            int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(isLeftToRight)&#123;</span><br><span class="line">                    subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    subList<span class="built_in">.</span>add(<span class="number">0</span>, node<span class="built_in">.</span>val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>left);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下一层跟该层的顺序相反，取非</span></span><br><span class="line">            isLeftToRight = <span class="subst">!</span>isLeftToRight;</span><br><span class="line">            res<span class="built_in">.</span>add(subList);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Binary_Tree_Level_Order_Traversal_I">Binary Tree Level Order Traversal I</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree, return t]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Largest Divisible Subset]]></title>
    <link href="http://blog.noobsky.com/2016/07/06/LeetCode-Largest-Divisible-Subset/"/>
    <id>http://blog.noobsky.com/2016/07/06/LeetCode-Largest-Divisible-Subset/</id>
    <published>2016-07-06T04:43:52.000Z</published>
    <updated>2016-07-06T05:17:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p>
<p>If there are multiple solutions, return any subset is fine.</p>
<p><strong> Example 1: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">Result: [<span class="number">1</span>,<span class="number">2</span>] (of course, [<span class="number">1</span>,<span class="number">3</span>] will also be ok)</span><br></pre></td></tr></table></figure>
<p><strong> Example 2: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">Result: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>这道题的DP思想跟LIS（最长递增子序列）的思想是一样的，详见<a href="http://noobsky.com/2016/06/07/LeetCode-Longest-Increasing-Subsequence/" target="_blank" rel="external">Longest Increasing Subsequence</a>，只是LIS只要求长度，这里要给出序列。<br>dp[n]表示最大元素为nums[n]的largest divisible subset的长度，则：</p>
<p>dp[i] = max{dp[j] + 1 if dp[i] % dp[j] == 0}, 0&lt;= j &lt; i </p>
<p>有了以上状态方程，我们可以写出O(n<sup>2</sup>)的算法。</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; largestDivisibleSubset(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需要排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//dp数组dp[i]表示最大元素为num[i]的longest divisible subset的长度</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//为了得到序列我们需要记录每个nums[i]的前驱元素，所以我们prev数组来记录nums[i]前驱元素的下标</span></span><br><span class="line">        <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录largest divisible subset的最大长度</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最大长度最大元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//如果j = i开始，不用写dp[i] = 1;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span> &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//记录前驱元素的下标</span></span><br><span class="line">                    prev[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//dp[i]大于maxLen则更新最大长度和下标</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxLen)&#123;</span><br><span class="line">                maxLen = dp[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据prev数组找出largest divisible subset的所以元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++)&#123;</span><br><span class="line">            <span class="comment">//res.add(nums[maxIndex]);//这样添加其实是元素的逆序，但题目中也没有要求是顺序的</span></span><br><span class="line">            <span class="comment">//如果要求需要按顺序，当然这里顺序也不是原始数组的顺序，是排序后的顺序</span></span><br><span class="line">            res.add(<span class="number">0</span>, nums[maxIndex]);</span><br><span class="line">            maxIndex = prev[maxIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in th]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Game of Life]]></title>
    <link href="http://blog.noobsky.com/2016/07/06/LeetCode-Game-of-Life/"/>
    <id>http://blog.noobsky.com/2016/07/06/LeetCode-Game-of-Life/</id>
    <published>2016-07-06T01:05:20.000Z</published>
    <updated>2016-07-06T02:05:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>According to the <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="external">Wikipedia’s article</a>: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p>
<p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<pre><code><span class="number">1.</span> Any live cell <span class="operator">with</span> fewer than <span class="constant">two</span> live neighbors dies, <span class="keyword">as</span> <span class="keyword">if</span> caused <span class="keyword">by</span> under-population.
<span class="number">2.</span> Any live cell <span class="operator">with</span> <span class="constant">two</span> <span class="operator">or</span> <span class="constant">three</span> live neighbors lives <span class="command"><span class="keyword">on</span> <span class="title">to</span> <span class="title">the</span> <span class="title">next</span> <span class="title">generation</span>.</span>
<span class="number">3.</span> Any live cell <span class="operator">with</span> more than <span class="constant">three</span> live neighbors dies, <span class="keyword">as</span> <span class="keyword">if</span> <span class="keyword">by</span> over-population..
<span class="number">4.</span> Any dead cell <span class="operator">with</span> exactly <span class="constant">three</span> live neighbors becomes <span class="operator">a</span> live cell, <span class="keyword">as</span> <span class="keyword">if</span> <span class="keyword">by</span> reproduction.
</code></pre><p>Write a function to compute the next state (after one update) of the board given its current state.</p>
<p><strong> Follow up: </strong> </p>
<pre><code><span class="number">1.</span> Could you solve <span class="keyword">it</span> <span class="operator">in</span>-place? Remember that <span class="operator">the</span> board needs <span class="built_in">to</span> be updated <span class="keyword">at</span> <span class="operator">the</span> same <span class="built_in">time</span>: You cannot update some cells <span class="keyword">first</span> <span class="operator">and</span> <span class="keyword">then</span> use their updated values <span class="built_in">to</span> update other cells.
<span class="number">2.</span> In this question, we represent <span class="operator">the</span> board <span class="keyword">using</span> <span class="operator">a</span> <span class="number">2</span>D array. In principle, <span class="operator">the</span> board is infinite, which would cause problems when <span class="operator">the</span> active area encroaches <span class="operator">the</span> border <span class="operator">of</span> <span class="operator">the</span> array. How would you address these problems?
</code></pre><h2 id="代码">代码</h2><p>每个细胞有一个初始状态活(1)或死(0)，每个细胞与周围八个细胞(水平、竖直、对角线)相互作用，规则如下：</p>
<ul>
<li>如果活细胞周围八个位置的活细胞少于两个，则该位置的活细胞会死亡 </li>
<li>如果活细胞周围八个位置有两个或者三个活细胞，则该位置的活细胞仍然存活</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置的活细胞死亡</li>
<li>如果死细胞周围八个位置刚好有三个活细胞，则该位置的死细胞复活</li>
</ul>
<p>为了不使用额外的内存(in place)，我们使用两比特位来表示状态</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">2nd</span> bit, <span class="number">1</span>st bit] = <span class="list">[<span class="keyword">next</span> state, current state]</span><br><span class="line"></span><br><span class="line">- <span class="number">00</span>  dead <span class="list">(<span class="keyword">next</span>)</span> &lt;- dead <span class="list">(<span class="keyword">current</span>)</span></span><br><span class="line">- <span class="number">01</span>  dead <span class="list">(<span class="keyword">next</span>)</span> &lt;- live <span class="list">(<span class="keyword">current</span>)</span>  </span><br><span class="line">- <span class="number">10</span>  live <span class="list">(<span class="keyword">next</span>)</span> &lt;- dead <span class="list">(<span class="keyword">current</span>)</span>  </span><br><span class="line">- <span class="number">11</span>  live <span class="list">(<span class="keyword">next</span>)</span> &lt;- live <span class="list">(<span class="keyword">current</span>)</span></span></span></span><br></pre></td></tr></table></figure>
<p>我们用第一个比特位(从右往左)表示当前细胞的状态，1（二进制01，活）、0(二进制00，死)，第二个比特位来表示细胞下一代的状态(00/01(死)、10/11(活))。</p>
<ul>
<li>初始时，任何细胞的状态为00或01</li>
<li>我们统计当前细胞周围的活细胞数量(第一个比特位)来决定细胞的下一状态(设置第二个比特位)，然后右移一位，第二比特位变成第一比特位就得到细胞的下一状态</li>
<li>因为第二个比特位默认为0(因为只有0和1)也就是代表细胞死，所以我们不需要考虑细胞的下一状态为死的转换(00-&gt;00、01-&gt;01)</li>
<li>最后我们通过右移一位来删除细胞当前的状态进入下一状态(即第二比特位成为第一比特位)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == null || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> lives = liveNeighbors(board, row, col, i, j);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第二比特位初始就为0，所以我们只需要考虑第二比特位会变成1的情况</span></span><br><span class="line">                <span class="comment">//有两种情况：当前存活且周围活细胞数是2或3，则仍然存活,01-&gt;11</span></span><br><span class="line">                <span class="comment">//当前细胞死亡，周围刚好有三个活细胞，复活00-&gt;10</span></span><br><span class="line">                <span class="comment">//我们只需要将第二比特位置为1，不改变第一比特位的值，不会干扰其他细胞的判断</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; lives &gt;= <span class="number">2</span> &amp;&amp; lives &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="number">3</span>;<span class="comment">//将第二比特位置为1，即11，就是3</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">0</span> &amp;&amp; lives == <span class="number">3</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//全部细胞转化后，右移一位，更新细胞的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                board[i][j] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计细胞board[i][j]周围细胞的存活数量</span></span><br><span class="line">    <span class="comment">//row、col可以传进来也可以不传</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">liveNeighbors</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lives = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历board[i][j]为中心的小九宫格即可</span></span><br><span class="line">        <span class="comment">//用Math.min/max来处理边界还是很tricky的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = Math.max(i - <span class="number">1</span>, <span class="number">0</span>); x &lt;= Math.min(i+<span class="number">1</span>, row-<span class="number">1</span>); x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = Math.max(j - <span class="number">1</span>, <span class="number">0</span>); y &lt;= Math.min(j+<span class="number">1</span>, col-<span class="number">1</span>); y++)&#123;</span><br><span class="line">                <span class="comment">//board[x][y]为1存活数加1，&amp;1可以达到这个目的</span></span><br><span class="line">                lives += board[x][y] &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//因为九宫格也统计了自身board[i][j]的状态，需要减掉</span></span><br><span class="line">        lives -= board[i][j] &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> lives;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>According to the <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="external">Wi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Container With Most Water]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Container-With-Most-Water/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Container-With-Most-Water/</id>
    <published>2016-07-05T15:14:01.000Z</published>
    <updated>2016-07-05T15:27:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container.</p>
<h2 id="代码">代码</h2><p><img src="http://7xonwi.com1.z0.glb.clouddn.com/containswater.png" alt=""></p>
<p>如图所示，容纳水的多少由（左右两端更小的高度）*两端x坐标值之差决定</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> int maxArea(int[] height) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(height == null || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = height.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最大面积</span></span><br><span class="line">        int maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            <span class="comment">//面积由更矮的一条线决定</span></span><br><span class="line">            maxArea = <span class="type">Math</span>.<span class="built_in">max</span>(maxArea, <span class="type">Math</span>.<span class="built_in">min</span>(height[<span class="keyword">left</span>], height[<span class="keyword">right</span>]) * (<span class="keyword">right</span> - <span class="keyword">left</span>));</span><br><span class="line">            <span class="comment">//因为左边的高度小于右边的高度，移动右边那根线是没有作用的，移动右边的线形成的面积都是小于等于当前的面积</span></span><br><span class="line">            <span class="comment">//假设移动右边即right--，如果移动后height[new right] &gt; height[left]，那么还是左边线的高度更低，</span></span><br><span class="line">            <span class="comment">//面积等于当前面积；如果移动后height[new right] &lt; height[left]，那么形成的面积更小，所以移动right是没有帮助的</span></span><br><span class="line">            <span class="comment">//只能移动left</span></span><br><span class="line">            <span class="keyword">if</span>(height[<span class="keyword">left</span>] &lt; height[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">left</span>++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//同理右边高度更小的话，移动左边是没有作用的，只能移动右边</span></span><br><span class="line">                <span class="keyword">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种写法更繁琐但对于有些人来说可能更直观：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> int maxArea(int[] height)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == null || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = height.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        int maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int h = <span class="type">Math</span>.<span class="built_in">min</span>(height[<span class="keyword">left</span>], height[<span class="keyword">right</span>]);</span><br><span class="line">            </span><br><span class="line">            maxArea = <span class="type">Math</span>.<span class="built_in">max</span>(maxArea, h * (<span class="keyword">right</span> - <span class="keyword">left</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//往右寻找高度更高的线</span></span><br><span class="line">            <span class="keyword">while</span>(height[<span class="keyword">left</span>] &lt;= h &amp;&amp; <span class="keyword">left</span> &lt; <span class="keyword">right</span>) <span class="keyword">left</span>++;</span><br><span class="line">            <span class="comment">//往左寻找高度比h更高的线，形成的面积才有可能大于当前面积</span></span><br><span class="line">            <span class="keyword">while</span>(height[<span class="keyword">right</span>] &lt;= h &amp;&amp; <span class="keyword">left</span> &lt; <span class="keyword">right</span>) <span class="keyword">right</span>--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Valid Perfect Square]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Valid-Perfect-Square/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Valid-Perfect-Square/</id>
    <published>2016-07-05T14:06:30.000Z</published>
    <updated>2016-07-05T14:08:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>
<p>Note: Do not use any built-in library function such as sqrt.</p>
<p><strong> Example 1: </strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">16</span></span><br><span class="line"><span class="attribute">Returns</span>: <span class="string">True</span></span><br></pre></td></tr></table></figure>
<p><strong> Example 2: </strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">14</span></span><br><span class="line"><span class="attribute">Returns</span>: <span class="string">False</span></span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//这里可以直接用数学规律</span></span><br><span class="line">    <span class="comment">//1 = 1</span></span><br><span class="line">    <span class="comment">//4 = 1 + 3</span></span><br><span class="line">    <span class="comment">//9 = 1 + 3 + 5</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//但是这里我们需要注意的是我们不能用加法来做</span></span><br><span class="line">    <span class="comment">//因为加法存在溢出的问题，我们可以逆向考虑，</span></span><br><span class="line">    <span class="comment">//用减法，减1、3...，看看最后num是否会为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isPerfectSquare1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            num -= i;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果我们不知道这个规律，之前实现过sqrt，同理这里也可以使用二分搜索</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//除法是下取整的，mid取值偏小</span></span><br><span class="line">            <span class="comment">//取值偏小的mid的平方都大于num，那么平方根肯定小于mid，所以right = mid - 1</span></span><br><span class="line">            <span class="comment">//除法防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(mid &gt; num / mid)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//小于等于</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &lt; num / mid)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果这样写会造成死循环，比如5</span></span><br><span class="line">                <span class="comment">//if(num % mid == 0) return true;</span></span><br><span class="line">                <span class="keyword">return</span> num % mid == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>
<p>No]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
