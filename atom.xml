<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-06-08T14:31:11.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Kth Largest Element in an Array]]></title>
    <link href="http://blog.noobsky.com/2016/06/08/LeetCode-Kth-Largest-Element-in-an-Array/"/>
    <id>http://blog.noobsky.com/2016/06/08/LeetCode-Kth-Largest-Element-in-an-Array/</id>
    <published>2016-06-08T06:32:43.000Z</published>
    <updated>2016-06-08T14:31:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given <font color="red">[3,2,1,5,6,4]</font> and k = 2, return 5.</p>
<p><strong> Note: </strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<h2 id="解题思路与代码">解题思路与代码</h2><h3 id="排序法">排序法</h3><p>将数组排序，然后返回第K大的数组元素<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span>(<span class="params"><span class="keyword">int</span>[] nums, <span class="keyword">int</span> k</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//if(nums == null || nums.length == 0) return -1;</span></span><br><span class="line">        <span class="comment">//check if 1&lt;= k &lt;= nums.length</span></span><br><span class="line">        <span class="comment">//排序，O(nlgn)</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的<font color="red">时间复杂度为O(nlgn)，空间复杂度为O(1)</font>。</p>
<h3 id="堆">堆</h3><p>维护k个元素的最小堆，遍历数组，将每个元素加入堆中，当堆的大小大于k时，删除堆顶元素，最后堆中为top k元素，堆顶最小，则为第k大元素</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	    <span class="comment">//维护k个元素的最小堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用优先级队列模拟堆，构造函数不提供Comparator函数，则优先级队列中元素以自然顺序排列</span></span><br><span class="line">        <span class="comment">//相当于最小堆，堆顶是堆中最小的元素</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">        <span class="comment">// for(int num: nums)&#123;</span></span><br><span class="line">        <span class="comment">//     if(pq.size() &lt; k)&#123;</span></span><br><span class="line">        <span class="comment">//         pq.offer(num);</span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//         if(num &gt; pq.peek())&#123;</span></span><br><span class="line">        <span class="comment">//             pq.offer(num);</span></span><br><span class="line">        <span class="comment">//             pq.poll();</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            pq.offer(num);</span><br><span class="line">            <span class="comment">//如果优先级队列中元素个数大于k，则删除堆顶元素（堆中最小）</span></span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k) pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时，堆中为top k元素，堆顶最小，则为第k大元素</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> pq.<span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆方法的<font color="red">时间复杂度为O(nlgk)，空间复杂度为O(k)</font>。</p>
<h3 id="快速选择算法(Quickselect)">快速选择算法(Quickselect)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="comment">//two pointers</span></span><br><span class="line">        <span class="comment">//小于等于枢纽（主元）的元素都往前放，从left下标开始</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//i左边的数即[left, i)都比pivot小，i&lt;=位置&lt;j的数即[i, j)都比pivot大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i位置为pivot最后的位置</span></span><br><span class="line">        swap(nums,i, right);</span><br><span class="line">        <span class="comment">//返回主元的位置,i左边的元素都比nums[i]小，右边都比nums[i]大</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//另一种partition的实现,特别容易写错，比如写成nums&lt;pivot和nums[j]&gt;pivot时，在nums[i] = nums[j]= pivot</span></span><br><span class="line">    <span class="comment">//会造成死循环，看看就好，以后不写这个版本的了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;right &amp;&amp; nums[i] &lt;= pivot) i++;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;left &amp;&amp; nums[j] &gt;= pivot) j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) swap(nums, i, j);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, right);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分函数的随机化版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomizedPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//nextInt(i)产生[0, i)中的随机数</span></span><br><span class="line">        <span class="comment">//nextInt(right - left)为[0, right - left+1) + left =&gt; [left, right]</span></span><br><span class="line">        <span class="keyword">int</span> randomIndex = random.nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        <span class="comment">//随机选择[left, right]中的元素有nums[right]交换，会nums[right]作为pivot，相当于随机选择一个元素作为pivot</span></span><br><span class="line">        swap(nums, randomIndex, right);</span><br><span class="line">        <span class="keyword">return</span> partition(nums, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回第k小的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//处理k的非法值</span></span><br><span class="line">        <span class="comment">//if(k &lt; 1 || k &gt; (right - left + 1)) return -1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivotIndex = randomizedPartition(nums, left, right);</span><br><span class="line">        <span class="keyword">int</span> s = pivotIndex - left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对三种情况进行处理：s = pivotIndex - left + 1</span></span><br><span class="line">        <span class="comment">//s == k: 即返回的主元就是我们要找的第k小的元素</span></span><br><span class="line">        <span class="comment">//s &lt; k : 那么接下来要到高区间nums[pivotIndex+1, right]寻找, 丢掉低区间</span></span><br><span class="line">        <span class="comment">//s &gt; k : 那么接下来要到低区间nums[left, pivotIndex - 1]寻找，丢掉高区间</span></span><br><span class="line">        <span class="keyword">if</span>(s == k) <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; k) <span class="keyword">return</span> quickSelect(nums, pivotIndex + <span class="number">1</span>, right, k - s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第k大，就是第nums.length - k + 1小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法叫快速选择，类似快速排序，但是快速选择只需处理一个子问题，而快排需要处理两个子问题。详见维基百科<img src="https://en.wikipedia.org/wiki/Quickselect" alt="Quickselect">。该算法<font color="red">最好情况的时间复杂度为O(n)，最坏情况下时间复杂度为O(n<sup>2</sup>)，平均时间复杂度为O(n)</font>。我们可以利用随机化版本的Partition函数大大降低最坏情况发生的概率,如上代码，应该也可以利用洗牌算法对数组进行洗牌（随机化)降低最坏情况发生的概率。如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//洗牌算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//每次让nums[i]和nums[0.....i]中随机一元素交换</span></span><br><span class="line">        <span class="comment">//i=0自己跟自己交换没必要循环了，jdk也类似这样写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            swap(nums, i, random.nextInt(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="comment">//two pointers</span></span><br><span class="line">        <span class="comment">//小于等于枢纽（主元）的元素都往前放，从left下标开始</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//i左边的数即[left, i)都比pivot小，i&lt;=位置&lt;j的数即[i, j)都比pivot大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= pivot)&#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i位置为pivot最后的位置</span></span><br><span class="line">        swap(nums,i, right);</span><br><span class="line">        <span class="comment">//返回主元的位置,i左边的元素都比nums[i]小，右边都比nums[i]大</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//返回第k小的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//处理k的非法值</span></span><br><span class="line">        <span class="comment">//if(k &lt; 1 || k &gt; (right - left + 1)) return -1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">int</span> s = pivotIndex - left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对三种情况进行处理：s = pivotIndex - left + 1</span></span><br><span class="line">        <span class="comment">//s == k: 即返回的主元就是我们要找的第k小的元素</span></span><br><span class="line">        <span class="comment">//s &lt; k : 那么接下来要到高区间nums[pivotIndex+1, right]寻找, 丢掉低区间</span></span><br><span class="line">        <span class="comment">//s &gt; k : 那么接下来要到低区间nums[left, pivotIndex - 1]寻找，丢掉高区间</span></span><br><span class="line">        <span class="keyword">if</span>(s == k) <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; k) <span class="keyword">return</span> quickSelect(nums, pivotIndex + <span class="number">1</span>, right, k - s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//第k大，就是第nums.length - k + 1小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以使用Median of medians算法，也叫BRPRT算法，详见维基百科<img src="https://en.wikipedia.org/wiki/Median_of_medians" alt="Median of medians">。该算法使用五分化中项的中项的方法来选择枢纽元素，该算法能保证快速选择算法最坏情况下时间复杂度也为O(n)。虽然该算法理论上是O(n)的，但是这个算法n的系数实际上比较大，所以还是随机话快速选择更有实际意义，也更简单。另外，这个思路也可以应用到优化快速排序最坏情况的时间复杂度问题上去。我们还可以使用Introselect算法，详见维基百科<img src="https://en.wikipedia.org/wiki/Introselect" alt="Introselect">。</p>
<h2 id="参考文献">参考文献</h2><p><img src="https://en.wikipedia.org/wiki/Selection_algorithm" alt="Selection algorithm"><br><img src="https://en.wikipedia.org/wiki/Quickselect" alt="Quickselect"><br><img src="https://en.wikipedia.org/wiki/Median_of_medians" alt="Median of medians"><br><img src="https://en.wikipedia.org/wiki/Introselect" alt="Introselect"><br><img src="http://blog.csdn.net/v_JULY_v/article/details/6370650" alt="程序员编程艺术：第三章、寻找最小的k个数"><br><img src="http://blog.csdn.net/v_JULY_v/article/details/6403777" alt="程序员编程艺术：第三章续、Top K算法问题的实现"><br><img src="http://blog.csdn.net/v_JULY_v/article/details/6431001" alt="十四、第三章再续：快速选择SELECT算法的深入分析与实现"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, no]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Increasing Triplet Subsequence]]></title>
    <link href="http://blog.noobsky.com/2016/06/07/LeetCode-Increasing-Triplet-Subsequence/"/>
    <id>http://blog.noobsky.com/2016/06/07/LeetCode-Increasing-Triplet-Subsequence/</id>
    <published>2016-06-07T10:40:19.000Z</published>
    <updated>2016-06-08T06:33:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Formally the function should:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Return <span class="constant">true</span> <span class="keyword">if</span> there exists i, j, k </span><br><span class="line">such <span class="keyword">that</span> arr[i] &lt; arr[j] &lt; arr[k] <span class="keyword">given</span> <span class="number">0</span> ≤ i &lt; j &lt; k ≤ n-<span class="number">1</span> <span class="keyword">else</span> <span class="constant">return</span> <span class="constant">false</span>.</span><br></pre></td></tr></table></figure>
<p>Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>
<p><strong> Examples: </strong><br>Given <font color="red">[1, 2, 3, 4, 5]</font>,<br>return <font color="red">true</font>.</p>
<p>Given <font color="red">[5, 4, 3, 2, 1]</font>,<br>return <font color="red">false</font>.</p>
<h2 id="代码">代码</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历数组，维护一个到目前为止最小的数first，second为至少有一个数比second小的所有候选者中最小的数，</span></span><br><span class="line">    <span class="comment">//我们可知first &lt; second,而且second是最小的大于first的数，是最优的递增三元子序列第二个候选元素。</span></span><br><span class="line">    <span class="comment">//如果数组元素小于等于first更新first，如果大于first但小于等于second，则更新second的值</span></span><br><span class="line">    <span class="comment">//如果出现大于second的数，则返回true</span></span><br><span class="line">    public boolean increasingTriplet(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> first = Integer.MAX_VALUE, second = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> <span class="built_in">num</span>: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">num</span> &lt;= first)&#123;</span><br><span class="line">                first = <span class="built_in">num</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">num</span> &lt;= second)&#123;</span><br><span class="line">                second = <span class="built_in">num</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//程序能执行到这说明存在first &lt; second &lt; num[i]</span></span><br><span class="line">                <span class="comment">//所以存在递增三元子序列，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Fo]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Longest Increasing Subsequence]]></title>
    <link href="http://blog.noobsky.com/2016/06/07/LeetCode-Longest-Increasing-Subsequence/"/>
    <id>http://blog.noobsky.com/2016/06/07/LeetCode-Longest-Increasing-Subsequence/</id>
    <published>2016-06-07T01:30:36.000Z</published>
    <updated>2016-06-07T07:20:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>For example,<br>Given [10, 9, 2, 5, 3, 7, 101, 18],<br>The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p>
<p>Your algorithm should run in O(n2) complexity.</p>
<p>Follow up: Could you improve it to O(n log n) time complexity?</p>
<h2 id="解法一：排序+LCS">解法一：排序+LCS</h2><p>这个问题可以转换为最长公共子序列问题。如数组A:[10, 9, 2, 5, 3, 7, 101, 18]，对该数组排序得到数组A’:[2, 3, 5, 7, 9, 10, 18, 101]，然后找出A和A’的最长公共子序列即可。这里的最长公共子序列就是[2, 3, 7, 18]或者[2, 3, 7, 101]。最长公共子序列（LCS）算法详见算法导论。其主要思想如下：<br>假定两个序列为X={x<sub>1</sub>, x<sub>2</sub>, …, x<sub>m</sub>}和Y={y<sub>1</sub>, y<sub>2</sub>, …, y<sub>n</sub>)，并设Z={z<sub>1</sub>, z<sub>2</sub>, …, z<sub>k</sub>}为X和Y的任意一个LCS。<br>1）如果x<sub>m</sub> = y<sub>n</sub>，则z<sub>k</sub> = x<sub>m</sub>=y<sub>n</sub>，且Z<sub>k-1</sub>是X<sub>m-1</sub>和Y<sub>n-1</sub>的一个LCS。<br>2）如果x<sub>m</sub> != y<sub>n</sub>, 则z<sub>k</sub> != x<sub>m</sub>意味着Z是X<sub>m-1</sub>和Y的一个LCS。<br>3）如果x<sub>m</sub> != y<sub>n</sub>, 则z<sub>k</sub> != y<sub>n</sub>意味着Z是X和Y<sub>n-1</sub>的一个LCS。<br>我们定义c[i, j]表示X<sub>i</sub>和Y<sub>j</sub>的LCS的长度，则可得以下公式：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/LCS_1.PNG" alt=""><br><img src="http://7xonwi.com1.z0.glb.clouddn.com/LCS_2.PNG" alt=""><br>但是如果有重复元素，用LCS的方法得到的结果不对，用LCS在LeetCode上AC不了，比如[2,2],LCS的长度为2，但是LIS的长度是1。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] numsCopy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        numsCopy = Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">        Arrays.sort(numsCopy);</span><br><span class="line">        <span class="comment">//System.arraycopy(nums, 0, numsCopy, 0, nums.length);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>][nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i-<span class="number">1</span>] == numsCopy[j-<span class="number">1</span>])&#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][nums.length];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二：动态规划（O(n2)）">解法二：动态规划（O(n<sup>2</sup>)）</h2><p>设长度为n的数组为{a0, a1, a2, … an-1}，以a[j]结尾的最长递增子序列为L(j)，则L(j) = {max(L(i))+1, i&lt;j且a[i]&lt;a[j]}，也就是说，我们需要遍历在j之前的所有位置i(从0到j-1)，找出满足条件a[i]&lt;a[j]的L(i)，求出max(L(i))+1即为L(j)的值。最后，我们遍历所有的L(j)（从0到n-1），找出最大值即为最大递增子序列。时间复杂度为O(n^2)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//dp[j] = max(dp[i]) + 1 i&lt;j&amp;&amp;nums[i] &lt; nums[j]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            dp[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt; nums[j]) dp[j] = Math.max(dp[j], dp[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res = Math.max(res, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法三：动态规划（O(nlgn)）">解法三：动态规划（O(nlgn)）</h2><p>解法二中的动态规划时间复杂度为O(n<sup>2</sup>)，原因是因为对于每一个新的位置j都需要遍历j之前的所以位置，找出之前位置最长递增子序列长度。那么我们是不是可以有一中方法能不用遍历之前所有的位置，而可以更快的确定i的位置呢？</p>
<p>我们使用数组ends，ends[i]记录的是最长递增子序列长度为i的序列的末尾元素的值，如果有多个递增子序列的长度都为i，那么ends[i]的值是这些长度为i的最长递增子序列的末尾元素的值中最小的元素（长度为i的那些LIS中的最小末尾）。则ends数组的长度就是所求最长递增子序列的长度。</p>
<p>假设存在一个序列d[1..9] ={ 2，1 ，5 ，3 ，6，4， 8 ，9， 7}，可以看出来它的LIS长度为5。下面一步一步试着求ends。</p>
<p>首先，把d[1]有序地放到ends里，令ends[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1</p>
<p>然后，把d[2]有序地放到ends里，令ends[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，很容易理解吧。这时Len=1</p>
<p>接着，d[3] = 5，d[3]&gt;ends[1]，所以令ends[1+1]=ends[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候ends[1..2] = 1, 5，Len＝2</p>
<p>再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候ends[1..2] = 1, 3，Len = 2</p>
<p>继续，d[5] = 6，它在3后面，因为ends[2] = 3, 而6在3后面，于是很容易可以推知ends[3] = 6, 这时ends[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。</p>
<p>第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到ends[3] = 4。ends[1..3] = 1, 3, 4， Len继续等于3</p>
<p>第7个, d[7] = 8，它很大，比4大，嗯。于是ends[4] = 8。Len变成4了</p>
<p>第8个, d[8] = 9，得到ends[5] = 9，嗯。Len继续增大，到5了。</p>
<p>最后一个, d[9] = 7，它在ends[3] = 4和ends[4] = 8之间，所以我们知道，最新的ends[4] =7，ends[1..5] = 1, 3, 4, 7, 9，Len = 5。</p>
<p>于是我们知道了LIS的长度为5。</p>
<p>注意，这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到ends[5], 9更新到ends[6]，得出LIS的长度为6。</p>
<p>然后应该发现一件事情了：在ends中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)。于是算法的时间复杂度就降低到了O(NlogN)！</p>
<p>简而言之，先建立一个数组ends，把首元素放进去，然后比较之后的元素，如果遍历到的新元素比ends数组中的首元素小的话，替换首元素为此新元素，如果遍历到的新元素比ends数组中的末尾元素还大的话，将此新元素添加到ends数组末尾(注意不覆盖原末尾元素)。如果遍历到的新元素比ends数组首元素大，比尾元素小时，此时用二分查找法找到第一个不小于此新元素的位置，覆盖掉位置的原来的数字，以此类推直至遍历完整个nums数组，此时ends数组的长度就是我们要求的LIS的长度，特别注意的是ends数组的值可能不是一个真实的LIS，比如若输入数组nums为{4, 2， 4， 5， 3， 7}，那么算完后的ends数组为{2， 3， 5， 7}，可以发现它不是一个原数组的LIS，只是长度相等而已，千万要注意这点。参见代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//1.排序后的序列和原序列求LCS最长公共子序列</span></span><br><span class="line">    <span class="comment">//2.dp (O(n*n))</span></span><br><span class="line">    <span class="comment">//3.dp (O(nlgn))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//二分搜索可以利用Arrays.binarySearch(int[] a, int fromIndex, int toIndex, int key),</span></span><br><span class="line">        <span class="comment">//该函数的返回值是这样的：如果a中存在key，则返回key在a中的index，不存在key返回-insertionpoint-1，所以</span></span><br><span class="line">        <span class="comment">//此时insertionpoint =  -(返回值+1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ret = Arrays.binarySearch(ends, <span class="number">0</span>, len, nums[i]);</span><br><span class="line">            <span class="comment">//小于0，不存在key，计算插入位置</span></span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) ret = -(ret+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//或者使用自己二分搜索函数</span></span><br><span class="line">            <span class="comment">//int ret = binarySearch(ends, 0, len, nums[i]);</span></span><br><span class="line">            ends[ret] = nums[i];</span><br><span class="line">            <span class="comment">//在ends尾部增加了一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(ret == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果不记得Arrays.binarySearch返回值的含义，可以自己写一个二分搜索函数，</span></span><br><span class="line">    <span class="comment">//如果存在key返回index，不存在时返回插入位置的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = fromIndex, right = toIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == key) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; key) right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题描述">问题描述</h2><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>For example,<br>Giv]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Combinations]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Combinations/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Combinations/</id>
    <published>2016-06-06T15:38:49.000Z</published>
    <updated>2016-06-06T15:41:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>For example,<br>If n = 4 and k = 2, a solution is:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        helper(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> void helper(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">List</span>&lt;Integer&gt; curr, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; i++)&#123;</span><br><span class="line">            curr.add(i);</span><br><span class="line">            helper(n, k-<span class="number">1</span>, i+<span class="number">1</span>, curr, res);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>For example,<br>If ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Search a 2D Matrix I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Search-a-2D-Matrix-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Search-a-2D-Matrix-I-II/</id>
    <published>2016-06-06T13:36:32.000Z</published>
    <updated>2016-06-06T14:57:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Search_a_2D_Matrix_I">Search a 2D Matrix I</h2><h3 id="题目描述">题目描述</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p>For example,</p>
<p>Consider the following matrix:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Given target = 3, return true.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;    </span><br><span class="line">    <span class="comment">//row*col矩阵转换为数组=&gt;matrix[i][j] =&gt; array[i * col + j] </span></span><br><span class="line">    <span class="comment">//数组转换为矩阵array[i] =&gt; matrix[i / col][i % col]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right - left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(matrix[mid/col][mid % col] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid/col][mid % col] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid/col][mid % col] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_a_2D_Matrix_II">Search a 2D Matrix II</h2><h3 id="题目描述-1">题目描述</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p>For example,</p>
<p>Consider the following matrix:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Given target = 5, return true.</p>
<p>Given target = 20, return false.</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//初始比较位置为右上角即matrix[0][col-1],如果target大于该值，那么target不可能在该row，因为每一row都是升序，可以排除该row</span></span><br><span class="line">    <span class="comment">//如果target小于该值，那么target不可能在该col，因为每一col都是升序的，可以排除该col，</span></span><br><span class="line">    <span class="comment">//如果相等，返回</span></span><br><span class="line">    <span class="comment">//时间复杂度O(m+n) </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[row][col])&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[row][col])&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Search_a_2D_Matrix_I">Search a 2D Matrix I</h2><h3 id="题目描述">题目描述</h3><p>Write an efficient algorithm that searches for a value in a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sort Colors]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Sort-Colors/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Sort-Colors/</id>
    <published>2016-06-06T11:44:14.000Z</published>
    <updated>2016-06-06T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note:<br>You are not suppose to use the library’s sort function for this problem.</p>
<h2 id="代码一">代码一</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//将0往左边放，2往右边放，1留中间</span></span><br><span class="line">    <span class="comment">//维护两个索引指针left、和right，left初始为0，right初始为nums.length-1</span></span><br><span class="line">    <span class="comment">//然后遍历数组，遇到0时交换到left位置，遇到2时交换到right位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环终止条件为i&lt;=right</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">                nums[left] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[right];</span><br><span class="line">                nums[right] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                <span class="comment">//交换过来的nums[right]有可能是0，i不能++</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码二">代码二</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Ugly Number I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Ugly-Number-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Ugly-Number-I-II/</id>
    <published>2016-06-06T07:22:02.000Z</published>
    <updated>2016-06-06T15:04:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Ugly_Number_I">Ugly Number I</h2><h3 id="题目描述">题目描述</h3><p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>) num = num / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>) num = num / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>) num = num / <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ugly_Number_II">Ugly Number II</h2><h3 id="题目描述-1">题目描述</h3><p>Write a program to find the n-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<p>Hint:</p>
<pre><code><span class="number">1.</span>The naive approach is <span class="built_in">to</span> call isUgly <span class="keyword">for</span> every <span class="built_in">number</span> <span class="keyword">until</span> you reach <span class="operator">the</span> nth <span class="constant">one</span>. Most numbers are <span class="operator">not</span> ugly. Try <span class="built_in">to</span> focus your effort <span class="command"><span class="keyword">on</span> <span class="title">generating</span> <span class="title">only</span> <span class="title">the</span> <span class="title">ugly</span> <span class="title">ones</span>.</span>
<span class="number">2.</span>An ugly <span class="built_in">number</span> must be multiplied <span class="keyword">by</span> either <span class="number">2</span>, <span class="number">3</span>, <span class="operator">or</span> <span class="number">5</span> <span class="built_in">from</span> <span class="operator">a</span> smaller ugly <span class="built_in">number</span>.
<span class="number">3.</span>The key is how <span class="built_in">to</span> maintain <span class="operator">the</span> order <span class="operator">of</span> <span class="operator">the</span> ugly numbers. Try <span class="operator">a</span> similar approach <span class="operator">of</span> merging <span class="built_in">from</span> <span class="constant">three</span> sorted lists: L1, L2, <span class="operator">and</span> L3.
<span class="number">4.</span>Assume you have Uk, <span class="operator">the</span> kth ugly <span class="built_in">number</span>. Then Uk+<span class="number">1</span> must be Min(L1 * <span class="number">2</span>, L2 * <span class="number">3</span>, L3 * <span class="number">5</span>).
</code></pre><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//ugly[0] = 1</span></span><br><span class="line">    <span class="comment">//ugly[1] = min(2*ugly[0], 3*ugly[0], 5*ugly[0])</span></span><br><span class="line">    <span class="comment">//ugly[2] = min(2*ugly[1], 3*ugly[0], 5*ugly[0])</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] ugly = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>, index3 = <span class="number">0</span>, index5 = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;i++)&#123;</span><br><span class="line">            ugly[i] = Math.min(Math.min(<span class="number">2</span> * ugly[index2], <span class="number">3</span> * ugly[index3]), <span class="number">5</span> * ugly[index5]);</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">2</span> * ugly[index2]) index2++;</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">3</span> * ugly[index3]) index3++;</span><br><span class="line">            <span class="keyword">if</span>(ugly[i] == <span class="number">5</span> * ugly[index5]) index5++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ugly[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Super_Ugly_Number">Super Ugly Number</h2><h3 id="题目描述-2">题目描述</h3><p>Write a program to find the nth super ugly number.</p>
<p>Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4.</p>
<p>Note:<br>(1) 1 is a super ugly number for any given primes.<br>(2) The given numbers in primes are in ascending order.<br>(3) 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000.</p>
<h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//思路类似，Ugly Number II，只是质数因子不是固定的三个，由primes数组提供，</span></span><br><span class="line">    <span class="comment">//则我们维护一个长度跟primes数组长度一样indexes数组即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] primes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] ugly = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] indexes = <span class="keyword">new</span> <span class="keyword">int</span>[primes.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ugly[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.length; j++)&#123;</span><br><span class="line">                ugly[i] = Math.min(ugly[i], primes[j]*ugly[indexes[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ugly[i] == primes[j]*ugly[indexes[j]])&#123;</span><br><span class="line">                    indexes[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ugly[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Ugly_Number_I">Ugly Number I</h2><h3 id="题目描述">题目描述</h3><p>Write a program to check whether a given number is an ugly number.</p>
<p]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Rotate Image]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Rotate-Image/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Rotate-Image/</id>
    <published>2016-06-06T05:18:34.000Z</published>
    <updated>2016-06-06T05:19:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Follow up:<br>Could you do this in-place?</p>
<h2 id="代码">代码</h2><figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    <span class="comment">//顺时针旋转90度，先转置然后左右翻转(y轴反转)</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    1 2 3    1 4 7    7 4 1</span><br><span class="line">    4 5 6 =&gt; 2 5 8 =&gt; 8 5 2</span><br><span class="line">    7 8 9    3 6 9    9 6 3</span><br><span class="line">    */</span></span><br><span class="line">    public void rotate(int[][] <span class="keyword">matrix</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">matrix</span> == null || <span class="keyword">matrix</span>.<span class="built_in">length</span> == <span class="number">0</span> || <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="built_in">length</span> == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        int <span class="built_in">length</span> = <span class="keyword">matrix</span>.<span class="built_in">length</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i+<span class="number">1</span>; j &lt; <span class="built_in">length</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[j][i];</span><br><span class="line">                <span class="keyword">matrix</span>[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="built_in">length</span>/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[i][<span class="built_in">length</span>-j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">matrix</span>[i][<span class="built_in">length</span>-j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逆时针旋转90度，先转置然后上下翻转(x轴对称)</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    1 2 3    1 4 7    3 6 9</span><br><span class="line">    4 5 6 =&gt; 2 5 8 =&gt; 2 5 8</span><br><span class="line">    7 8 9    3 6 9    1 4 7</span><br><span class="line">    */</span></span><br><span class="line">    public void rotate2(int[][] <span class="keyword">matrix</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">matrix</span> == null || <span class="keyword">matrix</span>.<span class="built_in">length</span> == <span class="number">0</span> || <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="built_in">length</span> == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        int <span class="built_in">length</span> = <span class="keyword">matrix</span>.<span class="built_in">length</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i+<span class="number">1</span>; j &lt; <span class="built_in">length</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[j][i];</span><br><span class="line">                <span class="keyword">matrix</span>[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">length</span>/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="built_in">length</span>; j++)&#123;</span><br><span class="line">                int temp = <span class="keyword">matrix</span>[i][j];</span><br><span class="line">                <span class="keyword">matrix</span>[i][j] = <span class="keyword">matrix</span>[<span class="built_in">length</span>-i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">matrix</span>[<span class="built_in">length</span>-i-<span class="number">1</span>][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Search Tree Iterator]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Search-Tree-Iterator/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Search-Tree-Iterator/</id>
    <published>2016-06-06T02:38:37.000Z</published>
    <updated>2016-06-06T02:40:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//很自然的思路就是将所有的树节点放入array中，然后利用索引指针进行next和hashNext</span></span><br><span class="line"><span class="comment">//满足O(1)time但是不满足O(h)memory</span></span><br><span class="line"><span class="comment">//我们可以利用栈，首先将树的left branch压栈，此时栈顶元素为最小的元素，当调用next弹出栈顶元素</span></span><br><span class="line"><span class="comment">//后，最小元素并不在栈中，我们需要寻找到最小元素然后入栈。此时树中元素最小元素在弹出元素的右子树的left branch</span></span><br><span class="line"><span class="comment">//这一点是由BST的性质决定的，所以我们next之后需要将弹出元素的右子树的left branch入栈。</span></span><br><span class="line"><span class="comment">//此种解法满足O(h)memory,next O(1), hashNext的平均时间能达到O(1)</span></span><br><span class="line"><span class="comment">//我们用next遍历整颗树，则next函数会遍历每个节点，run time为O(n),所以对于整棵树来说，平均运行时间为O(n)/n=O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> BSTIterator &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">stack</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode temp = <span class="built_in">stack</span>.pop();</span><br><span class="line">        pushLeftBranch(temp.right);</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLeftBranch</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node != null)&#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your BSTIterator will be called like this:</span><br><span class="line"> * BSTIterator i = new BSTIterator(root);</span><br><span class="line"> * while (i.hasNext()) v[f()] = i.next();</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a B]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Right Side View]]></title>
    <link href="http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Tree-Right-Side-View/"/>
    <id>http://blog.noobsky.com/2016/06/06/LeetCode-Binary-Tree-Right-Side-View/</id>
    <published>2016-06-06T01:21:29.000Z</published>
    <updated>2016-06-06T01:23:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>For example:<br>Given the following binary tree,</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span>            &lt;-<span class="comment">--</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;-<span class="comment">--</span></span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;-<span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>You should return [1, 3, 4].</p>
<h2 id="代码">代码</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; res = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rightView(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一层就取一个，而且是最右边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> rightView(TreeNode root, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; res, int currHeight)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//tricky，因为一层就取一个（最右边的），当res.size()==currHeight时，说明该元素就是该层最右边的元素</span></span><br><span class="line">        <span class="keyword">if</span>(res<span class="built_in">.</span>size() == currHeight) res<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//右边优先</span></span><br><span class="line">        rightView(root<span class="built_in">.</span>right, res, currHeight+<span class="number">1</span>);</span><br><span class="line">        rightView(root<span class="built_in">.</span>left, res, currHeight+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Spiral Matrix I,II]]></title>
    <link href="http://blog.noobsky.com/2016/06/05/LeetCode-Spiral-Matrix-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/05/LeetCode-Spiral-Matrix-I-II/</id>
    <published>2016-06-05T08:52:49.000Z</published>
    <updated>2016-06-05T09:47:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Spiral_Matrix_I">Spiral Matrix I</h2><h3 id="题目描述">题目描述</h3><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>Given the following matrix:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>You should return [1,2,3,6,9,8,7,4,5].</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//matrix[0][0]、matrix[0][1]</span></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置为-1比较好</span></span><br><span class="line">        <span class="keyword">int</span> col = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当m或者n等于0时终止循环</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//col初始值为-1，for循环结束后col刚好为下一次循环的起始值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                res.add(matrix[row][++col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已经少了一行(row),所以m--</span></span><br><span class="line">            m--;</span><br><span class="line">            <span class="comment">//如果m==0终止循环</span></span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//等价于if(--m == 0) break;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                res.add(matrix[++row][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上面的for循环后，会减少一列，所以n--</span></span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                res.add(matrix[row][--col]);</span><br><span class="line">            &#125;</span><br><span class="line">            m--;</span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                res.add(matrix[--row][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spiral_Matrix_II">Spiral Matrix II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p>For example,<br>Given n = 3,</p>
<p>You should return the following matrix:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//if(n &lt;= 0) return new int[0][0];</span></span><br><span class="line">        <span class="keyword">int</span> rowLen = n;</span><br><span class="line">        <span class="keyword">int</span> colLen = n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colLen; i++)&#123;</span><br><span class="line">                matrix[row][++col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加上小于是防止n=0的情况，或者直接在前面判断特殊情况</span></span><br><span class="line">            <span class="keyword">if</span>(--rowLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowLen; i++)&#123;</span><br><span class="line">                matrix[++row][col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(--colLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colLen; i++)&#123;</span><br><span class="line">                matrix[row][--col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(--rowLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowLen; i++)&#123;</span><br><span class="line">                matrix[--row][col] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(--colLen &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Spiral_Matrix_I">Spiral Matrix I</h2><h3 id="题目描述">题目描述</h3><p>Given a matrix of m x n elements (m rows, n columns), return all elem]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Permutations I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/05/LeetCode-Permutations-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/05/LeetCode-Permutations-I-II/</id>
    <published>2016-06-05T06:22:34.000Z</published>
    <updated>2016-06-06T15:04:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Permutations_I">Permutations I</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of distinct numbers, return all possible permutations.</p>
<p>For example,<br>[1,2,3] have the following permutations:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><ul>
<li><p>一般思路</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(nums, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> void permute(<span class="keyword">int</span>[]nums, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">int</span> start)&#123;</span><br><span class="line">        <span class="comment">//产生了一个permutation</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= nums.length)&#123;</span><br><span class="line">            <span class="comment">//如果Arrays.asList(arr)的参数arr是原生数组的话并不能得到你想要的结果，</span></span><br><span class="line">            <span class="comment">//Arrays.asList(T...a)形参为可变长参数，如果传入int[] nums的话，会将int[]看做一个类型</span></span><br><span class="line">            <span class="comment">//List list = Arrays.asList(nums)则list.size() == 1;</span></span><br><span class="line">            <span class="comment">//res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums)));</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//还是乖乖遍历吧，或者加多一个参数</span></span><br><span class="line">            <span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">list</span>.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">list</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">            <span class="comment">//注意第三个参数是start+1不是i+1</span></span><br><span class="line">            permute(nums, res, start+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//相当于还原回来</span></span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> void swap(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码比较简洁易懂</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute(nums, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> void permute(<span class="keyword">int</span>[] nums, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">List</span>&lt;Integer&gt; curr)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//curr中已经包含nums[i],跳过本次循环</span></span><br><span class="line">            <span class="keyword">if</span>(curr.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            permute(nums, res, curr);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Permutations_II">Permutations II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br>[1,1,2] have the following unique permutations:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码-1">代码</h3><ul>
<li><p>比较tricky的写法</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//注意排序，让重复的数相邻</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        helper(nums, used, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> void helper(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, <span class="keyword">List</span>&lt;Integer&gt; curr, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//only insert duplicate element when the previous duplicate element has been inserted</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            helper(nums, used, curr, res);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常规思路加排重</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; permuteUnique(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute(nums, res, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">void</span> permute(<span class="built_in">int</span>[] nums, <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res, <span class="built_in">int</span> start)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">            <span class="built_in">List</span>&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> <span class="built_in">num</span>: nums) &#123;temp.add(<span class="built_in">num</span>);&#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//set在for循环外面定义，在里面定义错误</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; <span class="literal">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">set</span>.add(nums[i]))&#123;</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">                permute(nums, res, start+<span class="number">1</span>);</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private <span class="keyword">void</span> swap(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> x, <span class="built_in">int</span> y)&#123;</span><br><span class="line">        <span class="built_in">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Permutations_I">Permutations I</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of distinct numbers, return all possible permutation]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Combination Sum I II III]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Combination-Sum-I-II-III/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Combination-Sum-I-II-III/</id>
    <published>2016-06-04T12:23:07.000Z</published>
    <updated>2016-06-05T01:43:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Combination_Sum_I">Combination Sum I</h2><h3 id="题目描述">题目描述</h3><p>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>The same repeated number may be chosen from C unlimited number of times.</p>
<p>Note:</p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</li>
<li>The solution set must not contain duplicate combinations.</li>
<li>For example, given candidate set 2,3,6,7 and target 7,<br>A solution set is:<br>[7]<br>[2, 2, 3]</li>
</ul>
<h3 id="代码">代码</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(candidates, <span class="keyword">target</span>, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">target</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; <span class="keyword">target</span> &gt;= candidates[i]; i++)&#123;</span><br><span class="line">                curr.add(candidates[i]);</span><br><span class="line">                <span class="comment">//元素可以重复利用，所以start为i</span></span><br><span class="line">                helper(candidates, <span class="keyword">target</span> - candidates[i], res, curr, i);</span><br><span class="line">                <span class="comment">//回溯，删除curr中最后一个元素</span></span><br><span class="line">                curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(<span class="keyword">target</span> == <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">            <span class="comment">//找到一个序列</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Combination_Sum_II">Combination Sum II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>Each number in C may only be used once in the combination.</p>
<p>Note:</p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>For example, given candidate set 10,1,2,7,6,1,5 and target 8,<br>A solution set is:<br>[1, 7]<br>[1, 2, 5]<br>[2, 6]<br>[1, 1, 6] </p>
<h3 id="代码-1">代码</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(candidates, <span class="keyword">target</span>, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> <span class="keyword">target</span>, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">target</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">target</span> &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; <span class="keyword">target</span> &gt;= candidates[i]; i++)&#123;</span><br><span class="line">            <span class="comment">//i==start || candidates[i]!=candidates[i-1]避免重复结果</span></span><br><span class="line">            <span class="comment">//等价于（i&gt;start&amp;&amp;candidates[i]==candidates[i-1] continue</span></span><br><span class="line">            <span class="comment">//i大于start意味着candidates[i-1]已经从curr被remove，所以如果candidates[i]==candidates[i-1]</span></span><br><span class="line">            <span class="comment">//则我们不应该将candidates[i]加入curr中</span></span><br><span class="line">            <span class="keyword">if</span>(i==start || candidates[i]!=candidates[i-<span class="number">1</span>])&#123;</span><br><span class="line">                curr.add(candidates[i]);</span><br><span class="line">                <span class="comment">//candidates的每个元素智能使用一次,所以下一次递归时为i+1</span></span><br><span class="line">                helper(candidates, <span class="keyword">target</span>-candidates[i], res, curr, i+<span class="number">1</span>);</span><br><span class="line">                curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Combination_Sum_III">Combination Sum III</h2><h3 id="题目描述-2">题目描述</h3><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Ensure that numbers within the set are sorted in ascending order.</p>
<p>Example 1:</p>
<p>Input: k = 3, n = 7</p>
<p>Output:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<p>Input: k = 3, n = 9</p>
<p>Output:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>], [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(k, n, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> need, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(need == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//需要寻找从i开始的need个数，所以需要满足target &gt;= i+(i+1)+...+(i+need-1) = i*need+need*(need-1)/2</span></span><br><span class="line">        <span class="comment">//即i开始的need个数最小和为i+(i+1)+...+(i+need-1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i != <span class="number">10</span> &amp;&amp; target &gt;= i * need + need * (need - <span class="number">1</span>) / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            curr.add(i);</span><br><span class="line">            helper(need-<span class="number">1</span>, target-i, res, curr, i+<span class="number">1</span>);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Combination_Sum_I">Combination Sum I</h2><h3 id="题目描述">题目描述</h3><p>Given a set of candidate numbers (C) and a target number (T), fin]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Find Minimum in Rotated Sorted Array I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Find-Minimum-in-Rotated-Sorted-Array-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Find-Minimum-in-Rotated-Sorted-Array-I-II/</id>
    <published>2016-06-04T07:07:07.000Z</published>
    <updated>2016-06-04T08:49:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Find_Minimum_in_Rotated_Sorted_Array_I">Find Minimum in Rotated Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<h3 id="代码如下">代码如下</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="keyword">public</span> int findMin(int[] nums) &#123;</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>])&#123;<span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">                <span class="keyword">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="keyword">right</span>])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                <span class="keyword">right</span> = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="keyword">left</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Find_Minimum_in_Rotated_Sorted_Array_II">Find Minimum in Rotated Sorted Array II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for “Find Minimum in Rotated Sorted Array”:<br>What if duplicates are allowed?</p>
<p>Would this affect the run-time complexity? How and why?<br>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<h3 id="代码">代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="comment">//nums[mid] &gt; nums[right],nums[left:mid]有序，搜索右边</span></span><br><span class="line">    <span class="comment">//nums[mid] &lt; nums[right],nums[mid:right]有序，搜索左边</span></span><br><span class="line">    <span class="comment">//nums[mid] = nums[right],有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">    <span class="comment">//但可以肯定排除nums[right],即使min = A[right],排除A[right]并没有使min丢失</span></span><br><span class="line">    <span class="keyword">public</span> int findMin(int[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int mid = <span class="keyword">left</span>+(<span class="keyword">right</span> - <span class="keyword">left</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">left</span> = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="keyword">right</span>])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                <span class="keyword">right</span> = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">                <span class="keyword">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="keyword">left</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Find_Minimum_in_Rotated_Sorted_Array_I">Find Minimum in Rotated Sorted Array I</h2><h3 id="题目描述">题目描述</h3><p>Suppose a sorted array ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Populating Next Right Pointers in Each Node I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Populating-Next-Right-Pointers-in-Each-Node/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Populating-Next-Right-Pointers-in-Each-Node/</id>
    <published>2016-06-04T05:28:55.000Z</published>
    <updated>2016-06-04T06:38:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Populating_Next_Right_Pointers_in_Each_Node_I">Populating Next Right Pointers in Each Node I</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">struct</span> TreeLinkNode &#123;</span><br><span class="line">      <span class="title">TreeLinkNode</span> *left;</span><br><span class="line">      <span class="title">TreeLinkNode</span> *right;</span><br><span class="line">      <span class="title">TreeLinkNode</span> *next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<ul>
<li>You may only use constant extra space.</li>
<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
<p>For example,<br>Given the following perfect binary tree,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>After calling your function, the tree should look like:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span> -&gt; <span class="literal">NULL</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">NULL</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span> -&gt; <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p>
<h3 id="代码如下">代码如下</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree with next pointer.</span><br><span class="line"> * public class TreeLinkNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeLinkNode left, right, next;</span><br><span class="line"> *     TreeLinkNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//思路比较直接，直接迭代法遍历,分层处理</span></span><br><span class="line">    <span class="comment">//注意，所有节点的next都初始化为null</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> connect(TreeLinkNode root)&#123;</span><br><span class="line"></span><br><span class="line">		TreeLinkNode levelStart = root;</span><br><span class="line">		TreeLinkNode curr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(levelStart != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//从每一层的第一个节点开始处理</span></span><br><span class="line">			curr = levelStart;</span><br><span class="line">			<span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(curr.left != <span class="keyword">null</span>) curr.left.<span class="keyword">next</span> = curr.right;</span><br><span class="line">				<span class="keyword">if</span>(curr.right != <span class="keyword">null</span> &amp;&amp; curr.<span class="keyword">next</span> != <span class="keyword">null</span>) curr.right.<span class="keyword">next</span> = curr.<span class="keyword">next</span>.left;</span><br><span class="line">				curr = curr.<span class="keyword">next</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//换到下一层第一个节点</span></span><br><span class="line">			levelStart = levelStart.left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Populating_Next_Right_Pointers_in_Each_Node_II">Populating Next Right Pointers in Each Node II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for problem “Populating Next Right Pointers in Each Node”.</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note:</p>
<ul>
<li>You may only use constant extra space.<br>For example,<br>Given the following binary tree,<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"> / \    \</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>    <span class="number">7</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>After calling your function, the tree should look like:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span> -&gt; <span class="literal">NULL</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">NULL</span></span><br><span class="line"> / \    \</span><br><span class="line"><span class="number">4</span>-&gt; <span class="number">5</span> -&gt; <span class="number">7</span> -&gt; <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p>
<h3 id="代码">代码</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree with <span class="built_in">next</span> pointer.</span><br><span class="line"> * public class TreeLinkNode &#123;</span><br><span class="line"> *     <span class="typename">int</span> val;</span><br><span class="line"> *     TreeLinkNode left, right, <span class="built_in">next</span>;</span><br><span class="line"> *     TreeLinkNode(<span class="typename">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void connect(TreeLinkNode root)&#123;</span><br><span class="line">        TreeLinkNode levelStart = root;<span class="comment">//下一层的最左边节点</span></span><br><span class="line">        TreeLinkNode <span class="built_in">prev</span> = <span class="built_in">null</span>; <span class="comment">//下一层的前一节点</span></span><br><span class="line">        TreeLinkNode curr = <span class="built_in">null</span>;<span class="comment">//当前节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(levelStart != <span class="built_in">null</span>)&#123;</span><br><span class="line">            curr = levelStart;</span><br><span class="line">            <span class="built_in">prev</span> = <span class="built_in">null</span>;</span><br><span class="line">            <span class="comment">//不能缺少，少了会超时（只有根节点的情况），&#123;0&#125;死循环</span></span><br><span class="line">            levelStart = <span class="built_in">null</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(curr != <span class="built_in">null</span>)&#123;</span><br><span class="line">                <span class="comment">//不为空，进行处理</span></span><br><span class="line">                if(curr.left != <span class="built_in">null</span>)&#123;</span><br><span class="line">                    if(<span class="built_in">prev</span> != <span class="built_in">null</span>)</span><br><span class="line">                        <span class="built_in">prev</span>.<span class="built_in">next</span> = curr.left;</span><br><span class="line">                    else</span><br><span class="line">                        levelStart = curr.left;<span class="comment">//没有prev节点的话，则新的levelStart为curr.left</span></span><br><span class="line">                    <span class="comment">//处理完之后，curr.left成为prev节点</span></span><br><span class="line">                    <span class="built_in">prev</span> = curr.left;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if(curr.right != <span class="built_in">null</span>)&#123;</span><br><span class="line">                    if(<span class="built_in">prev</span> != <span class="built_in">null</span>)</span><br><span class="line">                        <span class="built_in">prev</span>.<span class="built_in">next</span> = curr.right;</span><br><span class="line">                    else</span><br><span class="line">                        levelStart = curr.right;</span><br><span class="line">                    <span class="comment">//处理完之后，curr.left成为prev节点</span></span><br><span class="line">                    <span class="built_in">prev</span> = curr.right;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr.<span class="built_in">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Populating_Next_Right_Pointers_in_Each_Node_I">Populating Next Right Pointers in Each Node I</h2><h3 id="题目描述">题目描述</h3><p>Given a b]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Unique Paths I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Unique-Paths-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Unique-Paths-I-II/</id>
    <published>2016-06-04T02:38:02.000Z</published>
    <updated>2016-06-04T04:03:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Unique_Paths">Unique Paths</h2><h3 id="题目描述">题目描述</h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="http://7xonwi.com1.z0.glb.clouddn.com/robot_maze.png" alt=""><br>Above is a 3 x 7 grid. How many possible unique paths are there?</p>
<p>Note: m and n will be at most 100.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//a[m][n] = a[m-1][n]+a[m][n-1]</span></span><br><span class="line">    <span class="comment">// public int uniquePaths(int m, int n) &#123;</span></span><br><span class="line">    <span class="comment">//     if(m &lt;= 0 || n &lt;= 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int[][] grid = new int[m][n];</span></span><br><span class="line">    <span class="comment">//     //第一排和第一列都为1</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; m; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         grid[i][0] = 1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     for(int j = 0; j &lt; n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//         grid[0][j] = 1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt; m; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 1; j &lt; n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             grid[i][j] = grid[i-1][j]+grid[i][j-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return grid[m-1][n-1];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a[m][n] = a[m-1][n]+a[m][n-1]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                grid[i][j] = (i == <span class="number">0</span> || j == <span class="number">0</span>) ? <span class="number">1</span> : grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Unique_Paths_II">Unique Paths II</h2><h3 id="题目描述-1">题目描述</h3><p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p>For example,<br>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> grid[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) grid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">0</span> : grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) grid[<span class="number">0</span>][j] = (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) ? <span class="number">0</span> : grid[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                grid[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : grid[i-<span class="number">1</span>][j]+grid[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也可以但是不够好理解</span></span><br><span class="line">    <span class="comment">// public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span></span><br><span class="line">    <span class="comment">//     int m = obstacleGrid.length;</span></span><br><span class="line">    <span class="comment">//     if(m == 0) return 0;</span></span><br><span class="line">    <span class="comment">//     int n = obstacleGrid[0].length;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int grid[][] = new int[m+1][n+1];</span></span><br><span class="line">    <span class="comment">//     grid[0][1] = 1;</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt;= m; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 1; j &lt;= n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             grid[i][j] = obstacleGrid[i-1][j-1] == 1 ? 0 : grid[i-1][j]+grid[i][j-1];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     return grid[m][n];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Unique_Paths">Unique Paths</h2><h3 id="题目描述">题目描述</h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ i]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Gray Code]]></title>
    <link href="http://blog.noobsky.com/2016/06/04/LeetCode-Gray-Code/"/>
    <id>http://blog.noobsky.com/2016/06/04/LeetCode-Gray-Code/</id>
    <published>2016-06-04T00:59:16.000Z</published>
    <updated>2016-06-04T01:55:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> - <span class="number">0</span></span><br><span class="line"><span class="number">01</span> - <span class="number">1</span></span><br><span class="line"><span class="number">11</span> - <span class="number">3</span></span><br><span class="line"><span class="number">10</span> - <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Note:<br>For a given n, a gray code sequence is not uniquely defined.</p>
<p>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Int    Grey Code    Binary</span><br><span class="line"> <span class="number">0</span>  　　  <span class="number">000</span>        <span class="number">000</span></span><br><span class="line"> <span class="number">1</span>  　　  <span class="number">001</span>        <span class="number">001</span></span><br><span class="line"> <span class="number">2</span>   　 　<span class="number">011</span>        <span class="number">010</span></span><br><span class="line"> <span class="number">3</span>   　 　<span class="number">010</span>        <span class="number">011</span></span><br><span class="line"> <span class="number">4</span>   　 　<span class="number">110</span>        <span class="number">100</span></span><br><span class="line"> <span class="number">5</span>   　 　<span class="number">111</span>        <span class="number">101</span></span><br><span class="line"> <span class="number">6</span>   　 　<span class="number">101</span>        <span class="number">110</span></span><br><span class="line"> <span class="number">7</span>   　　 <span class="number">100</span>        <span class="number">111</span></span><br></pre></td></tr></table></figure>
<h2 id="解法一">解法一</h2><p>利用格雷码和二进制数的相互转换，G(i)=(i/2)^i<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//G(i)=(i/2)^i</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; grayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            res.add(i ^ (i&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二">解法二</h2><p>格雷码有镜射排列的性质，即n位元的格雷码可以从n-1位元的格雷码以上下镜射后加上新位元的方式快速得到，如下图所示<br><img src="https://upload.wikimedia.org/wikipedia/commons/c/c1/Binary-reflected_Gray_code_construction.svg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//镜面排列</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; grayCode(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        res.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> highBit = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                res.add(res.get(j)+highBit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-ne]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Generate Parentheses]]></title>
    <link href="http://blog.noobsky.com/2016/06/03/LeetCode-Generate-Parentheses/"/>
    <id>http://blog.noobsky.com/2016/06/03/LeetCode-Generate-Parentheses/</id>
    <published>2016-06-03T12:00:58.000Z</published>
    <updated>2016-06-03T12:24:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:</p>
<p>“((()))”, “(()())”, “(())()”, “()(())”, “()()()”</p>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(n,n,<span class="string">""</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="comment">//在每次递归函数中记录左括号和右括号剩余的数量，然后有两种选择，一种是放一个左括号，一种放一个右括号</span></span><br><span class="line">    <span class="comment">//有一些否定条件，比如右括号的数量不能比左括号少，左右括号的数量要大于0</span></span><br><span class="line">    <span class="comment">//正常的递归终止条件是左右括号的数量都为0</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// public void helper(int left, int right, String item, List&lt;String&gt; res)&#123;</span></span><br><span class="line">    <span class="comment">//     //右括号的数量比左括号少，递归终止</span></span><br><span class="line">    <span class="comment">//     if(right &lt; left) return;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(right == 0 &amp;&amp; left == 0) res.add(item);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(left &gt; 0) helper(left-1, right, item+"(", res);</span></span><br><span class="line">    <span class="comment">//     if(right &gt; 0) helper(left, right-1, item+")", res);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//right不能比左括号少，且right &gt; 0,即条件为right &gt; left</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String item, List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//右括号的数量比左括号少，递归终止</span></span><br><span class="line">        <span class="comment">//if(right &lt; left) return;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">0</span> &amp;&amp; left == <span class="number">0</span>) res.add(item);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>) helper(left-<span class="number">1</span>, right, item+<span class="string">"("</span>, res);</span><br><span class="line">        <span class="comment">//右括号比左括号多时才能往下递归，比如n=3，当递归到helper(1,1,"()()",res),"()()"+")"显然是不可行的</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; left) helper(left, right-<span class="number">1</span>, item+<span class="string">")"</span>, res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]House Robber I II III]]></title>
    <link href="http://blog.noobsky.com/2016/06/03/LeetCode-House-Robber-I-II-III/"/>
    <id>http://blog.noobsky.com/2016/06/03/LeetCode-House-Robber-I-II-III/</id>
    <published>2016-06-03T06:25:53.000Z</published>
    <updated>2016-06-03T08:51:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="House_Robber_I">House Robber I</h2><h3 id="题目描述">题目描述</h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<h3 id="解题思路及代码">解题思路及代码</h3><p>dp解法，第i家要么不抢要么抢，dp[i] = max(dp[i-1],dp[i-2]+nums[i])，dp数组可以省略</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//dp[i] = max(dp[i-1],dp[i-2]+nums[i])</span></span><br><span class="line">    <span class="comment">//自己想的，O(n),但是需要O(n)的内存空间</span></span><br><span class="line">    <span class="comment">// public int rob(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     if(nums.length == 1) return nums[0];</span></span><br><span class="line">    <span class="comment">//     int[] dp = new int[nums.length];</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     dp[0] = nums[0];</span></span><br><span class="line">    <span class="comment">//     dp[1] = Math.max(nums[0], nums[1]);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     for(int i = 2; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return dp[nums.length - 1];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ifRobedPrevious = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ifDontRobedPrevious = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前house要么抢要么不抢</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//当前house抢能获得的money，则前一house不能抢，</span></span><br><span class="line">            <span class="keyword">int</span> currentRobed = ifDontRobedPrevious + nums[i];</span><br><span class="line">            <span class="comment">//当前house不抢能获得的money，则为前一house抢或者不抢，取最大值</span></span><br><span class="line">            <span class="keyword">int</span> currentNotRobed = Math.max(ifRobedPrevious, ifDontRobedPrevious);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对于下一次循环来说相当于前一house抢</span></span><br><span class="line">            ifRobedPrevious = currentRobed;</span><br><span class="line">            <span class="comment">//对于下一次循环来说相当于前一house不抢</span></span><br><span class="line">            ifDontRobedPrevious = currentNotRobed;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(ifRobedPrevious, ifDontRobedPrevious);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="House_Robber_II">House Robber II</h2><h3 id="题目描述-1">题目描述</h3><p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<h3 id="解题思路及代码-1">解题思路及代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//房子首尾相连形成了一个圈，所以i间房子和i+1间房子只能有一间抢，或者两者都不抢</span></span><br><span class="line">    <span class="comment">//如果假设第i间不抢，则我们可以打断该圈，比如1-&gt;2-&gt;3-&gt;1则变成了2-&gt;3如果1不抢，</span></span><br><span class="line">    <span class="comment">//我们假设第i间房子不抢，剩下的房子组成的连续序列用House Robber的方法求解出最大值max1</span></span><br><span class="line">    <span class="comment">//然后假设第i+1间房子不抢，剩下的房子组成的连续序列用House Robber的方法求解出最大值max2，max1和max2的较大者即为所求</span></span><br><span class="line">    <span class="comment">//为了编程简单，我们选择i=n，i+1=0，也就是说我们把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后比较两个值取</span></span><br><span class="line">    <span class="comment">//取其中的最大值即为所求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(robHelper(nums, <span class="number">0</span>, nums.length-<span class="number">2</span>), robHelper(nums, <span class="number">1</span>, nums.length-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robHelper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> robedPrevious = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dontRobedPrevious = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> currentRobed = dontRobedPrevious + nums[i];</span><br><span class="line">            <span class="keyword">int</span> currentDontRobed = Math.max(robedPrevious, dontRobedPrevious);</span><br><span class="line">            </span><br><span class="line">            robedPrevious = currentRobed;</span><br><span class="line">            dontRobedPrevious = currentDontRobed;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(robedPrevious, dontRobedPrevious);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="House_Robber_III">House Robber III</h2><h3 id="题目描述-2">题目描述</h3><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>
<p><em>Example 1:</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> \   \ </span><br><span class="line">  <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.<br><em>Example 2:</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"> / \   \ </span><br><span class="line"><span class="number">1</span>   <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>
<h3 id="解题思路及代码-2">解题思路及代码</h3><ul>
<li>方法一</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//最优子结构：如果从想从当前二叉树中抢到最大的money，那么从子二叉树也是应该抢到最多的money</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    <span class="comment">//递归解法，会有很多重复子问题，效率低</span></span><br><span class="line">    <span class="comment">//max(抢root，不抢root) 即max(rob(root),rob(root.left)+rob(root.right))</span></span><br><span class="line">    <span class="keyword">public</span> int rob(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">      <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">      int val = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span>(root.<span class="keyword">left</span> != null)&#123;</span><br><span class="line">          val += rob(root.<span class="keyword">left</span>.<span class="keyword">left</span>)+rob(root.<span class="keyword">left</span>.<span class="keyword">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span>(root.<span class="keyword">right</span> != null)&#123;</span><br><span class="line">          val += rob(root.<span class="keyword">right</span>.<span class="keyword">left</span>)+rob(root.<span class="keyword">right</span>.<span class="keyword">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">return</span> <span class="type">Math</span>.<span class="built_in">max</span>(val+root.val, rob(root.<span class="keyword">left</span>)+rob(root.<span class="keyword">right</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//最优子结构：如果从想从当前二叉树中抢到最大的money，那么从子二叉树也是应该抢到最多的money</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="comment">//直接递归有很多重复子问题，可以利用带备忘的递归，使用HashMap记录访问过的子树的结果</span></span><br><span class="line">    <span class="keyword">public</span> int rob(<span class="type">TreeNode</span> root)&#123;</span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">TreeNode</span>, <span class="type">Integer</span>&gt; <span class="built_in">map</span> = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> robHelper(root, <span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> int robHelper(<span class="type">TreeNode</span> root, <span class="type">Map</span>&lt;<span class="type">TreeNode</span>, <span class="type">Integer</span>&gt; <span class="built_in">map</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果map中存在root对应的值，则不需要递归，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(root)) <span class="keyword">return</span> <span class="built_in">map</span>.<span class="keyword">get</span>(root);</span><br><span class="line">        </span><br><span class="line">        int val = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.<span class="keyword">left</span> != null)&#123;</span><br><span class="line">            val += robHelper(root.<span class="keyword">left</span>.<span class="keyword">left</span>, <span class="built_in">map</span>)+robHelper(root.<span class="keyword">left</span>.<span class="keyword">right</span>, <span class="built_in">map</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.<span class="keyword">right</span> != null)&#123;</span><br><span class="line">            val += robHelper(root.<span class="keyword">right</span>.<span class="keyword">left</span>, <span class="built_in">map</span>)+robHelper(root.<span class="keyword">right</span>.<span class="keyword">right</span>,<span class="built_in">map</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        val = <span class="type">Math</span>.<span class="built_in">max</span>(val+root.val, robHelper(root.<span class="keyword">left</span>, <span class="built_in">map</span>)+robHelper(root.<span class="keyword">right</span>,<span class="built_in">map</span>));</span><br><span class="line">        <span class="comment">//将root对应的max money存入map中</span></span><br><span class="line">        <span class="built_in">map</span>.put(root, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法三</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//最优子结构：如果从想从当前二叉树中抢到最大的money，那么从子二叉树也是应该抢到最多的money</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//方法三</span></span><br><span class="line">    <span class="comment">//重新定义rob(root)函数，返回值为含有两个元素的数组，第一个元素代表不抢root获得的最大money，</span></span><br><span class="line">    <span class="comment">//第二个元素代表抢root获得的最大money</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = robHelper(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] robHelper(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] left = robHelper(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = robHelper(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//不抢root，则left可抢其子root也可不抢其子root,right同理</span></span><br><span class="line">        res[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//抢root,则left和right不能抢其子root</span></span><br><span class="line">        res[<span class="number">1</span>] = root.val +  left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="House_Robber_I">House Robber I</h2><h3 id="题目描述">题目描述</h3><p>You are a professional robber planning to rob houses along a street. Ea]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://blog.noobsky.com/tags/Dynamic-Programming/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Convert Sorted Array/List to Binary Search Tree]]></title>
    <link href="http://blog.noobsky.com/2016/06/02/LeetCode-Convert-Sorted-Array-List-to-Binary-Search-Tree/"/>
    <id>http://blog.noobsky.com/2016/06/02/LeetCode-Convert-Sorted-Array-List-to-Binary-Search-Tree/</id>
    <published>2016-06-02T07:01:58.000Z</published>
    <updated>2016-06-02T15:16:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Convert_Sorted_Array_to_Binary_Search_Tree">Convert Sorted Array to Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="解题思路与代码">解题思路与代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意判断是否为start&gt;end,不然会发生数组越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="comment">//取中间节点作为树的root，可以保证是height balanced的BST</span></span><br><span class="line">        <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, start, mid-<span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Convert_Sorted_List_to_Binary_Search_Tree">Convert Sorted List to Binary Search Tree</h2><h3 id="题目描述-1">题目描述</h3><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h3 id="解题思路与代码-1">解题思路与代码</h3><p>方法一：O(nlogn) runtime, O(logn) stack space<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//类似Convert Sorted Array to BST，找出中间节点</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(nlgn),找中间节点为O(n),需要找lgn次</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="comment">//pre指向slow前一节点，记录slow前面是否有节点</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//找出单链表的中间节点,循环结束后slow指向单链表的中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pre != null意味着slow前面有节点，pre.next = null,head则为单链表的前半部分</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//pre == null 意味着slow前面没有节点</span></span><br><span class="line">        <span class="keyword">else</span> head = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        <span class="comment">//head指向单链表前半部分的头结点</span></span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        <span class="comment">//slow.next指向单链表后半部分的头结点</span></span><br><span class="line">        root.right = sortedListToBST(slow.<span class="keyword">next</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二：O(n) runtime, O(logn) stack space, Bottom-up recursion<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="keyword">list</span>;</span><br><span class="line">    <span class="comment">//感觉不好理解</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode sortedListToBST(ListNode head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">list</span> = head;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,size-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode helper(<span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        TreeNode left = helper(start, mid-<span class="number">1</span>);</span><br><span class="line">        TreeNode <span class="keyword">parent</span> = <span class="keyword">new</span> TreeNode(<span class="keyword">list</span>.val);</span><br><span class="line">        <span class="keyword">parent</span>.left = left;</span><br><span class="line">        <span class="keyword">list</span> = <span class="keyword">list</span>.next;</span><br><span class="line">        <span class="keyword">parent</span>.right = helper(mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Convert_Sorted_Array_to_Binary_Search_Tree">Convert Sorted Array to Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given an array ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="Tree" scheme="http://blog.noobsky.com/tags/Tree/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
