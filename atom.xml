<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-07-07T11:14:44.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Additive Number]]></title>
    <link href="http://blog.noobsky.com/2016/07/07/LeetCode-Additive-Number/"/>
    <id>http://blog.noobsky.com/2016/07/07/LeetCode-Additive-Number/</id>
    <published>2016-07-07T09:03:11.000Z</published>
    <updated>2016-07-07T11:14:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>
<p><strong>For example:</strong><br>“112358” is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.</p>
<p>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8<br>“199100199” is also an additive number, the additive sequence is: 1, 99, 100, 199.<br>1 + 99 = 100, 99 + 100 = 199<br>Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p>
<p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.</p>
<p><strong>Follow up:</strong><br>How would you handle overflow for very large input integers?</p>
<h2 id="代码">代码</h2><p>采用暴力解法，第一个数字从一位、两位…，第二个数字也从一位、两位，往高位搜索。两个数字确定以后，相加计算它们的和，判断它们的和是否是剩下的数字的前缀，如果不是说明该两个数字的组合不是additive sequence，尝试下一对组合；如果是，说明该组合有可能是additive sequence，那么取出上一次计算的第二个数和和作为新一次迭代的第一和第二个数，继续进行上面的判断，以此类推，直到两个数字的和长度不小于原字符串的长度，返回true。如果尝试了所有的组合后都不是，则返回false。第一个数字的长度的取值范围为[1, n/2]，n为字符串的长度，因为第二个数字的长度跟第一个数字的长度相等。两个数字的和的长度大于等于两个数字长度的最大值。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAdditiveNumber</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个数字长度取值范围为[0, n/2]</span></span><br><span class="line">        <span class="comment">//i表示第一个数字的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//j表示第二个数字的长度</span></span><br><span class="line">            <span class="comment">//两个数字的和也就是剩下的字符串的长度n - i -j要大于等于两个数字长度的较大值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>; Math.max(i, j) &lt;= n - i - j; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isValid(i, j, num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//题中说了两位数以上不能以0开头</span></span><br><span class="line">        <span class="comment">//如果第一个数字以0开头，而且长度还大于1的话无效，直接返回false；</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(num.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; i &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//第二个字符无效</span></span><br><span class="line">        <span class="keyword">if</span>(num.charAt(i) == <span class="string">'0'</span> &amp;&amp; j &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Long x1 = Long.parseLong(num.substring(<span class="number">0</span>, i));</span><br><span class="line">        Long x2 = Long.parseLong(num.substring(i, i+j));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不断的跟剩下的字符串比较</span></span><br><span class="line">        <span class="comment">//剩下的字符串为substring(i+j, num.length)</span></span><br><span class="line">        <span class="comment">//下一次剩下的字符串为i+j + sum.length()</span></span><br><span class="line">        <span class="comment">//x1+x2</span></span><br><span class="line">        String sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = i+j; start &lt; num.length(); start += sum.length())&#123;</span><br><span class="line">            <span class="comment">//两个数之和是下一次迭代的第二个数</span></span><br><span class="line">            x2 = x1 + x2;</span><br><span class="line">            x1 = x2 - x1;</span><br><span class="line">            <span class="comment">//将和转化为字符串，然后跟剩下的字符串比较，</span></span><br><span class="line">            sum = x2.toString();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//只要和是剩下字符串的前缀，就能继续往下比较，否则直接返回false</span></span><br><span class="line">            <span class="comment">//剩下的字符串为num.substring(start);</span></span><br><span class="line">            <span class="comment">//判断和是否是剩下字符串的前缀可以用startsWith(sum)</span></span><br><span class="line">            <span class="comment">//num.substring(start).startsWith(sum)等价于num.startsWith(sum, start);</span></span><br><span class="line">            <span class="keyword">if</span>(!num.substring(start).startsWith(sum)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果对于Follow up中输入特别大的数的话，java可以使用BigInteger，修改如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAdditiveNumber</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个数字长度取值范围为[0, n/2]</span></span><br><span class="line">        <span class="comment">//i表示第一个数字的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//j表示第二个数字的长度</span></span><br><span class="line">            <span class="comment">//两个数字的和也就是剩下的字符串的长度n - i -j要大于等于两个数字长度的较大值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>; Math.max(i, j) &lt;= n - i - j; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isValid(i, j, num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//题中说了两位数以上不能以0开头</span></span><br><span class="line">        <span class="comment">//如果第一个数字以0开头，而且长度还大于1的话无效，直接返回false；</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(num.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; i &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//第二个字符无效</span></span><br><span class="line">        <span class="keyword">if</span>(num.charAt(i) == <span class="string">'0'</span> &amp;&amp; j &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        BigInteger x1 = <span class="keyword">new</span> BigInteger(num.substring(<span class="number">0</span>, i));</span><br><span class="line">        BigInteger x2 = <span class="keyword">new</span> BigInteger(num.substring(i, i+j));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不断的跟剩下的字符串比较</span></span><br><span class="line">        <span class="comment">//剩下的字符串为substring(i+j, num.length)</span></span><br><span class="line">        <span class="comment">//下一次剩下的字符串为i+j + sum.length()</span></span><br><span class="line">        <span class="comment">//x1+x2</span></span><br><span class="line">        String sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = i+j; start &lt; num.length(); start += sum.length())&#123;</span><br><span class="line">            <span class="comment">//两个数之和是下一次迭代的第二个数</span></span><br><span class="line">            x2 = x1.add(x2);</span><br><span class="line">            x1 = x2.subtract(x1);</span><br><span class="line">            <span class="comment">//将和转化为字符串，然后跟剩下的字符串比较，</span></span><br><span class="line">            sum = x2.toString();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//只要和是剩下字符串的前缀，就能继续往下比较，否则直接返回false</span></span><br><span class="line">            <span class="comment">//剩下的字符串为num.substring(start);</span></span><br><span class="line">            <span class="comment">//判断和是否是剩下字符串的前缀可以用startsWith(sum)</span></span><br><span class="line">            <span class="comment">//num.substring(start).startsWith(sum)等价于num.startsWith(sum, start);</span></span><br><span class="line">            <span class="keyword">if</span>(!num.substring(start).startsWith(sum)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Additive number is a string whose digits can form additive sequence.</p>
<p>A valid additive sequence should conta]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Implement Trie(Prefix Tree)]]></title>
    <link href="http://blog.noobsky.com/2016/07/07/LeetCode-Implement-Trie-Prefix-Tree/"/>
    <id>http://blog.noobsky.com/2016/07/07/LeetCode-Implement-Trie-Prefix-Tree/</id>
    <published>2016-07-07T07:52:59.000Z</published>
    <updated>2016-07-07T08:43:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement a trie with insert, search, and startsWith methods.</p>
<p><strong>Note:</strong><br>You may assume that all inputs are consist of lowercase letters a-z.</p>
<h2 id="代码">代码</h2><p>实现前缀树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示该TrieNode的节点是否代表是一个word的结束</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">    <span class="comment">// 本题假设输入只包含a-z的26个小写字母</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ws初始指向根节点</span></span><br><span class="line">        TrieNode ws = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="comment">//使用ch-'a'来计算children的位置</span></span><br><span class="line">            <span class="comment">//children的下标与它代表的字符是一一对应的</span></span><br><span class="line">            <span class="keyword">if</span>(ws.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                ws.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ws指向children节点，进入下一次循环</span></span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个节点代表一个word的结束</span></span><br><span class="line">        ws.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode ws = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ws.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ws.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode ws = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ws.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里跟search不同，只要prefix的每个字符在Trie树上出现，就是true</span></span><br><span class="line">        <span class="comment">//而search要求还要是一个word的结束才代表是一个word否则是一个prefix</span></span><br><span class="line">        <span class="comment">//其实search和startsWith函数代码非常相似，可以进行进一步的封装，减少冗余</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Trie trie = new Trie();</span></span><br><span class="line"><span class="comment">// trie.insert("somestring");</span></span><br><span class="line"><span class="comment">// trie.search("key");</span></span><br></pre></td></tr></table></figure>
<p>搜索时间复杂度为O(m)，m为搜索字符串的长度，空间复杂度为O(1)。代码还可以进一步封装一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示该TrieNode的节点是否代表是一个word的结束</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">    <span class="comment">// 本题假设输入只包含a-z的26个小写字母</span></span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ws初始指向根节点</span></span><br><span class="line">        TrieNode ws = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="comment">//使用ch-'a'来计算children的位置</span></span><br><span class="line">            <span class="comment">//children的下标与它代表的字符是一一对应的</span></span><br><span class="line">            <span class="keyword">if</span>(ws.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                ws.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ws指向children节点，进入下一次循环</span></span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个节点代表一个word的结束</span></span><br><span class="line">        ws.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TrieNode ws = root;</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; word.length(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     char ch = word.charAt(i);</span></span><br><span class="line">        <span class="comment">//     if(ws.children[ch - 'a'] == null) return false;</span></span><br><span class="line">        <span class="comment">//     ws = ws.children[ch - 'a'];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return ws.isWord;</span></span><br><span class="line">        TrieNode ws = searchHelper(word);</span><br><span class="line">        <span class="keyword">return</span> ws != <span class="keyword">null</span> &amp;&amp; ws.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TrieNode ws = root;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; prefix.length(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     char ch = prefix.charAt(i);</span></span><br><span class="line">        <span class="comment">//     if(ws.children[ch - 'a'] == null) return false;</span></span><br><span class="line">        <span class="comment">//     ws = ws.children[ch - 'a'];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// //这里跟search不同，只要prefix的每个字符在Trie树上出现，就是true</span></span><br><span class="line">        <span class="comment">// //而search要求还要是一个word的结束才代表是一个word否则是一个prefix</span></span><br><span class="line">        <span class="comment">// //其实search和startsWith函数代码非常相似，可以进行进一步的封装，减少冗余</span></span><br><span class="line">        <span class="comment">// return true;</span></span><br><span class="line">        <span class="keyword">return</span> searchHelper(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">searchHelper</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        TrieNode ws = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length() &amp;&amp; ws != <span class="keyword">null</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = key.charAt(i);</span><br><span class="line">            ws = ws.children[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ws;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Trie trie = new Trie();</span></span><br><span class="line"><span class="comment">// trie.insert("somestring");</span></span><br><span class="line"><span class="comment">// trie.search("key");</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement a trie with insert, search, and startsWith methods.</p>
<p><strong>Note:</strong><br>You may assume that]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Permutation Sequence]]></title>
    <link href="http://blog.noobsky.com/2016/07/07/LeetCode-Permutation-Sequence/"/>
    <id>http://blog.noobsky.com/2016/07/07/LeetCode-Permutation-Sequence/</id>
    <published>2016-07-07T04:47:43.000Z</published>
    <updated>2016-07-07T05:20:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for n = 3):</p>
<ol>
<li>“123”</li>
<li>“132”</li>
<li>“213”</li>
<li>“231”</li>
<li>“312”</li>
<li>“321”</li>
</ol>
<p>Given n and k, return the kth permutation sequence.</p>
<p><strong>Note:</strong> Given n will be between 1 and 9 inclusive.</p>
<h2 id="代码">代码</h2><p>下面用例子说明一下算法的思想：</p>
<p>n = 4, 排列元素为{1,2,3,4},总共有4!=24种排列，分别为<br>1 + permutation(2,3,4)：6种排列<br>2 + permutation(1,3,4)：6种排列<br>3 + permutation(1,2,4)：6种排列<br>4 + permutation(1,2,3)：6种排列<br>比如要找第14个排列，那么k从0开始的话k=13，为了确定一个元素的下标，我们可以用k除以剩下元素全排列的数量，这里{1，2，3，4}就是k/(n-1)!=13/6=2，也就是说第一个元素的下标为2，即元素3。同理我们利用同样的方法找到剩下的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; num = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) num.add(i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] fact = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//求n!存到fact[n]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) fact[i] = fact[i-<span class="number">1</span>] * i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换为从0开始</span></span><br><span class="line">        k = k -<span class="number">1</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//计算元素index</span></span><br><span class="line">            <span class="keyword">int</span> index = k / fact[i-<span class="number">1</span>];</span><br><span class="line">            k = k % fact[i-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//理论上get操作时间复杂度为O(n)</span></span><br><span class="line">            sb.append(num.get(index));</span><br><span class="line">            <span class="comment">//Linkedlist的remove为O(1)</span></span><br><span class="line">            num.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutat]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Next Permutation]]></title>
    <link href="http://blog.noobsky.com/2016/07/07/LeetCode-Next-Permutation/"/>
    <id>http://blog.noobsky.com/2016/07/07/LeetCode-Next-Permutation/</id>
    <published>2016-07-07T01:16:29.000Z</published>
    <updated>2016-07-07T02:37:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h2 id="代码">代码</h2><p>算法如下：</p>
<ul>
<li>从后往前，找到第一个nums[i-1] &lt; nums[i]。也就是说nums[i]到nums[n-1]是单调递减序列。</li>
<li>从nums[n-1]到num[i]找到第一个比num[i-1]大的数，也就是说在num[i]到num[n-1]中找到比num[i-1]大的数中最小的一个数。</li>
<li>交互这两个数，并且把num[i]到nums[n-1]从小到大排序。(其实此时后面这部分仍然是逆序的，reverse一下即可)</li>
</ul>
<p>简单说一下背后的原理，因为num[i]到num[n-1]是逆序，也就是说num[i]到nums[n-1]已经从完全的顺序（第一个字典序）排列到了完全逆序（最后一个字典序），已经没有下一个字典序了。那么nums的下一个字典序是什么？答案就是从num[i]s到nums[n-1]逆序中找到一个最小的比num[i-1]大的数与nums[i-1]交互，然后将nums[i]到nums[n-1]从小到大排序即nums[i]到nums[n-1]的排列是第一个字典序。代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(;i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// //没找到，说明完全逆序，完全逆序比如4-3-2-1的下一个应该是1-2-3-4</span></span><br><span class="line">        <span class="comment">// if(i == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     reverse(nums, 0, nums.length - 1);</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//       //i!=0 -&gt;i &gt;= 1</span></span><br><span class="line">        <span class="comment">//      //存在，否则是完全逆序，已经是最后一个permutation</span></span><br><span class="line">        <span class="comment">//     for(int j = nums.length - 1; j &gt;= i; j--)&#123;</span></span><br><span class="line">        <span class="comment">//         if(nums[j] &gt; nums[i-1]) &#123;</span></span><br><span class="line">        <span class="comment">//             swap(nums, i-1, j);</span></span><br><span class="line">        <span class="comment">//             break;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     reverse(nums, i, nums.length-1);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//其实上面只写一个reverse就可以了</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt;= i; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, i-<span class="number">1</span>, j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverse(nums, i, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            swap(nums, start, end);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of number]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Minimum Height Trees]]></title>
    <link href="http://blog.noobsky.com/2016/07/06/LeetCode-Minimum-Height-Trees/"/>
    <id>http://blog.noobsky.com/2016/07/06/LeetCode-Minimum-Height-Trees/</id>
    <published>2016-07-06T14:28:37.000Z</published>
    <updated>2016-07-06T15:47:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>
<p><em>Format</em><br>The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).</p>
<p>You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<p><strong>Example 1:</strong></p>
<p>Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span></span><br><span class="line">  |</span><br><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>return [1]</p>
<p><strong>Example 2:</strong></p>
<p>Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"> \ | /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line">   |</span><br><span class="line">   <span class="number">4</span></span><br><span class="line">   |</span><br><span class="line">   <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>return [3, 4]</p>
<p><strong>Hint:</strong></p>
<pre><code><span class="number">1.</span>How many MHTs can <span class="operator">a</span> graph have <span class="keyword">at</span> most?
</code></pre><p><strong>Note:</strong></p>
<p>(1) According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”</p>
<p>(2) The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>
<h2 id="代码">代码</h2><p>我们先考虑特例，即path graph，<a href="https://discuss.leetcode.com/topic/30572/share-some-thoughts" target="_blank" rel="external">path graph</a>详见维基百科。举个简单例子：1-2-3-4-5-6就是path graph，很明显path graph的minimum height trees的根节点为中间节点，如果节点总数为奇数，则为正中间节点，如果节点总数为偶数，则为中间两个节点。从这，我们可以得到的想法就是不断的删去叶子节点，直到剩下一个或者两个节点。<br><img src="http://s32.postimg.org/3vi3z4dad/1463645059503_1214297289.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一个节点0</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> Collections.singletonList(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里用集合主要不是为了去重，而是为了后面删除邻接节点能在O(1)时间内完成</span></span><br><span class="line">        List&lt;Set&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n; i++) adj.add(<span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用edges构造邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">            adj.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">            adj.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; leaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//只有一个邻接节点就为叶子</span></span><br><span class="line">            <span class="keyword">if</span>(adj.get(i).size() == <span class="number">1</span>)&#123;</span><br><span class="line">                leaves.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            n -= leaves.size();</span><br><span class="line">            List&lt;Integer&gt; newLeaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//删除叶子节点，即将叶子节点从其邻接节点的邻接表中移除</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> leave: leaves)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//其实叶子节点只有一个邻接节点</span></span><br><span class="line">                <span class="comment">//叶子节点的邻接节点</span></span><br><span class="line">                <span class="keyword">int</span> j = adj.get(leave).iterator().next();</span><br><span class="line">                <span class="comment">//集合的删除操作为O(1)</span></span><br><span class="line">                adj.get(j).remove(leave);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果删除邻接节点后成为叶子节点，加入叶子节点list中</span></span><br><span class="line">                <span class="keyword">if</span>(adj.get(j).size() == <span class="number">1</span>) newLeaves.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">            leaves = newLeaves;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leaves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想每次新new一个newLeaves，可以使用队列，新的叶子节点加入队列即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//只有一个节点0</span></span><br><span class="line">      <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> Collections.singletonList(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//这里用集合主要不是为了去重，而是为了后面删除邻接节点能在O(1)时间内完成</span></span><br><span class="line">      List&lt;Set&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n; i++) adj.add(<span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//利用edges构造邻接矩阵</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">          adj.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">          adj.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回类型为List，所以不能用Queue</span></span><br><span class="line">      LinkedList&lt;Integer&gt; leaves = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">          <span class="comment">//只有一个邻接节点就为叶子</span></span><br><span class="line">          <span class="keyword">if</span>(adj.get(i).size() == <span class="number">1</span>)&#123;</span><br><span class="line">              leaves.offer(i);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(n &gt; <span class="number">2</span>)&#123;</span><br><span class="line">          <span class="keyword">int</span> numLeaf = leaves.size();</span><br><span class="line">          n -= numLeaf;</span><br><span class="line">          <span class="comment">//List&lt;Integer&gt; newLeaves = new ArrayList&lt;&gt;();</span></span><br><span class="line">          <span class="comment">//删除叶子节点，即将叶子节点从其邻接节点的邻接表中移除</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>; k &lt; numLeaf; k++)&#123;</span><br><span class="line">              <span class="keyword">int</span> leave = leaves.poll();</span><br><span class="line">              <span class="comment">//其实叶子节点只有一个邻接节点</span></span><br><span class="line">              <span class="comment">//叶子节点的邻接节点</span></span><br><span class="line">              <span class="keyword">int</span> j = adj.get(leave).iterator().next();</span><br><span class="line">              <span class="comment">//集合的删除操作为O(1)</span></span><br><span class="line">              adj.get(j).remove(leave);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//如果删除邻接节点后成为叶子节点，加入叶子节点list中</span></span><br><span class="line">              <span class="keyword">if</span>(adj.get(j).size() == <span class="number">1</span>) leaves.offer(j);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//leaves = newLeaves;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> leaves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a r]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Course Schedule I II]]></title>
    <link href="http://blog.noobsky.com/2016/07/06/LeetCode-Course-Schedule-I-II/"/>
    <id>http://blog.noobsky.com/2016/07/06/LeetCode-Course-Schedule-I-II/</id>
    <published>2016-07-06T08:43:27.000Z</published>
    <updated>2016-07-06T12:35:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Course_Schedule_I">Course Schedule I</h2><h3 id="题目描述">题目描述</h3><p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>For example:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>, <span class="string">[[1,0]]</span></span><br></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<p><strong>Note:</strong><br>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank" rel="external">how a graph is represented</a>.</p>
<p><strong>Hints:</strong><br>  1.This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.<br>  2.Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.<br>  3.Topological sort could also be done via BFS.</p>
<h3 id="代码">代码</h3><p>这道题其本质是拓扑排序，拓扑排序详见维基百科<a href="https://en.wikipedia.org/wiki/Topological_sorting" target="_blank" rel="external">Topological sorting</a>和博文<a href="http://blog.csdn.net/dm_vincent/article/details/7714519" target="_blank" rel="external">拓扑排序的原理及其实现</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//题目中图的表示是边的列表，我们需要转换为邻接矩阵或者邻接表</span></span><br><span class="line">        <span class="comment">//这里使用邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses][numCourses];<span class="comment">// i-&gt;j</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录每个节点的入度</span></span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; prerequisites.length; i++)&#123;</span><br><span class="line">            <span class="comment">//边的起始节点</span></span><br><span class="line">            <span class="keyword">int</span> start = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//终止节点</span></span><br><span class="line">            <span class="keyword">int</span> end = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//防止重复边出现</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[start][end] == <span class="number">0</span>)</span><br><span class="line">                indegree[end]++;</span><br><span class="line">            matrix[start][end] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将所有入度为0的节点加入队列中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计输出顶点的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">                <span class="comment">//如果course和i相邻接，i节点的入度减1，入度变为0要加入队列中</span></span><br><span class="line">                <span class="keyword">if</span>(matrix[course][i] != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span>(--indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.offer(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是以上使用邻接矩阵内存消耗太大，其实邻接矩阵是不必要使用的，改进后的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//不用使用邻接矩阵</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//统计每个节点的入度</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">          indegree[pair[<span class="number">0</span>]]++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">          <span class="comment">//不使用额外的变量count来统计也是可以的</span></span><br><span class="line">          numCourses--;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">              <span class="keyword">if</span>(pair[<span class="number">1</span>] == course)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(--indegree[pair[<span class="number">0</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                      queue.offer(pair[<span class="number">0</span>]);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的算法时间复杂度为O(V*E)，但是节省了邻接表或者邻接矩阵的内存空间。也可以使用邻接表，时间复杂度可以降为O(V+E)，但是空间复杂度会上升，空间复杂度比邻接矩阵低，代码如下，非本人所写，风格不一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        ArrayList[] graph = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">        <span class="keyword">int</span>[] degree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Queue queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">            degree[prerequisites[i][<span class="number">1</span>]]++;</span><br><span class="line">            graph[prerequisites[i][<span class="number">0</span>]].add(prerequisites[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;degree.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> course = (<span class="keyword">int</span>)queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph[course].size();i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> pointer = (<span class="keyword">int</span>)graph[course].get(i);</span><br><span class="line">                degree[pointer]--;</span><br><span class="line">                <span class="keyword">if</span>(degree[pointer] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(pointer);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == numCourses)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS也放上代码，以后有时间再研究吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">            ArrayList[] graph = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)</span><br><span class="line">                graph[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">                graph[prerequisites[i][<span class="number">1</span>]].add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(graph,visited,i))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(ArrayList[] graph, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> course)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[course])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                visited[course] = <span class="keyword">true</span>;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph[course].size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(graph,visited,(<span class="keyword">int</span>)graph[course].get(i)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[course] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Course_Schedule_II">Course Schedule II</h2><h3 id="题目描述-1">题目描述</h3><p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>For example:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>, <span class="string">[[1,0]]</span></span><br></pre></td></tr></table></figure></p>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure></p>
<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p>
<p><strong>Note:</strong><br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</p>
<h3 id="代码-1">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//统计每个节点的入度</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">          indegree[pair[<span class="number">0</span>]]++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">          res[count++] = course;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">              <span class="keyword">if</span>(pair[<span class="number">1</span>] == course)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(--indegree[pair[<span class="number">0</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                      queue.offer(pair[<span class="number">0</span>]);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(numCourses == count)&#123;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Course_Schedule_I">Course Schedule I</h2><h3 id="题目描述">题目描述</h3><p>There are a total of n courses you have to take, labeled from 0 t]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Zigzag Level/Level Order Traversal I II]]></title>
    <link href="http://blog.noobsky.com/2016/07/06/LeetCode-Binary-Tree-Zigzag-Level-Level-Order-Traversal-I-II/"/>
    <id>http://blog.noobsky.com/2016/07/06/LeetCode-Binary-Tree-Zigzag-Level-Level-Order-Traversal-I-II/</id>
    <published>2016-07-06T07:41:31.000Z</published>
    <updated>2016-07-06T07:49:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Binary_Tree_Level_Order_Traversal_I">Binary Tree Level Order Traversal I</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its level order traversal as:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">    <span class="comment">//对一般的分层遍历稍加改进，就能实现分行打印每一层</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">        <span class="comment">//先不急着出队列，记录队列的大小，相当于每层元素的个数</span></span><br><span class="line">        int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//一般的分层遍历都是每次循环从队列头中取出一个元素然后将其左右节点分别入队列，</span></span><br><span class="line">        <span class="comment">//改进后就是每次从队列头中取出levelNumber个元素,</span></span><br><span class="line">        <span class="comment">//然后将每个元素的左右节点分别入队列。</span></span><br><span class="line">        f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">            <span class="comment">//使用peek可以节省一个局部变量</span></span><br><span class="line">            <span class="comment">// if(queue.peek().left != null) queue.add(queue.peek().left);</span></span><br><span class="line">            <span class="comment">// if(queue.peek().right != null) queue.add(queue.peek().right);</span></span><br><span class="line">            <span class="comment">// subList.add(queue.poll().val);</span></span><br><span class="line">            <span class="comment">//使用局部变量,测试发现速度能稍微快一点</span></span><br><span class="line">            TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">            subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">            <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>left);</span><br><span class="line">            <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>right);</span><br><span class="line">        &#125;</span><br><span class="line">        res<span class="built_in">.</span>add(subList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们也可以使用DFS的思想，代码如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(level &gt;= res<span class="built_in">.</span>size())&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res<span class="built_in">.</span>get(level)<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level+<span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Binary_Tree_Level_Order_Traversal_II">Binary Tree Level Order Traversal II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>return its bottom-up level order traversal as:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码-1">代码</h3><p>使用BFS思想:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//使用LinkedList，不使用ArrayList，原因见后面</span></span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//将root加入队列中</span></span><br><span class="line">        <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">        <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">            int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">            LinkedList&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> LinkedList();</span><br><span class="line">            f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">                subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>left);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//总是在0索引的位置插入每一层的遍历结果，最后遍历res的时候结果就是反过来的，即从下往上分层遍历</span></span><br><span class="line">            <span class="comment">//这里之所以使用LinkedList的原因是ArrayList的底层是数组，插入元素时需要移动大量的元素，效率低</span></span><br><span class="line">            <span class="comment">//而LinkedList的底层是链表，插入操作非常高效</span></span><br><span class="line">            res<span class="built_in">.</span>add(<span class="number">0</span>,subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用DFS思想：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrderBottom(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res<span class="built_in">.</span>size() &lt;= level)&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="number">0</span>, <span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res<span class="built_in">.</span>get(res<span class="built_in">.</span>size()-<span class="number">1</span><span class="attribute">-level</span>)<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level + <span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_Zigzag_Level_Order_Traversal">Binary Tree Zigzag Level Order Traversal</h2><h3 id="题目描述-2">题目描述</h3><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its zigzag level order traversal as:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码-2">代码</h3><p>DFS:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	<span class="comment">//DFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; zigzagLevelOrder1(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res<span class="built_in">.</span>size() &lt;= level)&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; subList = res<span class="built_in">.</span>get(level);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//偶数层，从左往右</span></span><br><span class="line">        <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">0</span>) subList<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        <span class="comment">//奇数层，从右往左</span></span><br><span class="line">        <span class="keyword">else</span> subList<span class="built_in">.</span>add(<span class="number">0</span>, root<span class="built_in">.</span>val);</span><br><span class="line">        </span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level + <span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BFS:</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution&#123;</span><br><span class="line">	<span class="comment">//BFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; zigzagLevelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">        <span class="comment">//从左往右</span></span><br><span class="line">        <span class="built_in">boolean</span> isLeftToRight = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">            <span class="comment">//每层的节点个数</span></span><br><span class="line">            int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(isLeftToRight)&#123;</span><br><span class="line">                    subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    subList<span class="built_in">.</span>add(<span class="number">0</span>, node<span class="built_in">.</span>val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>left);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下一层跟该层的顺序相反，取非</span></span><br><span class="line">            isLeftToRight = <span class="subst">!</span>isLeftToRight;</span><br><span class="line">            res<span class="built_in">.</span>add(subList);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Binary_Tree_Level_Order_Traversal_I">Binary Tree Level Order Traversal I</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree, return t]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Largest Divisible Subset]]></title>
    <link href="http://blog.noobsky.com/2016/07/06/LeetCode-Largest-Divisible-Subset/"/>
    <id>http://blog.noobsky.com/2016/07/06/LeetCode-Largest-Divisible-Subset/</id>
    <published>2016-07-06T04:43:52.000Z</published>
    <updated>2016-07-06T05:17:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p>
<p>If there are multiple solutions, return any subset is fine.</p>
<p><strong> Example 1: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">Result: [<span class="number">1</span>,<span class="number">2</span>] (of course, [<span class="number">1</span>,<span class="number">3</span>] will also be ok)</span><br></pre></td></tr></table></figure>
<p><strong> Example 2: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">Result: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>这道题的DP思想跟LIS（最长递增子序列）的思想是一样的，详见<a href="http://noobsky.com/2016/06/07/LeetCode-Longest-Increasing-Subsequence/" target="_blank" rel="external">Longest Increasing Subsequence</a>，只是LIS只要求长度，这里要给出序列。<br>dp[n]表示最大元素为nums[n]的largest divisible subset的长度，则：</p>
<p>dp[i] = max{dp[j] + 1 if dp[i] % dp[j] == 0}, 0&lt;= j &lt; i </p>
<p>有了以上状态方程，我们可以写出O(n<sup>2</sup>)的算法。</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; largestDivisibleSubset(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需要排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//dp数组dp[i]表示最大元素为num[i]的longest divisible subset的长度</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//为了得到序列我们需要记录每个nums[i]的前驱元素，所以我们prev数组来记录nums[i]前驱元素的下标</span></span><br><span class="line">        <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录largest divisible subset的最大长度</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最大长度最大元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//如果j = i开始，不用写dp[i] = 1;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span> &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//记录前驱元素的下标</span></span><br><span class="line">                    prev[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//dp[i]大于maxLen则更新最大长度和下标</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxLen)&#123;</span><br><span class="line">                maxLen = dp[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据prev数组找出largest divisible subset的所以元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++)&#123;</span><br><span class="line">            <span class="comment">//res.add(nums[maxIndex]);//这样添加其实是元素的逆序，但题目中也没有要求是顺序的</span></span><br><span class="line">            <span class="comment">//如果要求需要按顺序，当然这里顺序也不是原始数组的顺序，是排序后的顺序</span></span><br><span class="line">            res.add(<span class="number">0</span>, nums[maxIndex]);</span><br><span class="line">            maxIndex = prev[maxIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in th]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Game of Life]]></title>
    <link href="http://blog.noobsky.com/2016/07/06/LeetCode-Game-of-Life/"/>
    <id>http://blog.noobsky.com/2016/07/06/LeetCode-Game-of-Life/</id>
    <published>2016-07-06T01:05:20.000Z</published>
    <updated>2016-07-06T02:05:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>According to the <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="external">Wikipedia’s article</a>: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p>
<p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<pre><code><span class="number">1.</span> Any live cell <span class="operator">with</span> fewer than <span class="constant">two</span> live neighbors dies, <span class="keyword">as</span> <span class="keyword">if</span> caused <span class="keyword">by</span> under-population.
<span class="number">2.</span> Any live cell <span class="operator">with</span> <span class="constant">two</span> <span class="operator">or</span> <span class="constant">three</span> live neighbors lives <span class="command"><span class="keyword">on</span> <span class="title">to</span> <span class="title">the</span> <span class="title">next</span> <span class="title">generation</span>.</span>
<span class="number">3.</span> Any live cell <span class="operator">with</span> more than <span class="constant">three</span> live neighbors dies, <span class="keyword">as</span> <span class="keyword">if</span> <span class="keyword">by</span> over-population..
<span class="number">4.</span> Any dead cell <span class="operator">with</span> exactly <span class="constant">three</span> live neighbors becomes <span class="operator">a</span> live cell, <span class="keyword">as</span> <span class="keyword">if</span> <span class="keyword">by</span> reproduction.
</code></pre><p>Write a function to compute the next state (after one update) of the board given its current state.</p>
<p><strong> Follow up: </strong> </p>
<pre><code><span class="number">1.</span> Could you solve <span class="keyword">it</span> <span class="operator">in</span>-place? Remember that <span class="operator">the</span> board needs <span class="built_in">to</span> be updated <span class="keyword">at</span> <span class="operator">the</span> same <span class="built_in">time</span>: You cannot update some cells <span class="keyword">first</span> <span class="operator">and</span> <span class="keyword">then</span> use their updated values <span class="built_in">to</span> update other cells.
<span class="number">2.</span> In this question, we represent <span class="operator">the</span> board <span class="keyword">using</span> <span class="operator">a</span> <span class="number">2</span>D array. In principle, <span class="operator">the</span> board is infinite, which would cause problems when <span class="operator">the</span> active area encroaches <span class="operator">the</span> border <span class="operator">of</span> <span class="operator">the</span> array. How would you address these problems?
</code></pre><h2 id="代码">代码</h2><p>每个细胞有一个初始状态活(1)或死(0)，每个细胞与周围八个细胞(水平、竖直、对角线)相互作用，规则如下：</p>
<ul>
<li>如果活细胞周围八个位置的活细胞少于两个，则该位置的活细胞会死亡 </li>
<li>如果活细胞周围八个位置有两个或者三个活细胞，则该位置的活细胞仍然存活</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置的活细胞死亡</li>
<li>如果死细胞周围八个位置刚好有三个活细胞，则该位置的死细胞复活</li>
</ul>
<p>为了不使用额外的内存(in place)，我们使用两比特位来表示状态</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">2nd</span> bit, <span class="number">1</span>st bit] = <span class="list">[<span class="keyword">next</span> state, current state]</span><br><span class="line"></span><br><span class="line">- <span class="number">00</span>  dead <span class="list">(<span class="keyword">next</span>)</span> &lt;- dead <span class="list">(<span class="keyword">current</span>)</span></span><br><span class="line">- <span class="number">01</span>  dead <span class="list">(<span class="keyword">next</span>)</span> &lt;- live <span class="list">(<span class="keyword">current</span>)</span>  </span><br><span class="line">- <span class="number">10</span>  live <span class="list">(<span class="keyword">next</span>)</span> &lt;- dead <span class="list">(<span class="keyword">current</span>)</span>  </span><br><span class="line">- <span class="number">11</span>  live <span class="list">(<span class="keyword">next</span>)</span> &lt;- live <span class="list">(<span class="keyword">current</span>)</span></span></span></span><br></pre></td></tr></table></figure>
<p>我们用第一个比特位(从右往左)表示当前细胞的状态，1（二进制01，活）、0(二进制00，死)，第二个比特位来表示细胞下一代的状态(00/01(死)、10/11(活))。</p>
<ul>
<li>初始时，任何细胞的状态为00或01</li>
<li>我们统计当前细胞周围的活细胞数量(第一个比特位)来决定细胞的下一状态(设置第二个比特位)，然后右移一位，第二比特位变成第一比特位就得到细胞的下一状态</li>
<li>因为第二个比特位默认为0(因为只有0和1)也就是代表细胞死，所以我们不需要考虑细胞的下一状态为死的转换(00-&gt;00、01-&gt;01)</li>
<li>最后我们通过右移一位来删除细胞当前的状态进入下一状态(即第二比特位成为第一比特位)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == null || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> lives = liveNeighbors(board, row, col, i, j);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//第二比特位初始就为0，所以我们只需要考虑第二比特位会变成1的情况</span></span><br><span class="line">                <span class="comment">//有两种情况：当前存活且周围活细胞数是2或3，则仍然存活,01-&gt;11</span></span><br><span class="line">                <span class="comment">//当前细胞死亡，周围刚好有三个活细胞，复活00-&gt;10</span></span><br><span class="line">                <span class="comment">//我们只需要将第二比特位置为1，不改变第一比特位的值，不会干扰其他细胞的判断</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; lives &gt;= <span class="number">2</span> &amp;&amp; lives &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="number">3</span>;<span class="comment">//将第二比特位置为1，即11，就是3</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">0</span> &amp;&amp; lives == <span class="number">3</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//全部细胞转化后，右移一位，更新细胞的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                board[i][j] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计细胞board[i][j]周围细胞的存活数量</span></span><br><span class="line">    <span class="comment">//row、col可以传进来也可以不传</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">liveNeighbors</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lives = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历board[i][j]为中心的小九宫格即可</span></span><br><span class="line">        <span class="comment">//用Math.min/max来处理边界还是很tricky的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = Math.max(i - <span class="number">1</span>, <span class="number">0</span>); x &lt;= Math.min(i+<span class="number">1</span>, row-<span class="number">1</span>); x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = Math.max(j - <span class="number">1</span>, <span class="number">0</span>); y &lt;= Math.min(j+<span class="number">1</span>, col-<span class="number">1</span>); y++)&#123;</span><br><span class="line">                <span class="comment">//board[x][y]为1存活数加1，&amp;1可以达到这个目的</span></span><br><span class="line">                lives += board[x][y] &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//因为九宫格也统计了自身board[i][j]的状态，需要减掉</span></span><br><span class="line">        lives -= board[i][j] &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> lives;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>According to the <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="external">Wi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Container With Most Water]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Container-With-Most-Water/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Container-With-Most-Water/</id>
    <published>2016-07-05T15:14:01.000Z</published>
    <updated>2016-07-05T15:27:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container.</p>
<h2 id="代码">代码</h2><p><img src="http://7xonwi.com1.z0.glb.clouddn.com/containswater.png" alt=""></p>
<p>如图所示，容纳水的多少由（左右两端更小的高度）*两端x坐标值之差决定</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> int maxArea(int[] height) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(height == null || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = height.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最大面积</span></span><br><span class="line">        int maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            <span class="comment">//面积由更矮的一条线决定</span></span><br><span class="line">            maxArea = <span class="type">Math</span>.<span class="built_in">max</span>(maxArea, <span class="type">Math</span>.<span class="built_in">min</span>(height[<span class="keyword">left</span>], height[<span class="keyword">right</span>]) * (<span class="keyword">right</span> - <span class="keyword">left</span>));</span><br><span class="line">            <span class="comment">//因为左边的高度小于右边的高度，移动右边那根线是没有作用的，移动右边的线形成的面积都是小于等于当前的面积</span></span><br><span class="line">            <span class="comment">//假设移动右边即right--，如果移动后height[new right] &gt; height[left]，那么还是左边线的高度更低，</span></span><br><span class="line">            <span class="comment">//面积等于当前面积；如果移动后height[new right] &lt; height[left]，那么形成的面积更小，所以移动right是没有帮助的</span></span><br><span class="line">            <span class="comment">//只能移动left</span></span><br><span class="line">            <span class="keyword">if</span>(height[<span class="keyword">left</span>] &lt; height[<span class="keyword">right</span>])&#123;</span><br><span class="line">                <span class="keyword">left</span>++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//同理右边高度更小的话，移动左边是没有作用的，只能移动右边</span></span><br><span class="line">                <span class="keyword">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种写法更繁琐但对于有些人来说可能更直观：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> int maxArea(int[] height)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == null || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = height.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        int maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">            int h = <span class="type">Math</span>.<span class="built_in">min</span>(height[<span class="keyword">left</span>], height[<span class="keyword">right</span>]);</span><br><span class="line">            </span><br><span class="line">            maxArea = <span class="type">Math</span>.<span class="built_in">max</span>(maxArea, h * (<span class="keyword">right</span> - <span class="keyword">left</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//往右寻找高度更高的线</span></span><br><span class="line">            <span class="keyword">while</span>(height[<span class="keyword">left</span>] &lt;= h &amp;&amp; <span class="keyword">left</span> &lt; <span class="keyword">right</span>) <span class="keyword">left</span>++;</span><br><span class="line">            <span class="comment">//往左寻找高度比h更高的线，形成的面积才有可能大于当前面积</span></span><br><span class="line">            <span class="keyword">while</span>(height[<span class="keyword">right</span>] &lt;= h &amp;&amp; <span class="keyword">left</span> &lt; <span class="keyword">right</span>) <span class="keyword">right</span>--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Valid Perfect Square]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Valid-Perfect-Square/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Valid-Perfect-Square/</id>
    <published>2016-07-05T14:06:30.000Z</published>
    <updated>2016-07-05T14:08:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>
<p>Note: Do not use any built-in library function such as sqrt.</p>
<p><strong> Example 1: </strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">16</span></span><br><span class="line"><span class="attribute">Returns</span>: <span class="string">True</span></span><br></pre></td></tr></table></figure>
<p><strong> Example 2: </strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">14</span></span><br><span class="line"><span class="attribute">Returns</span>: <span class="string">False</span></span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//这里可以直接用数学规律</span></span><br><span class="line">    <span class="comment">//1 = 1</span></span><br><span class="line">    <span class="comment">//4 = 1 + 3</span></span><br><span class="line">    <span class="comment">//9 = 1 + 3 + 5</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//但是这里我们需要注意的是我们不能用加法来做</span></span><br><span class="line">    <span class="comment">//因为加法存在溢出的问题，我们可以逆向考虑，</span></span><br><span class="line">    <span class="comment">//用减法，减1、3...，看看最后num是否会为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isPerfectSquare1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            num -= i;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果我们不知道这个规律，之前实现过sqrt，同理这里也可以使用二分搜索</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//除法是下取整的，mid取值偏小</span></span><br><span class="line">            <span class="comment">//取值偏小的mid的平方都大于num，那么平方根肯定小于mid，所以right = mid - 1</span></span><br><span class="line">            <span class="comment">//除法防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(mid &gt; num / mid)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//小于等于</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &lt; num / mid)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果这样写会造成死循环，比如5</span></span><br><span class="line">                <span class="comment">//if(num % mid == 0) return true;</span></span><br><span class="line">                <span class="keyword">return</span> num % mid == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>
<p>No]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Different Ways to Add Parentheses]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Different-Ways-to-Add-Parentheses/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Different-Ways-to-Add-Parentheses/</id>
    <published>2016-07-05T12:22:15.000Z</published>
    <updated>2016-07-05T12:28:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.</p>
<p><strong> Example 1 </strong></p>
<p>Input: “2-1-1”.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((<span class="number">2</span>-<span class="number">1</span>)-<span class="number">1</span>) = <span class="number">0</span></span><br><span class="line">(<span class="number">2</span>-(<span class="number">1</span>-<span class="number">1</span>)) = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Output: [0, 2]</p>
<p><strong> Example 2 </strong></p>
<p>Input: “2<em>3-4</em>5”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>*(<span class="number">3</span>-(<span class="number">4</span>*<span class="number">5</span>))) = -<span class="number">34</span></span><br><span class="line">((<span class="number">2</span>*<span class="number">3</span>)-(<span class="number">4</span>*<span class="number">5</span>)) = -<span class="number">14</span></span><br><span class="line">((<span class="number">2</span>*(<span class="number">3</span>-<span class="number">4</span>))*<span class="number">5</span>) = -<span class="number">10</span></span><br><span class="line">(<span class="number">2</span>*((<span class="number">3</span>-<span class="number">4</span>)*<span class="number">5</span>)) = -<span class="number">10</span></span><br><span class="line">(((<span class="number">2</span>*<span class="number">3</span>)-<span class="number">4</span>)*<span class="number">5</span>) = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>Output: [-34, -14, -10, -10, 10]</p>
<h2 id="代码">代码</h2><p>这道题跟<a href="http://noobsky.com/2016/05/31/LeetCode-Unique-Binary-Search-Trees/" target="_blank" rel="external">Unique Binary Search Trees II</a>思路类似，都是利用分治的思想，可对照理解</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; diffWaysToCompute(<span class="keyword">String</span> input) &#123;</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || input.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//结果集</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++)&#123;</span><br><span class="line">            <span class="built_in">char</span> ch = input.charAt(i);</span><br><span class="line">            <span class="comment">//字符ch为+、-、*，可以采用分治的方法将input在ch分为左右两部分，递归计算</span></span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'-'</span> || ch == <span class="string">'+'</span> || ch == <span class="string">'*'</span>)&#123;</span><br><span class="line">                List&lt;Integer&gt; leftList = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; rightList = diffWaysToCompute(input.substring(i+<span class="number">1</span>));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> left : leftList)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> right : rightList)&#123;</span><br><span class="line">                        <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'-'</span>: res.<span class="built_in">add</span>(left - right);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'+'</span>: res.<span class="built_in">add</span>(left + right);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'*'</span>: res.<span class="built_in">add</span>(left * right);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数字</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>() == <span class="number">0</span>) res.<span class="built_in">add</span>(Integer.valueOf(input));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a string of numbers and operators, return all possible results from computing all the different possible way]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Count Numbers with Unique Digits]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Count-Numbers-with-Unique-Digits/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Count-Numbers-with-Unique-Digits/</id>
    <published>2016-07-05T11:00:11.000Z</published>
    <updated>2016-07-05T11:37:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10<sup>n</sup>.</p>
<p>Example:<br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])</p>
<p><strong> Hint: </strong></p>
<ol>
<li>A direct way is to use the backtracking approach.</li>
<li>Backtracking should contains three states which are (the current number, number of steps to get that number and a bitmask which represent which number is marked as visited so far in the current number). Start with state (0,0,0) and count all valid number till we reach number of steps equals to 10n.</li>
<li>This problem can also be solved using a dynamic programming approach and some knowledge of combinatorics.</li>
<li>Let f(k) = count of numbers with unique digits with length equals k.</li>
<li>f(1) = 10, …, f(k) = 9 <em> 9 </em> 8 * … (9 - k + 2) [The first factor is 9 because a number cannot start with 0].</li>
</ol>
<h2 id="代码">代码</h2><p>给定一非负整数n，计算各位数都不同相同的数字x的个数，0 ≤ x &lt; 10<sup>n</sup></p>
<p>f(k)表示k位数各位数都不相同的数字的个数</p>
<p>f(1) = 10, (0,1,2,3,4,5,6,7,8,9)</p>
<p>f(2) = 9 * 9,第一位处0外都可以，有9种选择，第二位0可以但是不能是第一位的数字，也有9种选择</p>
<p>f(3) = 9 <em> 9 </em> 8 = f(2) * 8, 第三位有8种选择</p>
<p>…</p>
<p>f(10) = 9<em>9</em>8<em>7</em>6<em>…</em>1</p>
<p>f(11) = 0 = f(12) = f(13)</p>
<p>11位数以后肯定会出现重复，f(k) = 0 , k &gt;= 11</p>
<p>题目求0 ≤ x &lt; 10<sup>n</sup>区间满足条件的，所以总数为f(1)+f(2)+f(3)+…+f(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10以后的都没必要算了</span></span><br><span class="line">        n = Math.min(n, <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>, count = <span class="number">9</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            count = count * (<span class="number">9</span>-i+<span class="number">2</span>);</span><br><span class="line">            res += count;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> uniqueDigits = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> availableNumber = <span class="number">9</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用availableNumber &gt; 0来去掉那些多余的计算跟用Math.min(10,n);效果类似</span></span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">1</span> &amp;&amp; availableNumber &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            uniqueDigits = uniqueDigits * availableNumber;</span><br><span class="line">            res += uniqueDigits;</span><br><span class="line">            availableNumber--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10<sup>n</sup>.</p>
<p>E]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]ZigZag Conversion]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-ZigZag-Conversion/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-ZigZag-Conversion/</id>
    <published>2016-07-05T04:00:35.000Z</published>
    <updated>2016-07-05T08:16:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   <span class="keyword">H</span>   <span class="keyword">N</span></span><br><span class="line">A P <span class="keyword">L</span> S I I <span class="keyword">G</span></span><br><span class="line">Y   I   <span class="literal">R</span></span><br></pre></td></tr></table></figure>
<p>And then read line by line: “PAHNAPLSIIGYIR”<br>Write the code that will take a string and make this conversion given a number of rows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> text, <span class="keyword">int</span> nRows)</span></span>;</span><br></pre></td></tr></table></figure>
<p>convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.</p>
<h2 id="代码">代码</h2><p>这道题关键就是找出字符下标变化的规律</p>
<p>rows=2时，字符串下标变成zigzag的走法就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>rows=3时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>     <span class="number">4</span>     <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>     <span class="number">6</span>    <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>rows=4时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>      <span class="number">6</span>        <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>   <span class="number">5</span>  <span class="number">7</span>    <span class="number">11</span>  <span class="number">13</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">4</span>    <span class="number">8</span> <span class="number">10</span>     <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>      <span class="number">9</span>        <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>观察可知，我们第一行和最后一行相邻元素的下标相差为2*rows - 2，比如rows = 3时，第一行字符串下标为0、4、8，相邻元素相差2*rows - 2 = 4，可以验证其他也是符合的。接着我们来看除了第一行和最后一行的规律，其他行除了zigzag斜线上的字符，也是满足这个规律，比如1、3、5、7、9除了斜线上的3和7，1、5、9也是相差4，那么斜线上的字符下标跟前面一个字符相差多少？规律是相差2*rows-2 - 2*i（i是行的index），比如斜线上的3、7比前面的1、5都相差2*rows-2-2*i = 2，可以验证其他字符也是满足这个规律的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span> || numRows &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">            <span class="comment">//字符下标不能超过字符的长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.length(); j += step)&#123;</span><br><span class="line">                res.append(s.charAt(j));</span><br><span class="line">                <span class="comment">//如果不是第一行和最后一行，还要append斜线上字符</span></span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//斜线上的字符跟前一字符下标相差step-2i</span></span><br><span class="line">                    <span class="keyword">int</span> temp = j + step - <span class="number">2</span>*i;</span><br><span class="line">                    <span class="keyword">if</span>(temp &lt; s.length())&#123;</span><br><span class="line">                        res.append(s.charAt(temp));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种更直观更好理解的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="comment">//很好理解的一种写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span> || numRows &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//没一行都用一个StringBuilder存</span></span><br><span class="line">        StringBuilder[] sb = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) sb[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">            <span class="comment">//竖直方向遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numRows &amp;&amp; i &lt; len; j++)&#123;</span><br><span class="line">                sb[j].append(c[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//斜线方向遍历，总共有numRows-2个</span></span><br><span class="line">            <span class="comment">//从倒数第二行开始，到第二行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = numRows -<span class="number">2</span>; k &gt;=<span class="number">1</span> &amp;&amp; i &lt; len; k--)&#123;</span><br><span class="line">                sb[k].append(c[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把每一行拼接起来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt; numRows; idx++)&#123;</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[idx]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to d]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Valid Sudoku and Sudoku Solver]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Valid-Sudoku-and-Sudoku-Solver/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Valid-Sudoku-and-Sudoku-Solver/</id>
    <published>2016-07-05T01:44:33.000Z</published>
    <updated>2016-07-05T03:05:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Valid_Sudoku">Valid Sudoku</h2><h3 id="题目描述">题目描述</h3><p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx" target="_blank" rel="external">Sudoku Puzzles - The Rules</a>.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""></p>
<p>A partially filled sudoku which is valid.</p>
<p><strong> Note: </strong><br>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p>
<h3 id="代码">代码</h3><p>注意到题目中说的,只要当前已经填充的数字是合法的就可以,不一定要这个数独是有解.</p>
<p>因此，根据数独的游戏规则，我们只需要判断9<em>9网格中的每一行、每一列、每个小九宫格中某个数字（只能是1到9）是否重复出现了，如果没有就是合法的。比较tricky的一点就是如果九宫格按照行从0开始标号，那么数字board[i][j]位于第i/3\</em>3 + j/3个九宫格内。第 i 个九宫格里面的第 j 个元素在原矩阵的第 3*(i/3) + j/3 行，第 3*(i%3) + j%3）列，“/” 表示整数除法）。最直接的写法就是三个双重for循环，还可以更简洁一点，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == null || board.length != <span class="number">9</span> || board[<span class="number">0</span>].length != <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用于检查每一行</span></span><br><span class="line">        boolean[][] row= <span class="keyword">new</span> boolean[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="comment">//用于检查每一列</span></span><br><span class="line">        boolean[][] col = <span class="keyword">new</span> boolean[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="comment">//用于检查每一个小九宫格</span></span><br><span class="line">        boolean[][] box = <span class="keyword">new</span> boolean[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">//减1是下标从0开始</span></span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//第k个小九宫格</span></span><br><span class="line">                    <span class="keyword">int</span> k = i/<span class="number">3</span>*<span class="number">3</span> + j/<span class="number">3</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(row[i][num] || col[j][num] || box[k][num])&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    row[i][num] = col[j][num] = box[k][num] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sudoku_Solver">Sudoku Solver</h2><h3 id="题目描述-1">题目描述</h3><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>Empty cells are indicated by the character ‘.’.</p>
<p>You may assume that there will be only one unique solution.</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""></p>
<p>A sudoku puzzle…</p>
<p><a href="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" target="_blank" rel="external"></a></p>
<p>…and its solution numbers marked in red.</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//思路挺简单的，用回溯法</span></span><br><span class="line">    <span class="comment">//双重for循环遍历每一个元素，如果当前格子的元素为'.'，则尝试放置1-9，如果找到一个有效的数字，递归调用</span></span><br><span class="line">    <span class="comment">//solveSudoku，如果能找到解，返回true，否则，回溯，继续搜索</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == null || board.length != <span class="number">9</span> || board[<span class="number">0</span>].length != <span class="number">9</span>) <span class="keyword">return</span>;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">//尝试1-9看能不能找到解</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> ch = <span class="string">'1'</span>; ch &lt;= <span class="string">'9'</span>; ch++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(isValid(board, i, j, ch))&#123;</span><br><span class="line">                            <span class="comment">//将[i][j]放置ch</span></span><br><span class="line">                            board[i][j] = ch;</span><br><span class="line">                            <span class="keyword">if</span>(solve(board))</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                board[i][j] = <span class="string">'.'</span>;<span class="comment">//回溯</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果该位置1到9都不行，说明无解</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断字符ch能不能放到board[i][j]中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断j列是否出现重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][j] == ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断i行是否出现重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断board[i][j]所属的九宫格是否出现重复</span></span><br><span class="line">        <span class="keyword">int</span> rowStart = i / <span class="number">3</span> * <span class="number">3</span>, colStart = j / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = rowStart; row &lt; rowStart + <span class="number">3</span>; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = colStart; col &lt; colStart + <span class="number">3</span>; col++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[row][col] == ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Valid_Sudoku">Valid Sudoku</h2><h3 id="题目描述">题目描述</h3><p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sum of Two Integers]]></title>
    <link href="http://blog.noobsky.com/2016/07/05/LeetCode-Sum-of-Two-Integers/"/>
    <id>http://blog.noobsky.com/2016/07/05/LeetCode-Sum-of-Two-Integers/</id>
    <published>2016-07-05T01:03:21.000Z</published>
    <updated>2016-07-05T01:04:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:<br>Given a = 1 and b = 2, return 3.</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//举个例子：5+17 = 22 </span></span><br><span class="line">    <span class="comment">//0+0 = 0 ,1+1 = 0, 1+0 = 1, 0+1 = 1跟异或相同</span></span><br><span class="line">    <span class="comment">//先不考虑进位：5 + 17 = 101 + 10001 = 10100 = 20</span></span><br><span class="line">    <span class="comment">//再加上进位1+1才有进位1+1 = 10 = (1&amp;1) &lt;&lt; 1</span></span><br><span class="line">    <span class="comment">//在比如11+11的进位：11 + 11 = 110 = (11&amp;11) &lt;&lt; 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(b == 0) &#123;</span></span><br><span class="line">        <span class="comment">//     return a;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// int sum, carry;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sum = a ^ b;</span></span><br><span class="line">        <span class="comment">// carry = (a &amp; b) &lt;&lt; 1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// return getSum(sum, carry);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等价于</span></span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//迭代的形式</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum, carry;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum = a ^ b;</span><br><span class="line">            carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;<span class="keyword">while</span>(b != <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example:<br]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Median of Two Sorted Arrays]]></title>
    <link href="http://blog.noobsky.com/2016/07/04/LeetCode-Median-of-Two-Sorted-Arrays/"/>
    <id>http://blog.noobsky.com/2016/07/04/LeetCode-Median-of-Two-Sorted-Arrays/</id>
    <published>2016-07-04T03:48:13.000Z</published>
    <updated>2016-07-04T08:52:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p><strong> Example 1: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">The median is <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p><strong> Example 2: </strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = <span class="comment">[1, 2]</span></span><br><span class="line">nums2 = <span class="comment">[3, 4]</span></span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<h2 id="解题思路">解题思路</h2><p>首先要明白中位数的用途，在统计学中<font color="red"><code>dividing a set into two equal length subsets, that one subset is always greater than the other.</code></font>这就告诉了我们大概的思路。</p>
<p>首先，将数组A在随机位置i上划分成两部分：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      left_A             |        right_A</span><br><span class="line">A<span class="string">[0]</span>, A<span class="string">[1]</span>, ..., A<span class="string">[i-1]</span>  |  A<span class="string">[i]</span>, A<span class="string">[i+1]</span>, ..., A<span class="string">[m-1]</span></span><br></pre></td></tr></table></figure>
<p>数组A有m个元素，所以i的取值有m+1（0~m）种选择来划分数组A，而且len(left_A) = i，len(right_A) = m-i。需要注意的是，如果i=0，则left_A为空；如果i=m，则right_A为空。</p>
<p>同理，我们在随机位置j上将数组B划分为两部分：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      left_B             |        right_B</span><br><span class="line">B<span class="string">[0]</span>, B<span class="string">[1]</span>, ..., B<span class="string">[j-1]</span>  |  B<span class="string">[j]</span>, B<span class="string">[j+1]</span>, ..., B<span class="string">[n-1]</span></span><br></pre></td></tr></table></figure>
<p>我们将left_A和left_B放到一个集合中，right_A和right_B放到另一个集合中，分别为left_part和right_part:</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      left_part          |        right_part</span><br><span class="line">A<span class="string">[0]</span>, A<span class="string">[1]</span>, ..., A<span class="string">[i-1]</span>  |  A<span class="string">[i]</span>, A<span class="string">[i+1]</span>, ..., A<span class="string">[m-1]</span></span><br><span class="line">B<span class="string">[0]</span>, B<span class="string">[1]</span>, ..., B<span class="string">[j-1]</span>  |  B<span class="string">[j]</span>, B<span class="string">[j+1]</span>, ..., B<span class="string">[n-1]</span></span><br></pre></td></tr></table></figure>
<p>所以我们只需要确保：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="function"><span class="title">len</span><span class="params">(left_part)</span></span> == <span class="function"><span class="title">len</span><span class="params">(right_part)</span></span></span><br><span class="line"><span class="number">2</span>) <span class="function"><span class="title">max</span><span class="params">(left_part)</span></span> &lt;= <span class="function"><span class="title">min</span><span class="params">(right_part)</span></span></span><br></pre></td></tr></table></figure></p>
<p>那么我们就能将全部元素划分为相等的两部分（或者相差1），并且一部分中的元素都小于另一部分的元素。那么中位数为<font color="red"><code>median = (max(left_part) + min(right_part))/2</code></font>。</p>
<p>为了确保以上两个条件，我们需要满足：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) i + j == <span class="keyword">m</span> - i + <span class="keyword">n</span> - j (or: <span class="keyword">m</span> - i + <span class="keyword">n</span> - j + 1)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">n</span> &gt;= <span class="keyword">m</span>, we just need to <span class="keyword">set</span>: i = 0 ~ <span class="keyword">m</span>, j = (<span class="keyword">m</span> + <span class="keyword">n</span> + 1)/2 - <span class="literal">i</span></span><br><span class="line">(2) B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]</span><br></pre></td></tr></table></figure>
<p>如果m+n为奇数时，两部分的长度相差1，所以i + j == m - i + n - j (or: m - i + n - j + 1,(m+n为奇数时))。而让n &gt;= m是因为i = 0~m, j=(m+n+1)/2-i，n &gt;= m能确保j不为负数。为了简单，我们这里先假设A[i-1],B[j-1],A[i],B[j] 都是有限的，我们在后面再讨论i=0/i=m/j=0/j=n的边界情况。</p>
<p>所以，我们需要做的是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Searching <span class="tag">i</span> <span class="keyword">in</span> [<span class="number">0</span>, m], to find an <span class="tag">object</span> `i` that:</span><br><span class="line">    B[j-<span class="number">1</span>] &lt;= A[i] and A[i-<span class="number">1</span>] &lt;= B[j], ( where j = (m + n + <span class="number">1</span>)/<span class="number">2</span> - <span class="tag">i</span> )</span><br></pre></td></tr></table></figure>
<p>因为数组是有序的，所以我们可以利用二分搜索来查找，伪代码如下：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">1</span>&gt; Set imin = <span class="number">0</span>, imax = m, then start searching in [imin, imax]</span><br><span class="line"></span><br><span class="line">&lt;<span class="number">2</span>&gt; Set i = (imin + imax)/<span class="number">2</span>, j = (m + n + <span class="number">1</span>)/<span class="number">2</span> - i</span><br><span class="line"></span><br><span class="line">&lt;<span class="number">3</span>&gt; Now we have len(left_part)==len(right_part). <span class="literal">And</span> there are only <span class="number">3</span> situations</span><br><span class="line"><span class="label">     that we may encounter:</span></span><br><span class="line">    &lt;<span class="literal">a</span>&gt; B[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i] <span class="literal">and</span> <span class="literal">A</span>[i-<span class="number">1</span>] &lt;= B[j]</span><br><span class="line">        Means we have found the object <span class="escape">`i</span><span class="escape">`,</span> so stop searching.</span><br><span class="line">    &lt;b&gt; B[j-<span class="number">1</span>] &gt; <span class="literal">A</span>[i]</span><br><span class="line">        Means <span class="literal">A</span>[i] is too small. We must <span class="escape">`a</span>just<span class="escape">` </span>i to get <span class="escape">`B</span>[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i]<span class="escape">`.</span></span><br><span class="line">        Can we <span class="escape">`i</span>ncrease<span class="escape">` </span>i?</span><br><span class="line">            Yes. Because when i is increased, j will be decreased.</span><br><span class="line">            So B[j-<span class="number">1</span>] is decreased <span class="literal">and</span> <span class="literal">A</span>[i] is increased, <span class="literal">and</span> <span class="escape">`B</span>[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i]<span class="escape">` </span>may</span><br><span class="line">            be satisfied.</span><br><span class="line">        Can we <span class="escape">`d</span>ecrease<span class="escape">` </span>i?</span><br><span class="line">            <span class="escape">`N</span>o!<span class="escape">` </span>Because when i is decreased, j will be increased.</span><br><span class="line">            So B[j-<span class="number">1</span>] is increased <span class="literal">and</span> <span class="literal">A</span>[i] is decreased, <span class="literal">and</span> B[j-<span class="number">1</span>] &lt;= <span class="literal">A</span>[i] will</span><br><span class="line">            be never satisfied.</span><br><span class="line">        So we must <span class="escape">`i</span>ncrease<span class="escape">` </span>i. That is, we must ajust the searching range to</span><br><span class="line">        [i+<span class="number">1</span>, imax]. So, set imin = i+<span class="number">1</span>, <span class="literal">and</span> goto &lt;<span class="number">2</span>&gt;.</span><br><span class="line">    &lt;c&gt; <span class="literal">A</span>[i-<span class="number">1</span>] &gt; B[j]</span><br><span class="line">        Means <span class="literal">A</span>[i-<span class="number">1</span>] is too big. <span class="literal">And</span> we must <span class="escape">`d</span>ecrease<span class="escape">` </span>i to get <span class="escape">`A</span>[i-<span class="number">1</span>]&lt;=B[j]<span class="escape">`.</span></span><br><span class="line">        That is, we must ajust the searching range to [imin, i-<span class="number">1</span>].</span><br><span class="line">        So, set imax = i-<span class="number">1</span>, <span class="literal">and</span> goto &lt;<span class="number">2</span>&gt;.</span><br></pre></td></tr></table></figure>
<p>当我们找到下标i后，那么中位数为：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max<span class="list">(<span class="keyword">A</span>[i-1], B[j-1])</span> <span class="list">(<span class="keyword">when</span> m + n is odd)</span></span><br><span class="line">or <span class="list">(<span class="keyword">max</span><span class="list">(<span class="keyword">A</span>[i-1], B[j-1])</span> + min<span class="list">(<span class="keyword">A</span>[i], B[j])</span>)</span>/2 <span class="list">(<span class="keyword">when</span> m + n is even)</span></span><br></pre></td></tr></table></figure>
<p>下面来处理那些边界情况：i=0,i=m,j=0,j=n ，此时A[i-1],B[j-1],A[i],B[j]并不存在。</p>
<p>我们需要确保max(left_part) &lt;= min(right_part)，如果i和j不是边界值，那么我们需要检查B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]。如果A[i-1],B[j-1],A[i],B[j]有些不存在，那么B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]这两个条件我们可以不检查一个条件（或者两个都不用检查）。比如，如果i=0，那么A[i-1]不存在，则我们不需要检查A[i-1] &lt; B[j]。所以我们需要做的修改为：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Searching i <span class="keyword">in</span> [<span class="number">0</span>, m], <span class="keyword">to</span> find an object `i` <span class="keyword">that</span>:</span><br><span class="line">    (j == <span class="number">0</span> <span class="keyword">or</span> i == m <span class="keyword">or</span> B[j-<span class="number">1</span>] &lt;= A[i]) <span class="keyword">and</span></span><br><span class="line">    (i == <span class="number">0</span> <span class="keyword">or</span> j == n <span class="keyword">or</span> A[i-<span class="number">1</span>] &lt;= B[j])</span><br><span class="line">    <span class="keyword">where</span> j = (m + n + <span class="number">1</span>)/<span class="number">2</span> - i</span><br></pre></td></tr></table></figure>
<p>搜索过程中，我们会遇到以下三种情况：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt; (j == <span class="number">0</span> or <span class="tag">i</span> == m or B[j-<span class="number">1</span>] &lt;= A[i]) and</span><br><span class="line">    (<span class="tag">i</span> == <span class="number">0</span> or j = n or A[i-<span class="number">1</span>] &lt;= B[j])</span><br><span class="line">    Means <span class="tag">i</span> is perfect, we can stop searching.</span><br><span class="line"></span><br><span class="line">&lt;b&gt; j &gt; <span class="number">0</span> and <span class="tag">i</span> &lt; m and B[j - <span class="number">1</span>] &gt; A[i]</span><br><span class="line">    Means <span class="tag">i</span> is too small, we must increase it.</span><br><span class="line"></span><br><span class="line">&lt;c&gt; <span class="tag">i</span> &gt; <span class="number">0</span> and j &lt; n and A[<span class="tag">i</span> - <span class="number">1</span>] &gt; B[j]</span><br><span class="line">    Means <span class="tag">i</span> is too big, we must decrease it.</span><br></pre></td></tr></table></figure>
<p>所以代码如下(python)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    m, n = len(A), len(B)</span><br><span class="line">    <span class="keyword">if</span> m &gt; n:</span><br><span class="line">        A, B, m, n = B, A, n, m</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line">    imin, imax, half_len = <span class="number">0</span>, m, (m + n + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> imin &lt;= imax:</span><br><span class="line">        i = (imin + imax) / <span class="number">2</span></span><br><span class="line">        j = half_len - i</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; m <span class="keyword">and</span> B[j-<span class="number">1</span>] &gt; A[i]:</span><br><span class="line">            <span class="comment"># i is too small, must increase it</span></span><br><span class="line">            imin = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &lt; n <span class="keyword">and</span> A[i-<span class="number">1</span>] &gt; B[j]:</span><br><span class="line">            <span class="comment"># i is too big, must decrease it</span></span><br><span class="line">            imax = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># i is perfect</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: max_of_left = B[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>: max_of_left = A[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>: max_of_left = max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> max_of_left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == m: min_of_right = B[j]</span><br><span class="line">            <span class="keyword">elif</span> j == n: min_of_right = A[i]</span><br><span class="line">            <span class="keyword">else</span>: min_of_right = min(A[i], B[j])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (max_of_left + min_of_right) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>修改为Java版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(nums1 == null || nums2 == null) return 0.0;</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m &gt; n) <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = m;</span><br><span class="line">        <span class="comment">//j = (m+n+1)/2 - i前面一部分是固定，可以先算，不用再while中重复计算</span></span><br><span class="line">        <span class="keyword">int</span> halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> maxOfLeft;</span><br><span class="line">        <span class="keyword">int</span> minOfRight;</span><br><span class="line">        <span class="comment">//在[0,m]中二分搜索</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            i = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            j = halfLen - i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; nums2[j-<span class="number">1</span>] &gt; nums1[i])&#123;</span><br><span class="line">                left = i+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; nums1[i-<span class="number">1</span>] &gt; nums2[j])&#123;</span><br><span class="line">                right = i-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) maxOfLeft = nums2[j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) maxOfLeft = nums1[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> maxOfLeft = Math.max(nums1[i-<span class="number">1</span>], nums2[j-<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//m+n为奇数</span></span><br><span class="line">                <span class="keyword">if</span>((m + n) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> maxOfLeft;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i == m) minOfRight = nums2[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == n) minOfRight = nums1[i];</span><br><span class="line">                <span class="keyword">else</span> minOfRight = Math.min(nums1[i], nums2[j]);</span><br><span class="line">                <span class="keyword">return</span> (maxOfLeft + minOfRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Interleaving String]]></title>
    <link href="http://blog.noobsky.com/2016/07/03/LeetCode-Interleaving-String/"/>
    <id>http://blog.noobsky.com/2016/07/03/LeetCode-Interleaving-String/</id>
    <published>2016-07-03T01:54:30.000Z</published>
    <updated>2016-07-04T09:03:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Given:<br>s1 = “aabcc”,<br>s2 = “dbbca”,</p>
<p>When s3 = “aadbbcbcac”, return true.<br>When s3 = “aadbbbaccc”, return false.</p>
<h2 id="代码">代码</h2><p>dp[i][j]表示s1[0…i-1]和s2[0…j-1]能表示s3[0…i+j-1]，即s1的前i个字符和s2的前j个字符能按规则表示s3的前i+j个字符。则：</p>
<p>dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1] 或者 dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]</p>
<p>结果为：</p>
<p>dp[s1.length()][s2.length()]</p>
<p>边界情况：</p>
<p>i=0,j=0:dp[i][j] = true，表示s1、s2、s3都未空字符串<br>i=0 dp[i][j] = dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]<br>j=0 dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s1.length() + s2.length() != s3.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        boolean[][] dp = <span class="keyword">new</span> boolean[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//注意循环条件可以等于</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s2.length(); j++)&#123;</span><br><span class="line">                <span class="comment">//都为空字符串</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//s1为空字符串</span></span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] &amp;&amp; s2.charAt(j-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//s2为空字符</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] &amp;&amp; s1.charAt(i-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//有两种情况s3[i+j-1]取自s1[i-1]或者取自s2[j-1]</span></span><br><span class="line">                    dp[i][j] = (dp[i][j-<span class="number">1</span>] &amp;&amp; s2.charAt(j-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>)) || (dp[i-<span class="number">1</span>][j] &amp;&amp; s1.charAt(i-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Given:<br>s1 ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Merge k Sorted Lists]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-Merge-k-Sorted-Lists/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-Merge-k-Sorted-Lists/</id>
    <published>2016-07-02T13:40:00.000Z</published>
    <updated>2016-07-04T08:58:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<h2 id="代码">代码</h2><ul>
<li>利用优先级队列</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	 <span class="comment">//使用优先级队列存k个sorted lists的节点</span></span><br><span class="line">    <span class="comment">//队列大小初始化为k，初始化时从每个Sorted lists中放入一个节点到优先级队列中，找出最小值</span></span><br><span class="line">    <span class="comment">//然后加入最小值ListNode.next的节点</span></span><br><span class="line">    <span class="keyword">public</span> ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> compare(ListNode l1, ListNode l2)&#123;</span><br><span class="line">                <span class="comment">//按val的自然序排序</span></span><br><span class="line">                <span class="comment">//return l1.val - l2.val;</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(l1.val, l2.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(ListNode node : lists)&#123;</span><br><span class="line">            <span class="comment">//注意判空</span></span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.offer(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            curr.<span class="keyword">next</span> = pq.poll();</span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            <span class="comment">//出队列的节点有next节点，加入队列中</span></span><br><span class="line">            <span class="keyword">if</span>(curr.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.offer(curr.<span class="keyword">next</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlgk)</p>
<ul>
<li>利用Merge Two Sorted Lists</li>
</ul>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">	    //使用merge two Sorted List的方法</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode merge(ListNode l1, ListNode l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l1;</span><br><span class="line">                l1 = l1.<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l2;</span><br><span class="line">                l2 = l2.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curr.<span class="keyword">next</span> = l1 != <span class="literal">null</span> ? l1 : l2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode mergeKListsHelper(ListNode[] lists, int start, int <span class="keyword">end</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="keyword">end</span>) <span class="keyword">return</span> lists[start];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start &gt; <span class="keyword">end</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        int mid = start + (<span class="keyword">end</span> - start)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode l1 = mergeKListsHelper(lists, start, mid);</span><br><span class="line">        ListNode l2 = mergeKListsHelper(lists, mid+<span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">        //<span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeKListsHelper(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlgk)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the no]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Maximum Path Sum]]></title>
    <link href="http://blog.noobsky.com/2016/07/02/LeetCode-Binary-Tree-Maximum-Path-Sum/"/>
    <id>http://blog.noobsky.com/2016/07/02/LeetCode-Binary-Tree-Maximum-Path-Sum/</id>
    <published>2016-07-02T09:45:09.000Z</published>
    <updated>2016-07-04T08:57:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root.</p>
<p>For example:<br>Given the below binary tree,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Return 6.</p>
<h2 id="代码">代码</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree <span class="keyword">node</span>.<span class="identifier"></span><br><span class="line"> </span><span class="title">* public</span> class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//<span class="number">1</span>. <span class="keyword">Node</span><span class="identifier"> </span><span class="title">only</span></span><br><span class="line">//<span class="number">2</span>. L-sub + <span class="keyword">Node</span><span class="identifier"></span><br><span class="line"></span><span class="title">//3</span>. R-sub + <span class="keyword">Node</span><span class="identifier"></span><br><span class="line"></span><span class="title">//4</span>. L-sub + <span class="keyword">Node</span><span class="identifier"> </span><span class="title">+ R-sub</span></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    //Java中pass by value，不像C++的引用或者指针</span><br><span class="line">    //解决办法是用全局变量、数组、包装类，这里用全局变量</span><br><span class="line">    int max = Integer.MIN_VALUE;</span><br><span class="line">    //因为存在负数，所以最大值不一定是roog+l-sub+r-sub</span><br><span class="line">    public int maxPathSum(TreeNode root) &#123;</span><br><span class="line">        maxPathDown(root);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //该函数计算路径最高节点为<span class="keyword">node</span><span class="identifier"></span><span class="title">的最大路径和(返回值)，并更新全局最大值</span><br><span class="line">    //returns</span> the maximum sum of the path that can be extended to input <span class="keyword">node</span><span class="identifier"></span><span class="title">'s</span> parent.</span><br><span class="line">    //返回能扩展输入节点（<span class="keyword">node</span><span class="identifier"></span><span class="title">）的父节点的路径的最大和</span><br><span class="line">    //能扩展输入节点node</span>的父节点的路径只有三种情况：</span><br><span class="line">    //<span class="number">1</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">only</span></span><br><span class="line">    //<span class="number">2</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">+ l-sub</span></span><br><span class="line">    //<span class="number">3</span>. <span class="keyword">node</span><span class="identifier"> </span><span class="title">+ r-sub</span></span><br><span class="line">    //而<span class="keyword">node</span><span class="identifier"></span><span class="title">+l-sub</span>+r-sub是不能扩展<span class="keyword">node</span><span class="identifier"></span><span class="title">的父节点的</span><br><span class="line">    // private</span> int maxPathDown(TreeNode <span class="keyword">node</span><span class="identifier"></span><span class="title">)&#123;</span><br><span class="line">    //     if</span>(<span class="keyword">node</span><span class="identifier"> </span><span class="title">== null</span>) return <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    //     int left = maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>);</span><br><span class="line">    //     int right = maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>);</span><br><span class="line">        </span><br><span class="line">    //     //表示通过<span class="keyword">node</span><span class="identifier"></span><span class="title">节点能到达node</span>的parent节点的最大和，作为返回值返回给父节点的函数调用</span><br><span class="line">    //     //因为更新全局最大值也要用到所以先用局部变量存起来，不用重复计算</span><br><span class="line">    //     int maxPathAcrossNodeToParent = Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    //     //更新全局最大值</span><br><span class="line">    //     max = Math.max(max, Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right, maxPathAcrossNodeToParent));</span><br><span class="line">    //     //return Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    //     return maxPathAcrossNodeToParent;</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    //其实maxPathDown的可以优化如下：</span><br><span class="line">    private int maxPathDown(TreeNode <span class="keyword">node</span><span class="identifier"></span><span class="title">)&#123;</span><br><span class="line">        if</span>(<span class="keyword">node</span><span class="identifier"> </span><span class="title">== null</span>) return <span class="number">0</span>;</span><br><span class="line">        //节点存在负数，如果为负数则对路径最大和没有任何帮助，抛弃即可</span><br><span class="line">        //left或right至少大于<span class="number">0</span>才对max有帮助</span><br><span class="line">        //这样处理后更新全局最大值时用max跟<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right比较即可</span><br><span class="line">        //<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right代表了<span class="keyword">node</span><span class="identifier"></span><span class="title">、node</span>+l-sub、<span class="keyword">node</span><span class="identifier"></span><span class="title">+r-sub</span>、<span class="keyword">node</span><span class="identifier"></span><span class="title">+l-sub</span>+r-sub最大值</span><br><span class="line">        int left = Math.max(<span class="number">0</span>,maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>));</span><br><span class="line">        int right = Math.max(<span class="number">0</span>, maxPathDown(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>));</span><br><span class="line">        </span><br><span class="line">        max = Math.max(max, <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span> + left + right);</span><br><span class="line">        </span><br><span class="line">        return Math.max(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>, Math.max(left, right) + <span class="keyword">node</span>.<span class="identifier"></span><span class="title">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.geeksforgeeks.org/find-maximum-path-sum-in-a-binary-tree/" target="_blank" rel="external">Maximum Path Sum in a Binary Tree</a><br><a href="http://blog.csdn.net/fightforyourdream/article/details/16894069" target="_blank" rel="external"> Binary Tree Maximum Path Sum 二叉树最大路径和 @LeetCode</a><br><a href="https://leetcode.com/discuss/14190/accepted-short-solution-in-java" target="_blank" rel="external">Accepted short solution in Java</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of node]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
