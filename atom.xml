<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-10-09T01:54:17.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java单例模式]]></title>
    <link href="http://blog.noobsky.com/2016/10/09/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.noobsky.com/2016/10/09/Java单例模式/</id>
    <published>2016-10-09T14:29:05.000Z</published>
    <updated>2016-10-09T01:54:17.000Z</updated>
    <content type="html"><![CDATA[<p>单例模式应该是设计模式中最容易理解，也是最容易手写代码，但这并不意味着简单，想要写对、用对单例模式还是需要费一番脑筋的。因为其中的坑不少，它也常作为面试题来考。本文对Java中常见的单例模式写法做一个总结。</p>
<h2 id="饿汉式">饿汉式</h2><p>饿汉式就是在类第一次加载到内存中就进行初始化</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>声明成static，类加载时就初始化</li>
<li>final意味着该实例不能重新生成，确保只有一个实例存在</li>
<li>private构造函数表明这个类不能调用构造方法生成其他实例</li>
<li>既然这个类不能调用构造方法形成实例，那么我们需要一个静态的方法getInstance()让其获得一个实例</li>
</ul>
<p>这种方法的好处是编写简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。但是这种方法无法做到延迟创建对象。但是我们很多时候都希望对象可以尽可能地延迟加载，从而减小负载，所以就需要下面的懒汉式。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//去掉final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法使用懒加载模式，由私有构造器和一个共有静态方法构成，在工厂方法中对singleton进行null判断，如果是null就new一个出来，最后返回singleton对象。这种方法可以实现延迟加载，但是有一个致命弱点：线程不安全。在单线程下可以正常工作，如果有多条线程同时调用getSingleton()方法时，很大可能导致重复创建对象。比如第一个线程进行singleton == null后还没执行后面的new，第二个线程也进行singleton == null判断时也为true，此时两个线程都会new出一个不同实例。</p>
<h2 id="线程安全的懒汉式">线程安全的懒汉式</h2><p>为了解决上面线程不安全的问题，最简单的方法就是把getSingleton方法设置为synchronize（同步）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//去掉final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做虽然是线程安全的，能解决多实例问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了同步代码块和双重检验锁。</p>
<h2 id="兼顾线程安全和效率">兼顾线程安全和效率</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="built_in">Singleton</span> &#123;</span><br><span class="line">    private <span class="keyword">static</span> <span class="built_in">Singleton</span> <span class="built_in">singleton</span> = <span class="literal">null</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    private <span class="built_in">Singleton</span>()&#123;&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">Singleton</span> getSingleton()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">singleton</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized (<span class="built_in">Singleton</span>.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">singleton</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="built_in">singleton</span> = new <span class="built_in">Singleton</span>()<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">singleton</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法被称为“双重检查锁”，顾名思义，就是在getSingleton方法中，进行两次null检查。</p>
<ul>
<li>第一null检查，如果实例创建了，就没必要进行同步了直接返回</li>
<li>如果没创建，就开始线程同步</li>
<li>第二个null检查，如果被同步的线程中，有一个线程创建了对象，那么其他线程就不需要创建了<br>第一次null检查极大提升了并发度，去掉第一次null检查跟上面的线程安全的懒汉式效果差不多。第二次null检查也是必须的，如果去掉，如下：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果有多个线程同时通过(singleton== null)的条件检查（因为他们并行运行），虽然我们的synchronized方法会帮助我们同步所有的线程，让我们并行线程变成串行的一个一个去new，同样会出现很多实例。</p>
<p>双重检查锁的代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面3件事情。</p>
<ol>
<li>给singleton分配内存</li>
<li>调用Singleton的构造函数来初始化成员变量，形成实例</li>
<li>将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）<br>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时instance已经是非 null了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。我们只需要将 instance 变量声明成 volatile 就可以了。<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>有些人认为使用volatile的原因是可见性，也就是可以保证线程在本地不会存有singleton的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完1-2-3 之后或者1-3-2之后，不存在执行到1-3然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>但是需要注意的是volatile的禁止指令重排优化这条语义知道JDK1.5才能正确使用。所以在JDK1.5之前双重检查锁的形式的单例模式是无法保证线程安全的。</p>
<p>为了个延迟加载，搞出来这么多问题，我们还是使用前面的饿汉式吧：）。</p>
<h2 id="静态内部类法">静态内部类法</h2><p>《Effective Java》中推荐使用静态内部类的方式实现单例模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/5/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这种方式，仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>
<h2 id="高大上的枚举Enum">高大上的枚举Enum</h2><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Jaye <span class="keyword">on</span> <span class="number">16</span>/<span class="number">5</span>/<span class="number">18</span>.</span><br><span class="line"> */</span><br><span class="line">public <span class="class"><span class="keyword">enum</span>  <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>居然用枚举！！看上去好牛逼，通过Singleton.INSTANCE来访问，这比调用getInstance()方法简单多了。</p>
<p>默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>单例模式应该是设计模式中最容易理解，也是最容易手写代码，但这并不意味着简单，想要写对、用对单例模式还是需要费一番脑筋的。因为其中的坑不少，它也常作为面试题来考。本文对Java中常见的单例模式写法做一个总结。</p>
<h2 id="饿汉式">饿汉式</h2><p>饿汉式就是]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://blog.noobsky.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Implement strStr()]]></title>
    <link href="http://blog.noobsky.com/2016/10/09/LeetCode-Implement-strStr/"/>
    <id>http://blog.noobsky.com/2016/10/09/LeetCode-Implement-strStr/</id>
    <published>2016-10-09T01:21:48.000Z</published>
    <updated>2016-10-09T01:22:27.000Z</updated>
    <content type="html"><![CDATA[<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public int strStr(String haystack, String needle) &#123;</span></span><br><span class="line">    <span class="comment">//     return haystack.indexOf(needle);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int strStr(String haystack, String needle)&#123;</span></span><br><span class="line">    <span class="comment">//     if(haystack == null || needle == null) return -1;</span></span><br><span class="line">    <span class="comment">//     //""和""返回0，但是""和"a"返回-1</span></span><br><span class="line">    <span class="comment">//     if(haystack.length() == 0) return needle.length() == 0 ? 0:-1;</span></span><br><span class="line">    <span class="comment">//     //暴力法</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; haystack.length()-needle.length() + 1; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         int j = 0;</span></span><br><span class="line">    <span class="comment">//         for(; j &lt; needle.length(); j++)&#123;</span></span><br><span class="line">    <span class="comment">//             if(haystack.charAt(i+j) != needle.charAt(j)) break;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if(j == needle.length()) return i;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; ; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (j == needle.length()) <span class="keyword">return</span> i;</span><br><span class="line">              <span class="keyword">if</span> (i + j == haystack.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (needle.charAt(j) != haystack.charAt(i + j)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之二叉树问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/09/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/09/面试算法之二叉树问题集锦/</id>
    <published>2016-10-08T16:24:12.000Z</published>
    <updated>2016-10-08T16:31:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Symmetric_Tree">Symmetric Tree</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public boolean isSymmetric(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return true;</span></span><br><span class="line">    <span class="comment">//     return isMirror(root.left, root.right);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// //判断左右子树是否为镜像</span></span><br><span class="line">    <span class="comment">// public boolean isMirror(TreeNode t1, TreeNode t2)&#123;</span></span><br><span class="line">    <span class="comment">//     if(t1 == null &amp;&amp; t2 == null) return true;</span></span><br><span class="line">    <span class="comment">//     if(t1 == null || t2 == null) return false;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return t1.val == t2.val &amp;&amp; isMirror(t1.left, t2.right) &amp;&amp; isMirror(t1.right, t2.left);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode t1 = queue.poll();</span><br><span class="line">            TreeNode t2 = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            queue.offer(t1.left);</span><br><span class="line">            queue.offer(t2.right);</span><br><span class="line">            queue.offer(t1.right);</span><br><span class="line">            queue.offer(t2.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_Paths">Binary Tree Paths</h2><p>返回二叉树所有根到叶子的路径<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line">/   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>All root-to-leaf paths are:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1-&gt;2-&gt;5"</span>, <span class="string">"1-&gt;3"</span>]</span><br></pre></td></tr></table></figure>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     List&lt;String&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     StringBuilder sb = new StringBuilder();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     binaryTreePathsHelper(root, res, sb);</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public void binaryTreePathsHelper(TreeNode root, List&lt;String&gt; res, StringBuilder sb)&#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return;</span></span><br><span class="line">    <span class="comment">//     int length = sb.length();</span></span><br><span class="line">    <span class="comment">//     sb.append(root.val);</span></span><br><span class="line">    <span class="comment">//     if(root.left == null &amp;&amp; root.right == null)&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         res.add(sb.toString());</span></span><br><span class="line">    <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//         sb.append("-&gt;");</span></span><br><span class="line">    <span class="comment">//         binaryTreePathsHelper(root.left, res, sb);</span></span><br><span class="line">    <span class="comment">//         binaryTreePathsHelper(root.right, res, sb);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //回溯，remove掉最后加的一个元素</span></span><br><span class="line">    <span class="comment">//     sb.setLength(length);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) searchPaths(root, res, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchPaths</span><span class="params">(TreeNode root,List&lt;String&gt; res, String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) res.add(path + root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) searchPaths(root.left, res, path + root.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) searchPaths(root.right, res, path + root.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Symmetric_Tree">Symmetric Tree</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br>]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Sort List]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Sort-List/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Sort-List/</id>
    <published>2016-10-08T14:45:35.000Z</published>
    <updated>2016-10-08T15:13:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将list分为两部分</span></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找链表中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分为两部分，pre为空说明slow前面前面没有元素，前半部分单链表为空</span></span><br><span class="line">        <span class="comment">// if(pre != null) pre.next = null;</span></span><br><span class="line">        <span class="comment">// else head = null;</span></span><br><span class="line">        <span class="comment">//这里因为前面if(head == null || head.next == null) return head;保证了起码有两个元素才会往下运行</span></span><br><span class="line">        <span class="comment">//则保证会进入while循环，则pre一定不会为空(前半部分单链表不可能为空)，写成上面先判空也可以</span></span><br><span class="line">        <span class="comment">//置为空，将链表割断</span></span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode l1 = sortList(head);</span><br><span class="line">        ListNode l2 = sortList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l1 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(l2 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l2;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">quickSort</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  ListNode smallDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), small = smallDummy;</span><br><span class="line">  ListNode largeDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), large = largeDummy;</span><br><span class="line">  ListNode equalDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), equal = equalDummy;</span><br><span class="line"></span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.val &lt; head.val)&#123;</span><br><span class="line">      small.next = curr;</span><br><span class="line">      small = small.next;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr.val &gt; head.val)&#123;</span><br><span class="line">      large.next = curr;</span><br><span class="line">      large = large.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      equal.next = curr;</span><br><span class="line">      equal = equal.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  small.next = large.next = equal.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(merge(quickSort(smallDummy.next), quickSort(largeDummy.next)), equalDummy.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">            current.next = l1;</span><br><span class="line">            <span class="comment">//current = current.next;</span></span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            current.next = l2;</span><br><span class="line">            <span class="comment">//current = current.next;</span></span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if(l1 != null)&#123;</span></span><br><span class="line">    <span class="comment">//     current.next = l1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if(l2 != null)&#123;</span></span><br><span class="line">    <span class="comment">//     current.next = l2;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    current.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<figure class="highlight java"><table><]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Max Points on a Line]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Max-Points-on-a-Line/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Max-Points-on-a-Line/</id>
    <published>2016-10-08T13:52:36.000Z</published>
    <updated>2016-10-08T16:03:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>暴力法，注意相同的点和x坐标相等的点（斜率无穷大）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a point.</span><br><span class="line"> * class Point &#123;</span><br><span class="line"> *     int x;</span><br><span class="line"> *     int y;</span><br><span class="line"> *     Point() &#123; x = 0; y = 0; &#125;</span><br><span class="line"> *     Point(int a, int b) &#123; x = a; y = b; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(points.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> points.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++)&#123;</span><br><span class="line">      <span class="comment">//key为斜率，value为点数</span></span><br><span class="line">      HashMap&lt;Double, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="comment">//x坐标相等的点的数量</span></span><br><span class="line">      <span class="keyword">int</span> samex = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//记录相同点</span></span><br><span class="line">      <span class="keyword">int</span> samep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">          <span class="keyword">if</span>((points[j].x == points[i].x) &amp;&amp; (points[j].y == points[i].y))&#123;</span><br><span class="line">            samep++;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(points[j].x == points[i].x)&#123;</span><br><span class="line">            samex++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">double</span> k = (<span class="keyword">double</span>)(points[j].y - points[i].y) / (<span class="keyword">double</span>)(points[j].x - points[i].x);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(map.containsKey(k))&#123;</span><br><span class="line">            map.put(k, map.get(k) + <span class="number">1</span>);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(k, <span class="number">2</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          result = Math.max(result, map.get(k) + samep);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      result = Math.max(result, samex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>暴力法，注意相]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之Two Pointers问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8BTwo-Pointers%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/08/面试算法之Two-Pointers问题集锦/</id>
    <published>2016-10-08T12:18:29.000Z</published>
    <updated>2016-10-08T12:18:29.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试算法之二分搜索问题集锦]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://blog.noobsky.com/2016/10/08/面试算法之二分搜索问题集锦/</id>
    <published>2016-10-08T09:07:05.000Z</published>
    <updated>2016-10-08T12:50:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="First_Bad_Version">First Bad Version</h2><p>给定一个判断版本是否是坏版本的函数，查找[1…n]中第一个坏的版本<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span><br><span class="line">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//int mid = left + (right - left)/2;</span></span><br><span class="line">            <span class="keyword">if</span>(!isBadVersion(mid)) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     public int firstBadVersion(int n) &#123;</span></span><br><span class="line"><span class="comment">//     int start = 1, end = n;</span></span><br><span class="line"><span class="comment">//     while (start &lt; end) &#123;</span></span><br><span class="line"><span class="comment">//         int mid = start + (end-start) / 2;</span></span><br><span class="line"><span class="comment">//         if (!isBadVersion(mid)) start = mid + 1;</span></span><br><span class="line"><span class="comment">//         else end = mid;            </span></span><br><span class="line"><span class="comment">//     &#125;        </span></span><br><span class="line"><span class="comment">//     return start;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Guess_Number_Higher_or_Lower">Guess Number Higher or Lower</h2><p>给定辅助guess(int num)函数，返回3种结果<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> lower</span><br><span class="line"> <span class="number">1</span> : My <span class="type">number</span> <span class="keyword">is</span> higher</span><br><span class="line"> <span class="number">0</span> : Congrats! You got <span class="keyword">it</span>!</span><br></pre></td></tr></table></figure></p>
<p>代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The guess API is defined in the parent class GuessGame.</span><br><span class="line">   @param num, your guess</span><br><span class="line">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span><br><span class="line">      int guess(int num); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(guess(mid) == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(guess(mid) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 1 : My number is higher,这里的My number是指要你猜的那个数</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Sqrt(x)">Sqrt(x)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid == x / mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; x / mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_a_2D_Matrix">Search a 2D Matrix</h2><p>矩阵每一行升序，每一行的第一个元素大于前一行的最后一个元素<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Given target = 3, return true.</p>
<p>每一行从左到右组成有序数组，数组下标范围为[0,row*col-1]，可以使用二分搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="comment">//row*col矩阵转换为数组=&gt;matrix[i][j] =&gt; array[i * col + j]</span></span><br><span class="line"><span class="comment">//数组转换为矩阵array[i] =&gt; matrix[i / col][i % col]</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">      <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">          <span class="keyword">int</span> mid = left+(right - left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(matrix[mid/col][mid % col] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Find_Peak_Element">Find Peak Element</h2><p>给定数组，num[i] ≠ num[i+1]，查找peek元素，并返回其下标</p>
<p>You may imagine that num[-1] = num[n] = -∞.</p>
<p>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//local maximum就是一个peek</span></span><br><span class="line">    <span class="comment">//mid = (left + right)/2,mid1 = mid + 1</span></span><br><span class="line">    <span class="comment">//如果nums[mid] &lt; nums[mid1]，那么nums[mid1...right]一定有peek，为什么？</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid1右边的数只能增加或者减少，如果mid1右边的数一直增加，则nums[right]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid1右边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="comment">//同理nums[mid] &gt; nums[mid1]，那么nums[left, mid]一定有peek，道理是一样的</span></span><br><span class="line">    <span class="comment">//因为相邻的数不能相等,那么mid左边的数只能增加或者减少，如果mid左边的数一直增加，则nums[left]就是peek，</span></span><br><span class="line">    <span class="comment">//否则的话mid左边的数出现下降的时候就会出现peek</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> mid1 = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右边一定有peek</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid1])&#123;</span><br><span class="line">                left = mid1;</span><br><span class="line">            <span class="comment">//左边一定有peek</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="comment">//如果出现相等就不符合题目中相邻元素不相等，可以抛异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历的方法不符合时间复杂度，但是实现非常tricky</span></span><br><span class="line">    <span class="comment">// public int findPeakElement(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     //右边有减小的话则peek出现</span></span><br><span class="line">    <span class="comment">//     for(int i = 1; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[i] &lt; nums[i-1]) return i-1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //否则元素一直增大到最右边元素就是peek</span></span><br><span class="line">    <span class="comment">//     return nums.length - 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kth_Smallest_Element_in_a_BST">Kth Smallest Element in a BST</h2><p>寻找BST中第k小的元素<br>利用BST的性质，递归搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计左子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> count = countNodes(root.left);</span><br><span class="line">        <span class="comment">//左子树的节点个数大于等于k，说明第k小的元素在左子树中，递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.left, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第k个元素在右子树中，相当于在右子树中寻找第k-count-1小的元素</span></span><br><span class="line">        <span class="keyword">if</span>(count &lt; k-<span class="number">1</span>) <span class="keyword">return</span> kthSmallest(root.right, k - count -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//count = k-1,说明左子树有k-1个节点，跟该节点即为第k小的元素</span></span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以利用中序遍历，边遍历边查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用中序遍历法，因为中序遍历二叉树是有序的</span></span><br><span class="line"><span class="comment">//使用递归中序遍历</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    count = k;</span><br><span class="line">    dfsHelper(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) dfsHelper(root.left);</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">        number = root.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) dfsHelper(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_for_a_Range">Search for a Range</h2><p>给定有序数组，查找目标数在数组的开始和结束位置<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找左边界：mid = (left+right)/2，下取整，往左偏</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找左边界，所以right = mid</span></span><br><span class="line">    <span class="comment">// 2和3可以合并，合并后：if(nums[mid] &lt; target) left = mid+1; else right = mid;</span></span><br><span class="line">    <span class="comment">// 找右边界：mid = (left+right)/2+1，上取整，往右篇</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找右边界，所以left = mid</span></span><br><span class="line">    <span class="comment">// 1和3可以合并，合并后：if(nums[mid] &gt; target) right = mid-1; else left = mid;</span></span><br><span class="line">    <span class="comment">// 就是两种二分搜索的写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[left] != target) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> res[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line">        right = nums.length - <span class="number">1</span>;<span class="comment">//第二次时，left可以不重新设置为0，设置了也没错，多余而已</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//上取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有左边界，就一定能执行到这里，而且不用判断，right最起码等于前面判断左边界</span></span><br><span class="line">        res[<span class="number">1</span>] = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Search_a_2D_Matrix_II">Search a 2D Matrix II</h2><p>m*n的矩阵，每一行从左往右升序，每一列从上往下升序，在矩阵查找目标元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始比较位置为右上角即matrix[0][col-1],如果target大于该值，那么target不可能在该row，因为每一row都是升序，可以排除该row</span></span><br><span class="line">    <span class="comment">//如果target小于该值，那么target不可能在该col，因为每一col都是升序的，可以排除该col，</span></span><br><span class="line">    <span class="comment">//如果相等，返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[row][col])&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; matrix[row][col])&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Search_in_Rotated_Sorted_Array_II">Search in Rotated Sorted Array II</h2><p>[4 5 6 7 0 1 2]，考虑有重复元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//左半部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//右半部分有序</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, rigth = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//左半部分有序</span></span><br><span class="line">      <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[] &lt; nums[right])&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Find_Minimum_in_Rotated_Sorted_Array">Find Minimum in Rotated Sorted Array</h2><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;<span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有重复元素呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二分后肯定有一边是有序的</span></span><br><span class="line">    <span class="comment">//nums[mid] &gt; nums[right],nums[left:mid]有序，搜索右边</span></span><br><span class="line">    <span class="comment">//nums[mid] &lt; nums[right],nums[mid:right]有序，搜索左边</span></span><br><span class="line">    <span class="comment">//nums[mid] = nums[right],有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">    <span class="comment">//但可以肯定排除nums[right],即使min = A[right],排除A[right]并没有使min丢失</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//nums[left:mid]有序，搜索右边</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;<span class="comment">//nums[mid:right]有序，搜索左边</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//有重复元素，无法判断哪边有序比如3 1 2 3 3 3 3 和 3 3 3 3 1 2 3</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Valid_Perfect_Square">Valid Perfect Square</h2><p>判断是否为完全平方数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里可以直接用数学规律</span></span><br><span class="line">    <span class="comment">//1 = 1</span></span><br><span class="line">    <span class="comment">//4 = 1 + 3</span></span><br><span class="line">    <span class="comment">//9 = 1 + 3 + 5</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//但是这里我们需要注意的是我们不能用加法来做</span></span><br><span class="line">    <span class="comment">//因为加法存在溢出的问题，我们可以逆向考虑，</span></span><br><span class="line">    <span class="comment">//用减法，减1、3...，看看最后num是否会为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            num -= i;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们不知道这个规律，之前实现过sqrt，同理这里也可以使用二分搜索</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//除法是下取整的，mid取值偏小</span></span><br><span class="line">            <span class="comment">//取值偏小的mid的平方都大于num，那么平方根肯定小于mid，所以right = mid - 1</span></span><br><span class="line">            <span class="comment">//除法防止溢出</span></span><br><span class="line">            <span class="keyword">if</span>(mid &gt; num / mid)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//小于等于</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &lt; num / mid)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果这样写会造成死循环，比如5</span></span><br><span class="line">                <span class="comment">//if(num % mid == 0) return true;</span></span><br><span class="line">                <span class="keyword">return</span> num % mid == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Find_the_Duplicate_Number">Find the Duplicate Number</h2><p>数组nums包含n+1个元素，每个元素的值在[1,n]区间<br>类似找到链表环的起点，快慢指针<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="LIS最长递增子序列">LIS最长递增子序列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.排序后的序列和原序列求LCS最长公共子序列</span></span><br><span class="line">    <span class="comment">//2.dp (O(n*n))</span></span><br><span class="line">    <span class="comment">//3.dp (O(nlgn))</span></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int[] ends = new int[nums.length];</span></span><br><span class="line">    <span class="comment">//     int len = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //二分搜索可以利用Arrays.binarySearch(int[] a, int fromIndex, int toIndex, int key),</span></span><br><span class="line">    <span class="comment">//     //该函数的返回值是这样的：如果a中存在key，则返回key在a中的index，不存在key返回-insertionpoint-1，所以</span></span><br><span class="line">    <span class="comment">//     //此时insertionpoint =  -(返回值+1)</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         int ret = Arrays.binarySearch(ends, 0, len, nums[i]);</span></span><br><span class="line">    <span class="comment">//         //小于0，不存在key，计算插入位置</span></span><br><span class="line">    <span class="comment">//         if(ret &lt; 0) ret = -(ret+1);</span></span><br><span class="line">    <span class="comment">//         //或者使用自己二分搜索函数</span></span><br><span class="line">    <span class="comment">//         //int ret = binarySearch(ends, 0, len, nums[i]);</span></span><br><span class="line">    <span class="comment">//         ends[ret] = nums[i];</span></span><br><span class="line">    <span class="comment">//         //在ends尾部增加了一个元素</span></span><br><span class="line">    <span class="comment">//         if(ret == len) len++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return len;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不记得Arrays.binarySearch返回值的含义，可以自己写一个二分搜索函数，</span></span><br><span class="line">    <span class="comment">//如果存在key返回index，不存在时返回插入位置的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = fromIndex, right = toIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == key) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; key) right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[j] = max(dp[i]) + 1 i&lt;j&amp;&amp;nums[i] &lt; nums[j]</span></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums)&#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int res = 0;</span></span><br><span class="line">    <span class="comment">//     int[] dp = new int[nums.length];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     for(int j = 0; j &lt; nums.length; j++)&#123;</span></span><br><span class="line">    <span class="comment">//         //也可以在前面用Arrays.fill(dp, 1)</span></span><br><span class="line">    <span class="comment">//         dp[j] = 1;</span></span><br><span class="line">    <span class="comment">//         for(int i = 0; i &lt; j; i++)&#123;</span></span><br><span class="line">    <span class="comment">//             if(nums[i] &lt; nums[j]) dp[j] = Math.max(dp[j], dp[i]+1);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         res = Math.max(res, dp[j]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public int lengthOfLIS(int[] nums)&#123;</span></span><br><span class="line">    <span class="comment">//     if(nums == null || nums.length == 0) return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int[] numsCopy = new int[nums.length];</span></span><br><span class="line">    <span class="comment">//     numsCopy = Arrays.copyOfRange(nums, 0, nums.length);</span></span><br><span class="line">    <span class="comment">//     Arrays.sort(numsCopy);</span></span><br><span class="line">    <span class="comment">//     //System.arraycopy(nums, 0, numsCopy, 0, nums.length);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int dp[][] = new int[nums.length+1][nums.length+1];</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt;= nums.length; i++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int j = 0; j &lt;= nums.length; j++)&#123;</span></span><br><span class="line">    <span class="comment">//             if(i == 0 || j == 0) dp[i][j] = 0;</span></span><br><span class="line">    <span class="comment">//             else&#123;</span></span><br><span class="line">    <span class="comment">//                 if(nums[i-1] == numsCopy[j-1])&#123;</span></span><br><span class="line">    <span class="comment">//                     dp[i][j] = dp[i-1][j-1]+1;</span></span><br><span class="line">    <span class="comment">//                 &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                     dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);</span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return dp[nums.length][nums.length];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Russian_Doll_Envelopes">Russian Doll Envelopes</h2><p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>
<p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<p>Example:<br>Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分两步</span></span><br><span class="line">    <span class="comment">//1. 信封按宽升序高降序排序</span></span><br><span class="line">    <span class="comment">//2. 对信封的高找最长递增子序列</span></span><br><span class="line">    <span class="comment">//因为信封的宽已经是升序，我们只要考虑信封的高就可以了</span></span><br><span class="line">    <span class="comment">//[3, 4]是装不下[3, 3]，所以我们需要将[3, 4]排在[3, 3]的前面，如果排序排成了[3,3] [3,4]会被当成递增序列，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span> || envelopes[<span class="number">0</span>].length != <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[<span class="number">0</span>] == arr2[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="comment">//高度降序</span></span><br><span class="line">                    <span class="keyword">return</span> arr2[<span class="number">1</span>] - arr1[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] envelope : envelopes)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(dp, <span class="number">0</span>, len, envelope[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                index = -(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[index] = envelope[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(index == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="First_Bad_Version">First Bad Version</h2><p>给定一个判断版本是否是坏版本的函数，查找[1…n]中第一个坏的版本<br><figure class="highlight java"><table><tr><td class]]>
    </summary>
    
      <category term="Binary Search" scheme="http://blog.noobsky.com/tags/Binary-Search/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Find K Pairs with Smallest Sums]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Find-K-Pairs-with-Smallest-Sums/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Find-K-Pairs-with-Smallest-Sums/</id>
    <published>2016-10-08T08:46:58.000Z</published>
    <updated>2016-10-08T08:49:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.</p>
<p>Define a pair (u,v) which consists of one element from the first array and one element from the second array.</p>
<p>Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums.</p>
<p>Example 1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],  k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Return: [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">The first <span class="number">3</span> pairs are returned from the sequence:</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">11</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],  k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Return: [<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">The first <span class="number">2</span> pairs are returned from the sequence:</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given nums1 = [<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">3</span>],  k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Return: [<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">All possible pairs are returned from the sequence:</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路">解题思路</h2><p>类似两路归并排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;Tuple&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.length &amp;&amp; j &lt; k; j++) pq.offer(<span class="keyword">new</span> Tuple(<span class="number">0</span>,j,nums1[<span class="number">0</span>]+nums2[j]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(k, nums1.length*nums2.length); i++)&#123;</span><br><span class="line">            Tuple temp = pq.poll();</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums1[temp.x], nums2[temp.y]&#125;);</span><br><span class="line">            <span class="keyword">if</span>(temp.x == nums1.length - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> Tuple(temp.x+<span class="number">1</span>, temp.y, nums1[temp.x+<span class="number">1</span>]+nums2[temp.y]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tuple</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Tuple that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - that.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.</p>
<p>Define a pair ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Permutations I II]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Permutations-I-II/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Permutations-I-II/</id>
    <published>2016-10-08T06:22:34.000Z</published>
    <updated>2016-10-08T16:15:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Permutations_I">Permutations I</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of distinct numbers, return all possible permutations.</p>
<p>For example,<br>[1,2,3] have the following permutations:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><ul>
<li><p>一般思路</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(nums, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void permute(<span class="keyword">int</span>[]nums, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">int</span> start)&#123;</span><br><span class="line">        <span class="comment">//产生了一个permutation</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= nums.length)&#123;</span><br><span class="line">            <span class="comment">//如果Arrays.asList(arr)的参数arr是原生数组的话并不能得到你想要的结果，</span></span><br><span class="line">            <span class="comment">//Arrays.asList(T...a)形参为可变长参数，如果传入int[] nums的话，会将int[]看做一个类型</span></span><br><span class="line">            <span class="comment">//List list = Arrays.asList(nums)则list.size() == 1;</span></span><br><span class="line">            <span class="comment">//res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums)));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//还是乖乖遍历吧，或者加多一个参数</span></span><br><span class="line">            <span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">list</span>.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">list</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">            <span class="comment">//注意第三个参数是start+1不是i+1</span></span><br><span class="line">            permute(nums, res, start+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//相当于还原回来</span></span><br><span class="line">            swap(nums, start, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void swap(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码比较简洁易懂</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute(nums, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void permute(<span class="keyword">int</span>[] nums, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res, <span class="keyword">List</span>&lt;Integer&gt; curr)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//curr中已经包含nums[i],跳过本次循环</span></span><br><span class="line">            <span class="keyword">if</span>(curr.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            permute(nums, res, curr);</span><br><span class="line">            curr.remove(curr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Permutations_II">Permutations II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br>[1,1,2] have the following unique permutations:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码-1">代码</h3><ul>
<li><p>比较tricky的写法</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//注意排序，让重复的数相邻</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        helper(nums, used, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void helper(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, <span class="keyword">List</span>&lt;Integer&gt; curr, <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//only insert duplicate element when the previous duplicate element has been inserted</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            helper(nums, used, curr, res);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常规思路加排重</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; permuteUnique(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute(nums, res, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> permute(<span class="built_in">int</span>[] nums, <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; res, <span class="built_in">int</span> start)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">            <span class="built_in">List</span>&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> <span class="built_in">num</span>: nums) &#123;temp.add(<span class="built_in">num</span>);&#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//set在for循环外面定义，在里面定义错误</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; <span class="literal">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">set</span>.add(nums[i]))&#123;</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">                permute(nums, res, start+<span class="number">1</span>);</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> swap(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> x, <span class="built_in">int</span> y)&#123;</span><br><span class="line">        <span class="built_in">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Permutations_I">Permutations I</h2><h3 id="题目描述">题目描述</h3><p>Given a collection of distinct numbers, return all possible permutation]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Tree Preorder/Inorder/Postorder Traversal]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/"/>
    <id>http://blog.noobsky.com/2016/10/08/LeetCode-Binary-Tree-Preorder-Inorder-Postorder-Traversal/</id>
    <published>2016-10-08T06:20:02.000Z</published>
    <updated>2016-10-08T16:03:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>return [1,2,3].</p>
<h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    preorder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    preorder(root.left,res);</span><br><span class="line">    preorder(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Binary_Tree_Inorder_Traversal">Binary Tree Inorder Traversal</h2><h3 id="题目描述-1">题目描述</h3><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree [1,null,2,3],<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>return [1,3,2].</p>
<h3 id="代码-1">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inorder(root,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root.left, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    inorder(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    TreeNode node = stack.pop();</span><br><span class="line">    res.add(node.val);</span><br><span class="line">    <span class="comment">//栈是先进后出，应该先把右子树进栈，先访问左子树</span></span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">  List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  TreeNode curr = root;</span><br><span class="line">  <span class="keyword">while</span>(curr != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//如果curr非空，把curr加入栈，然后curr指向curr的左儿子</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">      stack.push(curr);</span><br><span class="line">      curr = curr.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//curr为空，跳出while循环，说明已经向左走到尽头，弹出当前栈顶元素，进行访问，然后指向右儿子</span></span><br><span class="line">    curr = stack.pop();</span><br><span class="line">    res.add(curr.val);</span><br><span class="line">    curr = curr.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Binary_Tree_Postorder_Traversal">Binary Tree Postorder Traversal</h2><h3 id="题目描述-2">题目描述</h3><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>return [3,2,1].</p>
<h3 id="代码-2">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    postorder(root,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorder(root.left, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    postorder(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前序遍历是root-left-right,后序是left-right-root</span></span><br><span class="line">    <span class="comment">//如果把前序遍历稍微修改下，改为root-right-left，则可以发现这种顺序跟后序的完全相反，最后reverse一下结果就行了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="comment">//栈是先进后出，要想先访问右子树，则先进栈左子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Binary_Tree_Preorder_Traversal">Binary Tree Preorder Traversal</h2><h3 id="题目描述">题目描述</h3><p>Given a binary tree, return the preorde]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google 2016面试题]]></title>
    <link href="http://blog.noobsky.com/2016/10/08/Google-2016%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.noobsky.com/2016/10/08/Google-2016面试题/</id>
    <published>2016-10-08T02:17:47.000Z</published>
    <updated>2016-10-08T08:06:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="轴对称">轴对称</h2><h3 id="题目描述">题目描述</h3><p>给定平面上的n个点，问是否存在一条平行于y轴的直线，使得这n个点相对于这条直线对称。</p>
<p><strong>Follow-up</strong><br>是否存在一条直线使得这n个点关于这条直线对称？</p>
<h3 id="算法分析">算法分析</h3><p>因为对称轴一定平行于y轴，这看起来缩小了穷举范围（可是我们真的要穷举可能的对称轴吗？有实无限个可能点对称轴…）</p>
<p>那么我们怎么找到那条对称轴？对称轴的特点就是每一个点都在另一边有一个对应的点。第一想法是：最左边的点一定对应某个最右边的点，因此最左边的点和最右边的点的中点应该在对称轴上。当然还有很多其他的找对称轴的方法，比如求所有x坐标的平均值。</p>
<p>找到了对称轴的位置，我们就可以通过HashMap判断是否每一个点都有对应的点，最后输出答案即可。</p>
<p>时间复杂度为O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReflected</span><span class="params">(Point[] points)</span></span>&#123;</span><br><span class="line">    <span class="comment">//最右边点的x坐标值</span></span><br><span class="line">    <span class="keyword">int</span> max = Math.MIN_VALUE;</span><br><span class="line">    <span class="comment">//最左边点的x坐标值</span></span><br><span class="line">    <span class="keyword">int</span> min = Math.MAX_VALUE;</span><br><span class="line">    <span class="comment">//key为y坐标值，value为y坐标值为key的所有点的x坐标值的集合</span></span><br><span class="line">    HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">      <span class="comment">//找出最左边和最右边对应点的x坐标值</span></span><br><span class="line">      max = Math.max(max, points[i].x);</span><br><span class="line">      min = Math.min(min, points[i].x);</span><br><span class="line">      <span class="keyword">if</span>(!map.containsKey(points[i].y))&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(points[i].x);</span><br><span class="line">        map.put(points[i].y, set);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        map.get(points[i].y).add(points[i].x);</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//max-y0 = y0-min; p-y0 = y0 - p' =&gt; p' = max+min-p</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++)&#123;</span><br><span class="line">      <span class="comment">//根据对称轴判断其他点是否都有对应的点</span></span><br><span class="line">      <span class="keyword">if</span>(!map.containsKey(points[i].y) || !map.get(points[i].y).contains(max+min-points[i].x))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">int</span> y;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">()</span></span>&#123;x = <span class="number">0</span>; y = <span class="number">0</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;x = a; y = b;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组补丁">数组补丁</h2><h3 id="题目描述-1">题目描述</h3><p>给出一个从小到大排好序的整数数组nums和一个整数n，在数组中添加若干个补丁（元素）使得[1,n]的区间内的所有数都可以表示成nums中若干个数的和。返回最少需要添加的补丁个数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>：</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>], n = <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>返回1，表示至少需要添加1个数｛2｝，才可以表示1到6之间所有数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">2</span>:</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>], n = <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>返回2，表示至少需要添加两个数｛2，4｝，才可以表示1到20之间所有数。</p>
<p>我们不妨先思考一个简单的问题，如果nums数组为空，那么最少需要多少个数字才能表示1到n之间所有数？相信大家都可以想到一个贪心算法，即按照1、2、4、8…都顺序添加，每次加入都数都比之前所有数的总和大1，直到总和大于n。本题的难点是预先给出了一些数，但这不影响我们的贪心策略：假设nums当前至多可以表示1到m之间的所有数，加入m+1；直到m大于等于n。</p>
<p>变量miss表示[0,n]中我们缺少的最小的和，也就是说nums中元素求和我们已经能得到[0,miss)范围内的数<br>遍历nums数组，如果nums[i] &lt;= miss,那么我们可以将我们能得到的和的范围[0,miss)扩充到[0,miss+nums[i]);如果nums[i] &gt; miss,那么我们将不能连续扩充[0,miss),也就是说[0,miss+nums[i])的一些元素我们不能得到，则这时我们需要patch元素，那么应该patch什么数？我们采用贪心算法，我们patch的元素为miss，因为选择miss可以得到最大的连续区间[0, miss+miss)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化为缺少1</span></span><br><span class="line">    <span class="keyword">int</span> miss = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//统计patch的数量</span></span><br><span class="line">    <span class="keyword">int</span> patch = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">//如果溢出，miss小于0</span></span><br><span class="line">    <span class="keyword">while</span>(miss &gt; <span class="number">0</span> &amp;&amp; miss &lt;= n)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i &lt; nums.length &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">        miss = miss + nums[i];</span><br><span class="line">        i++;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//扩充miss</span></span><br><span class="line">        miss = miss + miss;</span><br><span class="line">        patch++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> patch;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="不构造树的情况下验证先序遍历">不构造树的情况下验证先序遍历</h2><h3 id="题目描述-2">题目描述</h3><p>给出一个字符序列，问该序列是否是一棵合法的二叉树的先序遍历？<br>找到一种不需要构造二叉树的方法。<br>For example：<br>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>是下面这颗二叉树的先序遍历。其中＃代表空节点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">9</span></span><br><span class="line">       /      \</span><br><span class="line">      <span class="number">3</span>       <span class="number">2</span></span><br><span class="line">    /   \   /    \</span><br><span class="line">   <span class="number">4</span>     <span class="number">1</span> <span class="preprocessor">#      <span class="number">6</span></span></span><br><span class="line"> /   \  / \      / \</span><br><span class="line"><span class="preprocessor">#    #  #  #    #   #</span></span><br></pre></td></tr></table></figure></p>
<h3 id="分析解答">分析解答</h3><p>通过观察上图中二叉树我们可以发现，一棵合法的二叉树去掉某个叶子节点后仍是合法的二叉树。在给出的字符序列中，叶子节点有很明显的特征，即叶子节点之后一定紧跟两个空节点＃。通过不断的把number,#,#的子串缩成空节点#(把number,#,#子串替换为#)，如果最后字符序列可以缩短到只有一个字符＃，那它就是我们要找的合法的先序遍历了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span></span>&#123;</span><br><span class="line">    String s = preorder;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.length() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> index = s.indexOf(<span class="string">",#,#"</span>);</span><br><span class="line">      <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> start = index;</span><br><span class="line">      <span class="comment">//找到,#,#前一个节点</span></span><br><span class="line">      <span class="comment">//有可能数字有多位</span></span><br><span class="line">      <span class="keyword">while</span>(start &gt; <span class="number">0</span> &amp;&amp; s.charAt(start-<span class="number">1</span>) != <span class="string">','</span>)&#123;</span><br><span class="line">        start--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(s.charAt(start) == <span class="string">'#'</span>)&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      s = s.substring(<span class="number">0</span>,start)+s.substring(index+<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"#"</span>) &amp;&amp; flag) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摆动排序_II">摆动排序 II</h2><p>给出一个整数数组nums，重新排列nums使得nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…<br>Example:<br>nums = [1, 5, 1, 1, 6, 4], 一个可能的答案是[1, 4, 1, 5, 1, 6]<br>数据保证必定有解。</p>
<h2 id="分析解答-1">分析解答</h2><p>本题有一种简单的做法，先快速排序，然后把最小的一半依次放在奇数位上，最大的一半依次放在偶数位上。算法复杂度是快速排序的复杂度O(NlogN)。仔细思考后发现快速排序不是必要的，只需要找到中位数即可。利用快速排序的思想找中位数的期望时间复杂度是O(N)。为了防止相等的数放在一起，需要注意放置的顺序。笔者采用的方法是依nums长度分两种情况：若长度为奇数，把比中位数小的依次放在0,2,4,…位置，比中位数大的依次放在length-2,length-4,…位置；若长度为偶数，把比中位数小的依次放在length-2,length-4,…位置，比中位数大的依次放在1,3,5,…位置。其余位置填充中位数。这样可以保证中位数一定与较小与较大的数相邻（题目保证一定有解）。</p>
<p>排序解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先排序数组，然后将数组的前半部分和后半部分merge起来</span></span><br><span class="line">    <span class="comment">//把更大的一般放到奇数下标中，更小的一半放到偶数下标中</span></span><br><span class="line">    <span class="comment">//比如nums=[1,2,3,4,5,6,7]</span></span><br><span class="line">    <span class="comment">//4 3 2 1</span></span><br><span class="line">    <span class="comment">// 7 6 5 = &gt; 4 7 3 6 2 5 1</span></span><br><span class="line">    <span class="comment">//该种解法只要输入中存在valid answer就能正确找到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        <span class="comment">//排序，分成两部分</span></span><br><span class="line">        Arrays.sort(copy);</span><br><span class="line">        <span class="comment">//left初始时指向中间元素的后一元素</span></span><br><span class="line">        <span class="keyword">int</span> right = nums.length, left = (nums.length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? copy[--left] : copy[--right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="矩阵中的最长上升路径">矩阵中的最长上升路径</h2><h3 id="题目描述-3">题目描述</h3><p>给出一个数字矩阵，寻找一条最长上升路径，每个位置只能向上下左右四个位置移动。<br>Example：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [</span><br><span class="line">  [<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>返回 4，最长上升路径是[1, 2, 6, 9].</p>
<h3 id="分析解答-2">分析解答</h3><p>最直观的做法是穷举每一个数字作为起点，dfs寻找最长上升路径，时间复杂度是指数级别的。仔细思考dfs有些盲目，此题中的最长上升路径很符合bfs的特点（每次向外扩展一层），bfs可以显著降低时间复杂度，朴素的bfs复杂度为O(n^4)，因为在bfs的过程中，每个位置最多会经过k次（k为到这个点对最长上升路径长度，最大可能为n^2）。如果使用动态规划的思路，把到每个位置的最长上升路径长度储存下来，那每个点只会计算一次，可以使复杂度变为O(n^2)。当前位置最长上升路径可以通过周围四个点的最长上升路径而得到。但是这里有个问题就是动态规划的穷举顺序，有两种方法解决，一是通过拓扑排序来确定穷举顺序，因为最长上升路径总是从小到大扩展的；二是通过记忆化搜索实现动态规划，记忆化搜索是搜索和动态规划的结合，在搜索过程中记录已经求解完毕的状态，使得每个状态只需进行一次搜索。在本题中，dp[i][j]记录在(i,j)位置可以得到的最长上升路径，其值通过搜索相邻四个位置的dp值确定；flag[i][j]表示(i,j)位置的解是否已经搜索完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//四个搜索方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> len = dfs(matrix, i, j, row, col, cache);</span><br><span class="line">                max = Math.max(max, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度搜索从[i][j]出发的最长递增路径的长度</span></span><br><span class="line">    <span class="comment">//cache缓存，即备忘录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] cache)</span></span>&#123;</span><br><span class="line">        <span class="comment">//已经搜索过，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(cache[i][j] != <span class="number">0</span>) <span class="keyword">return</span> cache[i][j];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//四个方向搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//matrix[x][y] &lt;= matrix[i][j]可以避免使用visited[row][col]数组</span></span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= row || y &lt; <span class="number">0</span> || y &gt;= col || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span> + dfs(matrix, x, y, row, col, cache);</span><br><span class="line">            max = Math.max(len, max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache[i][j] = max;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="岛屿计数2">岛屿计数2</h2><h2 id="Count_of_Smaller_Numbers_After_Self(数组计数)">Count of Smaller Numbers After Self(数组计数)</h2><h3 id="题目描述-4">题目描述</h3><p>给定一个数组nums,返回一个计数数组count，count[i]表示nums中第i个右边有多少个数小于nums[i]<br>Example:<br>nums = [5, 2, 6, 1]<br>输出[2,1,1,0]</p>
<h3 id="分析解答-3">分析解答</h3><p>此题不难给出O(N^2)的算法，先穷举nums中每个位置i，再穷举右边的数计算有多少个小于nums[i]。难点在于利用数据结构进行优化从而降低时间复杂度。线段树（segment tree）和平衡树（Balanced Binary Tree）是两种可以使用的数据结构。</p>
<p>线段树的每个节点表示一段区间，记录这个区间的某些信息，其基本思想是把区间一分为二，二分为四。。。直到不可再分（因此叶子节点的区间只包含一个数），如此可以把任意区间表示成log（区间大小）个子区间的拼接，以降低查询时间复杂度。在本题中，假设nums中的数字范围在0到maxnum之间，那么建树的区间为[0,maxnum]（也就是根节点所表示的区间）。每个节点记录其表示区间内的数字个数。本题涉及两种线段树基本操作：插入和查询。插入操作把nums[i]插入到线段树相应位置，同时对所有经过的区间的sum值进行累加；查询操作需要查询区间[0,nums[i]-1]所包含的数字个数，利用已经建好的线段树把查询区间分割为若干个节点所表示的区间，统计并返回这些节点的sum值之和。</p>
<p>平衡树用途更广，代码复杂度也更高，是一种保持叶子节点深度平衡的二叉搜索树，有多种方法实现，因篇幅有限不再赘述，大家可以自行在网上搜索学习。</p>
<h2 id="翻转游戏（Flip_Game_II）">翻转游戏（Flip Game II）</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&amp;mid=401839317&amp;idx=1&amp;sn=0660926cc1e5edab1b92aa8160fa93e6&amp;scene=21#wechat_redirect" target="_blank" rel="external">详见</a></p>
<p>搜索+回溯：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWin</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] state = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span>)&#123;</span><br><span class="line">        state[i] = <span class="keyword">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        state[i] = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search(state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">boolean</span>[] state)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; state.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="comment">//连续加号</span></span><br><span class="line">      <span class="keyword">if</span>(state[i] &amp;&amp; state[i+<span class="number">1</span>])&#123;</span><br><span class="line">        state[i] = <span class="keyword">false</span>;</span><br><span class="line">        state[i+<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//不能继续翻转</span></span><br><span class="line">        <span class="keyword">if</span>(!search(state))&#123;</span><br><span class="line">          state[i] = <span class="keyword">true</span>;</span><br><span class="line">          state[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//能继续翻转，回溯</span></span><br><span class="line">          state[i] = <span class="keyword">true</span>;</span><br><span class="line">          state[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="吹气球">吹气球</h2><h3 id="题目描述-5">题目描述</h3><p>有n个气球，编号为0到n-1，每个气球都有一个分数，存在nums数组中。每次吹气球i可以得到的分数为 nums[left] <em> nums[i] </em> nums[right]，left和right分别表示i气球相邻的两个气球。当i气球被吹爆后，其左右两气球即为相邻。要求吹爆所有气球，得到最多的分数。<br>注释:<br>(1) 你可以假设nums[-1] = nums[n] = 1<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>Example:<br>给出[3, 1, 5, 8]<br>返回167</p>
<p>dp解法：<br>Definition:<br>     dp[i][j]表示吹爆i到j之间的气球所能得到的最大分数</p>
<p>Function:<br>     dp[i][j] = max(dp[i][k-1] + score(k) + dp[k+1][j]) 对于所有k属于{i,j}</p>
<p>Intialize:<br>     dp[i][i] = 0 for each i.</p>
<p>Answer:<br>     dp[1][n]</p>
<h2 id="题目链接">题目链接</h2><p><a href="http://posts.careerengine.us/p/579993895afff74f7f7f9e42" target="_blank" rel="external">题目</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="轴对称">轴对称</h2><h3 id="题目描述">题目描述</h3><p>给定平面上的n个点，问是否存在一条平行于y轴的直线，使得这n个点相对于这条直线对称。</p>
<p><strong>Follow-up</strong><br>是否存在一条直线使得这n个]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Kth Smallest Element in a Sorted Matrix]]></title>
    <link href="http://blog.noobsky.com/2016/10/07/LeetCode-Kth-Smallest-Element-in-a-Sorted-Matrix/"/>
    <id>http://blog.noobsky.com/2016/10/07/LeetCode-Kth-Smallest-Element-in-a-Sorted-Matrix/</id>
    <published>2016-10-07T11:51:14.000Z</published>
    <updated>2016-10-08T08:32:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p><strong>Example:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">9</span>],</span><br><span class="line">   [<span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">   [<span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>]</span><br><span class="line">],</span><br><span class="line">k = <span class="number">8</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">13.</span></span><br></pre></td></tr></table></figure></p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ n2.</p>
<h2 id="解题思路">解题思路</h2><p>每一列、每一行都是有序的。其实这个问题类似k路归并排序。全部行或者全部列就是那k路有序数组。<br>可以利用最小堆。<br>首先利用第一行（或第一列）构造最小堆。然后进行k-1次取出最小堆的堆顶元素，取出堆顶元素之后，将所取堆顶元素所在列的下一元素加入最小堆中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int n = matrix.length;</span></span><br><span class="line">        PriorityQueue&lt;Tuple&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> bound = matrix.length &lt; k ? matrix.length : k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; i++) pq.offer(<span class="keyword">new</span> Tuple(<span class="number">0</span>,i,matrix[<span class="number">0</span>][i]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            Tuple t = pq.poll();</span><br><span class="line">            <span class="comment">//已经是某列的最后一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(t.row == matrix.length-<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> Tuple(t.row+<span class="number">1</span>, t.col, matrix[t.row+<span class="number">1</span>][t.col]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要知道元素对应的行或者列，所以使用Tuple类表示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tuple</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, col, val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.row = row;</span><br><span class="line">        <span class="keyword">this</span>.col = col;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Tuple that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - that.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest eleme]]>
    </summary>
    
      <category term="Binary Search" scheme="http://blog.noobsky.com/tags/Binary-Search/"/>
    
      <category term="Heap" scheme="http://blog.noobsky.com/tags/Heap/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Binary Watch]]></title>
    <link href="http://blog.noobsky.com/2016/10/07/LeetCode-Binary-Watch/"/>
    <id>http://blog.noobsky.com/2016/10/07/LeetCode-Binary-Watch/</id>
    <published>2016-10-07T09:26:43.000Z</published>
    <updated>2016-10-07T09:46:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).</p>
<p>Each LED represents a zero or one, with the least significant bit on the right.<br><img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" alt=""></p>
<p>For example, the above binary watch reads “3:25”.</p>
<p>Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>
<p>Example:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Input</span>: <span class="keyword">n</span> = 1</span><br><span class="line"><span class="keyword">Return</span>: [<span class="string">"1:00"</span>, <span class="string">"2:00"</span>, <span class="string">"4:00"</span>, <span class="string">"8:00"</span>, <span class="string">"0:01"</span>, <span class="string">"0:02"</span>, <span class="string">"0:04"</span>, <span class="string">"0:08"</span>, <span class="string">"0:16"</span>, <span class="string">"0:32"</span>]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The order of output does not matter.</li>
<li>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</li>
<li>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</li>
</ul>
<h2 id="解题思路">解题思路</h2><p>思路特别巧妙，有多少个LEDs亮说明表示的时间中代表的二进制中有多少个比特1。<br>我们可以将时间表示转化为二进制，高四位代表时，低六位代表分钟。时间表示3:25转化为二进制位0011:011001，这样处理之后则问题转化为求时间二进制表示中比特位为1的数量为num的时间表示的全部情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; times = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; h++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; m++)&#123;</span><br><span class="line">                <span class="comment">// if(Integer.bitCount((h&lt;&lt;6) + m) == num)&#123;</span></span><br><span class="line">                <span class="comment">//     times.add(String.format("%d:%02d", h, m));</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">//或者</span></span><br><span class="line">                <span class="keyword">if</span>(Integer.bitCount(h)+Integer.bitCount(m) == num)&#123;</span><br><span class="line">                    times.add(String.format(<span class="string">"%d:%02d"</span>, h, m));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP]]></title>
    <link href="http://blog.noobsky.com/2016/10/07/HTTP/"/>
    <id>http://blog.noobsky.com/2016/10/07/HTTP/</id>
    <published>2016-10-07T02:30:19.000Z</published>
    <updated>2016-10-07T07:51:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="网络基础TCP/IP">网络基础TCP/IP</h2><h3 id="TCP/IP的分层管理">TCP/IP的分层管理</h3><p>TCP/IP协议族重要的一点就是分层。分为以下四层：应用层、传输层、网络层、数据链路层。</p>
<p><strong>应用层</strong><br>应用层决定了向用户提供应用服务时通信的活动</p>
<p>应用服务包括FTP、DNS、HTTP等</p>
<p><strong>传输层</strong></p>
<p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。<br>传输层协议包括TCP（传输控制协议）和UDP（用户数据报协议）</p>
<p><strong>网络层</strong><br>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。</p>
<p>网络层所起的作用就是在众多的选项内选择一条传输路线。</p>
<p><strong>链路层</strong><br>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p>
<h3 id="TCP/IP通信传输流">TCP/IP通信传输流</h3><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p>以HTTP举例来说：<br>首先作为发送端的客户端在应用层（HTTP协议）发送一个想看某个Web页面的HTTP请求。</p>
<p>接着为了传输方便，在传输层（TCP协议）把从应用层收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号即端口号后转发给网络层。</p>
<p>在网络层(IP协议)，增加作为通信目的地的MAC地址后转发给链路层。</p>
<p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客服端发送过来的HTTP请求。发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，没经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装。</p>
<h3 id="与HTTP关系密切的协议：IP、TCP和DNS">与HTTP关系密切的协议：IP、TCP和DNS</h3><h4 id="负责传输的IP协议">负责传输的IP协议</h4><p>IP协议位于网络层。作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要条件是IP地址和MAC地址。</p>
<p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变，但MAC地址一般不变。</p>
<p><strong>利用ARP协议获取MAC地址进行通信</strong></p>
<p>IP间的通信依赖MAC地址。网络上，通信双方在同一局域网内的情况很少，通常经过多台计算机和网络设备中转才能连接对方。而在中转时，利用MAC地址搜索下一个中转目标。利用ARP协议（地址解析协议）可以根据通信方的IP地址获取对应的MAC地址。</p>
<h4 id="确保可靠性的TCP协议">确保可靠性的TCP协议</h4><p>TCP位于传输层，提供可靠的字节流服务。<br>字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。</p>
<p><strong>确保数据能到达目标</strong></p>
<p>为了准确无误地将数据送达目标，TCP协议采用了三次握手策略。发送端首先发送一个带有SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表握手结束。</p>
<h3 id="负责域名解析的DNS服务">负责域名解析的DNS服务</h3><p>DNS服务位于应用层，提供域名到IP地址之间的解析服务。</p>
<h2 id="简单的HTTP协议">简单的HTTP协议</h2><h3 id="HTTP协议用于客户端和服务端之间的通信">HTTP协议用于客户端和服务端之间的通信</h3><p>请求访问的文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。</p>
<h3 id="通过请求和响应交换达成通信">通过请求和响应交换达成通信</h3><h3 id="HTTP是不保存状态的协议">HTTP是不保存状态的协议</h3><p>HTTP是无状态协议，也就说HTTP协议对于发送过的请求或响应都不做持久化处理。</p>
<p>HTTP为了实现保存状态的功能引入了Cookie技术。</p>
<h3 id="请求URI定位资源">请求URI定位资源</h3><h3 id="告知服务器意图的HTTP方法">告知服务器意图的HTTP方法</h3><ul>
<li><p>GET：获取资源</p>
</li>
<li><p>POST：传输实体主体</p>
</li>
<li><p>PUT：传输文件</p>
</li>
<li><p>HEAD：获取报文首部</p>
</li>
<li><p>DELETE：删除文件</p>
</li>
<li><p>OPTIONS：询问支持的方法</p>
</li>
<li><p>TRACE：追踪路径</p>
</li>
<li><p>CONNECT：要求用隧道协议连接代理</p>
</li>
</ul>
<h3 id="持久连接节省通信量">持久连接节省通信量</h3><p><strong>持久连接</strong></p>
<p>持久连接（HTTP Persistent Connections也称为HTTP keep-alive或者HTTP connection reuse）的方法。持久连接的特点是只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p>
<p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>
<p><strong>管线化</strong><br>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。以前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p>
<p>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应。</p>
<h3 id="使用Cookie的状态管理">使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p>
<p>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
<p>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<h2 id="HTTP报文">HTTP报文</h2><h3 id="请求报文">请求报文</h3><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。报文的一般格式如下：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;request-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;blank line&gt;</span><br><span class="line"></span><br><span class="line"><span class="annotation">[&lt;request-body&gt;]</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>请求行</li>
</ul>
<p>请求行由请求方法、URL字段和HTTP协议版本3个字段组成，由空格分隔。例如：GET /index.html HTTP/1.1。<br>HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p>
<ul>
<li><p>请求头部<br>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：<br>User-Agent: 产生请求的浏览器类型<br>Accept: 客户端可识别的内容类型列表。<br>Host: 请求主机名，允许多个域名同处于一个IP地址，即虚拟主机。</p>
</li>
<li><p>空行<br>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
</li>
<li><p>请求数据</p>
</li>
</ul>
<p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>
<h3 id="响应报文">响应报文</h3><p>HTTP响应也由三个部分组成，分别是：状态行、消息报头、空行和响应正文。格式如下：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;status-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;blank line&gt;</span><br><span class="line"></span><br><span class="line"><span class="annotation">[&lt;response-body&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p>
<p>状态行格式如下：</p>
<p>HTTP-Version Status-Code Reason-Phrase CRLF</p>
<p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p>
<p>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。</p>
<p>常见状态代码、状态描述的说明如下。</p>
<ul>
<li>200 OK：客户端请求成功。</li>
<li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li>
<li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li>
<li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li>
<li>500 Internal Server Error：服务器发生不可预期的错误。</li>
<li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<h2 id="编码提升传输速率">编码提升传输速率</h2><h3 id="压缩传输的内容编码">压缩传输的内容编码</h3><h3 id="分割发送的分块传输编码">分割发送的分块传输编码</h3><h2 id="HTTP状态码">HTTP状态码</h2><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">类别</th>
<th style="text-align:left">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">Informational（信息性状态码）</td>
<td style="text-align:left">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">Success （成功状态码）</td>
<td style="text-align:left">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">Redirection（重定向状态码）</td>
<td style="text-align:left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">Client Error（客户端错误状态码）</td>
<td style="text-align:left">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">Server Error（服务器错误状态码）</td>
<td style="text-align:left">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h2 id="确保Web安全的HTTPS">确保Web安全的HTTPS</h2><h3 id="HTTP的缺点">HTTP的缺点</h3><ul>
<li>通信使用明文（不加密），内容可能会被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭篡改</li>
</ul>
<h3 id="HTTP+加密+认证+完整性保护=HTTPS">HTTP+加密+认证+完整性保护=HTTPS</h3><h4 id="HTTP加上加密处理和认证以及完整性保护后即是HTTPS">HTTP加上加密处理和认证以及完整性保护后即是HTTPS</h4><h4 id="HTTPS是身披SSL外壳的HTTP">HTTPS是身披SSL外壳的HTTP</h4><p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。</p>
<p>通常HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。</p>
<h4 id="相互交换密钥的公开密钥加密技术">相互交换密钥的公开密钥加密技术</h4><ul>
<li>共享密钥加密（对称加密）的困境<br>加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也叫对称密钥加密。</li>
</ul>
<p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？因为只要拿到密钥任何人都能破解密码。</p>
<ul>
<li>使用两把密钥的公开密钥加密（非对称加密）</li>
</ul>
<p>公开密钥加密方式可以很好地解决共享密钥加密的困难。<br>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。私钥需要自行进行保护！公钥可以随便分享。</p>
<p>同时，生成的这个“私钥-公钥”对还有个强大的功能就是，使用私钥加密的信息，只能由该私钥对应的公钥才能解密，使用公钥加密的信息，只能由该公钥对应的私钥才能解密！</p>
<ul>
<li>HTTPS采用混合加密机制</li>
</ul>
<p>HTTPS采用共享密钥（对称）加密和公开密钥加密（非对称）两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p>
<p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立的通信交换报文阶段则使用共享密钥加密方式。</p>
<h4 id="证明公开密钥正确性的证书">证明公开密钥正确性的证书</h4><p>公开密钥加密方式存在的问题是无法证明公开密钥本身就是货真价实的公开密钥。公开密钥传输途中，可能被攻击者替换掉。</p>
<p>为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。</p>
<p>首先,服务器的 运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构 在判明提出申请者的身份之后,会对已申请的公开密钥做数字签名,然 后分配这个已签名的公开密钥,并将该公开密钥放入公钥证书后绑定在一起。</p>
<p>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户 端,以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接 称为证书。</p>
<p>接到证书的客户端可使用数字证书认证机构的公开密钥,对那张证 书上的数字签名进行验证,一旦验证通过,客户端便可明确两件事: 一,认证服务器的公开密钥的是真实有效的数字证书认证机构。二,服务器的公开密钥是值得信赖的。</p>
<p>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式 时,如何安全转交是一件很困难的事,因此,多数浏览器开发商发布版 本时,会事先在内部植入常用认证机关的公开密钥。</p>
<p><img src="http://7xonwi.com1.z0.glb.clouddn.com/https.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="网络基础TCP/IP">网络基础TCP/IP</h2><h3 id="TCP/IP的分层管理">TCP/IP的分层管理</h3><p>TCP/IP协议族重要的一点就是分层。分为以下四层：应用层、传输层、网络层、数据链路层。</p>
<p><strong>应用层</]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 8 新特性]]></title>
    <link href="http://blog.noobsky.com/2016/10/06/Java-8-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://blog.noobsky.com/2016/10/06/Java-8-新特性/</id>
    <published>2016-10-06T09:33:30.000Z</published>
    <updated>2016-10-06T14:38:40.000Z</updated>
    <content type="html"><![CDATA[<p>Java 8是Java 5（2004年发行）以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。本文会一一简要介绍。</p>
<h2 id="Java语言新特性">Java语言新特性</h2><h3 id="Lambda表达式和Functional接口">Lambda表达式和Functional接口</h3><p>Lambda表达式可以理解为简洁地传递匿名函数的一种方式（将函数作为一个方法的参数）。它没有名称，但它可以有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。写过函数式编程语言的程序员对这个概念一定并不陌生。</p>
<p>Java中Lambda表达式由逗号分隔的参数列表、-&gt;符号和函数体三部分组成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; System.out.println(e) );</span><br></pre></td></tr></table></figure>
<p>请注意参数e的类型是由编译器推测出来的。同时，你也可以通过把参数类型与参数包括在括号中的形式直接给出参数的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( ( String e ) -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure></p>
<p>在某些情况下lambda的函数体会更加复杂，这时可以把函数体放到在一对花括号中，就像在Java中定义普通函数一样。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; &#123;</span><br><span class="line">    System.out.print(e);</span><br><span class="line">    System.out.print(<span class="string">","</span>);</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<p>Lambda可以引用类的成员变量与局部变量（如果这些变量不是final的话，它们会被隐含的转为final，这样效率更高）。例如，下面两个代码片段是等价的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach(</span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach(</span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure></p>
<p>Lambda可能会返回一个值。返回值的类型也是由编译器推测出来的。如果lambda的函数体只有一行的话，那么没有必要显式使用return语句。下面两个代码片段是等价的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> result = e1.compareTo( e2 );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></p>
<p>如果表达式没有参数，你扔可以提供一对空的小括号，如同不含参数的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#125; doWork();</span><br></pre></td></tr></table></figure></p>
<p>语言设计者投入了大量精力来思考如何使现有的函数友好地支持lambda。最终采取的方法是：增加函数式接口的概念。对于只包含一个抽象方法的接口(除了隐含的Object对象的公共方法)，可以通过lambda表达式来创建该接口的对象。这种接口被称为函数式接口。像这样的接口，可以被隐式转换为lambda表达式。java.lang.Runnable与java.util.concurrent.Callable是函数式接口最典型的两个例子。在实际使用过程中，函数式接口是容易出错的：如有某个人在接口定义中增加了另一个方法，这时，这个接口就不再是函数式的了，并且编译过程也会失败。为了克服函数式接口的这种脆弱性并且能够明确声明接口作为函数式接口的意图，Java 8增加了一种特殊的注解@FunctionalInterface（Java 8中所有类库的已有接口都添加了@FunctionalInterface注解）。让我们看一下这种函数式接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要记住的一件事是：默认方法与静态方法并不影响函数式接口的契约，可以任意使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionalDefaultMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口的默认方法与静态方法">接口的默认方法与静态方法</h3><p>如果某个接口比如Collection添加了新方法，例如forEach，那么每个实现了Collection接口的自定义类就必须都实现该方法。这在Java中是完全无法接受的。</p>
<p>Java设计者们通过允许接口包含带有具体实现的方法（称为默认方法）来解决这个问题，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"Jaye"</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认方法终结了以前一种经典模式，即提供一个接口，以及一个实现接口的大多数或全部方法的抽象类，例如Collection/AbstractCollection，现在直接在接口中实现即可。</p>
<p>如果一个接口中定义了一个默认方法，而另外一个父类或者接口中又定义了一个同名的方法，选择方法的规则如下：</p>
<ol>
<li>选择父类中的方法。如果一个父类提供了具体的实现方法，那么接口中具有相同名称和参数的默认方法会被忽略。</li>
<li>接口冲突。如果一个父接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数类型的方法（不管该方法是否是默认方法），那么你必须通过覆盖该方法来解决冲突。</li>
</ol>
<p>某个类继承了某个父类并实现了某个接口，父类和接口有一个同名的方法，此时，只有父类中的方法会起作用，这是“类优先”规则。</p>
<p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。例如：</p>
<h3 id="方法引用">方法引用</h3><p>如果想传递给其他代码的操作已经有实现的方法，可以使用方法引用。</p>
<p>如果你希望不区分大小写地对字符串进行排序，那么可以传入方法引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings, String::compareToIgnoreCase)</span><br></pre></td></tr></table></figure></p>
<p>::操作符将方法名和对象或类的名字分隔开来。以下是三种主要的使用情况：</p>
<ul>
<li>对象::实例方法</li>
<li>类::静态方法</li>
<li>类::实例方法</li>
</ul>
<p>方法引用等同于提供方法参数的lambda表达式。<br>System.out::println等同于System.out.println(x)。相似的，Math::pow等同于(x, y) -&gt; Math.pow(x, y)。</p>
<p>在Arrays.sort(strings, String::compareToIgnoreCase)中第一个参数会成为执行方法的对象。例如：String::compareToIgnoreCase等同于(x, y) -&gt; x.compareToIgnoreCase(y)</p>
<p>还可以捕获方法中的this参数。例如this::equals就等同于x -&gt; this.equals(x)。也可以使用super对象。super::实例方法会使用this作为执行方法的对象，并调用父类中指定方法。</p>
<h3 id="重复注解">重复注解</h3><h3 id="更好的类型推测机制">更好的类型推测机制</h3><h3 id="扩展注解的支持">扩展注解的支持</h3><h2 id="Java编译器的新特性">Java编译器的新特性</h2><h3 id="参数名字">参数名字</h3><p>在Java 8中把这个获取参数名字的功能添加到语言层面（通过反射API与Parameter.getName()方法）与字节码文件（通过新版的javac的–parameters选项）中。</p>
<h2 id="Java类库的新特性">Java类库的新特性</h2><h3 id="Optional">Optional</h3><h3 id="Stream">Stream</h3><h3 id="Date/Time_API">Date/Time API</h3><h3 id="JavaScript引擎Nashorn">JavaScript引擎Nashorn</h3><h3 id="Base64">Base64</h3><h3 id="并行数组">并行数组</h3><h3 id="并发">并发</h3><h2 id="新的Java工具">新的Java工具</h2><p>Java 8带来了一些新的命令行工具。</p>
<h3 id="Nashorn引擎：jjs">Nashorn引擎：jjs</h3><h3 id="类依赖分析器jdeps">类依赖分析器jdeps</h3><h2 id="JVM的新特性">JVM的新特性</h2><p>PermGen空间被移除了，取而代之的是Metaspace（JEP 122）。JVM选项-XX:PermSize与-XX:MaxPermSize分别被-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。</p>
<h2 id="参考资料">参考资料</h2><p><a href="http://colobu.com/2014/10/28/secrets-of-java-8-functional-interface/" target="_blank" rel="external">Java 8函数式接口functional interface的秘密</a><br><a href="http://www.importnew.com/11908.html" target="_blank" rel="external">Java 8新特性终极指南</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java 8是Java 5（2004年发行）以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。本文会一一简要介绍。</p>
<h2 id="Java语言新特性">Java语言新特性</h2><h3 id="Lambda表达式和]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 8 CompletableFuture: 组合式异步编程]]></title>
    <link href="http://blog.noobsky.com/2016/10/06/Java-8-CompletableFuture-%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.noobsky.com/2016/10/06/Java-8-CompletableFuture-组合式异步编程/</id>
    <published>2016-10-06T08:52:54.000Z</published>
    <updated>2016-10-06T09:16:19.000Z</updated>
    <content type="html"><![CDATA[<p>Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。</p>
<p>虽然Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无畏的CPU资源，而且也不能及时得到计算结果。为什么不能使用观察者设计模式当计算结果完成及时通知监听者呢？</p>
<p>Nodejs采用回调的方式实现异步编程。Netty扩展了Java的Future接口提供了addListener等多个扩展方法。</p>
<p>Java 8中，新增加了一个包含50个方法左右的类：CompletableFuture，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p>
<p><a href="http://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="external"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用isDone方法检查计算是否完成，或者使用get阻塞住调用线程，直到计算完成返回结果，你也可以使用cancel方法停止任务的执行。</p>
<p>虽然Future以及相关使用方法提供了异步执行任务的能]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8之杂项改进]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8%E4%B9%8B%E6%9D%82%E9%A1%B9%E6%94%B9%E8%BF%9B/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8之杂项改进/</id>
    <published>2016-10-05T13:48:48.000Z</published>
    <updated>2016-10-06T02:03:14.000Z</updated>
    <content type="html"><![CDATA[<p>要点包括：</p>
<ul>
<li>用分隔符连接字符串的至简方法</li>
<li>Integer类现在支持无符号数学运算</li>
<li>Math类现在有了检测整数是否溢出的方法</li>
<li>使用Math.floorMod(x, n)代替x % n来处理x可能是负数的情况</li>
<li>Collocation(removeIf)和List(replaceAll, sort)中提供了很多新的方法</li>
<li>Files.lines可以延迟读取一个包含文件行的流</li>
<li>Files.list可以延迟列举目录下的项目，而且Files.walk可以递归遍历它们</li>
<li>对Base64提供了官方支持</li>
<li>Objects类中提供了对null参数的检查</li>
</ul>
<h2 id="字符串">字符串</h2><p>将多个字符串通过分隔符组合起来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String joined = String.join(<span class="string">"/"</span>, <span class="string">"usr"</span>, <span class="string">"local"</span>, <span class="string">"bin"</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="数字类">数字类</h2><p>7种数字类型的包装类提供了一个BYTES字段，以byte为单位来表示该类型的长度</p>
<p>8种原始类型包装类提供了静态的hashCode方法</p>
<p>Short、Integer、Long、Float和Double提供了sum、max和min，用来在流操作中作为聚合函数使用<br>Boolean包含了静态方法logicalAnd、logicalOr、logicalXor</p>
<p>Integer类实现了支持无符号数学运算。<br>。。。</p>
<h2 id="新的数学函数">新的数学函数</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>要点包括：</p>
<ul>
<li>用分隔符连接字符串的至简方法</li>
<li>Integer类现在支持无符号数学运算</li>
<li>Math类现在有了检测整数是否溢出的方法</li>
<li>使用Math.floorMod(x, n)代替x % n来处理x可能是]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8之并发增强]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%A2%9E%E5%BC%BA/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8之并发增强/</id>
    <published>2016-10-05T13:03:08.000Z</published>
    <updated>2016-10-05T13:48:43.000Z</updated>
    <content type="html"><![CDATA[<p>要点包括：</p>
<ul>
<li>使用updateAndGet/accumulateAndGet方法可以更容易地更新原子变量</li>
<li>在激烈得竞争环境下，LongAccumulator/DoubleAccumulator比AtomicLong/AtomicDouble效率更高</li>
<li>使用compute和merge方法可以更容易地更新ConcurrentHashMap中的元素项</li>
<li>ConcurrentHashMap提供了对键、值、键值对及元素项的各类操作，例如search、reduce和forEach</li>
<li>集合视图允许你将ConcurrentHashMap作为一个Set来使用</li>
<li>Arrays类提供了排序、填充及前缀操作的并行方法</li>
<li>完善的Future类允许你创建异步的操作</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>要点包括：</p>
<ul>
<li>使用updateAndGet/accumulateAndGet方法可以更容易地更新原子变量</li>
<li>在激烈得竞争环境下，LongAccumulator/DoubleAccumulator比AtomicLong/AtomicDo]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8之新的日期和时间API]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8%E4%B9%8B%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8之新的日期和时间API/</id>
    <published>2016-10-05T12:31:58.000Z</published>
    <updated>2016-10-05T12:50:52.000Z</updated>
    <content type="html"><![CDATA[<p>要点包括：</p>
<ul>
<li>所有java.time对象都是不可变的</li>
<li>一个瞬间(Instant)是时间线上的一个点(与Date类似)</li>
<li>在Java时间中，每天都是86400秒（即没有闰秒）</li>
<li>持续时间(Duration)是两个瞬间之间的时间</li>
<li>LocalDateTime没有时区信息</li>
<li>TemporalAdjuster的方法可以处理常用的日历计算，例如找到某个月的第一个星期二</li>
<li>ZonedDateTime是指时区中的某一个时间点(类似于Gregorian Calendar)</li>
<li>当处理带时区的时间时，请使用时段(Period)，而非Duration，以便将夏令时的变化考虑在内</li>
<li>使用DateTimeFormatter来格式化和解析日期和时间</li>
</ul>
<h2 id="时间线">时间线</h2><h2 id="本地日期">本地日期</h2><h2 id="日期校正器">日期校正器</h2><h2 id="本地时间">本地时间</h2><h2 id="带时区的时间">带时区的时间</h2><h2 id="格式化和解析">格式化和解析</h2><h2 id="与遗留代码互操作">与遗留代码互操作</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>要点包括：</p>
<ul>
<li>所有java.time对象都是不可变的</li>
<li>一个瞬间(Instant)是时间线上的一个点(与Date类似)</li>
<li>在Java时间中，每天都是86400秒（即没有闰秒）</li>
<li>持续时间(Duratio]]>
    </summary>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给大忙人看的Java SE 8之StreamAPI]]></title>
    <link href="http://blog.noobsky.com/2016/10/05/%E5%86%99%E7%BB%99%E5%A4%A7%E5%BF%99%E4%BA%BA%E7%9C%8B%E7%9A%84Java-SE-8%E4%B9%8BStreamAPI/"/>
    <id>http://blog.noobsky.com/2016/10/05/写给大忙人看的Java-SE-8之StreamAPI/</id>
    <published>2016-10-05T08:46:46.000Z</published>
    <updated>2016-10-07T07:52:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="从迭代器到Stream操作">从迭代器到Stream操作</h2><p>统计长单词的数量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String w : words)&#123;</span><br><span class="line">  <span class="keyword">if</span>(w.length() &gt; <span class="number">12</span>) count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java8之前的此种写法很难被并行计算。这也是Java8引入大量操作符的原因。在Java8中，实现相同功能的操作如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = words.stream().filter(w -&gt; w.length() &gt; <span class="number">12</span>).count();</span><br></pre></td></tr></table></figure></p>
<p>stream方法会为单词列表生成一个Stream。filter方法会返回另一个只包含单词长度大于12的Stream。count方法会将Stream化简为一个结果。</p>
<p>Stream与集合的区别：</p>
<ul>
<li>Stream自己不会存储元素。元素可能被存储在底层的集合中，或者根据需要产生出来。</li>
<li>Stream操作符不会改变源对象。相反，它们会返回一个持有结果的新Stream。</li>
<li>Stream操作符可能是延迟执行的。这意味着它们会等到需要结果的时候才执行。</li>
</ul>
<p>当你使用Stream时，你会通过三个阶段来建立一个操作流水线。</p>
<ol>
<li>创建一个Stream</li>
<li>在一个或多个步骤中，指定将初始Stream转换为另一个Stream的中间操作</li>
<li>使用一个终止操作来产生一个结果。该操作会强制它之前的延迟操作立即执行。</li>
</ol>
<h2 id="创建Stream">创建Stream</h2><p>通过Java8在Collection接口中新添加的stream方法，可以将任何集合转化为一个Stream。如果你面对的是一个数组，可以用静态的Stream.of方法将它转化为一个Stream。</p>
<h2 id="filter、map和flatMap方法">filter、map和flatMap方法</h2><p>filter是过滤器转换，产生一个包含符合某个特定条件的所有元素的新的流</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="从迭代器到Stream操作">从迭代器到Stream操作</h2><p>统计长单词的数量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line]]>
    </summary>
    
      <category term="Stream API" scheme="http://blog.noobsky.com/tags/Stream-API/"/>
    
      <category term="Java8" scheme="http://blog.noobsky.com/categories/Java8/"/>
    
  </entry>
  
</feed>
