<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-06-15T11:21:42.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[LeetCode]Majority Element I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/15/LeetCode-Majority-Element-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/15/LeetCode-Majority-Element-I-II/</id>
    <published>2016-06-15T08:00:45.000Z</published>
    <updated>2016-06-15T11:21:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Majority_Element_I">Majority Element I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and <font color="red">the majority element always exist in the array</font>.</p>
<h3 id="代码">代码</h3><p>比较常规的解法有使用HashMap计数，可以在线性时间解决，但是需要额外的内存，如果有内存限制则改方法不可取；也可以使用排序的方法，排序后出现次数超过一半的元素肯定在中间，直接返回即可。还可以使用位操作，建立一个大小为32的数组，将原数组每个数字的每位为1的数量存入这个数组。因为majorit element的数量超过一半，那么1的数量大于一半的一定是majori element的1，0的数量大于一半的，也一定是majori elemen的0。如此还原出那个majori elemen。该题最好的解法是使用摩尔投票算法，关于该算法详见维基百科<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm" target="_blank" rel="external">Boyer–Moore majority vote algorithm</a>。算法的主要思想是使用变量candidate表示当前候选众数和计数器count，从头遍历数组，如果当前数组元素与candidate相等，计算器count++。如果不相等且count等于0，将candidate置为当前元素且设置count为1；否则count–。</p>
<p>使用摩尔投票算法代码如下：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> majorityElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//自己的想法</span></span><br><span class="line">        <span class="comment">// if(nums == null || nums.length == 0) return -1;</span></span><br><span class="line">        <span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">        <span class="comment">// return nums[nums.length/2];</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>, candidate = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">count</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">count</span>++;</span><br><span class="line">                candidate = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate)&#123;</span><br><span class="line">                <span class="keyword">count</span>++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">count</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用摩尔投票算法选出的候选元素不一定是出现次数超过一半的元素，比如数组[1, 2, 3, 4, 5]返回5，我们应该在遍历一遍数组确认候选元素是否真的是出现次数超过一半的元素。但是题目中已经假设majority element肯定存在了，就不用检查了。</p>
<h2 id="Majority_Element_II">Majority Element II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.</p>
<p><strong> Hint: </strong></p>
<p>How many majority elements could it possibly have?</p>
<h3 id="代码-1">代码</h3><p>出现次数超过⌊ n/3 ⌋的元素小于等于2，我们稍微修改一下上面的摩尔投票算法，维护两个candidate和count，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//超过n/3的元素个数少于等于2</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; majorityElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> candidate1 = nums[<span class="number">0</span>], candidate2 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//这种写法当测试用例为[8,8,7,7,7]时不能通过</span></span><br><span class="line">            <span class="comment">// if(count1 == 0)&#123;</span></span><br><span class="line">            <span class="comment">//     candidate1 = nums[i];</span></span><br><span class="line">            <span class="comment">//     count1 = 1;</span></span><br><span class="line">            <span class="comment">// &#125;else if(count2 == 0)&#123;</span></span><br><span class="line">            <span class="comment">//     candidate2 = nums[i];</span></span><br><span class="line">            <span class="comment">//     count2 = 1;</span></span><br><span class="line">            <span class="comment">// &#125;else if(nums[i] == candidate1)&#123;</span></span><br><span class="line">            <span class="comment">//     count1++;</span></span><br><span class="line">            <span class="comment">// &#125;else if(nums[i] == candidate2)&#123;</span></span><br><span class="line">            <span class="comment">//     count2++;</span></span><br><span class="line">            <span class="comment">// &#125;else&#123;</span></span><br><span class="line">            <span class="comment">//     count1--;</span></span><br><span class="line">            <span class="comment">//     count2--;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count1 == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate1 = nums[i];</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count2 == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate2 = nums[i];</span><br><span class="line">                count2 = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count1 &gt; nums.length / <span class="number">3</span>) res.add(candidate1);</span><br><span class="line">        <span class="keyword">if</span>(count2 &gt; nums.length / <span class="number">3</span>) res.add(candidate2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是如果几个if-else写出如下形式不能AC：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(count1 == <span class="number">0</span>)&#123;</span><br><span class="line">             candidate1 = nums[i];</span><br><span class="line">             count1 = <span class="number">1</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count2 == <span class="number">0</span>)&#123;</span><br><span class="line">             candidate2 = nums[i];</span><br><span class="line">             count2 = <span class="number">1</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate1)&#123;</span><br><span class="line">             count1++;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == candidate2)&#123;</span><br><span class="line">             count2++;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             count1--;</span><br><span class="line">             count2--;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>当测试用例为[8, 8, 7, 7, 7]，正确答案为[8, 7]，但是程序只返回[7]。第一次循环时，因count1 == 0，则candidate1 = 8，count1 = 1；第二次循环时， 因count2 = 0，则candidate2 = 8，count2 = 1；第三次循环时，nums[2] == 7，count1–后为0，count2–后为0，第四、五次循环分别把candidate1和candidate2设置为7，所以最后统计时只有7。</p>
<h2 id="参考文献">参考文献</h2><p><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm" target="_blank" rel="external">Boyer–Moore majority vote algorithm</a><br><a href="http://www.geeksforgeeks.org/majority-element/" target="_blank" rel="external">Majority Element</a><br><a href="http://www.cs.utexas.edu/users/misra/scannedPdf.dir/FindRepeatedElements.pdf" target="_blank" rel="external">Finding Repeated Elements</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Majority_Element_I">Majority Element I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of size n, find the majority element. The majori]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Gas Station]]></title>
    <link href="http://blog.noobsky.com/2016/06/15/LeetCode-Gas-Station/"/>
    <id>http://blog.noobsky.com/2016/06/15/LeetCode-Gas-Station/</id>
    <published>2016-06-15T00:48:25.000Z</published>
    <updated>2016-06-15T05:06:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with <font color="red">an unlimited gas tank</font> and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p><strong> Note: </strong><br>The solution is guaranteed to be unique.</p>
<h2 id="代码">代码</h2><p>由题意我们可以得到两个性质：</p>
<ul>
<li>如果从station A出发不能到达 station B，那么A和B之间的任意station都不能到达B。（B是A第一个不能到达的station）</li>
<li>如果全部station的gas总和大于cost的总和，那么一定存在一个solution。</li>
</ul>
<p>第一个性质的简单证明：<br>假设C为A和B之间任一的加油站，我们要证明C也不能到达B。因为A不能到达B，所以A和B之间全部station的gas的总和小于cost的总和。从A出发，当到达C的时候（B是A第一个不能到达的station，A能到C），剩下的gas &gt;= 0，仍然不能到达B。因为从A到C带来了额外的gas然后从C出发都不能到达B，所以直接从C出发更不可能到达B。</p>
<p>第二个性质的证明直接从网上找的英文证明：）</p>
<ul>
<li><p>If there is only one gas station, it’s true.</p>
</li>
<li><p>If there are two gas stations a and b, and gas(a) cannot afford cost(a), i.e., gas(a) &lt; cost(a), then gas(b) must be greater than cost(b), i.e., gas(b) &gt; cost(b), since gas(a) + gas(b) &gt; cost(a) + cost(b); so there must be a way too.</p>
</li>
<li><p>If there are three gas stations a, b, and c, where gas(a) &lt; cost(a), i.e., we cannot travel from a to b directly, then:</p>
<ul>
<li><p>either if gas(b) &lt; cost(b), i.e., we cannot travel from b to c directly, then cost(c) &gt; cost(c), so we can start at c and travel to a; since gas(b) &lt; cost(b), gas(c) + gas(a) must be greater than cost(c) + cost(a), so we can continue traveling from a to b. Key Point: this can be considered as there is one station at c’ with gas(c’) = gas(c) + gas(a) and the cost from c’ to b is cost(c’) = cost(c) + cost(a), and the problem reduces to a problem with two stations. This in turn becomes the problem with two stations above.</p>
</li>
<li><p>or if gas(b) &gt;= cost(b), we can travel from b to c directly. Similar to the case above, this problem can reduce to a problem with two stations b’ and a, where gas(b’) = gas(b) + gas(c) and cost(b’) = cost(b) + cost(c). Since gas(a) &lt; cost(a), gas(b’) must be greater than cost(b’), so it’s solved too.</p>
</li>
</ul>
</li>
<li><p>For problems with more stations, we can reduce them in a similar way. In fact, as seen above for the example of three stations, the problem of two stations can also reduce to the initial problem with one station.</p>
</li>
</ul>
<p>根据以上性质可得以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sumGas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sumCost = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录开始station</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tank = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; i++)&#123;</span><br><span class="line">            sumGas += gas[i];</span><br><span class="line">            sumCost += cost[i];</span><br><span class="line">            </span><br><span class="line">            tank += gas[i] - cost[i];</span><br><span class="line">            <span class="comment">//tank小于0说明不能到达i，从下一个station i+1开始</span></span><br><span class="line">            <span class="keyword">if</span>(tank &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">                tank = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sumGas &gt;= sumCost ? start : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Remove Duplicates from Sorted List I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Remove-Duplicates-from-Sorted-List-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Remove-Duplicates-from-Sorted-List-I-II/</id>
    <published>2016-06-14T11:35:31.000Z</published>
    <updated>2016-06-14T15:18:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Remove_Duplicates_from_Sorted_List_I">Remove Duplicates from Sorted List I</h2><h3 id="题目描述">题目描述</h3><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
<h3 id="代码">代码</h3><ul>
<li>迭代</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	 <span class="comment">//迭代</span></span><br><span class="line">    <span class="comment">//链表有序，相同元素相邻，遍历单链表，如果当前节点和下一个节点的值相等删除下一个节点</span></span><br><span class="line">    <span class="comment">//否则跳到下一个节点继续处理</span></span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前节点和下一个节点的值相等，删除下一个节点，让当前节点的next指向下下个节点</span></span><br><span class="line">            <span class="keyword">if</span>(curr.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; curr.<span class="keyword">next</span>.val == curr.val)&#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = curr.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归</li>
</ul>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        //加上判断head.<span class="keyword">next</span> == <span class="literal">null</span>判断能够保证递归返回的给head.<span class="keyword">next</span>的节点不为空</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        head.<span class="keyword">next</span> = deleteDuplicates(head.<span class="keyword">next</span>);</span><br><span class="line">        //head.<span class="keyword">next</span>不会为空</span><br><span class="line">        <span class="keyword">return</span> head.val == head.<span class="keyword">next</span>.val ? head.<span class="keyword">next</span> : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Remove_Duplicates_from_Sorted_List_II">Remove Duplicates from Sorted List II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
<h3 id="代码-1">代码</h3><ul>
<li>递归</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; head.<span class="keyword">next</span>.val == head.val)&#123;</span><br><span class="line">            <span class="comment">//删除所有值相等的节点</span></span><br><span class="line">            <span class="keyword">while</span>(head.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; head.<span class="keyword">next</span>.val == head.val)&#123;</span><br><span class="line">                head = head.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时head是最后一个跟前面删除节点值相等的节点，不保留,其next节点才是distinc节点</span></span><br><span class="line">            <span class="comment">//所以递归处理head.next</span></span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(head.<span class="keyword">next</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//此时head节点没有出现重复，保留</span></span><br><span class="line">            head.<span class="keyword">next</span> = deleteDuplicates(head.<span class="keyword">next</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	    <span class="comment">//迭代</span></span><br><span class="line">    <span class="comment">//使用一个前驱指针pre指向上一个不重复的元素</span></span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.<span class="keyword">next</span> = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//出现重复元素，让curr指向最右边的重复元素</span></span><br><span class="line">            <span class="keyword">while</span>(curr.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; curr.<span class="keyword">next</span>.val == curr.val)&#123;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//目前没有出现重复节点，curr指向的是一个distinc numbers的节点</span></span><br><span class="line">            <span class="comment">//更新不重复节点pre为curr</span></span><br><span class="line">            <span class="comment">//没有出现重复节点是pre和curr相邻</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pre.<span class="keyword">next</span> == curr)&#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//出现了重复值的节点，curr指向最右边的重复节点，删除重复节点，pre.next = curr.next;</span></span><br><span class="line">                pre.<span class="keyword">next</span> = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = curr.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Remove_Duplicates_from_Sorted_List_I">Remove Duplicates from Sorted List I</h2><h3 id="题目描述">题目描述</h3><p>Given a sorted linked list,]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Palindrome Partitioning I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Palindrome-Partitioning-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Palindrome-Partitioning-I-II/</id>
    <published>2016-06-14T11:20:32.000Z</published>
    <updated>2016-06-14T11:33:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Palindrome_Partitioning_I">Palindrome Partitioning I</h2><h3 id="题目描述">题目描述</h3><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">"aa"</span>,<span class="string">"b"</span>],</span><br><span class="line">  [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; partition(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backTrack(s, <span class="number">0</span>, curr, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">void</span> backTrack(<span class="built_in">String</span> s, <span class="built_in">int</span> start, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; curr, <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = start; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//[0, 0]是回文时然后检查[0,1]然后[0,2]</span></span><br><span class="line">            <span class="comment">//检查[0,0],递归检查子字符串。</span></span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s, start, i))&#123;</span><br><span class="line">                curr.add(s.substring(start, i+<span class="number">1</span>));</span><br><span class="line">                backTrack(s, i+<span class="number">1</span>, curr, res);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断一个字符串是否为回文字符串</span></span><br><span class="line">    public boolean isPalindrome(<span class="built_in">String</span> s, <span class="built_in">int</span> left, <span class="built_in">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Palindrome_Partitioning_II">Palindrome Partitioning II</h2><h3 id="题目描述-1">题目描述</h3><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut.</p>
<h3 id="代码-1">代码</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Palindrome_Partitioning_I">Palindrome Partitioning I</h2><h3 id="题目描述">题目描述</h3><p>Given a string s, partition s such that every sub]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Pow(x,n)]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Pow-x-n/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Pow-x-n/</id>
    <published>2016-06-14T06:42:09.000Z</published>
    <updated>2016-06-14T06:46:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>mplement pow(x, n).</p>
<h2 id="代码">代码</h2><ul>
<li>递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            <span class="comment">//n = -n在n = Integer.MIN_VALUE时会溢出，而且溢出n的值为Integer.MIN_VALUE，也就是说n没变，手动修改</span></span><br><span class="line">            <span class="comment">//如果不知道溢出后刚好n没变，就用if else</span></span><br><span class="line">            <span class="keyword">if</span>(n == Integer.MIN_VALUE)&#123;</span><br><span class="line">                n = Integer.MAX_VALUE;</span><br><span class="line">                x = x * x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span> ? myPow(x * x, n / <span class="number">2</span>) : <span class="function">x * <span class="title">myPow</span><span class="params">(x * x, n / <span class="number">2</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// if(n &lt; 0)&#123;</span></span><br><span class="line">        <span class="comment">//     if(n == Integer.MIN_VALUE)&#123;</span></span><br><span class="line">        <span class="comment">//         x = 1 / x;</span></span><br><span class="line">        <span class="comment">//         x = x * x;</span></span><br><span class="line">        <span class="comment">//         n = Integer.MAX_VALUE;</span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//         n = -n;</span></span><br><span class="line">        <span class="comment">//         x = 1/x;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            <span class="comment">//n = -n在n = Integer.MIN_VALUE时会溢出，而且溢出n的值为Integer.MIN_VALUE，也就是说n没变，手动修改</span></span><br><span class="line">            <span class="comment">//如果不知道溢出后刚好n没变，就用if else</span></span><br><span class="line">            <span class="keyword">if</span>(n == Integer.MIN_VALUE)&#123;</span><br><span class="line">                n = Integer.MAX_VALUE;</span><br><span class="line">                x = x * x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>) ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>mplement pow(x, n).</p>
<h2 id="代码">代码</h2><ul>
<li>递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td cla]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Group Anagrams]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Group-Anagrams/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Group-Anagrams/</id>
    <published>2016-06-14T04:14:16.000Z</published>
    <updated>2016-06-14T04:51:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>, <span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong> Note: </strong> All inputs will be in lower-case.</p>
<h2 id="代码">代码</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution &#123;</span><br><span class="line">    <span class="comment">//同字母异序词排序后就是同一个词，所以可以用HashMap，key为排序后的词，value为对应的同字母异序词</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; groupAnagrams(<span class="keyword">String</span>[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">String</span>&gt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Map&lt;<span class="keyword">String</span>, List&lt;<span class="keyword">String</span>&gt;&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//Arrays.sort(strs);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">str</span>: strs)&#123;</span><br><span class="line">            <span class="comment">//直接转换为char数组用Arrays.sort排序，更简单:)</span></span><br><span class="line">            <span class="built_in">char</span>[] temp = <span class="built_in">str</span>.toCharArray();</span><br><span class="line">            Arrays.<span class="built_in">sort</span>(temp);</span><br><span class="line">            <span class="keyword">String</span> keyStr = <span class="keyword">String</span>.valueOf(temp);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.containsKey(keyStr)) <span class="built_in">map</span>.put(keyStr, <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;());</span><br><span class="line">            <span class="built_in">map</span>.<span class="built_in">get</span>(keyStr).<span class="built_in">add</span>(<span class="built_in">str</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">String</span>&gt;&gt;(<span class="built_in">map</span>.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”,]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Number of Islands I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Number-of-Islands-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Number-of-Islands-I-II/</id>
    <published>2016-06-14T02:45:10.000Z</published>
    <updated>2016-06-14T03:19:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Number_of_Islands_I">Number of Islands I</h2><h3 id="题目描述">题目描述</h3><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong> Example 1: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00000</span></span><br></pre></td></tr></table></figure>
<p>Answer: 1</p>
<p><strong> Example 2: </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br></pre></td></tr></table></figure>
<p>Answer: 3</p>
<p>给定一个由字符‘1’（陆地）和‘0’（水域）组成的二维网格地图，计算岛屿的个数。岛屿被水域环绕，由竖直或者水平方向邻接的陆地构成。你可以假设网格地图的四条边都被水域包围。</p>
<p>遍历矩阵的每一个点，如果为1（陆地），则岛屿数加1，然后将与该陆地邻接的陆地（1）置为0，因为这些陆地属于同一个岛屿。其实该题就是找出里面不相邻的只包含1的块的个数。</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == null || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">//DFS标记周围节点</span></span><br><span class="line">                    DFSMarking(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS标记周围节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSMarking</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] != <span class="string">'1'</span> ) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        DFSMarking(grid, i-<span class="number">1</span>, j);</span><br><span class="line">        DFSMarking(grid, i+<span class="number">1</span>, j);</span><br><span class="line">        DFSMarking(grid, i, j-<span class="number">1</span>);</span><br><span class="line">        DFSMarking(grid, i, j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Number_of_Islands_II">Number of Islands II</h2><h3 id="题目描述-1">题目描述</h3><h3 id="代码-1">代码</h3>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Number_of_Islands_I">Number of Islands I</h2><h3 id="题目描述">题目描述</h3><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count th]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Jump Game I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Jump-Game-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Jump-Game-I-II/</id>
    <published>2016-06-14T01:21:57.000Z</published>
    <updated>2016-06-14T02:30:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Jump_Game_I">Jump Game I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br>A = [2,3,1,1,4], return true.</p>
<p>A = [3,2,1,0,4], return false.</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//贪心</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//记录能到达的最大Index，i在后边需要用到，定义在for循环外边</span></span><br><span class="line">        <span class="keyword">int</span> maxReach = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意不要漏了i &lt;= maxReach，如果maxReach &lt; i，即最大能达到的下标比当前的index还小，则肯定不能到达数组的最后index</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length &amp;&amp; i &lt;= maxReach; i++)&#123;</span><br><span class="line">            <span class="comment">//更新能到达的最大Index</span></span><br><span class="line">            maxReach = Math.max(maxReach, i + nums[i]);</span><br><span class="line">            <span class="comment">//可以优化一下，已经能到达last Index，提前终止for循环</span></span><br><span class="line">            <span class="keyword">if</span>(maxReach &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//return i == nums.length;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Jump_Game_II">Jump Game II</h2><h3 id="题目描述-1">题目描述</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>For example:<br>Given array A = [2,3,1,1,4]</p>
<p>The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)</p>
<p><strong> Note: </strong><br>You can assume that you can always reach the last index.</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//number of jumps</span></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前能达到的最大Index</span></span><br><span class="line">        <span class="keyword">int</span> maxReach = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> nextMaxReach = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//终止条件是i &lt; nums.length - 1,比如只有一个元素[0]，则step = 0，不用进入循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span> &amp;&amp; i &lt;= maxReach; i++)&#123;</span><br><span class="line">            nextMaxReach = Math.max(nextMaxReach, i + nums[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i == maxReach)&#123;</span><br><span class="line">                step++;</span><br><span class="line">                maxReach = nextMaxReach;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不能到达last index，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> maxReach &gt;= nums.length - <span class="number">1</span> ? step : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Jump_Game_I">Jump Game I</h2><h3 id="题目描述">题目描述</h3><p>Given an array of non-negative integers, you are initially positioned at the ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Flatten Nested List Iterator]]></title>
    <link href="http://blog.noobsky.com/2016/06/14/LeetCode-Flatten-Nested-List-Iterator/"/>
    <id>http://blog.noobsky.com/2016/06/14/LeetCode-Flatten-Nested-List-Iterator/</id>
    <published>2016-06-14T00:54:28.000Z</published>
    <updated>2016-06-14T00:56:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a nested list of integers, implement an iterator to flatten it.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p><strong> Example 1: </strong><br>Given the list [[1,1],2,[1,1]],</p>
<p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</p>
<p><strong> Example 2: </strong><br>Given the list [1,[4,[6]]],</p>
<p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * // This is the interface that allows for creating nested lists.</span><br><span class="line"> * // You should not implement it, or speculate about its implementation</span><br><span class="line"> * public interface NestedInteger &#123;</span><br><span class="line"> *</span><br><span class="line"> *     // @return true if this NestedInteger holds a single integer, rather than a nested list.</span><br><span class="line"> *     public boolean isInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // @return the single integer that this NestedInteger holds, if it holds a single integer</span><br><span class="line"> *     // Return null if this NestedInteger holds a nested list</span><br><span class="line"> *     public Integer getInteger();</span><br><span class="line"> *</span><br><span class="line"> *     // @return the nested list that this NestedInteger holds, if it holds a nested list</span><br><span class="line"> *     // Return null if this NestedInteger holds a single integer</span><br><span class="line"> *     public List&lt;NestedInteger&gt; getList();</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">//使用栈，在构造函数中将List&lt;NestedInteger&gt;中的元素从后往前push到栈中，因为栈先进后出，pop时可以从前往后访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NestedIterator implements Iterator&lt;Integer&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;NestedInteger&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nestedList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(nestedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.pop().getInteger();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//stack为空时返回false，不为空时进入while循环，在循环中判断栈顶元素是单一的Integer，还是nested list</span></span><br><span class="line">    <span class="comment">//如果是单一的Integer元素，返回true，如果是nested list将nested list中的Integer从后往前push到栈中</span></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> boolean <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty())&#123;</span><br><span class="line">            NestedInteger curr = <span class="built_in">stack</span>.peek();</span><br><span class="line">            <span class="comment">//栈顶元素是单一的Integer元素，返回true</span></span><br><span class="line">            <span class="keyword">if</span>(curr.isInteger())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = curr.getList().size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(curr.getList().get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your NestedIterator object will be instantiated and called as such:</span><br><span class="line"> * NestedIterator i = new NestedIterator(nestedList);</span><br><span class="line"> * while (i.hasNext()) v[f()] = i.next();</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a nested list of integers, implement an iterator to flatten it.</p>
<p>Each element is either an integer, or]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Construct Binary Tree from Preorder/Postorder and Inorder Traversal]]></title>
    <link href="http://blog.noobsky.com/2016/06/13/LeetCode-Construct-Binary-Tree-from-Preorder-Postorder-and-Inorder-Traversal/"/>
    <id>http://blog.noobsky.com/2016/06/13/LeetCode-Construct-Binary-Tree-from-Preorder-Postorder-and-Inorder-Traversal/</id>
    <published>2016-06-13T15:29:51.000Z</published>
    <updated>2016-06-13T16:10:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal">Construct Binary Tree from Preorder and Inorder Traversal</h2><h3 id="题目描述">题目描述</h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong> Note: </strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>preorder[0]一定是树的根，然后在inorder中找到preorder[0],将inorder分成了两部分，前半部分是preorder[0]的左子树，右半部分是preorder[0]的右子树，然后在子数组中递归处理。</p>
<h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == null || inorder == null || preorder.length != inorder.length) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//preorder[0]一定是树的根，然后在inorder中找到preorder[0],将inorder分成了两部分，前半部分是preorder[0]</span></span><br><span class="line">    <span class="comment">//的左子树，右半部分是preorder[0]的右子树，然后在子数组中递归处理。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preorder.length - <span class="number">1</span> || inStart &gt; inEnd) <span class="keyword">return</span> null;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出preorder[preStart]在inorder中的下标</span></span><br><span class="line">        <span class="comment">//题目中假设没有重复元素</span></span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == preorder[preStart])&#123;</span><br><span class="line">                inIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.left = helper(preStart + <span class="number">1</span>, inStart, inIndex - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">        <span class="comment">//右子树根节点的索引：preStart + inIndex - inStart + 1，稍微举个例子算算就可以了</span></span><br><span class="line">        root.right = helper(preStart + inIndex - inStart + <span class="number">1</span>, inIndex + <span class="number">1</span>, inEnd, preorder, inorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法每次都要到inorder中线性搜索root节点的index，如果我们构造的的二叉树是平衡的，那么时间复杂度为O(nlgn)。如果构造的树退化为单链表（每个节点只有左/右节点），那么久需要O(n)的时间复杂度。我们可以使用HashMap缓存inorder中值和对应的index，将时间复杂度降到O(n)。修改后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == null || inorder == null || preorder.length != inorder.length) <span class="keyword">return</span> null;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, inorder, <span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//preorder[0]一定是树的根，然后在inorder中找到preorder[0],将inorder分成了两部分，前半部分是preorder[0]</span></span><br><span class="line">    <span class="comment">//的左子树，右半部分是preorder[0]的右子树，然后在子数组中递归处理。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, Map&lt;Integer, Integer&gt; <span class="built_in">map</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preorder.length - <span class="number">1</span> || inStart &gt; inEnd) <span class="keyword">return</span> null;</span><br><span class="line">    </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出preorder[preStart]在inorder中的下标</span></span><br><span class="line">        <span class="comment">//题目中假设没有重复元素</span></span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="built_in">map</span>.get(preorder[preStart]);</span><br><span class="line">        </span><br><span class="line">        root.left = helper(preStart + <span class="number">1</span>, inStart, inIndex - <span class="number">1</span>, preorder, inorder, <span class="built_in">map</span>);</span><br><span class="line">        <span class="comment">//右子树根节点的索引：preStart + inIndex - inStart + 1，稍微举个例子算算就可以了</span></span><br><span class="line">        root.right = helper(preStart + inIndex - inStart + <span class="number">1</span>, inIndex + <span class="number">1</span>, inEnd, preorder, inorder, <span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal">Construct Binary Tree from Inorder and Postorder Traversal</h2><h3 id="题目描述-1">题目描述</h3><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><strong> Note: </strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>postorder[postorder.length - 1]为树的根节点,然后在inorder中找到postorder[postorder.length - 1]的索引,将inorder分成两部分，分别为左右子树，然后递归处理。</p>
<h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(inorder == null || postorder == null || inorder.length != postorder.length) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">return</span> helper(postorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//postorder[postorder.length - 1]为树的根节点,然后在inorder中找到postorder[postorder.length - 1]的索引</span></span><br><span class="line">    <span class="comment">//将inorder分成两部分，分别为左右子树，递归处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> postEnd, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postEnd &lt; <span class="number">0</span> || inStart &gt; inEnd) <span class="keyword">return</span> null;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postEnd]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == postorder[postEnd])&#123;</span><br><span class="line">                inIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.left = helper(postEnd - (inEnd - inIndex) - <span class="number">1</span> ,inStart,inIndex - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">        root.right = helper(postEnd - <span class="number">1</span>, inIndex+<span class="number">1</span>, inEnd, inorder, postorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="http://articles.leetcode.com/construct-binary-tree-from-inorder-and-preorder-postorder-traversal" target="_blank" rel="external">Construct Binary Tree From Inorder and Preorder/Postorder Traversal</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal">Construct Binary Tree from Preorder and Inorder Traversal</h2><h3 id="题目描]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Lowest Common Ancestor of a Binary Search Tree or Search Tree]]></title>
    <link href="http://blog.noobsky.com/2016/06/13/LeetCode-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-or-Search-Tree/"/>
    <id>http://blog.noobsky.com/2016/06/13/LeetCode-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-or-Search-Tree/</id>
    <published>2016-06-13T08:09:00.000Z</published>
    <updated>2016-06-13T12:16:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Lowest_Common_Ancestor_of_a_Binary_Search_Tree">Lowest Common Ancestor of a Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    /              \</span><br><span class="line"> ___2__          ___8__</span><br><span class="line">/      \        /      \</span><br><span class="line"><span class="number">0</span>      _4       <span class="number">7</span>       <span class="number">9</span></span><br><span class="line">      /  \</span><br><span class="line">      <span class="number">3</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
<p>根据BST树的性质，可知，在遍历树的时候，如果当前节点的值都大于p和q节点的值，则p和q在当前节点的左子树中，则它们的LCA也在左子树；如果当前节点的值都小于p和q两个节点的值，则p和q在当前节点的右子树，在右子树中查找LCA。如果不是以上情况，则当前节点就是p和q的LCA。</p>
<h3 id="代码">代码</h3><ul>
<li>递归法</li>
</ul>
<p>时间复杂度O(h)，空间复杂度O(h)递归栈空间</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//p和q分居root的两边，lca为root</span></span><br><span class="line">        <span class="comment">//等价于</span></span><br><span class="line">        <span class="keyword">if</span>((root.<span class="keyword">val</span> - p.<span class="keyword">val</span>)*(root.<span class="keyword">val</span> - q.<span class="keyword">val</span>) &lt;= <span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//if((p.val &lt;= root.val &amp;&amp; root.val &lt;= q.val) || (q.val &lt;= root.val &amp;&amp; root.val &lt;= p.val)) return root;</span></span><br><span class="line">        <span class="comment">//p和q分居root的一边（左或右子树里）</span></span><br><span class="line">        root = p.<span class="keyword">val</span> &lt; root.<span class="keyword">val</span> ? root.left : root.right;</span><br><span class="line">        <span class="comment">//尾递归可以改写为迭代的形式</span></span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root, p,q);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>更clean的code：</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    return (root<span class="string">.val</span> - p<span class="string">.val)</span> * (root<span class="string">.val</span> - q<span class="string">.val)</span> &lt; 1 ? root :</span><br><span class="line">           lowestCommonAncestor(p<span class="string">.val</span> &lt; root<span class="string">.val</span> ? root<span class="string">.left</span> : root<span class="string">.right</span>, p, q);</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>一般我写下面朴实的写法：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//root.val大于p.val和q.val，则p和q在左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="keyword">val</span> &gt; p.<span class="keyword">val</span> &amp;&amp; root.<span class="keyword">val</span> &gt; q.<span class="keyword">val</span>) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="comment">//在右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.<span class="keyword">val</span> &lt; p.<span class="keyword">val</span> &amp;&amp; root.<span class="keyword">val</span> &lt; q.<span class="keyword">val</span>) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>迭代法</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾递归可以改写为迭代的形式</span></span><br><span class="line"><span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)&#123;</span><br><span class="line">    <span class="comment">//p、q各分居root同一侧：(p.val - root.val) * (root.val - q.val) &gt; 0表达式不对比如【2，1，3】分居两侧也大于0</span></span><br><span class="line">    <span class="comment">//正确的表达式为(root.val-p.val)*(root.val-q.val) &gt; 0</span></span><br><span class="line">    <span class="keyword">while</span>((root.<span class="keyword">val</span>-p.<span class="keyword">val</span>)*(root.<span class="keyword">val</span>-q.<span class="keyword">val</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        root = p.<span class="keyword">val</span> &lt; root.<span class="keyword">val</span> ? root.left : root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分居两侧时lca为root</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// while ((root.val - p.val) * (root.val - q.val) &gt; 0)</span></span><br><span class="line">    <span class="comment">//     root = p.val &lt; root.val ? root.left : root.right;</span></span><br><span class="line">    <span class="comment">//return root;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lowest_Common_Ancestor_of_a_Search_Tree">Lowest Common Ancestor of a Search Tree</h2><h3 id="题目描述-1">题目描述</h3><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line"><span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></span><br><span class="line">      /  \</span><br><span class="line">      <span class="number">7</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<p>可以利用深度优先搜索，从叶子节点向上，标记子树中出现目标节点的情况。如果子树中有目标节点，则通过返回该目标节点标记该子树有那个目标节点，如果没有，标记为null。如果左子树、右子树都有标记，说明p和q两个目标节点正好有一个在左子树中有一个在右子树中，则LCA就是当前节点。如果只有一个子树（左或右）有标记，则说明p和q都在这子树上，而且p或者q就是该子树的根节点，则p或者q就是LCA。</p>
<h3 id="代码-1">代码</h3><ul>
<li>递归法</li>
</ul>
<p>时间复杂度O(n)，空间复杂度O(h)栈空间<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> lowestCommonAncestor(<span class="type">TreeNode</span> root, <span class="type">TreeNode</span> p, <span class="type">TreeNode</span> q) &#123;</span><br><span class="line">        <span class="comment">//发现目标(p或q)节点就通过返回该目标节点标记该子树发现了某个目标节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == null || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">left</span> = lowestCommonAncestor(root.<span class="keyword">left</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">right</span> = lowestCommonAncestor(root.<span class="keyword">right</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//都不为空，说明p和q两个目标节点正好有一个在左子树中有一个在右子树中，则LCA为root</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span> != null &amp;&amp; <span class="keyword">right</span>  != null) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//如果left(或者right)不为空，而且left为p或者q节点，如果在left(left为p或者q)的子树中查找p和q的LCA，则必定是left</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span> != null ? <span class="keyword">left</span> : <span class="keyword">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法假设两个节点都在二叉树里，这里的题目也说了给定二叉树里的两个节点。如果这点不能保证，也就是一个节点在二叉树而另一个不在，那么该方法返回那个出现在二叉树中的节点，但是正确的做法是返回null。我们可以扩展上面的方法使得也能够正确处理这种情况，使用两个boolean变量v1和v2，如果p在二叉树中，则设置v1为true；如果q在二叉树中，设置v2为true。修改后的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> boolean v1, v2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> lowestCommonAncestor(<span class="type">TreeNode</span> root, <span class="type">TreeNode</span> p, <span class="type">TreeNode</span> q) &#123;</span><br><span class="line">        v1 = <span class="literal">false</span>;</span><br><span class="line">        v2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="type">LCA</span> = lowestCommonAncestorHelper(root, p, q);</span><br><span class="line">        <span class="keyword">if</span>(v1 &amp;&amp; v2) <span class="keyword">return</span> <span class="type">LCA</span>;</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> lowestCommonAncestorHelper(<span class="type">TreeNode</span> root, <span class="type">TreeNode</span> p, <span class="type">TreeNode</span> q) &#123;</span><br><span class="line">        <span class="comment">//发现目标(p或q)节点就通过返回该目标节点标记该子树发现了某个目标节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root == p)&#123;</span><br><span class="line">            v1 = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//注意！！！不能直接返回，如果直接返回，比如树为[2, 2], p = 2(root节点), q = 2(root.left节点)</span></span><br><span class="line">            <span class="comment">//会判断错误，因为只把v1设置为true之后就直接返回，但是v2也应该为true，应该在递归后加入代码：</span></span><br><span class="line">            <span class="comment">//if(root == p || root == q) return root;才能正确处理。</span></span><br><span class="line">            <span class="comment">//return root;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == q)&#123;</span><br><span class="line">            v2 = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//return root;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">left</span> = lowestCommonAncestorHelper(root.<span class="keyword">left</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查看左子树是否有目标节点，没有返回null，有的话返回目标节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="keyword">right</span> = lowestCommonAncestorHelper(root.<span class="keyword">right</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在这里判断返回才能正确处理类似树为[2, 2], p = 2(root节点), q = 2(root.left节点)的情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//都不为空，说明p和q两个目标节点正好有一个在左子树中有一个在右子树中，则LCA为root</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">left</span> != null &amp;&amp; <span class="keyword">right</span>  != null) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//如果left(或者right)不为空，而且left为p或者q节点，如果在left(left为p或者q)的子树中查找p和q的LCA，则必定是left</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span> != null ? <span class="keyword">left</span> : <span class="keyword">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代法</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        Map<span class="tag">&lt;TreeNode, TreeNode&gt;</span> parent = new HashMap<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        Deque<span class="tag">&lt;TreeNode&gt;</span> stack = new ArrayDeque<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        parent.put(root, null);</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        while (!parent.containsKey(p) || !parent.containsKey(q)) &#123;</span><br><span class="line">            TreeNode <span class="keyword">node</span><span class="identifier"> </span><span class="title">= stack</span>.pop();</span><br><span class="line">            if (<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span> != null) &#123;</span><br><span class="line">                parent.put(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>, <span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">                stack</span>.push(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">left</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            if (<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span> != null) &#123;</span><br><span class="line">                parent.put(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>, <span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">                stack</span>.push(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">right</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Set<span class="tag">&lt;TreeNode&gt;</span> ancestors = new HashSet<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            ancestors.add(p);</span><br><span class="line">            p = parent.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        while (!ancestors.contains(q))</span><br><span class="line">            q = parent.get(q);</span><br><span class="line">        return q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2><p><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/" target="_blank" rel="external">Lowest Common Ancestor in a Binary Search Tree</a><br><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/" target="_blank" rel="external">Lowest Common Ancestor in a Binary Tree</a><br><a href="https://segmentfault.com/a/1190000003509399" target="_blank" rel="external">Lowest Common Ancestor of a Binary Tree 最小公共祖先</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Lowest_Common_Ancestor_of_a_Binary_Search_Tree">Lowest Common Ancestor of a Binary Search Tree</h2><h3 id="题目描述">题目描述</h3><p>Given a]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]3Sum And 3Sum Closest]]></title>
    <link href="http://blog.noobsky.com/2016/06/13/LeetCode-3Sum-And-3Sum-Closest/"/>
    <id>http://blog.noobsky.com/2016/06/13/LeetCode-3Sum-And-3Sum-Closest/</id>
    <published>2016-06-13T06:46:13.000Z</published>
    <updated>2016-06-13T07:19:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="3Sum">3Sum</h2><h3 id="题目描述">题目描述</h3><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong> Note: </strong>The solution set must not contain duplicate triplets.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For example, given <span class="built_in">array</span> S = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">A solution <span class="built_in">set</span> is:</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这个题目跟3Sum Closest的思路都类似。首先排序，然后使用三个索引指针。</p>
<p>开始时：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">^  ^                                               ^</span><br><span class="line">|  |                                               |</span><br><span class="line">|  +- <span class="keyword">second</span>                                     <span class="keyword">third</span></span><br><span class="line">+-<span class="keyword">first</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>nums[first]+nums[second]+nums[third]</code>小于target，我们需要增大sum。所以讲second索引指针往右移动。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">^    ^                                             ^</span><br><span class="line">|    |                                             |</span><br><span class="line">|    +- <span class="keyword">second</span>                                   <span class="keyword">third</span></span><br><span class="line">+-<span class="keyword">first</span></span><br></pre></td></tr></table></figure>
<p>如果sum大于target，则我们需要减小sum。所以将third索引指针往前移动。如果sum等于target，那么我们返回sum或者加入到结果集中。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">^    ^                                          ^</span><br><span class="line">|    |                                          |</span><br><span class="line">|    +- <span class="keyword">second</span>                                <span class="keyword">third</span></span><br><span class="line">+-<span class="keyword">first</span></span><br></pre></td></tr></table></figure>
<p>当second和third相遇时，这一回合结束。将first往右移动开始下一回合，并且重置second和third。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">  ^    ^                                           ^</span><br><span class="line">  |    |                                           |</span><br><span class="line">  |    +- <span class="keyword">second</span>                                 <span class="keyword">third</span></span><br><span class="line">  +-<span class="keyword">first</span></span><br></pre></td></tr></table></figure></p>
<p>在这个过程中能得到满足条件的Sum或者Closest。最后三个索引指针聚集在数组末端。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----------------------------------------------------</span></span><br><span class="line">                                         ^    ^    ^</span><br><span class="line">                                         |    |    `- <span class="keyword">third</span></span><br><span class="line">                                         |    +- <span class="keyword">second</span></span><br><span class="line">                                         +-<span class="keyword">first</span></span><br></pre></td></tr></table></figure></p>
<h3 id="代码">代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; res = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//先排序，后面更好处理</span></span><br><span class="line">        <span class="type">Arrays</span>.<span class="built_in">sort</span>(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; nums.length -<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//进行nums[i] != nums[i-1]判断去除重复的结果，就不用利用集合去重了</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> ||(i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="comment">//先固定第一个数nums[i]，然后在数组的剩下部分查找两元素之和等于-nums[i]的组合</span></span><br><span class="line">                int sum = -nums[i];</span><br><span class="line">                <span class="comment">//使用两个索引指针，一头一尾进行扫荡</span></span><br><span class="line">                int <span class="keyword">left</span> = i+<span class="number">1</span>, <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] == sum)&#123;</span><br><span class="line">                        <span class="comment">//找到一种组合，加入结果集中</span></span><br><span class="line">                        res.add(<span class="type">Arrays</span>.asList(nums[i], nums[<span class="keyword">left</span>], nums[<span class="keyword">right</span>]));</span><br><span class="line">                        <span class="comment">//跳过重复元素</span></span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>+<span class="number">1</span>] == nums[<span class="keyword">left</span>]) <span class="keyword">left</span>++;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>-<span class="number">1</span>] == nums[<span class="keyword">right</span>]) <span class="keyword">right</span>--;</span><br><span class="line">                        <span class="keyword">left</span>++;</span><br><span class="line">                        <span class="keyword">right</span>--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] &lt; sum) <span class="keyword">left</span>++;<span class="comment">//数组有序，小于sum时，增大左边数才有可能相等</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">right</span>--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3Sum_Closest">3Sum Closest</h2><h3 id="题目描述-1">题目描述</h3><p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, given <span class="built_in">array</span> S = &#123;-<span class="number">1</span> <span class="number">2</span> <span class="number">1</span> -<span class="number">4</span>&#125;, and target = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is <span class="number">2.</span> (-<span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>
<h3 id="代码-1">代码</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">Solution</span> &#123;</span><br><span class="line">    public <span class="type">int</span> threeSumClosest(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        //如果nums.length&lt;<span class="number">3</span>,如何处理，随时沟通:)</span><br><span class="line">        </span><br><span class="line">        //排序，然后我们就能慢慢逼近target</span><br><span class="line">        <span class="type">Arrays</span>.sort(nums);</span><br><span class="line">        </span><br><span class="line">        //初始化结果，找三个数，nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[nums.length - <span class="number">1</span>]</span><br><span class="line">        <span class="type">int</span> <span class="literal">result</span> = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]; </span><br><span class="line">        //<span class="type">int</span> <span class="literal">result</span> = nums[<span class="number">0</span>] + nums[<span class="number">1</span>]+nums[nums.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(<span class="type">Math</span>.abs(<span class="literal">result</span> - target) &gt; <span class="type">Math</span>.abs(sum - target))&#123;</span><br><span class="line">                    <span class="literal">result</span> = sum;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="literal">result</span> == target) <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                //sum &gt; target ? right-- : left++;</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target) left++;</span><br><span class="line">                <span class="keyword">else</span> right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="3Sum">3Sum</h2><h3 id="题目描述">题目描述</h3><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Fi]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Search for a Range]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Search-for-a-Range/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Search-for-a-Range/</id>
    <published>2016-06-12T13:28:54.000Z</published>
    <updated>2016-06-12T13:49:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return <font color="red">[-1, -1]</font>.</p>
<p>For example,<br>Given <font color="red">[5, 7, 7, 8, 8, 10]</font> and target value 8,<br>return <font color="red">[3, 4]</font>.</p>
<p>找左边界：mid = (left+right)/2，下取整，往左偏。有以下三种可能：</p>
<ul>
<li>nums[mid] &lt; target, target在mid的右边，left = mid+1</li>
<li>nums[mid] &gt; target, target在mid的左边，right = mid-1</li>
<li>nums[mid] = target, 找左边界，所以right = mid</li>
</ul>
<p>2和3可以合并，合并后：if(nums[mid] &lt; target) left = mid+1; else right = mid;</p>
<p>找右边界：mid = (left+right)/2+1，上取整，往右偏。同理也有三种可能：</p>
<ul>
<li>nums[mid] &lt; target, target在mid的右边，left = mid+1</li>
<li>nums[mid] &gt; target, target在mid的左边，right = mid-1</li>
<li>nums[mid] = target, 找右边界，所以left = mid</li>
</ul>
<p>1和3可以合并，合并后：if(nums[mid] &gt; target) right = mid-1; else left = mid;</p>
<p>就是两种二分搜索的写法</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// 找左边界：mid = (left+right)/2，下取整，往左偏</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找左边界，所以right = mid</span></span><br><span class="line">    <span class="comment">// 2和3可以合并，合并后：if(nums[mid] &lt; target) left = mid+1; else right = mid;</span></span><br><span class="line">    <span class="comment">// 找右边界：mid = (left+right)/2+1，上取整，往右篇</span></span><br><span class="line">    <span class="comment">// 1.nums[mid] &lt; target, target在mid的右边，left = mid+1</span></span><br><span class="line">    <span class="comment">// 2.nums[mid] &gt; target, target在mid的左边，right = mid-1</span></span><br><span class="line">    <span class="comment">// 3.nums[mid] = target, 找右边界，所以left = mid</span></span><br><span class="line">    <span class="comment">// 1和3可以合并，合并后：if(nums[mid] &gt; target) right = mid-1; else left = mid;</span></span><br><span class="line">    <span class="comment">// 就是两种二分搜索的写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == null || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[left] != target) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> res[<span class="number">0</span>] = left;</span><br><span class="line">        </span><br><span class="line">        right = nums.length - <span class="number">1</span>;<span class="comment">//第二次时，left可以不重新设置为0，设置了也没错，多余而已</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//上取整</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有左边界，就一定能执行到这里，而且不用判断，right最起码等于前面判断左边界</span></span><br><span class="line">        res[<span class="number">1</span>] = right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algor]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Reverse Linked List I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Reverse-Linked-List-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Reverse-Linked-List-I-II/</id>
    <published>2016-06-12T07:24:14.000Z</published>
    <updated>2016-06-12T12:07:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Reverse_Linked_List_I">Reverse Linked List I</h2><h3 id="题目描述">题目描述</h3><p>Reverse a singly linked list.</p>
<p><strong> Hint: </strong><br>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<h3 id="代码">代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//遍历单链表，采用前插的方式构建单链表就能反转单链表</span></span><br><span class="line">        <span class="comment">//该循环可以改成尾递归的形式</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//后面会修改head.next的指向，先保存原始的head.next</span></span><br><span class="line">            <span class="comment">//先保存下一个前插的节点</span></span><br><span class="line">            ListNode <span class="keyword">next</span> = head.<span class="keyword">next</span>;</span><br><span class="line">            <span class="comment">//往前插入节点</span></span><br><span class="line">            head.<span class="keyword">next</span> = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = <span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse_Linked_List_II">Reverse Linked List II</h2><h3 id="题目描述-1">题目描述</h3><p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p>
<p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<p><strong> Note: </strong><br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p>
<h3 id="代码-1">代码</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> for singly-linked list.</span><br><span class="line"> * public <span class="keyword">class</span> <span class="type">ListNode</span> &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     <span class="type">ListNode</span> next;</span><br><span class="line"> *     <span class="type">ListNode</span>(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="title">public</span> <span class="keyword">class</span> <span class="type">Solution</span> &#123;</span><br><span class="line">    //链表的题目就要多用笔在草稿上多画画</span><br><span class="line">    public <span class="type">ListNode</span> reverseBetween(<span class="type">ListNode</span> head, int m, int n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == null) return head;</span><br><span class="line">        //虚拟头结点</span><br><span class="line">        <span class="type">ListNode</span> dummy = new <span class="type">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        //pre用来标记需要反转子链表头节点的前一节点</span><br><span class="line">        <span class="type">ListNode</span> pre = dummy;</span><br><span class="line">        </span><br><span class="line">        for(int i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) pre = pre.next;</span><br><span class="line">        //start节点指向需要反转的子链表的头结点</span><br><span class="line">        <span class="type">ListNode</span> start = pre.next;</span><br><span class="line">        //指向将被反转的结点</span><br><span class="line">        <span class="type">ListNode</span> <span class="keyword">then</span> = start.next;</span><br><span class="line">        </span><br><span class="line">        //<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>, m = <span class="number">2</span>, n = <span class="number">4</span>, pre = <span class="number">1</span>, start = <span class="number">2</span>, <span class="keyword">then</span> = <span class="number">3</span></span><br><span class="line">        //dummy-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">        </span><br><span class="line">        //我们需要将<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>有三个节点的子链表反转成dummy-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">        //我们只需要进行n-m=<span class="number">2</span>次交换：首先把<span class="number">3</span>交互到pre.next的位置变成dum-&gt;<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">        //然后将<span class="number">4</span>交互到pre.next的位置变成dummy-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">        </span><br><span class="line">        for(int i = <span class="number">0</span>; i &lt; n - m; i++)&#123;</span><br><span class="line">            start.next = <span class="keyword">then</span>.next;</span><br><span class="line">            <span class="keyword">then</span>.next = pre.next;</span><br><span class="line">            pre.next = <span class="keyword">then</span>;</span><br><span class="line">            //下一个需要反转的节点</span><br><span class="line">            <span class="keyword">then</span> = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化后：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         start </span><br><span class="line">          |</span><br><span class="line">dummy-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">	|     |</span><br><span class="line">       pre  <span class="keyword">then</span></span><br></pre></td></tr></table></figure></p>
<p>进入for循环执行第一次反转后：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">           start </span><br><span class="line">             |</span><br><span class="line">dummy-&gt;<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">	|        |</span><br><span class="line">       pre     <span class="keyword">then</span></span><br></pre></td></tr></table></figure></p>
<p>再次进入for循环进行第二次反转后：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              start </span><br><span class="line">                |</span><br><span class="line">dummy-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">	|           |</span><br><span class="line">       pre        <span class="keyword">then</span></span><br></pre></td></tr></table></figure>
<p>至此，循环结束，返回结果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Reverse_Linked_List_I">Reverse Linked List I</h2><h3 id="题目描述">题目描述</h3><p>Reverse a singly linked list.</p>
<p><strong> Hint: </str]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Linked List Cycle I II]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Linked-List-Cycle-I-II/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Linked-List-Cycle-I-II/</id>
    <published>2016-06-12T07:16:06.000Z</published>
    <updated>2016-06-12T07:19:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Linked_List_Cycle_I">Linked List Cycle I</h2><h3 id="题目描述">题目描述</h3><p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<p>判圈算法请看本博客中的<a href="http://noobsky.com/2016/04/30/Happy-Number%E4%B8%8EFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/" target="_blank" rel="external">Happy Number与Floyd判圈算法</a></p>
<h3 id="代码">代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//判圈算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> hasCycle(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Linked_List_Cycle_I-1">Linked List Cycle I</h2><h3 id="题目描述-1">题目描述</h3><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h3 id="代码-1">代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// public ListNode detectCycle(ListNode head) &#123;</span></span><br><span class="line">    <span class="comment">//     if(head == null) return head;</span></span><br><span class="line">    <span class="comment">//     ListNode slow = head, fast = head;</span></span><br><span class="line">    <span class="comment">//     boolean isCycle = false;</span></span><br><span class="line">    <span class="comment">//     while(fast != null &amp;&amp; fast.next != null)&#123;</span></span><br><span class="line">    <span class="comment">//         fast = fast.next.next;</span></span><br><span class="line">    <span class="comment">//         slow = slow.next;</span></span><br><span class="line">    <span class="comment">//         if(slow == fast )&#123;</span></span><br><span class="line">    <span class="comment">//             isCycle = true;</span></span><br><span class="line">    <span class="comment">//             break;</span></span><br><span class="line">    <span class="comment">//         &#125; </span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     if(isCycle == false) return null;</span></span><br><span class="line">    <span class="comment">//     //有circle</span></span><br><span class="line">    <span class="comment">//     slow = head;</span></span><br><span class="line">    <span class="comment">//     while(slow != fast)&#123;</span></span><br><span class="line">    <span class="comment">//         slow = slow.next;</span></span><br><span class="line">    <span class="comment">//         fast = fast.next;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return slow;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">boolean</span> isCycle = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast )&#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">                    slow = slow.<span class="keyword">next</span>;</span><br><span class="line">                    fast = fast.<span class="keyword">next</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Linked_List_Cycle_I">Linked List Cycle I</h2><h3 id="题目描述">题目描述</h3><p>Given a linked list, determine if it has a cycle in it.</p>
<]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Patching Array]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Patching-Array/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Patching-Array/</id>
    <published>2016-06-12T03:11:37.000Z</published>
    <updated>2016-06-12T03:53:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p>
<p><strong> Example 1: </strong><br>nums = [1, 3], n = 6<br>Return 1.</p>
<p>Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.<br>Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].<br>Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].<br>So we only need 1 patch.</p>
<p><strong> Example 2: </strong><br>nums = [1, 5, 10], n = 20<br>Return 2.<br>The two patches can be [2, 4].</p>
<p><strong> Example 3: </strong><br>nums = [1, 2, 2], n = 5<br>Return 0.</p>
<p>变量miss表示[0,n]中我们缺少的最小的和，也就是说nums中元素求和我们已经能得到[0,miss)范围内的数。遍历nums数组，如果nums[i] &lt;= miss,那么我们可以将我们能得到的和的范围[0,miss)扩充到[0, miss+nums[i])。如果nums[i] &gt; miss,那么我们将不能连续扩充[0,miss),也就是说[0, miss+nums[i])的一些元素我们不能得到，则这时我们需要patch元素，那么应该patch什么数？我们采用贪心算法，我们patch的元素为miss，因为选择miss可以得到最大的连续区间[0, miss+miss)</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 变量miss表示[0,n]中我们缺少的最小的和，也就是说nums中元素求和我们已经能得到[0,miss)范围内的数</span></span><br><span class="line">        <span class="comment">// 遍历nums数组，如果nums[i] &lt;= miss,那么我们可以将我们能得到的和的范围[0,miss)扩充到[0, miss+nums[i])</span></span><br><span class="line">        <span class="comment">// 如果nums[i] &gt; miss,那么我们将不能连续扩充[0,miss),也就是说[0, miss+nums[i])的一些元素我们不能得到，</span></span><br><span class="line">        <span class="comment">// 则这时我们需要patch元素，那么应该patch什么数？我们采用贪心算法，我们patch的元素为miss，因为选择miss</span></span><br><span class="line">        <span class="comment">// 可以得到最大的连续区间[0, miss+miss)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> miss = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//统计patch元素的数量</span></span><br><span class="line">        <span class="keyword">int</span> patch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(miss &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; nums.length &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">                miss = miss + nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                miss = miss + miss;</span><br><span class="line">                patch++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> patch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里程序有一个隐藏的bug，当测试用例为nums=[1,2,31,33], n=2147483647,程序运行到最后我们扩充miss的时候回超过Integer.MAX_VALUE即2147483647会造成miss溢出然后miss &lt;= n会一直为true，程序不能终止而超时。我们可以用long类型来表示miss或者在while的条件里增加miss &gt; 0的条件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 变量miss表示[0,n]中我们缺少的最小的和，也就是说nums中元素求和我们已经能得到[0,miss)范围内的数</span></span><br><span class="line">        <span class="comment">// 遍历nums数组，如果nums[i] &lt;= miss,那么我们可以将我们能得到的和的范围[0,miss)扩充到[0, miss+nums[i])</span></span><br><span class="line">        <span class="comment">// 如果nums[i] &gt; miss,那么我们将不能连续扩充[0,miss),也就是说[0, miss+nums[i])的一些元素我们不能得到，</span></span><br><span class="line">        <span class="comment">// 则这时我们需要patch元素，那么应该patch什么数？我们采用贪心算法，我们patch的元素为miss，因为选择miss</span></span><br><span class="line">        <span class="comment">// 可以得到最大的连续区间[0, miss+miss)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//long miss = 1;</span></span><br><span class="line">        <span class="keyword">int</span> miss = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//统计patch元素的数量</span></span><br><span class="line">        <span class="keyword">int</span> patch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//while(miss &lt;= n)&#123;</span></span><br><span class="line">        <span class="keyword">while</span>(miss &gt; <span class="number">0</span> &amp;&amp; miss &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; nums.length &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">                miss = miss + nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                miss = miss + miss;</span><br><span class="line">                patch++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> patch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Insertion Sort List 和 Sort List]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Insertion-Sort-List/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Insertion-Sort-List/</id>
    <published>2016-06-12T02:32:38.000Z</published>
    <updated>2016-06-12T06:45:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Insertion_Sort_List">Insertion Sort List</h2><h3 id="题目描述">题目描述</h3><p>Sort a linked list using insertion sort.</p>
<h3 id="代码">代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode insertionSortList(ListNode head) &#123;</span><br><span class="line">        <span class="comment">//虚拟头结点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//每次用来查找元素插入位置，从头往后遍历有序部分</span></span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="comment">//当前插入的元素</span></span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//每次从头开始在有序部分查找插入位置</span></span><br><span class="line">            pre = dummy;</span><br><span class="line">            <span class="keyword">while</span>(pre.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; pre.<span class="keyword">next</span>.val &lt;= curr.val)&#123;</span><br><span class="line">                pre = pre.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将curr元素插入到pre和pre.next之间时会修改curr.next</span></span><br><span class="line">            <span class="comment">//需要将curr.next先保存起来，下一次循环才能找到下一个插入元素</span></span><br><span class="line">            ListNode <span class="keyword">next</span> = curr.<span class="keyword">next</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//插入位置为pre.next</span></span><br><span class="line">            <span class="comment">//将curr元素插入到pre和pre.next之间</span></span><br><span class="line">            curr.<span class="keyword">next</span> = pre.<span class="keyword">next</span>;</span><br><span class="line">            pre.<span class="keyword">next</span> = curr;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//下一个插入的元素</span></span><br><span class="line">            curr = <span class="keyword">next</span>;           </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sort_List">Sort List</h2><h3 id="题目描述-1">题目描述</h3><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<h3 id="代码-1">代码</h3><p>类似归并排序：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode sortList(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将list分为两部分</span></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//寻找链表中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.<span class="keyword">next</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">            fast = fast.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分为两部分，pre为空说明slow前面前面没有元素，前半部分单链表为空</span></span><br><span class="line">        <span class="comment">// if(pre != null) pre.next = null;</span></span><br><span class="line">        <span class="comment">// else head = null;</span></span><br><span class="line">        <span class="comment">//这里因为前面if(head == null || head.next == null) return head;保证了起码有两个元素才会往下运行</span></span><br><span class="line">        <span class="comment">//则保证会进入while循环，则pre一定不会为空(前半部分单链表不可能为空)，写成上面先判空也可以</span></span><br><span class="line">        <span class="comment">//置为空将链表割断</span></span><br><span class="line">        pre.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode l1 = sortList(head);</span><br><span class="line">        ListNode l2 = sortList(slow);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode merge(ListNode l1, ListNode l2)&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                current.<span class="keyword">next</span> = l1;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l1 = l1.<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current.<span class="keyword">next</span> = l2;</span><br><span class="line">                <span class="comment">//current = current.next;</span></span><br><span class="line">                l2 = l2.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(l1 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(l2 != null)&#123;</span></span><br><span class="line">        <span class="comment">//     current.next = l2;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        current.<span class="keyword">next</span> = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序跟<a href="http://noobsky.com/2016/06/02/LeetCode-Convert-Sorted-Array-List-to-Binary-Search-Tree/" target="_blank" rel="external">Convert Sorted List to Binary Search Tree</a>有点类似，可对比理解。但是该程序使用了递归，空间复杂度不为O(1)，每次递归需要用到栈，空间复杂度为O(lgn)。不过这里的O(lgn)的栈空间算不算空间复杂度。可以先跟面试官商量，或者我们使用迭代的方法来进行归并。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Insertion_Sort_List">Insertion Sort List</h2><h3 id="题目描述">题目描述</h3><p>Sort a linked list using insertion sort.</p>
<h3 id="代码">代码</]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Partition List]]></title>
    <link href="http://blog.noobsky.com/2016/06/12/LeetCode-Partition-List/"/>
    <id>http://blog.noobsky.com/2016/06/12/LeetCode-Partition-List/</id>
    <published>2016-06-12T01:10:15.000Z</published>
    <updated>2016-06-12T01:13:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<p>维护两个临时链表，然后遍历一个原链表，将val小于x的存到第一个临时链表中，其他的存到第二个临时链表中，最后将两个临时链接起来即可</p>
<h2 id="代码">代码</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//维护两个临时链表，然后遍历一个原链表，将val小于x的存到第一个临时链表中，</span></span><br><span class="line">    <span class="comment">//其他的存到第二个临时链表中，然后将两个临时链接起来即可</span></span><br><span class="line">    <span class="keyword">public</span> ListNode partition(ListNode head, <span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="comment">//维护虚拟头结点</span></span><br><span class="line">        ListNode dummy1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>), dummy2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr1 = dummy1, curr2 = dummy2;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">                curr1.<span class="keyword">next</span> = head;</span><br><span class="line">                curr1 = head; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr2.<span class="keyword">next</span> = head;</span><br><span class="line">                curr2 = head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2，最后curr2指向5，curr2.next指向2，</span></span><br><span class="line">        <span class="comment">//我们需要将curr2.next置为null，不然会出现circle</span></span><br><span class="line">        curr2.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将第一个链表跟第二个链表链接起来</span></span><br><span class="line">        curr1.<span class="keyword">next</span> = dummy2.<span class="keyword">next</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy1.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Triangle]]></title>
    <link href="http://blog.noobsky.com/2016/06/11/LeetCode-Triangle/"/>
    <id>http://blog.noobsky.com/2016/06/11/LeetCode-Triangle/</id>
    <published>2016-06-11T15:55:58.000Z</published>
    <updated>2016-06-11T15:57:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:<br>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<h2 id="代码">代码</h2><p>public class Solution {<br>    //bottom-up简单<br>    //状态转移方程：minpath[k][i] = min(minpath[k+1][i], minpath[k+1][i+1]) + triangle[k][i]<br>    //Or even better, since the row minpath[k+1] would be useless after minpath[k] is computed,<br>    //we can simply set minpath as a 1D array, and iteratively update itself:<br>    //For the kth level:minpath[i] = min(minpath[i], minpath[i+1])+triangle[k][i]<br>    public int minimumTotal(List<list<integer>&gt; triangle) {<br>        if(triangle == null || triangle.size() == 0) return 0;<br>        List<integer> res = new ArrayList&lt;&gt;(triangle.get(triangle.size()-1));</integer></list<integer></p>
<pre><code>    <span class="comment">//从倒数第二行开始</span>
    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="built_in">triangle</span>.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--){
        <span class="comment">//i行有i+1个元素</span>
        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt;= i; j++){
            res.<span class="built_in">set</span>(j, Math.<span class="built_in">min</span>(res.<span class="built_in">get</span>(j), res.<span class="built_in">get</span>(j+<span class="number">1</span>)) + <span class="built_in">triangle</span>.<span class="built_in">get</span>(i).<span class="built_in">get</span>(j)); 
        }
    }

    <span class="keyword">return</span> res.<span class="built_in">get</span>(<span class="number">0</span>);
}
</code></pre><p>}</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the ]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Bitwise AND of Numbers Range]]></title>
    <link href="http://blog.noobsky.com/2016/06/11/LeetCode-Bitwise-AND-of-Numbers-Range/"/>
    <id>http://blog.noobsky.com/2016/06/11/LeetCode-Bitwise-AND-of-Numbers-Range/</id>
    <published>2016-06-11T14:43:50.000Z</published>
    <updated>2016-06-11T15:05:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p>
<p>For example, given the range [5, 7], you should return 4.</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code"> bin     dec</span></span><br><span class="line"><span class="code"> 101       5</span></span><br><span class="line"><span class="code"> 110       6</span></span><br><span class="line"><span class="header"> 111       7</span><br><span class="line">-------------</span></span><br><span class="line"><span class="code"> 100       4</span></span><br></pre></td></tr></table></figure>
<p>再举一个例子<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code"> bin      dec</span></span><br><span class="line"><span class="code"> 1000       8 </span></span><br><span class="line"><span class="code"> 1001       9</span></span><br><span class="line"><span class="code"> 1010       10</span></span><br><span class="line"><span class="header"> 1011       11</span><br><span class="line">-------------</span></span><br><span class="line"><span class="code"> 1000       8</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出[m,n]范围内的书按位与的结果为m与n二进制表示左边（高位）的共同部分</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">//[m,n]范围内的书按位与的结果为m与n二进制表示左边（高位）的共同部分</span></span><br><span class="line">    <span class="comment">// public int rangeBitwiseAnd(int m, int n) &#123;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int step = 0;</span></span><br><span class="line">    <span class="comment">//     while(m != n)&#123;</span></span><br><span class="line">    <span class="comment">//         m &gt;&gt;= 1;</span></span><br><span class="line">    <span class="comment">//         n &gt;&gt;= 1;</span></span><br><span class="line">    <span class="comment">//         step++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return m&lt;&lt;step;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            i &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m*i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述">题目描述</h2><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://blog.noobsky.com/categories/Leetcode/"/>
    
  </entry>
  
</feed>
