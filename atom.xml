<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[NoobSky]]></title>
  <subtitle><![CDATA[Talk is cheap. Show me the code. - http://noobsky.com]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.noobsky.com/"/>
  <updated>2016-05-05T03:13:46.000Z</updated>
  <id>http://blog.noobsky.com/</id>
  
  <author>
    <name><![CDATA[Jaye]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[二叉树的层次遍历]]></title>
    <link href="http://blog.noobsky.com/2016/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>http://blog.noobsky.com/2016/05/05/二叉树的层次遍历/</id>
    <published>2016-05-05T02:28:49.000Z</published>
    <updated>2016-05-05T03:13:46.000Z</updated>
    <content type="html"><![CDATA[<h3 id="二叉树的层次遍历">二叉树的层次遍历</h3><p>二叉树的层次遍历是指从上往下，从左往右按层打印树的每个节点。一般可以使用DFS和BFS的方法。<br>首先给出二叉树的代码：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     int <span class="variable"><span class="keyword">val</span>;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode(int x) &#123; <span class="keyword">val</span></span> = x; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用BFS思想的代码如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">    <span class="comment">//对一般的分层遍历稍加改进，就能实现分行打印每一层</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一般的分层遍历都是每次循环从队列头中取出一个元素然后将其左右节点分别入队列，</span></span><br><span class="line">        TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">        res<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">        <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>left);</span><br><span class="line">        <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>right);            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展一">扩展一</h3><p>一般的二叉树的层次遍历所有结点都输出在同一行。如果希望仅仅同层结点输出在同一行，该如何修改代码？我们稍微修改一下上面的二叉树的层次遍历即可，详细见下面代码的注释。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">    <span class="comment">//对一般的分层遍历稍加改进，就能实现分行打印每一层</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">        <span class="comment">//先不急着出队列，记录队列的大小，相当于每层元素的个数</span></span><br><span class="line">        int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//一般的分层遍历都是每次循环从队列头中取出一个元素然后将其左右节点分别入队列，</span></span><br><span class="line">        <span class="comment">//改进后就是每次从队列头中取出levelNumber个元素,</span></span><br><span class="line">        <span class="comment">//然后将每个元素的左右节点分别入队列。</span></span><br><span class="line">        f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">            <span class="comment">//使用peek可以节省一个局部变量</span></span><br><span class="line">            <span class="comment">// if(queue.peek().left != null) queue.add(queue.peek().left);</span></span><br><span class="line">            <span class="comment">// if(queue.peek().right != null) queue.add(queue.peek().right);</span></span><br><span class="line">            <span class="comment">// subList.add(queue.poll().val);</span></span><br><span class="line">            <span class="comment">//使用局部变量,测试发现速度能稍微快一点</span></span><br><span class="line">            TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">            subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">            <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>left);</span><br><span class="line">            <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>add(node<span class="built_in">.</span>right);</span><br><span class="line">        &#125;</span><br><span class="line">        res<span class="built_in">.</span>add(subList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实我们也可以使用DFS的思想，代码如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(level &gt;= res<span class="built_in">.</span>size())&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res<span class="built_in">.</span>get(level)<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level+<span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展二">扩展二</h3><p>前面的讨论都是从上往下、从左往右分层遍历二叉树，那么如果希望自下往上、从左右往右遍历二叉树，该如何修改代码呢？<br>方法很简单，我们只要把扩展一中的结果反转一下就可以了。详见下面的代码。<br>使用BFS思想:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//使用LinkedList，不使用ArrayList，原因见后面</span></span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//将root加入队列中</span></span><br><span class="line">        <span class="built_in">queue</span><span class="built_in">.</span>offer(root);</span><br><span class="line">        <span class="keyword">while</span>(<span class="subst">!</span><span class="built_in">queue</span><span class="built_in">.</span>isEmpty())&#123;</span><br><span class="line">            int levelNumber = <span class="built_in">queue</span><span class="built_in">.</span>size();</span><br><span class="line">            LinkedList&lt;<span class="built_in">Integer</span>&gt; subList = <span class="literal">new</span> LinkedList();</span><br><span class="line">            f<span class="subst">or</span>(int i = <span class="number">0</span>; i &lt; levelNumber; i++)&#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span><span class="built_in">.</span>poll();</span><br><span class="line">                subList<span class="built_in">.</span>add(node<span class="built_in">.</span>val);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>left != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>left);</span><br><span class="line">                <span class="keyword">if</span>(node<span class="built_in">.</span>right != <span class="built_in">null</span>) <span class="built_in">queue</span><span class="built_in">.</span>offer(node<span class="built_in">.</span>right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//总是在0索引的位置插入每一层的遍历结果，最后遍历res的时候结果就是反过来的，即从下往上分层遍历</span></span><br><span class="line">            <span class="comment">//这里之所以使用LinkedList的原因是ArrayList的底层是数组，插入元素时需要移动大量的元素，效率低</span></span><br><span class="line">            <span class="comment">//而LinkedList的底层是链表，插入操作非常高效</span></span><br><span class="line">            res<span class="built_in">.</span>add(<span class="number">0</span>,subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用DFS思想：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrderBottom(TreeNode root)&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res = <span class="literal">new</span> LinkedList();</span><br><span class="line">        DFS(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> DFS(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; res, TreeNode root, int level)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res<span class="built_in">.</span>size() &lt;= level)&#123;</span><br><span class="line">            res<span class="built_in">.</span>add(<span class="number">0</span>, <span class="literal">new</span> LinkedList&lt;<span class="built_in">Integer</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res<span class="built_in">.</span>get(res<span class="built_in">.</span>size()-<span class="number">1</span><span class="attribute">-level</span>)<span class="built_in">.</span>add(root<span class="built_in">.</span>val);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>left, level + <span class="number">1</span>);</span><br><span class="line">        DFS(res, root<span class="built_in">.</span>right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="二叉树的层次遍历">二叉树的层次遍历</h3><p>二叉树的层次遍历是指从上往下，从左往右按层打印树的每个节点。一般可以使用DFS和BFS的方法。<br>首先给出二叉树的代码：<br><figure class="highlight kotlin"><table>]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://blog.noobsky.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Implement Queue using Stacks]]></title>
    <link href="http://blog.noobsky.com/2016/05/04/LeetCode-Implement-Queue-using-Stacks/"/>
    <id>http://blog.noobsky.com/2016/05/04/LeetCode-Implement-Queue-using-Stacks/</id>
    <published>2016-05-04T13:30:27.000Z</published>
    <updated>2016-05-05T03:34:11.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Implement the following operations of a queue using stacks.</p>
<p>push(x) – Push element x to the back of queue.<br>pop() – Removes the element from in front of queue.<br>peek() – Get the front element.<br>empty() – Return whether the queue is empty.<br>Notes:<br>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.<br>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.<br>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</p>
<p>题意很容易理解，就是利用栈实现队列的功能，我们知道栈是FILO即先进后出，而队列是FIFO即先进先出，我们如何才能利用栈的先进后出实现队列的先进先出呢？答案就是利用两个栈，一个栈是先进后出，两个先进后出的结果就是先进先出就是队列的功能。先把元素压入（push）第一个栈inputStack，然后从第一个栈inputStack中弹栈（pop），接着将弹出的元素压入（push）到第二个栈outputStack中。这样做之后我们先进栈的元素将位于第二个栈outputStack中栈顶，当我们需要从队头取出元素时（pop）时，我们只要在第二个栈outputStack中弹栈（pop）即可。当我们需要向队尾放入元素（push）时，我们向第一个栈inputStack中压入元素（push）即可。这样第一个栈inputStack相当于队尾，第二个栈outputStack相当于队头。</p>
<p>算法思想已经理解，但是实现起来还是有需要注意的地方，下面是我一开始写的代码：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack&lt;Integer&gt; outputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = outputStack.<span class="keyword">pop</span>();</span><br><span class="line">            inputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStack.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">pop</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        outputStack.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> peek() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> inputStack.isEmpty() &amp;&amp; outputStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试之后发现结果不对，比如当我们执行<code>push(1),push(2),peek,push(3),peek</code>后发现输出为1、3，但是正确的输出应该为1。错误的原因如下：开始我们向inputStack压入1、2，然后第一次peek的时候，我们依次从inputStack弹出2、1然后压入outputStack，此时元素是反转过来变成了先进先出，因此我们peek的时候输出1，接着向栈inputStack压入3，最后peek的时候又直接将3压入outpuStack中，这时3和1、2的顺序是错误的。然后我的修改是往inputStack中push元素的时候将outputStack中元素弹出再反压入inputStack中保持元素的顺序，代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack&lt;Integer&gt; outputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = outputStack.<span class="keyword">pop</span>();</span><br><span class="line">            inputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStack.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">pop</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        outputStack.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> peek() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> inputStack.isEmpty() &amp;&amp; outputStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试通过，但是这样写性能太低了，时间复杂度有点大。其实push元素的时候我们不需要将元素反压入inputStack中，而是在pop或者peek时，只在outputStack为空时才将inputStack中的元素弹出然后反压入outputStack中。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue &#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; inputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack&lt;Integer&gt; outputStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="comment">// Push element x to the back of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        inputStack.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">pop</span>() &#123;</span><br><span class="line">    	<span class="comment">//这段代码跟peek中的重复，可以直接调用peek替代</span></span><br><span class="line">        <span class="keyword">if</span>(outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        outputStack.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the front element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> peek() &#123;</span><br><span class="line">        <span class="keyword">if</span>(outputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inputStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = inputStack.<span class="keyword">pop</span>();</span><br><span class="line">            outputStack.<span class="keyword">push</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the queue is empty.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> inputStack.isEmpty() &amp;&amp; outputStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Implement the following operations of a queue using stacks.</p>
<p>push(x) – Push element x to the back of queue.<]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://blog.noobsky.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[LeetCode]Swap Nodes in Pairs]]></title>
    <link href="http://blog.noobsky.com/2016/05/02/LeetCode-Swap-Nodes-in-Pairs/"/>
    <id>http://blog.noobsky.com/2016/05/02/LeetCode-Swap-Nodes-in-Pairs/</id>
    <published>2016-05-02T05:52:39.000Z</published>
    <updated>2016-05-05T02:33:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
<p>这个题目的思想很简单，但是要想写对代码还是有点繁琐的，稍微不慎可能就蒙圈了。<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode swapPairs(ListNode head)&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="keyword">next</span> == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">       </span><br><span class="line">       ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       dummy.<span class="keyword">next</span> = head;</span><br><span class="line">       ListNode current = dummy;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>(current.<span class="keyword">next</span> != <span class="literal">null</span> &amp;&amp; current.<span class="keyword">next</span>.<span class="keyword">next</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">           ListNode first = current.<span class="keyword">next</span>;</span><br><span class="line">           ListNode second = current.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">           </span><br><span class="line">           first.<span class="keyword">next</span> = second.<span class="keyword">next</span>;</span><br><span class="line">           current.<span class="keyword">next</span> = second;</span><br><span class="line">           second.<span class="keyword">next</span> = first;//或者是current.<span class="keyword">next</span>.<span class="keyword">next</span> = first;</span><br><span class="line">           </span><br><span class="line">           current = current.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> dummy.<span class="keyword">next</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们就以1-&gt;2-&gt;3-&gt;4为例，第一对邻接节点1和2的交换过程示意图如下：<br>初始化，执行<code>ListNode first = current.next; ListNode second = current.next.next;</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes1.png" alt=""></p>
<p>执行<code>first.next = second.next</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes2.png" alt=""></p>
<p>执行<code>current.next = second</code>之后<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes3.png" alt=""></p>
<p>执行<code>second.next = first</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes4.png" alt=""></p>
<p>执行<code>current = current.next.next</code>之后：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/swapnodes5.png" alt=""></p>
<p>之后进入下一次循环，过程类似。</p>
<p>其实该题更简洁的方法是使用递归，代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode swapPairs(ListNode head)&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">       </span><br><span class="line">       ListNode temp = head.<span class="keyword">next</span>;</span><br><span class="line">       head.<span class="keyword">next</span> = swapPairs(head.<span class="keyword">next</span>.<span class="keyword">next</span>);</span><br><span class="line">       temp.<span class="keyword">next</span> = head;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://blog.noobsky.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock系列]]></title>
    <link href="http://blog.noobsky.com/2016/04/30/Best-Time-to-Buy-and-Sell-Stock/"/>
    <id>http://blog.noobsky.com/2016/04/30/Best-Time-to-Buy-and-Sell-Stock/</id>
    <published>2016-04-30T10:49:01.000Z</published>
    <updated>2016-05-05T03:32:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Best_Time_to_Buy_and_Sell_Stock">Best Time to Buy and Sell Stock</h2><h3 id="题目描述">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>开始我对这个题目不是很理解，存在一些误区，然后看了一个歪果仁的更清楚的说明：<br>If you were only permitted to complete at most one buy and at most one sell during the whole period of days, design an algorithm such that your profit, i.e., sell price minus buy price, is maximized. Note that you can only not sell a stock before you buy one.</p>
<p>For example:</p>
<p>[1,2,3,4] ==&gt; returns 3 (buy at 1 and sell at 4)</p>
<p>[4,3,2,1] ==&gt; returns 0 (don’t buy)</p>
<p>[4,10,25,2,10] ==&gt; returns 21 (buy at 4 and sell at 25)</p>
<p>题目大意是说整个期间你最多只能买一次股票然后只能卖出一次，当然也可以不买股票。设计一个算法计算最大收益。<br>该问题可以使用动态规划解决，设dp[i]是[0,1,2…i]区间的最大利润，则该问题的一维动态规划方程如下：<br>dp[i+1] = max{dp[i], prices[i+1] - minPrices},minPrices是区间[0,1,2…,i]内的最低价格,我们要求解的最大利润 = max{dp[0], dp[1], dp[2], …, dp[n-1]} 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> maxProfit=<span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           <span class="comment">//最大收益</span></span><br><span class="line">           maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">           <span class="comment">//保存最小的price</span></span><br><span class="line">           minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果我们不再从每日的股票价格的角度去看待输入数据，而是考察每日股票价格的变化，第i天的股票价格变化定义为第i天和第i-1的价格差。并将这些价格差看做一个新数组A{prices[1]-prices[0], prices[2]-prices[1], prices[3]-prices[2], …, prices[n-1]-prices[n-2]}，那么问题就转化为寻找新数组A的最大子数组和。最大子数组和也是一个DP问题，详见维基百科<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank" rel="external">Maximum subarray problem</a>和本博客的博文最大子数组和。最大子数组和的Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_subarray</span><span class="params">(A)</span>:</span></span><br><span class="line">    max_ending_here = max_so_far = A[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> A[<span class="number">1</span>:]:</span><br><span class="line">        max_ending_here = max(x, max_ending_here + x)</span><br><span class="line">        max_so_far = max(max_so_far, max_ending_here)</span><br><span class="line">    <span class="keyword">return</span> max_so_far</span><br></pre></td></tr></table></figure>
<p>根据最大子数组和的程序，利用最大子数组和算法解决本股票问题的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxEndingHere = prices[<span class="number">1</span>] - prices[<span class="number">0</span>], maxSoFar = prices[<span class="number">1</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            maxEndingHere = Math.max(prices[i] - prices[i-<span class="number">1</span>], maxEndingHere+prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最大收益为负数，则不买股票，返回0</span></span><br><span class="line">        <span class="keyword">return</span> maxSoFar &gt; <span class="number">0</span> ? maxSoFar : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码可能不够直观，可以使用额外的O(n)的内存空间来存股票价格变化数组，更为直观的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span>[] diffPrices = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length-<span class="number">1</span>];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           diffPrices[i-<span class="number">1</span>] = prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> res = maxSubarray(diffPrices);</span><br><span class="line">       <span class="keyword">return</span> res &gt; <span class="number">0</span> ? res : <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> maxEndingHere = arr[<span class="number">0</span>],maxSoFar = arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">           maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);</span><br><span class="line">           maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxSoFar;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_II">Best Time to Buy and Sell Stock II</h2><h3 id="题目描述-1">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>在上一题的基础上，可以买卖多次股票，但是再买股票时必须把之前的股票卖出去，也就是说手上最多只能有一只股票。可以找到所有价格的递增区间，把这些递增区间的收益全部加起来就是最后的最大收益。代码有以下两种写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码一：</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> length = prices.length;</span><br><span class="line">       <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//注意循环结束条件是i &lt; length-1,如果是i &lt; length在&#123;1，2&#125;会陷入死循环</span></span><br><span class="line">       <span class="keyword">while</span>(i &lt; length - <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">while</span>(i+<span class="number">1</span> &lt; length &amp;&amp; prices[i+<span class="number">1</span>] &gt;= prices[i])&#123;</span><br><span class="line">               profit += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">               i++;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">while</span>(i+<span class="number">1</span> &lt; length &amp;&amp; prices[i+<span class="number">1</span>] &lt; prices[i]) i++;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> profit;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//代码二：</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(prices[i+<span class="number">1</span>] &gt; prices[i]) profit += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> profit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best_Time_to_Buy_and_Sell_Stock_III">Best Time to Buy and Sell Stock III</h2><h3 id="题目描述-2">题目描述</h3><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>这一题是最多只能买卖两次股票，求最大收益，同理手上最多只能有一只股票。因为不能连续买入两次股票，所以买卖两次肯定分布在两个不同区间。容易想到的解决办法是，把prices[] 分成两部分prices[0…m] 和 prices[m…length]  ，分别计算在这两部分内做交易的做大收益。在每个区间的问题又回到了I的情况。由于做n次划分，每次划分后求解的时间复杂度为O(n),所以总的时间复杂度为O(n<sup>2</sup>)，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n*n) time limit exceeded</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">           maxProfit = Math.max(maxProfit,maxProfitOnce(prices, <span class="number">0</span>, i) + maxProfitOnce(prices, i, prices.length -<span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfitOnce</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> minPrice = prices[start];</span><br><span class="line">       <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">           maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">           minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是由于时间复杂度为O(n<sup>2</sup>)，效率低，运行超时。可以利用动态规划的思想进行改进，保持计算的中间结果，减少重复的计算。那就是第一步扫描，先计算出子序列[0,…,i]中的最大利润，用一个数组保存下来，那么时间是O(n)。计算方法也是利用第一个问题的计算方法。第二步是逆向扫描，计算子序列[i,…,n-1]上的最大利润，这一步同时就能结合上一步的结果计算最终的最大利润了，这一步也是O(n)。 所以最后算法的复杂度就是O(n)的。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == null || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] maxProfitFromHead = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        maxProfitFromHead[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">            maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">            maxProfitFromHead[i] = maxProfit;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxPrice = prices[prices.length -<span class="number">1</span>];</span><br><span class="line">        maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> finalMaxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.length -<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            maxPrice = Math.max(prices[i], maxPrice);</span><br><span class="line">            maxProfit = Math.max(maxProfit, maxPrice - prices[i]);</span><br><span class="line">            finalMaxProfit = Math.max(finalMaxProfit, maxProfit + maxProfitFromHead[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> finalMaxProfit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Best_Time_to_Buy_and_Sell_Stock">Best Time to Buy and Sell Stock</h2><h3 id="题目描述">题目描述</h3><p>Say you have an array for which the i]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://blog.noobsky.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Happy Number与Floyd判圈算法]]></title>
    <link href="http://blog.noobsky.com/2016/04/30/Happy-Number%E4%B8%8EFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.noobsky.com/2016/04/30/Happy-Number与Floyd判圈算法/</id>
    <published>2016-04-30T04:46:38.000Z</published>
    <updated>2016-05-05T03:33:02.000Z</updated>
    <content type="html"><![CDATA[<p>最近在刷LeetCode的时候，遇到一题为Happy Number的题，该题最容易想到的思路就是利用集合，还有一个很巧妙的解法就是利用Floyd判圈算法来做，下面就来看看。</p>
<h3 id="题目描述">题目描述</h3><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example: 19 is a happy number</p>
<p>1<sup>2</sup> + 9<sup>2</sup> = 82<br>8<sup>2</sup> + 2<sup>2</sup> = 68<br>6<sup>2</sup> + 8<sup>2</sup> = 100<br>1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1</p>
<p>最直接的解法就是利用集合来判断各位的平方和是否已经出现过，如果出现过，则不是Happy Number。代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, digit;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            digit = n % <span class="number">10</span>;</span><br><span class="line">            sum += digit * digit;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">set</span>.add(n))&#123;</span><br><span class="line">            n = digitSquareSum(n);</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去讨论区里发现了一种利用Floyd判圈算法的解法非常巧妙，下面就来介绍一下Floyd判圈算法（Floyd Cycle Detection Algorithm）。</p>
<p>Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)。该算法由美国科学家罗伯特·弗洛伊德发明，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。</p>
<p>Floyd判圈算法的基本思想可以用我们跑步的例子来解释，如果两个人同时出发，如果赛道有环，那么快的一方总能追上慢的一方。进一步想，追上时快的一方肯定比慢的一方多跑了几圈，即多跑的路的长度是圈的长度的倍数。</p>
<p>基于上面的想法，Floyd算法用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果是等价的，只要一个比另一个快就行，从后面的讨论我们可以看出这一点）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没环。详见维基百科<a href="https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare" target="_blank" rel="external">Cycle detection</a></p>
<p>下面从数学的角度来推导一下：<br>乌龟和兔子从起点同时出发，首先假设乌龟每次走一步，兔子每次走两步，则乌龟和兔子最后必定会相遇。<br>借用这张经典的解析图：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/floyd_cycle_detection.jpg" alt=""><br>假设乌龟走的路程为L，兔子走的路程为2L，则有如下等式：<br>1) L = m + p <em> n + k<br>2) 2L = m + q </em> n + k<br>这里的p和q分别为乌龟和兔子在环里走的圈数（q&gt;p）。由1）和2）式可得：<br> 2( m + p <em> n + k ) = m + q </em> n + k<br> =&gt; 2m + 2pn + 2k = m + nq + k<br> =&gt; m + k = (q - 2p)n<br>因此，如果我们能够证明至少有一种k, p, q的值可以使得这个等式成立，我们就证明了假设成立。这里我们只要使p=0，q=m，k=mn-m，上式成立。</p>
<p>下面我们来解决第二个问题，即环的起点在哪里。<br>当乌龟和兔子相遇后，我们让乌龟放回链表起点，兔子留在相遇点，然后他们以相同的速度前进（都是一次一步），则乌龟和兔子将会在在环的起点处相遇。为什么？下面来推导一下。<br>假设让乌龟走m+k步，则乌龟会到达之前跟兔子的相遇点，前面我们已经证明m + k = (q - 2p)n，也就是说m+k是环路长度n的整数倍，同时，兔子绕环路（q-2p）圈后也回到该点（距离环路起点k步处）。我们不是让乌龟走m+k步而是只走m步，则乌龟会到达环路的起点处，而兔子此时还差k步才走完（q-2p）圈环路，而兔子是从离环路起点k步的地方开始走的，所以此时兔子也走到环路起点处。该算法还能用来判断链表中是否有环及找出环的起点，详见()[]。下面是Floyd判圈算法的python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floyd</span><span class="params">(f, x0)</span>:</span></span><br><span class="line">    <span class="comment"># Main phase of algorithm: finding a repetition x_i = x_2i.</span></span><br><span class="line">    <span class="comment"># The hare moves twice as quickly as the tortoise and</span></span><br><span class="line">    <span class="comment"># the distance between them increases by 1 at each step.</span></span><br><span class="line">    <span class="comment"># Eventually they will both be inside the cycle and then,</span></span><br><span class="line">    <span class="comment"># at some point, the distance between them will be</span></span><br><span class="line">    <span class="comment"># divisible by the period λ.</span></span><br><span class="line">    tortoise = f(x0) <span class="comment"># f(x0) is the element/node next to x0.</span></span><br><span class="line">    hare = f(f(x0))</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        tortoise = f(tortoise)</span><br><span class="line">        hare = f(f(hare))</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># At this point the tortoise position, ν, which is also equal</span></span><br><span class="line">    <span class="comment"># to the distance between hare and tortoise, is divisible by</span></span><br><span class="line">    <span class="comment"># the period λ. So hare moving in circle one step at a time, </span></span><br><span class="line">    <span class="comment"># and tortoise (reset to x0) moving towards the circle, will </span></span><br><span class="line">    <span class="comment"># intersect at the beginning of the circle. Because the </span></span><br><span class="line">    <span class="comment"># distance between them is constant at 2ν, a multiple of λ,</span></span><br><span class="line">    <span class="comment"># they will agree as soon as the tortoise reaches index μ.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the position μ of first repetition.    </span></span><br><span class="line">    mu = <span class="number">0</span></span><br><span class="line">    tortoise = x0</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        tortoise = f(tortoise)</span><br><span class="line">        hare = f(hare)   <span class="comment"># Hare and tortoise move at same speed</span></span><br><span class="line">        mu += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Find the length of the shortest cycle starting from x_μ</span></span><br><span class="line">    <span class="comment"># The hare moves one step at a time while tortoise is still.</span></span><br><span class="line">    <span class="comment"># lam is incremented until λ is found.</span></span><br><span class="line">    lam = <span class="number">1</span></span><br><span class="line">    hare = f(tortoise)</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        hare = f(hare)</span><br><span class="line">        lam += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> lam, mu</span><br></pre></td></tr></table></figure>
<p>好了，现在回到Happy Number本身。如果一个数不是Happy Number，则计算该数的各位的平方和时会出现环路，则我们可以利用Floyd判圈算法来做，慢“指针”（乌龟）每次计算一次Number的各位的平方和，快“指针”（兔子）每次计算两次Number的每位的平方和。如果慢指针和快指针相遇（计算的Number的每位平方和相等），则Number不是Happy的。反之最后计算的值都为1，则为Happy Number。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, digit;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            digit = n % <span class="number">10</span>;</span><br><span class="line">            sum += digit * digit;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow=n, fast = n;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = digitSquareSum(slow);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        <span class="keyword">if</span>(slow == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在刷LeetCode的时候，遇到一题为Happy Number的题，该题最容易想到的思路就是利用集合，还有一个很巧妙的解法就是利用Floyd判圈算法来做，下面就来看看。</p>
<h3 id="题目描述">题目描述</h3><p>Write an algorithm t]]>
    </summary>
    
      <category term="Floyd判圈算法" scheme="http://blog.noobsky.com/tags/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://blog.noobsky.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[罗马数字和阿拉伯数字的相互转换]]></title>
    <link href="http://blog.noobsky.com/2016/04/28/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E5%92%8C%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
    <id>http://blog.noobsky.com/2016/04/28/罗马数字和阿拉伯数字的相互转换/</id>
    <published>2016-04-28T06:37:29.000Z</published>
    <updated>2016-05-05T03:32:24.000Z</updated>
    <content type="html"><![CDATA[<p>罗马数字基本字符和阿拉伯数字的对应关系</p>
<table>
<thead>
<tr>
<th>Roman Literal</th>
<th>Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
</tbody>
</table>
<h3 id="记数方法">记数方法</h3><ul>
<li>相同的数字连写、所表示的数等于这些数字相加得到的数、如：Ⅲ=3；</li>
<li>小的数字在大的数字的右边、所表示的数等于这些数字相加得到的数、 如：Ⅷ=8、Ⅻ=12；</li>
<li>小的数字、（限于 Ⅰ、X 和 C）在大的数字的左边、所表示的数等于大数减小数得到的数、如：Ⅳ=4、Ⅸ=9；</li>
<li>正常使用时、连写的数字重复不得超过三次；</li>
<li>在一个数的上面画一条横线、表示这个数扩大 1000 倍。</li>
</ul>
<h3 id="组数规则">组数规则</h3><ul>
<li>基本数字 Ⅰ、X 、C 中的任何一个、自身连用构成数目、或者放在大数的右边连用构成数目、都不能超过三个；放在大数的左边只能用一个；</li>
<li>不能把基本数字 V 、L 、D 中的任何一个作为小数放在大数的左边采用相减的方法构成数目；放在大数的右边采用相加的方式构成数目、只能使用一个；</li>
<li>V 和 X 左边的小数字只能用 Ⅰ；</li>
<li>L 和 C 左边的小数字只能用X；</li>
<li>D 和 M 左边的小数字只能用 C。</li>
</ul>
<h3 id="罗马数字转阿拉伯数字">罗马数字转阿拉伯数字</h3><h4 id="题目描述">题目描述</h4><p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<ul>
<li>从左往右遍历转换</li>
</ul>
<p>初始化结果为0，然后从左往右遍历罗马数字，如果某个数比左边一个数小，则把该数加入到结果中；反之（即某个数比左边一个数大），则在结果中两次减去前一个数并加上当前这个数。这里解释一下后者，比如罗马数字IV，开始时遍历到I，然后将结果加1，接着遇到了V，我们知道V的前面出现了一个比V小的的I，所以我们需要从V中减去I，但是我们前面已经加过I，所以我们需要减去两倍的I。下面看一个更复杂的例子：</p>
<table>
<thead>
<tr>
<th>Roman literals from left to right</th>
<th>Accumulated total</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>1000</td>
</tr>
<tr>
<td>MX</td>
<td>1000 + 10 = 1010</td>
</tr>
<tr>
<td>MXC</td>
<td>1010 + (100 - 2 * 10) = 1010 + 80 = 1090</td>
</tr>
<tr>
<td>MXCV</td>
<td>1090 + 5 = 1095</td>
</tr>
<tr>
<td>MXCVI</td>
<td>1095 + 1 = 1096</td>
</tr>
</tbody>
</table>
<p>代码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="built_in">map</span>.get(s.charAt(i));</span><br><span class="line">            sum += (curr &gt; pre) ? (curr - <span class="number">2</span> * pre):curr;</span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>从右往左遍历转换</li>
</ul>
<p>其实更直观的转换方式是从右往左转换，如果某个数大于等于右边的数，则直接加入到结果中；反之，从结果中减去该数。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="built_in">map</span>.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="built_in">map</span>.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(curr &gt;= pre)&#123;</span><br><span class="line">                sum += curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum -= curr;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="阿拉伯数字转罗马数字">阿拉伯数字转罗马数字</h3><h4 id="题目描述-1">题目描述</h4><p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<p>把所有小数字在前的组合也作为基本数字，对应的数值表如下：</p>
<table>
<thead>
<tr>
<th>Roman Literal</th>
<th>Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>IV</td>
<td>4</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>IX</td>
<td>9</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>XL</td>
<td>40</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>XC</td>
<td>90</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>CD</td>
<td>400</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>CM</td>
<td>900</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> values[] = &#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        String[] symbols = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = num / values[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++)&#123;</span><br><span class="line">                sb.append(symbols[i]);</span><br><span class="line">                num -= values[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>罗马数字基本字符和阿拉伯数字的对应关系</p>
<table>
<thead>
<tr>
<th>Roman Literal</th>
<th>Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>1</td>
</]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://blog.noobsky.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximum Depth of Binary Tree二叉树的深度]]></title>
    <link href="http://blog.noobsky.com/2016/04/26/Maximum-Depth-of-Binary-Tree%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://blog.noobsky.com/2016/04/26/Maximum-Depth-of-Binary-Tree二叉树的深度/</id>
    <published>2016-04-26T07:43:33.000Z</published>
    <updated>2016-05-05T03:33:29.000Z</updated>
    <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>最直接的方式是递归方法，树的深度为左右子树深度最大值+1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法是使用广度搜索的方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth2</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">queue</span>.offer(root);</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="built_in">queue</span>.size();</span><br><span class="line">		<span class="comment">//让每一层的节点依次出队列，并把左右子节点加入队列中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">			TreeNode node = <span class="built_in">queue</span>.poll();</span><br><span class="line">			<span class="keyword">if</span>(node.left != null)&#123;</span><br><span class="line">				<span class="built_in">queue</span>.offer(node.left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(node.right != null)&#123;</span><br><span class="line">				<span class="built_in">queue</span>.offer(node.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="问题描述">问题描述</h3><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest pat]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://blog.noobsky.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nim Game]]></title>
    <link href="http://blog.noobsky.com/2016/04/26/Nim-Game/"/>
    <id>http://blog.noobsky.com/2016/04/26/Nim-Game/</id>
    <published>2016-04-26T03:03:39.000Z</published>
    <updated>2016-05-05T03:33:37.000Z</updated>
    <content type="html"><![CDATA[<p>今天遇到LeetCode上一道题叫Nim Game，虽然可以用程序解决，但感觉更像是一道数学题，游戏题。</p>
<h3 id="题目描述">题目描述</h3><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
<p><strong>Hint:</strong></p>
<p>If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?</p>
<p>根据题目描述可知，当n==1、2、3时，先手必赢，因为先手都可以一次性把石头移完。<br>当n==4时，先手必输，题目描述中也提到了这个，因为不管先手拿1、2、3个，对手都会拿走剩下的石头<br>当n==5，6，7，先手必赢，先手分别取走1、2、3颗石头，则后手的状态转化为n==4的情况，所以此时后手必输<br>当n==8时，无论先手第一轮拿1、2、3颗石头，下一轮后手都是转化为n==5、6、7的情况，此时先手必输。<br>当n==9,10,11，先手必赢，先手分别取走1、2、3颗石头，则后手的状态转化为n==8的情况，所以此时后手必输<br>……<br>以此类推，我们得出的结论是：<br>当数量是4的倍数时，即n % 4 == 0时，先手必输，否则先手必赢<br>有了上面的结论编写程序就很容易了，如下，但是想到上面的结论不太容易…..<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然想不到上面的数学解法，我们可以通过程序来解决<br>首先来个容易想到的递归解法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//如果不管先手拿1、2、3颗石头，后手都赢，那么先手必输</span></span><br><span class="line">       <span class="keyword">if</span>(canWinNim(n - <span class="number">1</span>) &amp;&amp; canWinNim(n - <span class="number">2</span>) &amp;&amp; canWinNim(n - <span class="number">3</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>递归解法会计算太多的重复值，可以证明程序的运行时间是指数级增长的，在LeetCode上当n==41时程序就已经超时了。<br>我们可以采用带备忘的（memoized）的方法记住已经计算过了的结果，程序如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">canWinNim2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    boolean[] dp = <span class="keyword">new</span> boolean[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = dp[<span class="number">3</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">        dp[i] = !(dp[i-<span class="number">1</span>] &amp;&amp; dp[i-<span class="number">2</span>] &amp;&amp; dp[i-<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这个程序在输入n非常大的时候，内存会超过限制。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天遇到LeetCode上一道题叫Nim Game，虽然可以用程序解决，但感觉更像是一道数学题，游戏题。</p>
<h3 id="题目描述">题目描述</h3><p>You are playing the following Nim Game with your frien]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://blog.noobsky.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reverse String 反转字符串]]></title>
    <link href="http://blog.noobsky.com/2016/04/26/Reverse-String-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://blog.noobsky.com/2016/04/26/Reverse-String-反转字符串/</id>
    <published>2016-04-26T01:41:43.000Z</published>
    <updated>2016-05-05T03:33:44.000Z</updated>
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>Write a function that takes a string as input and returns the string reversed.</p>
<p><strong>Example:</strong><br>Given s = “hello”, return “olleh”.</p>
<p>首先我想到的思路是将输入字符串转换为char数组，然后将字符反转最后返回字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] temp = s.toCharArray();</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temp.length-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者不借助StringBuffer或StringBuilder的帮忙。<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        char[] <span class="keyword">in</span> = s.toCharArray();</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = <span class="keyword">in</span>.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</span><br><span class="line">			char temp = <span class="keyword">in</span>[<span class="built_in">left</span>];</span><br><span class="line">			<span class="keyword">in</span>[<span class="built_in">left</span>] = <span class="keyword">in</span>[<span class="built_in">right</span>];</span><br><span class="line">			<span class="keyword">in</span>[<span class="built_in">right</span>] = temp;</span><br><span class="line">			<span class="built_in">left</span>++;</span><br><span class="line">			<span class="built_in">right</span>--;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return <span class="keyword">new</span> <span class="built_in">String</span>(<span class="keyword">in</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是其他一些常用解法，使用byte<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        byte[] bytes = s.getBytes();</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = bytes.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</span><br><span class="line">        	byte temp = bytes[<span class="built_in">left</span>];</span><br><span class="line">        	bytes[<span class="built_in">left</span>] = bytes[<span class="built_in">right</span>];</span><br><span class="line">        	bytes[<span class="built_in">right</span>] = temp;</span><br><span class="line">        	<span class="built_in">left</span>++;</span><br><span class="line">        	<span class="built_in">right</span>--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return <span class="keyword">new</span> <span class="built_in">String</span>(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>交互两个变量值最常使用的方法是使用一个临时变量temp，还有一种比较巧妙的方法就是使用异或运算<br>比如交互变量a和b：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> = a<span class="regexp"> ^</span> b;</span><br><span class="line"><span class="title">b</span> = b<span class="regexp"> ^</span> a;</span><br><span class="line"><span class="title">a</span> = b<span class="regexp"> ^</span> a;</span><br></pre></td></tr></table></figure></p>
<p>因为异或有两个特性：</p>
<ul>
<li>一个数异或自身恒等于0，比如6^6恒等于0；</li>
<li>一个数异或0恒等于自身，比如6^0恒等于6。</li>
</ul>
<p>所以不使用临时变量的交互则代码如下：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        byte[] bytes = s.getBytes();</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = bytes.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</span><br><span class="line">        	bytes[<span class="built_in">left</span>] = (byte)(bytes[<span class="built_in">left</span>] ^ bytes[<span class="built_in">right</span>]);</span><br><span class="line">        	bytes[<span class="built_in">right</span>] = (byte)(bytes[<span class="built_in">left</span>] ^ bytes[<span class="built_in">right</span>]);</span><br><span class="line">        	bytes[<span class="built_in">left</span>] = (byte)(bytes[<span class="built_in">left</span>] ^ bytes[<span class="built_in">right</span>]);</span><br><span class="line">        	<span class="built_in">left</span>++;</span><br><span class="line">        	<span class="built_in">right</span>--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return <span class="keyword">new</span> <span class="built_in">String</span>(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实自己不够熟悉StringBuffer或StringBuilder的api，既然想到用它们，就应该想起它们都有reverse方法，所以代码so easy：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String reverseString(String s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer(s).<span class="keyword">reverse</span>().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后也可以使用递归的方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        String leftString = s.substring(<span class="number">0</span>, length &gt;&gt; <span class="number">2</span>);</span><br><span class="line">        String rightString = s.substring(length &gt;&gt; <span class="number">2</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverseString(leftString) + reverseString(rightString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="题目描述">题目描述</h3><p>Write a function that takes a string as input and returns the string reversed.</p>
<p><strong>Example:</strong><br]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://blog.noobsky.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <link href="http://blog.noobsky.com/2016/04/18/Java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://blog.noobsky.com/2016/04/18/Java序列化/</id>
    <published>2016-04-18T12:53:50.000Z</published>
    <updated>2016-04-18T12:53:50.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java注解]]></title>
    <link href="http://blog.noobsky.com/2016/04/17/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://blog.noobsky.com/2016/04/17/Java注解/</id>
    <published>2016-04-17T03:07:37.000Z</published>
    <updated>2016-04-30T04:32:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="注解（Annotation）的工作方式">注解（Annotation）的工作方式</h3><p>Java5.0提供了一个正式的注解（Annotation）功能：允许开发者定义、使用自己的注解类型。此功能由一个定义注解类型的语法和一个描述注解声明的语法，读取注解的API，一个使用注解修饰的class文件和一个注解处理工具组成。</p>
<p>注解并不直接影响程序代码的语义，但是它工作的方式被看作类似程序的工具或者类库，他会反过来对正在运行的程序语义有所影响。</p>
<p>注解可以从源文件、class文件或者以在运行时反射的多种方式被读取。</p>
<h3 id="Java内置注解">Java内置注解</h3><ul>
<li>@Override注解</li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang</span><br><span class="line">Annotation <span class="keyword">Type</span> <span class="keyword">Override</span></span><br><span class="line">@Target(value=<span class="function"><span class="keyword">METHOD</span>)</span><br><span class="line">@<span class="title">Retention</span><span class="params">(value=SOURCE)</span></span><br><span class="line"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Override</span></span></span><br></pre></td></tr></table></figure>
<p>表示一个方法声明将重写父类中声明的一个方法。如果方法使用此注解类型进行注解但没有重写父类中的方法，则编译器会生成一条错误信息。</p>
<p>@Override注解表示子类要重写父类中对应的方法，它是一个Marker Annotation，用于标识Annotation，Annotation名称本身表示了要给工具程序的信息。<br>@Override注解非常常见，比如：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OverrideTest</span> &#123;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is OverrideTest"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">        OverrideTest test = <span class="keyword">new</span> OverrideTest();</span><br><span class="line">        System.<span class="keyword">out</span>.println(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>@Deprecated注解</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang</span><br><span class="line">Annotation <span class="keyword">Type</span> Deprecated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@Retention(<span class="keyword">value</span>=RUNTIME)</span><br><span class="line">@<span class="type">Target</span>(<span class="keyword">value</span>=&#123;CONSTRUCTOR,FIELD,LOCAL_VARIABLE,METHOD,PACKAGE,<span class="type">PARAMETER</span>,<span class="keyword">TYPE</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> @<span class="keyword">interface</span> Deprecated</span><br></pre></td></tr></table></figure>
<p>用@Deprecated注解的程序元素，是不鼓励程序员使用的，通常是因为它存在危险或存在更好的选择。在使用deprecated的程序元素或在非deprecated代码中重写它，编译器会发出警告。</p>
<p>@Deprecated注解表示某个方法已经不建议使用，即该方法是过时的。Deprecated也是个 Marker annotation。下面是使用@Deprecated注解的例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeprecatedTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Deprecated</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">        DeprecatedTest test = <span class="keyword">new</span> DeprecatedTest();</span><br><span class="line">        test.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>@SuppressWarnings注解</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang</span><br><span class="line">Annotation <span class="keyword">Type</span> SuppressWarnings</span><br><span class="line">@<span class="type">Target</span>(<span class="keyword">value</span>=&#123;<span class="keyword">TYPE</span>,FIELD,METHOD,<span class="type">PARAMETER</span>,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(<span class="keyword">value</span>=SOURCE)</span><br><span class="line"><span class="keyword">public</span> @<span class="keyword">interface</span> SuppressWarnings</span><br></pre></td></tr></table></figure>
<p>表明应该在注解元素（以及包含在该注解元素中的所有程序元素）中取消显示指定的编译器警告。注意，在给定元素中取消显示的警告集是所有包含元素中取消显示的警告的超集。例如，如果注解一个类来取消显示某个警告，同时注解一个方法来取消显示另一个警告，那么将在此方法中同时取消显示这两个警告。<br>根据风格不同，程序员应该始终在最里层的嵌套元素上使用此注解，在那里使用才有效。如果要在特定的方法中取消显示某个警告，则应该注解该方法而不是注解它的类。</p>
<p>@SuppressWarnings注解表示抑制警告。下面是一个使用@SuppressWarnings注解的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SuppressWarningsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;<span class="string">"unchecked"</span>, <span class="string">"deprecation"</span>&#125;)</span><br><span class="line">    public static <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)&#123;</span><br><span class="line">        <span class="built_in">Map</span> map = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        map.put(<span class="string">"hello"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">        System.out.println(map.get(<span class="string">"hello"</span>));</span><br><span class="line">        <span class="built_in">Date</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        System.out.println(date.toLocaleString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>@SafeVarargs注解</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java<span class="class">.lang</span></span><br><span class="line">Annotation Type SafeVarargs</span><br><span class="line">@Documented</span><br><span class="line">@<span class="function"><span class="title">Retention</span><span class="params">(value=RUNTIME)</span></span></span><br><span class="line">@<span class="function"><span class="title">Target</span><span class="params">(value=&#123;CONSTRUCTOR,METHOD&#125;)</span></span></span><br><span class="line">public @interface SafeVarargs</span><br></pre></td></tr></table></figure>
<p>@SafeVarargs是标记注解，只能用于参数长度可变的方法或构造函数，且方法必须声明为static或final，否则会出现编译错误。指示没有发生与可变长度参数相关的不安全动作。如果不安全代码与不能具体化的varargs类型相关，或者与参数化的数组实例相关，那么@SafeVarargs注解用于抑制“未检查不安全代码”警告(本质上，不能具体化的类是泛型类)。@SafeVarargs注解是由JDK 7新增的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SafeVarargsTest &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; a1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        a1.add(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">        a1.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Float&gt; a2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        a2.add(<span class="keyword">new</span> Float(<span class="number">3.0</span>));</span><br><span class="line">        a2.add(<span class="keyword">new</span> Float(<span class="number">4.0</span>));</span><br><span class="line"></span><br><span class="line">        displayElements(a1, a2, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SafeVarargs</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">displayElements</span><span class="params">(T... <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T element : <span class="built_in">array</span>) &#123;</span><br><span class="line">            System.out.println(element.getClass().getName() + <span class="string">":"</span> + element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="自定义注解">自定义注解</h3><p>使用@interface自定义注解时，实际上自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。如果我们定义了一个接口,并且让该接口继承 自 Annotation,那么我们所定义的接口依然还是接口而不是注解;Annotation 本身 是接口而不是注解。可以与 Enum 类比。<br>自定义注解：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Created by Jaye on 16/4/17.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">public <span class="comment">@interface MyAnnotation &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用自定义注解：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Created</span> by <span class="type">Jaye</span> on <span class="number">16</span>/<span class="number">4</span>/<span class="number">17</span>.</span><br><span class="line"> */</span><br><span class="line">public class <span class="type">AnnotationUsage</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="type">MyAnnotation</span></span><br><span class="line">    public <span class="type">void</span> <span class="keyword">method</span>()&#123;</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"usage of annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">AnnotationUsage</span> usage = new <span class="type">AnnotationUsage</span>();</span><br><span class="line">        usage.<span class="keyword">method</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>添加变量</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> @<span class="keyword">interface</span> <span class="title">MyAnnotation</span> &#123;</span><br><span class="line">    <span class="function">String <span class="title">value1</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用自定义注解：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">AnnotationUsage</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="type">MyAnnotation</span>(value1 = <span class="string">"jaye"</span>)</span><br><span class="line">    public <span class="type">void</span> <span class="keyword">method</span>()&#123;</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"usage of annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">AnnotationUsage</span> usage = new <span class="type">AnnotationUsage</span>();</span><br><span class="line">        usage.<span class="keyword">method</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当注解中使用的属性名为value时，对其赋值时可以不指定属性的名称而直接写上属性值接口；除了value意外的变量名都需要使用name=value的方式赋值。</p>
<ul>
<li>使用默认值</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> @<span class="interface"><span class="keyword">interface</span> MyAnnotation </span>&#123;</span><br><span class="line">    <span class="built_in">String</span> value1() <span class="keyword">default</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数组变量</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> @<span class="interface"><span class="keyword">interface</span> MyAnnotation </span>&#123;</span><br><span class="line">    <span class="built_in">String</span>[] value1() <span class="keyword">default</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">AnnotationUsage</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="type">MyAnnotation</span>(value1 = &#123;<span class="string">"jaye"</span>, <span class="string">"poop"</span>&#125;)</span><br><span class="line">    public <span class="type">void</span> <span class="keyword">method</span>()&#123;</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"usage of annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">AnnotationUsage</span> usage = new <span class="type">AnnotationUsage</span>();</span><br><span class="line">        usage.<span class="keyword">method</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多变量使用枚举</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="variable">@interface</span> <span class="constant">MyAnnotation</span> &#123;</span><br><span class="line">    <span class="constant">String</span>[] value1() default <span class="string">"hello"</span>;</span><br><span class="line">    <span class="constant">EnumTest</span> value2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumTest</span>&#123;</span></span><br><span class="line">    <span class="constant">Hello</span>, <span class="constant">World</span>, <span class="constant">Welcome</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">AnnotationUsage</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="type">MyAnnotation</span>(value1 = &#123;<span class="string">"jaye"</span>, <span class="string">"poop"</span>&#125;, value2 = <span class="type">EnumTest</span>.<span class="type">Hello</span>)</span><br><span class="line">    public <span class="type">void</span> <span class="keyword">method</span>()&#123;</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"usage of annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">AnnotationUsage</span> usage = new <span class="type">AnnotationUsage</span>();</span><br><span class="line">        usage.<span class="keyword">method</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置注解的作用范围">设置注解的作用范围</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java<span class="class">.lang</span><span class="class">.annotation</span></span><br><span class="line">Annotation Type Retention</span><br><span class="line">@Documented</span><br><span class="line">@<span class="function"><span class="title">Retention</span><span class="params">(value=RUNTIME)</span></span></span><br><span class="line">@<span class="function"><span class="title">Target</span><span class="params">(value=ANNOTATION_TYPE)</span></span></span><br><span class="line">public @interface Retention</span><br></pre></td></tr></table></figure>
<p>声明注解类型的注解需要保留多久。如果注解类型声明中没有Retention注解，则保留策略默认为RetentionPolicy.CLASS。只有元注释类型直接用于注释时，Target 元注释才有效。如果元注释类型用作另一种注释类型的成员，则无效。<br>注解保留策略。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span></span></span><br><span class="line">extends <span class="constant">Enum</span>&lt;<span class="constant">RetentionPolicy</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>此枚举类型的常量描述保留注解的不同策略。它们与 Retention 元注释类型一起使用，以指定保留多长的注解。</p>
<p><strong>CLASS:</strong> 编译器将注解类型记录在class文件中，但运行时VM不保留注解<br><strong>RUNTIME:</strong> 编译器把注解类型记录在class文件中，而且运行时VM将保留注解，因此可以利用反射机制读取。<br><strong>SOURCE:</strong> 编译器将丢弃注解</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.annotation.Retention;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">MyAnnotation2</span> </span>&#123;</span><br><span class="line">    String hello() <span class="keyword">default</span> <span class="string">"hellojaye"</span>;</span><br><span class="line">    String world();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用反射读取RUNTIME保留策略的注解信息">使用反射读取RUNTIME保留策略的注解信息</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect</span><br><span class="line"><span class="keyword">Interface</span> AnnotatedElement</span><br><span class="line"></span><br><span class="line">All Known Implementing Classes:</span><br><span class="line">AccessibleObject, <span class="keyword">Class</span>, <span class="function"><span class="keyword">Constructor</span>, <span class="title">Field</span>, <span class="title">Method</span>, <span class="title">Package</span></span></span><br></pre></td></tr></table></figure>
<p>表示目前正在此 VM 中运行的程序的一个已注解元素。该接口允许通过反射机制读取注解。由此接口中的方法返回的所有注解都是不可变并且可序列化的。调用者可以修改已赋值数组枚举成员的访问器返回的数组；这不会对其他调用者返回的数组产生任何影响。<br>如果此接口中的方法返回的注解（直接或间接地）包含一个已赋值的 Class 成员，该成员引用了一个在此 VM 中不可访问的类，则试图通过在返回的注解上调用相关的类返回的方法来读取该类，将导致一个 TypeNotPresentException。</p>
<p>类似地，如果注释中的枚举常量不再以枚举类型存在，那么试图读取一个已赋值的枚举成员将导致一个 EnumConstantNotPresentException。</p>
<p>最后，读取其定义已经引起不兼容性的成员将导致 AnnotationTypeMismatchException 或 IncompleteAnnotationException。<br>自定义注解：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.annotation.Retention;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">MyAnnotation2</span> </span>&#123;</span><br><span class="line">    String hello() <span class="keyword">default</span> <span class="string">"hellojaye"</span>;</span><br><span class="line">    String world();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用自定义注解：<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">@MyAnnotation2</span>(hello = <span class="string">"beijing"</span>, world = <span class="string">"haidian"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@MyAnnotation2</span>(hello = <span class="string">"poop"</span>, world = <span class="string">"jaye"</span>)</span><br><span class="line">    <span class="keyword">@Deprecated</span></span><br><span class="line">    <span class="keyword">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> output()&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"output something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用反射获取注解信息：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.<span class="type">Annotation</span>;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="type">Method</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * <span class="type">Created</span> by <span class="type">Jaye</span> on <span class="number">16</span>/<span class="number">4</span>/<span class="number">17</span>.</span><br><span class="line"> */</span><br><span class="line">public class <span class="type">MyReflection</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) throws <span class="type">Exception</span>&#123;</span><br><span class="line">        <span class="type">MyTest</span> myTest = new <span class="type">MyTest</span>();</span><br><span class="line">        //获取<span class="type">MyTest2</span>的<span class="type">Class</span>实例</span><br><span class="line">        <span class="type">Class</span>&lt;<span class="type">MyTest</span>&gt; cls = <span class="type">MyTest</span>.class;</span><br><span class="line">        //获取待处理方法的<span class="type">Method</span>实例</span><br><span class="line">        <span class="type">Method</span> <span class="keyword">method</span> = cls.getMethod(<span class="string">"output"</span>, new <span class="type">Class</span>[]&#123;&#125;);</span><br><span class="line">        //判断该方法是否包含<span class="type">MyAnnotation2</span>注解</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">method</span>.isAnnotationPresent(<span class="type">MyAnnotation2</span>.class))&#123;</span><br><span class="line">            //执行方法</span><br><span class="line">            <span class="keyword">method</span>.invoke(myTest, new <span class="type">Object</span>[]&#123;&#125;);</span><br><span class="line">            //获取方法的<span class="type">MyAnnotation2</span>的注解实例</span><br><span class="line">            <span class="type">MyAnnotation2</span> myAnnotation2 = <span class="keyword">method</span>.getAnnotation(<span class="type">MyAnnotation2</span>.class);</span><br><span class="line">            <span class="type">String</span> hello = myAnnotation2.hello();</span><br><span class="line">            <span class="type">String</span> world = myAnnotation2.world();</span><br><span class="line"></span><br><span class="line">            <span class="type">System</span>.<span class="keyword">out</span>.println(hello + <span class="string">","</span> + world);</span><br><span class="line">            //获取方法上的所有注解</span><br><span class="line">            <span class="type">Annotation</span>[] annotations = <span class="keyword">method</span>.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">Annotation</span> annotation : annotations)&#123;</span><br><span class="line">                <span class="type">System</span>.<span class="keyword">out</span>.println(annotation.annotationType().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序输出：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output something</span><br><span class="line">poop,jaye</span><br><span class="line">com<span class="class">.jaye</span><span class="class">.annotation</span><span class="class">.MyAnnotation2</span></span><br><span class="line">java<span class="class">.lang</span><span class="class">.Deprecated</span></span><br></pre></td></tr></table></figure></p>
<h3 id="限定注解的使用">限定注解的使用</h3><p>限定注解对象使用@Target<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ava<span class="class">.lang</span><span class="class">.annotation</span></span><br><span class="line">Annotation Type Target</span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@<span class="function"><span class="title">Retention</span><span class="params">(value=RUNTIME)</span></span></span><br><span class="line">@<span class="function"><span class="title">Target</span><span class="params">(value=ANNOTATION_TYPE)</span></span></span><br><span class="line">public @interface Target</span><br></pre></td></tr></table></figure></p>
<p>指示注解类型所适用的程序元素的种类。如果注解类型声明中不存在 Target 元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注解，则编译器强制实施指定的使用限制。 例如，此元注解指示该声明类型是其自身，即元注解类型。它只能用在注解类型声明上：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span></span></span><br><span class="line">extends <span class="constant">Enum</span>&lt;<span class="constant">ElementType</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>程序元素类型。此枚举类型的常量提供了 Java 程序中声明的元素的简单分类。<br>这些常量与 Target 元注解类型一起使用，以指定在什么情况下使用注解类型是合法的。枚举常量如下：</p>
<p><strong>ANNOTATION_TYPE:</strong> 注解类型声明<br><strong>CONSTRUCTOR:</strong> 构造方法声明<br><strong>FIELD:</strong> 字段声明（包括枚举常量）<br><strong>LOCAL_VARIABLE:</strong> 局部变量声明<br><strong>METHOD:</strong> 方法声明<br><strong>PACKAGE:</strong> 包声明<br><strong>PARAMETER:</strong> 参数声明<br><strong>TYPE:</strong> 类、接口（包括注释类型）或枚举声明</p>
<p>例子如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Created by Jaye on 16/4/17.</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line"><span class="comment">@Target(ElementType.METHOD)</span></span><br><span class="line">public <span class="comment">@interface MyTarget &#123;</span></span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在帮助文档中加入注解">在帮助文档中加入注解</h3><p>要想在制作JavaDoc文件的同时将注解信息加入到API文件中，可以使用java.lang.annotation.Documented。<br>在自定义注解中声明构建注解文档：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.annotation.Documented;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/17.</span><br><span class="line"> */</span></span><br><span class="line">@Documented</span><br><span class="line"><span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">DocumentedAnnotation</span> </span>&#123;</span><br><span class="line">    String hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">DocumentedTest</span></span><br><span class="line">&#123;</span><br><span class="line">	@<span class="type">DocumentedAnnotation</span>(hello = <span class="string">"welcome"</span>)</span><br><span class="line">	public <span class="type">void</span> <span class="keyword">method</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"hello world"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在注解中使用继承：">在注解中使用继承：</h3><p>默认情况下注解并不会被继承到子类中，可以在自定义注解时加上java.lang.annotation.Inherited注解声明使用继承。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java<span class="class">.lang</span><span class="class">.annotation</span></span><br><span class="line">Annotation Type Inherited</span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">@<span class="function"><span class="title">Retention</span><span class="params">(value=RUNTIME)</span></span></span><br><span class="line">@<span class="function"><span class="title">Target</span><span class="params">(value=ANNOTATION_TYPE)</span></span></span><br><span class="line">public @interface Inherited</span><br></pre></td></tr></table></figure></p>
<p>表示注解类型被自动继承。如果在注解类型声明中存在 Inherited 元注释，并且用户在某一类声明中查询该注解类型，同时该类声明中没有此类型的注解，则将在该类的父类中自动查询该注解类型。此过程会重复进行，直到找到此类型的注解或到达了该类层次结构的顶层 (Object) 为止。如果没有父类具有该类型的注解，则查询将指示当前类没有这样的注解。<br>注意，如果使用注解类型注解类以外的任何事物，此元注解类型都是无效的。还要注意，此元注解仅促成从父类继承注解；对已实现接口的注解无效。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="注解（Annotation）的工作方式">注解（Annotation）的工作方式</h3><p>Java5.0提供了一个正式的注解（Annotation）功能：允许开发者定义、使用自己的注解类型。此功能由一个定义注解类型的语法和一个描述注解声明的语法，读取注解的A]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="注解" scheme="http://blog.noobsky.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java静态代理和动态代理]]></title>
    <link href="http://blog.noobsky.com/2016/04/16/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://blog.noobsky.com/2016/04/16/Java静态代理和动态代理/</id>
    <published>2016-04-16T14:14:53.000Z</published>
    <updated>2016-04-16T16:05:01.000Z</updated>
    <content type="html"><![CDATA[<h3 id="代理模式">代理模式</h3><p>为某个对象提供一个代理对象，并由代理对象控制对于这个对象的访问。即客户不直接操控原对象，而是通过中介代理对象间接操控原对象。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象代替。代理类负责请求的预处理、过滤、分派请求给委托类处理以及委托类执行完请求后的后续处理。</p>
<p>代理模式一般涉及到的角色有：</p>
<ul>
<li>抽象角色：声明真实对象和代理对象的共同接口</li>
<li>代理角色：代理角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装</li>
<li>真实角色：代理角色所代表的真实对象，是我们最终要引用的对象<br>根据代理类的生成时间不同可以将代理分为静态代理和动态代理两种：</li>
<li>静态代理：代理类是在编译时就实现好的。也就是说Java编译完成后代理类是一个实际的class文件</li>
<li>动态代理：代理类是在运行时动态生成的。是在程序运行时，JVM利用反射机制动态创建而成的。<br>Talk is Cheap. Show me the Code.</li>
</ul>
<h3 id="静态代理">静态代理</h3><ul>
<li>代理接口(抽象角色)</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.jaye.staticproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/16.</span><br><span class="line"> * 代理接口</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Subject</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>委托类（真实角色）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jaye.staticproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/16.</span><br><span class="line"> * 委托类，处理业务，实现代理接口</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"From real subject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代理类（代理角色）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jaye.staticproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/16.</span><br><span class="line"> * 代理类，实现代理接口</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;<span class="comment">//代理角色内部引用真实角色</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preRequest();<span class="comment">//在真实角色操作之前附加的操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == realSubject)&#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        realSubject.request();<span class="comment">//真实角色所完成的事情</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.postRequest();<span class="comment">//在真实角色操作之后附加的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pre Request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"post Request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户类</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.jaye.staticproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/16.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> ProxySubject();</span><br><span class="line">        subject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pre Request</span><br><span class="line"><span class="built_in">From</span> real subject</span><br><span class="line">post Request</span><br></pre></td></tr></table></figure>
<p>如果按照上述的方法使用代理模式，那么真实角色(委托类)必须是事先已经存在的，并将其作为代理对象的内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀；此外，如果事先并不知道真实角色（委托类），该如何使用代理呢？这个问题可以通过Java的动态代理类来解决。</p>
<h3 id="动态代理">动态代理</h3><p>动态代理是一种高级的代理模式，它在AOP，权限控制、事务管理等领域都发挥了重要的作用。Java动态代理类位于java.lang.reflect包下，一般涉及一个重要的接口和一个重要的类。</p>
<ul>
<li>InvocationHandler接口<br>每一个动态代理类都必须实现InvocationHandler接口，并且每个代理类的实例都关联到一个handler，当通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke方法来进行调用。该接口仅定义了一个invoke方法：<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> invoke(<span class="type">Object</span> proxy, <span class="type">Method</span> <span class="keyword">method</span>, <span class="type">Object</span>[] args) throws <span class="type">Throwable</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参数：<br>proxy - 在其上调用方法的代理实例<br>method - 对应于在代理实例上调用的接口方法的 Method 实例。Method 对象的声明类将是在其中声明方法的接口，该接口可以是代理类赖以继承方法的代理接口的超接口。<br>args - 包含传入代理实例上方法调用的参数值的对象数组，如果接口方法不使用参数，则为 null。基本类型的参数被包装在适当基本包装器类（如 java.lang.Integer 或 java.lang.Boolean）的实例中。</p>
<ul>
<li>Proxy类<br>Proxy类的作用就是用来创建一个代理对象的类，使用最多的方法是<code>newProxyInstance</code>：<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Object</span> newProxyInstance(ClassLoader loader, <span class="keyword">Class</span>&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参数：<br>loader - 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载</p>
<p>interfaces - 一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</p>
<p>h - 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</p>
<p>Talk is Cheap.Show me the Code.</p>
<ul>
<li><p>代理接口和委托类跟静态代理的代码相同</p>
</li>
<li><p>动态代理类</p>
</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.jaye.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="type">InvocationHandler</span>;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="type">Method</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * <span class="type">Created</span> by <span class="type">Jaye</span> on <span class="number">16</span>/<span class="number">4</span>/<span class="number">16</span>.</span><br><span class="line"> * 动态代理类</span><br><span class="line"> */</span><br><span class="line">public class <span class="type">DynamicSubject</span> implements <span class="type">InvocationHandler</span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="type">Object</span> target;//需要代理的真实对象</span><br><span class="line"></span><br><span class="line">    //构造方法，为代理的真实对象赋值</span><br><span class="line">    public <span class="type">DynamicSubject</span>(<span class="type">Object</span> obj)&#123;</span><br><span class="line">        this.target = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    public <span class="type">Object</span> invoke(<span class="type">Object</span> proxy, <span class="type">Method</span> <span class="keyword">method</span>, <span class="type">Object</span>[] args) throws <span class="type">Throwable</span> &#123;</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"before calling: "</span> + <span class="keyword">method</span>);</span><br><span class="line">        // 当代理对象调用真实对象的方法时，会自动跳转到代理对象管理的handler对象的invoke方法来进行调用</span><br><span class="line">        <span class="keyword">method</span>.invoke(target, args);</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"after calling: "</span> + <span class="keyword">method</span>);</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户类</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jaye.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/16.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//需要代理的真实对象</span></span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        <span class="comment">//将真实对象传入handler中</span></span><br><span class="line">        InvocationHandler <span class="keyword">handler</span> = <span class="keyword">new</span> DynamicSubject(realSubject);</span><br><span class="line">        <span class="comment">//调用Proxy的newProxyInstance方法来动态创建我们的代理对象</span></span><br><span class="line">        Subject subject = (Subject)Proxy.newProxyInstance(realSubject.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), <span class="keyword">handler</span>);</span><br><span class="line">        subject.request();</span><br><span class="line">        System.out.println(subject.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before calling: public abstract void com<span class="class">.jaye</span><span class="class">.dynamicproxy</span><span class="class">.Subject</span><span class="class">.request</span>()</span><br><span class="line">From real subject</span><br><span class="line">after calling: public abstract void com<span class="class">.jaye</span><span class="class">.dynamicproxy</span><span class="class">.Subject</span><span class="class">.request</span>()</span><br><span class="line">com<span class="class">.sun</span><span class="class">.proxy</span>.<span class="variable">$Proxy0</span></span><br></pre></td></tr></table></figure></p>
<p><code>subject.request();</code>通过代理对象来调用接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的invoke方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的invoke方法去执行：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Override</span></span><br><span class="line">   public <span class="type">Object</span> invoke(<span class="type">Object</span> proxy, <span class="type">Method</span> <span class="keyword">method</span>, <span class="type">Object</span>[] args) throws <span class="type">Throwable</span> &#123;</span><br><span class="line">       <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"before calling: "</span> + <span class="keyword">method</span>);</span><br><span class="line">       // 当代理对象调用真实对象的方法时，会自动跳转到代理对象管理的handler对象的invoke方法来进行调用</span><br><span class="line">       <span class="keyword">method</span>.invoke(target, args);</span><br><span class="line">       <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"after calling: "</span> + <span class="keyword">method</span>);</span><br><span class="line">       <span class="keyword">return</span> null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract void com<span class="class">.jaye</span><span class="class">.dynamicproxy</span><span class="class">.Subject</span><span class="class">.request</span>()</span><br><span class="line"></span><br><span class="line">public abstract void com<span class="class">.jaye</span><span class="class">.dynamicproxy</span><span class="class">.Subject</span><span class="class">.request</span>()</span><br></pre></td></tr></table></figure></p>
<p>正好就是我们的Subject接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，其实际就是委托由其关联到的 handler 对象的invoke方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。</p>
<p>从程序的输出我们还可以看到，<code>System.out.println(subject.getClass().getName());</code>语句打印的动态生成的代理对象为<code>com.sun.proxy.$Proxy0</code>, 既不是InvocationHandler的对象，也不是Subject类型的对象，但其可以转化为Subject对象，因为其实现的Subject接口。所以通过<code>Proxy.newProxyInstance</code>创建的对象是在JVM运行时动态生成的一个对象它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。</p>
<p>JDK中动态代理仅支持interface的代理，如果需要动态代理具体类或抽象类，可以使用CGLib动态代理，CGLib动态代理有空再写相关的博文。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="代理模式">代理模式</h3><p>为某个对象提供一个代理对象，并由代理对象控制对于这个对象的访问。即客户不直接操控原对象，而是通过中介代理对象间接操控原对象。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象代替。代理类负责请求的]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="动态代理" scheme="http://blog.noobsky.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="静态代理" scheme="http://blog.noobsky.com/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <link href="http://blog.noobsky.com/2016/04/16/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.noobsky.com/2016/04/16/Java反射机制/</id>
    <published>2016-04-16T01:29:39.000Z</published>
    <updated>2016-04-30T04:35:01.000Z</updated>
    <content type="html"><![CDATA[<p>在Java运行时环境中，对应任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是肯定的。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java语言的反射(Reflection)机制。Java反射机制主要提供了以下基础功能：</p>
<ul>
<li>在运行时判断任意一个类所属对象的类。</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法</li>
</ul>
<p>在JDK中，主要提供以下类来实现Java反射机制，这些类都位于java.lang.reflect包中</p>
<ul>
<li>Class类：代表一个类</li>
<li>Field类：代表类的成员变量（成员变量也称为类的属性）</li>
<li>Method类：代表类的方法</li>
<li>Constructor：代表类的构造方法</li>
<li>Array类：提供了动态创建数组，以及访问数组元素的静态方法</li>
</ul>
<p>Talk is Cheap. Show me the code.下面先看一个简单的例子，通过这个例子来理解Java反射机制是如何工作的。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.jaye.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="type">Method</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * <span class="type">Created</span> by <span class="type">Jaye</span> on <span class="number">16</span>/<span class="number">4</span>/<span class="number">15</span>.</span><br><span class="line"> */</span><br><span class="line">public class <span class="type">DumpMethods</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) throws <span class="type">Exception</span>&#123;</span><br><span class="line">        //获取<span class="type">Class</span></span><br><span class="line">        <span class="type">Class</span>&lt;?&gt; cls = <span class="type">Class</span>.forName(args[<span class="number">0</span>]);</span><br><span class="line">        //通过<span class="type">Class</span>获得所对应对象的所有方法</span><br><span class="line">        <span class="type">Method</span>[] methods = cls.getDeclaredMethods();</span><br><span class="line">        //输出每个方法</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Method</span> <span class="keyword">method</span> : methods)&#123;</span><br><span class="line">            <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="keyword">method</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DumpMethods类演示了Reflection API的基本作用，它读取命令行参数中指定的类名，然后打印这个类所具有的方法信息。当传入的参数为java.lang.<br>String时会输出如下结果：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean java<span class="class">.lang</span><span class="class">.String</span><span class="class">.equals</span>(java<span class="class">.lang</span><span class="class">.Object</span>)</span><br><span class="line">public java<span class="class">.lang</span><span class="class">.String</span> java<span class="class">.lang</span><span class="class">.String</span><span class="class">.toString</span>()</span><br><span class="line">public int java<span class="class">.lang</span><span class="class">.String</span><span class="class">.hashCode</span>()</span><br><span class="line">public int java<span class="class">.lang</span><span class="class">.String</span><span class="class">.compareTo</span>(java<span class="class">.lang</span><span class="class">.Object</span>)</span><br><span class="line">public int java<span class="class">.lang</span><span class="class">.String</span><span class="class">.compareTo</span>(java<span class="class">.lang</span><span class="class">.String</span>)</span><br><span class="line">static int java<span class="class">.lang</span><span class="class">.String</span><span class="class">.indexOf</span>(char[],int,int,char[],int,int,int)</span><br><span class="line">public int java<span class="class">.lang</span><span class="class">.String</span><span class="class">.indexOf</span>(java<span class="class">.lang</span><span class="class">.String</span>,int)</span><br><span class="line">public int java<span class="class">.lang</span><span class="class">.String</span><span class="class">.indexOf</span>(java<span class="class">.lang</span><span class="class">.String</span>)</span><br><span class="line">public int java<span class="class">.lang</span><span class="class">.String</span><span class="class">.indexOf</span>(int)</span><br><span class="line">public int java<span class="class">.lang</span><span class="class">.String</span><span class="class">.indexOf</span>(int,int)</span><br><span class="line">public static java<span class="class">.lang</span><span class="class">.String</span> java<span class="class">.lang</span><span class="class">.String</span><span class="class">.valueOf</span>(char)</span><br><span class="line">public static java<span class="class">.lang</span><span class="class">.String</span> java<span class="class">.lang</span><span class="class">.String</span><span class="class">.valueOf</span>(java<span class="class">.lang</span><span class="class">.Object</span>)</span><br><span class="line">public static java<span class="class">.lang</span><span class="class">.String</span> java<span class="class">.lang</span><span class="class">.String</span><span class="class">.valueOf</span>(boolean)</span><br><span class="line">public static java<span class="class">.lang</span><span class="class">.String</span> java<span class="class">.lang</span><span class="class">.String</span><span class="class">.valueOf</span>(char[],int,int)</span><br><span class="line">public static java<span class="class">.lang</span><span class="class">.String</span> java<span class="class">.lang</span><span class="class">.String</span><span class="class">.valueOf</span>(char[])</span><br><span class="line">public static java<span class="class">.lang</span><span class="class">.String</span> java<span class="class">.lang</span><span class="class">.String</span><span class="class">.valueOf</span>(long)</span><br><span class="line">public static java<span class="class">.lang</span><span class="class">.String</span> java<span class="class">.lang</span><span class="class">.String</span><span class="class">.valueOf</span>(<span class="attribute">float</span>)</span><br><span class="line">public static java<span class="class">.lang</span><span class="class">.String</span> java<span class="class">.lang</span><span class="class">.String</span><span class="class">.valueOf</span>(int)</span><br><span class="line">public static java<span class="class">.lang</span><span class="class">.String</span> java<span class="class">.lang</span><span class="class">.String</span><span class="class">.valueOf</span>(double)</span><br><span class="line">int java<span class="class">.lang</span><span class="class">.String</span><span class="class">.hash32</span>()</span><br><span class="line">private static void java<span class="class">.lang</span><span class="class">.String</span><span class="class">.checkBounds</span>(byte[],int,int)</span><br><span class="line">public int java<span class="class">.lang</span><span class="class">.String</span><span class="class">.length</span>()</span><br><span class="line">public boolean java<span class="class">.lang</span><span class="class">.String</span><span class="class">.isEmpty</span>()</span><br><span class="line">public char java<span class="class">.lang</span><span class="class">.String</span><span class="class">.charAt</span>(int)</span><br><span class="line">......</span><br><span class="line">public byte[] java<span class="class">.lang</span><span class="class">.String</span><span class="class">.getBytes</span>(java<span class="class">.lang</span><span class="class">.String</span>) throws java<span class="class">.io</span><span class="class">.UnsupportedEncodingException</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>以上程序的输出列出了java.lang.String类的所有方法名，包括限制符、返回类型、以及抛出的异常。这里使用的是<code>getDeclaredMethods</code>方法，也可以使用<code>getMethods</code>方法，两者的区别是前者返回的是所有访问权限的方法，不包括父类的；后者返回的是访问权限为public的方法，包括父类的。其他的<code>getXXX</code>和<code>getDeclaredXXX</code>方法同理。<br>使用Java反射机制，一般需要遵循以下三步：</p>
<ol>
<li>获取你想操作类的Class对象</li>
<li>通过第一步中获取的Class对象去获取操作类的方法或属性</li>
<li>利用第二步获取的方法或属性进行下一步操作</li>
</ol>
<p>Java运行的时候，一个类无论生成多少个对象，他们都会对应同一个Class对象，它表示正在运行程序中的类和接口。要想使用反射，首先需要获取到待处理类或对象所对应的Class对象。获取Class对象有以下常用的三种方式：</p>
<ol>
<li>使用Class类的静态方法forName：Class.forName(“java.lang.String”)</li>
<li>使用类的.class语法：String.class</li>
<li>使用对象的getClass()方法：String s = “aa”; Class&lt;?&gt; cls = s.getClass();</li>
</ol>
<p>下面通过一个例子来说明使用Java反射机制一般需要遵循的三步：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.jaye.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="type">Method</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * <span class="type">Created</span> by <span class="type">Jaye</span> on <span class="number">16</span>/<span class="number">4</span>/<span class="number">15</span>.</span><br><span class="line"> */</span><br><span class="line">public class <span class="type">InvokeTester</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) throws <span class="type">Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        //<span class="number">1</span>.获得<span class="type">Class</span>对象</span><br><span class="line">        <span class="type">Class</span>&lt;?&gt; cls = <span class="type">Tester</span>.class;</span><br><span class="line"></span><br><span class="line">        //<span class="number">2</span>.通过<span class="type">Class</span>获得<span class="type">Tester</span>类的add方法</span><br><span class="line">        <span class="type">Method</span> <span class="keyword">method</span> = cls.getMethod(<span class="string">"add"</span>, new <span class="type">Class</span>[]&#123;<span class="type">int</span>.class, <span class="type">int</span>.class&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> tester =  cls.newInstance();</span><br><span class="line">        //<span class="number">3</span>.调用add方法</span><br><span class="line">        <span class="type">Object</span> <span class="literal">result</span> = <span class="keyword">method</span>.invoke(tester, new <span class="type">Object</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> echoMethod = cls.getMethod(<span class="string">"echo"</span>, new <span class="type">Class</span>[]&#123;<span class="type">String</span>.class&#125;);</span><br><span class="line">        <span class="type">Object</span> result2 = echoMethod.invoke(tester, new <span class="type">Object</span>[]&#123;<span class="string">"jijie"</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class <span class="type">Tester</span>&#123;</span><br><span class="line">    public <span class="type">int</span> add(<span class="type">int</span> p1, <span class="type">int</span> p2)&#123;</span><br><span class="line">        <span class="keyword">return</span> p1 + p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">String</span> echo(<span class="type">String</span> message)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello:"</span> + message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如代码14行，java反射的第一步就是获得类的Class对象。每个类的方法也必有一个Method对象与之对应，要通过反射的方式调用这个方法，就要首先获得这个方法的Method对象,如代码17行，然后用Method对象反过来调用这个方法，如代码21行。注意17行getMethod方法的第一个参数是方法名，第二个是此方法的参数类型列表（可变参数）。执行21行代码的invoke方法，其实也就是执行add方法，注意invoke的第一个参数，是Tester类的一个对象，也就是调用Tester类哪个对象的add方法，第二个参数是给add方法传递的参数列表。类型和个数一定要与17行的getMethod方法相对应。</p>
<p>上例讲述了如何通过反射调用某个类的方法，下面将写一个比较综合也有用一点的例子，该例通过反射实现对象的拷贝：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jaye.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 16/4/15.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> class ReflectTester &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 方法能够创建 一个和参数object 同样类型的对象,然后把 object对象中的所有属性拷贝到新建的对象中, 并将它返回</span><br><span class="line">     * 只能复制简单的JavaBean,假定 JavaBean 的每个属性都有public 类型的 get<span class="label">XXX()和setXXX()方法。</span></span><br><span class="line">     * @param object</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> <span class="built_in">copy</span>(<span class="keyword">Object</span> object) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class&lt;?&gt; cls = object.getClass();</span><br><span class="line">        <span class="keyword">Object</span> objectCopy = cls.getConstructor(<span class="keyword">new</span> Class[] &#123;&#125;).newInstance(<span class="keyword">new</span> <span class="keyword">Object</span>[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得对象的所有成员变量</span></span><br><span class="line">        Field[] fields = cls.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields)&#123;</span><br><span class="line">            <span class="keyword">String</span> name = field.getName();</span><br><span class="line">            <span class="comment">//将属性的首字母转化为大写</span></span><br><span class="line">            <span class="keyword">String</span> firstName = name.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">String</span> getMethodName = <span class="string">"get"</span> + firstName + name.substring(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">String</span> setMethodName = <span class="string">"set"</span> + firstName + name.substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            Method getMethod = cls.getDeclaredMethod(getMethodName, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">            Method setMethod = cls.getDeclaredMethod(setMethodName, <span class="keyword">new</span> Class[]&#123;field.getType()&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Object</span> value = getMethod.invoke(object, <span class="keyword">new</span> <span class="keyword">Object</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">            setMethod.invoke(objectCopy, <span class="keyword">new</span> <span class="keyword">Object</span>[]&#123;value&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objectCopy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer(<span class="string">"jaye"</span>, <span class="number">26</span>);</span><br><span class="line">        customer.setId(<span class="number">1</span>L);</span><br><span class="line"></span><br><span class="line">        ReflectTester tester = <span class="keyword">new</span> ReflectTester();</span><br><span class="line">        Customer customer2 = (Customer)tester.<span class="built_in">copy</span>(customer);</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(customer2.getId() + <span class="string">":"</span> + customer2.getName() + <span class="string">":"</span> + customer2.getAge());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Customer&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Customer()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Customer(<span class="keyword">String</span> name, <span class="built_in">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Long getId() &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setId(Long id) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setName(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> getAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setAge(<span class="built_in">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码19行，我们通过构造函数对应的类Constructor来生成一个拷贝对象实例。Class的newInstance方法只能创建只包含无参数的构造函数的类，如果某类只有带参数的构造函数，那么就要使用Constructor来构造一个实例对象。</p>
<ul>
<li>若想通过类的不带参数的构造方法来生成对象，有两种方式：</li>
</ul>
<ol>
<li><p>先获得Class对象，然后通过Class的newInstance()方法直接生成即可</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span>&lt;?&gt; cls = <span class="keyword">String</span>.<span class="keyword">class</span>;</span><br><span class="line"><span class="keyword">Object</span> obj = cls.newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p>先获得Class对象，然后通过该对象获得对应的Constructor对象，再通过Constructor对象的newInstance()方法生成。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span>&lt;?&gt; cls = Customer.<span class="keyword">class</span>;</span><br><span class="line"><span class="function"><span class="keyword">Constructor</span> <span class="title">cons</span> = <span class="title">cls</span>.<span class="title">getConstructor</span><span class="params">(new <span class="keyword">Class</span>[]&#123;&#125;)</span>;</span></span><br><span class="line"><span class="keyword">Object</span> obj = cons.newInstance(new <span class="keyword">Object</span>[]<span class="comment">&#123;&#125;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>若想通过类的带参数的构造方法生成对象，只能使用Constructor这一种方式</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span>&lt;?&gt; cls = Customer.<span class="keyword">class</span>;</span><br><span class="line"><span class="function"><span class="keyword">Constructor</span> <span class="title">cons</span> = <span class="title">cls</span>.<span class="title">getConstructor</span><span class="params">(new <span class="keyword">Class</span>[]&#123;<span class="keyword">String</span>.<span class="keyword">class</span>, int.<span class="keyword">class</span>&#125;)</span>;</span></span><br><span class="line"><span class="keyword">Object</span> obj = cons.newInstance(new <span class="keyword">Object</span>[]<span class="comment">&#123;"jaye", "26"&#125;</span>);</span><br></pre></td></tr></table></figure>
<p>我们甚至可以使用反射机制调用对象的私有方法、访问对象的私有成员变量：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.jaye.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="type">Field</span>;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="type">Method</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * <span class="type">Created</span> by <span class="type">Jaye</span> on <span class="number">16</span>/<span class="number">4</span>/<span class="number">16</span>.</span><br><span class="line"> */</span><br><span class="line">public class <span class="type">TestPrivate</span> &#123;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) throws <span class="type">Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Private</span> p = new <span class="type">Private</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span>&lt;?&gt; cls = p.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="keyword">method</span> = cls.getDeclaredMethod(<span class="string">"sayHello"</span>, new <span class="type">Class</span>[] &#123;<span class="type">String</span>.class&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">method</span>.setAccessible(<span class="literal">true</span>);//禁止<span class="type">Java</span>的访问控制检查</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> str = (<span class="type">String</span>)<span class="keyword">method</span>.invoke(p, new <span class="type">Object</span>[] &#123;<span class="string">"jaye"</span>&#125;);</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(str);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> field = cls.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.<span class="type">set</span>(p, <span class="string">"poopjaye"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(p.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class <span class="type">Private</span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="type">String</span> name = <span class="string">"poop"</span>;</span><br><span class="line"></span><br><span class="line">    private <span class="type">String</span> sayHello(<span class="type">String</span> name)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello:"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">String</span> getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Java运行时环境中，对应任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是肯定的。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java语言的反射(Reflection)机制。Java反射机制主要提供了以下基础功能：<]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="反射" scheme="http://blog.noobsky.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java一道判断Integer是否==的笔试题]]></title>
    <link href="http://blog.noobsky.com/2016/04/12/Java%E4%B8%80%E9%81%93%E5%88%A4%E6%96%ADInteger%E6%98%AF%E5%90%A6-%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.noobsky.com/2016/04/12/Java一道判断Integer是否-的面试题/</id>
    <published>2016-04-12T05:55:57.000Z</published>
    <updated>2016-04-12T10:16:20.000Z</updated>
    <content type="html"><![CDATA[<p>最近腾讯在线笔试时遇到一个笔试题，判断Integer是否==，也和自动装箱和拆箱有点关系，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">100</span>, i2 = <span class="number">100</span>, i3 = <span class="number">150</span>, i4 = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        System.out.println(i3 == i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们知道“==”对于原生数据类型来说比较的是左右两边的值得大小，而对于引用类型来说比较的是左右两边的引用是否指向同一个对象或者说左右两边的引用地址是否相同。这里我们就很容易的认为两个输出都是false，那么你就会发现你愉快地做错了。首先i1,i2,i3,i4四个变量都是Integer对象的引用，所以下面的==运算比较的不是值而是引用。而且这里还会发生自动装箱，装箱的本质是什么呢？就是当我们给一个Integer对象赋值一个int值得时候，会调用Integer类的静态方法valueOf，如果查看valueOf的源代码就知道发生了什么。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的IntegerCache是Integer的内部类，其代码如下所示：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Cache to support the object identity semantics of autoboxing for values between</span><br><span class="line">    * -128 and 127 (inclusive) as required by JLS.</span><br><span class="line">    *</span><br><span class="line">    * The cache is initialized on first usage.  The size of the cache</span><br><span class="line">    * may be controlled by the -XX:AutoBoxCacheMax=&lt;size&gt; option.</span><br><span class="line">    * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="line">    * may be set and saved in the private system properties in the</span><br><span class="line">    * sun.misc.VM class.</span><br><span class="line">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="comment">// high value may be configured by property</span></span><br><span class="line">           <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">           String integerCacheHighPropValue =</span><br><span class="line">               sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">           <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">               i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">               <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">               h = Math.min(i, Integer.MAX_VALUE - (-low));</span><br><span class="line">           &#125;</span><br><span class="line">           high = h;</span><br><span class="line"></span><br><span class="line">           cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">int</span> j = low;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">               cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> IntegerCache() &#123;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据以上代码可知，如果整形字面量在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中i1==i2的结果为true，i3==i4的结果为false。以后多看看源码，看源码才能知道问题的根本所在。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近腾讯在线笔试时遇到一个笔试题，判断Integer是否==，也和自动装箱和拆箱有点关系，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line"]]>
    </summary>
    
      <category term="Java" scheme="http://blog.noobsky.com/tags/Java/"/>
    
      <category term="面试" scheme="http://blog.noobsky.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java" scheme="http://blog.noobsky.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DTW:Dynamic Time Wraping 动态时间规整算法]]></title>
    <link href="http://blog.noobsky.com/2015/12/06/DTW-Dynamic-Time-Wraping-%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E8%A7%84%E6%95%B4%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.noobsky.com/2015/12/06/DTW-Dynamic-Time-Wraping-动态时间规整算法/</id>
    <published>2015-12-06T11:30:44.000Z</published>
    <updated>2015-12-06T12:50:15.000Z</updated>
    <content type="html"><![CDATA[<p>在时间序列分析中，动态时间规则（DTW）是衡量两个时间序列相似度的算法。甚至比较相似性的两段时间序列的时间或速度并不相等。比如，走路模式的相似度也可以使用DTW算法来检测，即使一个人比另一个人走的快。DTW算法也应用在视频序列、声音序列和图像数据，事实上，能够转化成线性序列任何数据都能用DTW进行分析。DTW主要应用于语音识别，处理不同的说话速度；还应用在说话人识别、在线签名识别和局部形状匹配。</p>
<p>总之，DTW用来计算两个给定序列（eg:时间序列）的最优匹配。在时间序列中，需要比较相似性的两段时间序列的长度可能并不相等，在语音识别领域表现为不同人的语速不同。而且同一个单词内的不同音素的发音速度也不同，比如有的人会把“A”这个音拖得很长，或者把“i”发的很短。另外，不同时间序列可能仅仅存在时间轴上的位移，亦即在还原位移的情况下，两个时间序列是一致的。在这些复杂情况下，使用传统的欧几里得距离无法有效地求的两个时间序列之间的距离（或者相似性）。DTW通过把时间序列进行延伸和缩短，来计算两个时间序列性之间的相似性：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/dtw-2015-12-06-20.32.34.png" alt=""><br>如上图所示，上下红线、黄线代表两个时间序列，时间序列之间的连线代表两个时间序列之间的相似的点。DTW使用所有这些相似点之间的距离的和，称之为归整路径距离(Warp Path Distance)来衡量两个时间序列之间的相似性。若像图上边那样一一对应，则两个时间序列的欧式距离可能就很大，会被误判为不相似，但是进行时间规整后如图下边那样进行对应，两个时间序列的欧式距离变得很小，那么两者会被判为极为相似（这与事实相符，肉眼可以看出两个时间序列是极为相似的）。DTW就是针对两个序列，要找到一个单一映射函数，使得对应之后，所有采样点的欧几里得距离的和最小。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在时间序列分析中，动态时间规则（DTW）是衡量两个时间序列相似度的算法。甚至比较相似性的两段时间序列的时间或速度并不相等。比如，走路模式的相似度也可以使用DTW算法来检测，即使一个人比另一个人走的快。DTW算法也应用在视频序列、声音序列和图像数据，事实上，能够转化成线性序列]]>
    </summary>
    
      <category term="DTW" scheme="http://blog.noobsky.com/tags/DTW/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="语音识别" scheme="http://blog.noobsky.com/tags/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    
      <category term="算法" scheme="http://blog.noobsky.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用AWS搭建Shadowsocks服务器]]></title>
    <link href="http://blog.noobsky.com/2015/11/27/%E5%88%A9%E7%94%A8AWS%E6%90%AD%E5%BB%BAShadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://blog.noobsky.com/2015/11/27/利用AWS搭建Shadowsocks服务器/</id>
    <published>2015-11-27T02:43:00.000Z</published>
    <updated>2015-11-30T15:05:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="aws和vps">aws和vps</h2><p>aws是亚马逊网络服务系统（英语：Amazon Web Services，简称为AWS），由亚马逊公司所创建的云计算平台，提供许多远程Web服务。Amazon EC2与Amazon S3都架构在这个平台上。在2002年7月首次公开运作，提供其他网站及客户端（client-side）的服务。aws的详细介绍见维基百科<a href="https://en.wikipedia.org/wiki/Amazon_Web_Services" target="_blank" rel="external">Amazon Web Services</a>。本文选择AWS的<em>EC2</em>搭建shadowsocks服务器。EC2详见<a href="https://en.wikipedia.org/wiki/Amazon_Elastic_Compute_Cloud" target="_blank" rel="external">Amazon Elastic Compute Cloud</a>。当然也可以用其他的vps搭建shadowsocks服务器。比如linode、digitalocean、<em>墙外</em>阿里云（比如<br>美国节点）。vps是虚拟专用服务器（英语：Virtual private server，缩写为 VPS），是指通过虚拟化技术在独立服务器中运行的专用服务器。每个使用VPS技术的虚拟独立服务器拥有各自独立的公网IP地址、操作系统、硬盘空间、内存空间、CPU资源等，还可以进行安装程序、重启服务器等操作，与运行一台独立服务器完全相同。更多介绍见维基百科<a href="https://en.wikipedia.org/wiki/Virtual_private_server" target="_blank" rel="external">Virtual private server</a></p>
<p>注：本文不对vps和云主机（云服务器）进行区分，两种类似。本文都称为vps。</p>
<p>为啥选择aws？aws可以免费提供一年的云服务，1G内存、1核，搭建shadowsocks服务器再跑个web足够了。需要注意的是aws注册时需要信用卡账号，如果你是学生党没有信用卡，可以到某宝上买个虚拟信用卡（只要10块钱左右）。还有就是aws应该选择日本或者新加坡节点，时延小，速度会快很多。阿里云的<em>国内节点</em>虽然有速度优势和价格优势（推出<br>学生机，一个月9块钱），但其翻不了墙；阿里云还有一个蛋疼的地方就是绑定域名的话需要进行<em>备案</em>。linode和digitalocean口碑好像不错，博主没有用过，因为博主没钱，linode最便宜的是10刀一个月，digitalocean最低价是5刀每个月，不知是否有其他优惠，详情到官网去看吧，不差钱的主可以选择。</p>
<h2 id="shadowsocks">shadowsocks</h2><p>再说一遍，程序员三大必备网站是：Google、Github、StackOverflow。如果你还在用Baidu搜索技术文章的话，我想说的是，少年你已经被鄙视很多年了，赶紧换成谷歌吧，不要再被鄙视了！Github、StackOverflow在国内能够正常访问，但是Google由于众所周知的原因，国内无法访问，所以我们需要翻墙访问Google。个人觉得shadowsocks的是目前最好用的代理，没有之一！shadowsocks有多牛？首先Github上shadowsocks开源代码一万多star，前段时间shadowsocks的作者被约谈了，还被要求删除在Github上的源码，你说有多牛！还有市场上卖shadowsocks代理的多的是，一方面shadowsocks是开源的，谁都可以在vps上搭建shadowsocks服务器；另一方面shadowsocks的速度真的很快（前提是vps不能太烂）。<br>shadowsocks有如下特点：</p>
<ul>
<li><p>快速（异步I/O和事件驱动程序，类似Nodejs）</p>
</li>
<li><p>安全（所有的流量都经过加密算法加密，支持自定义算法）</p>
</li>
<li><p>支持移动客户端（专为移动设备和无线网络优化）</p>
</li>
<li><p>跨平台（全平台，包括Mac、Linux、Windows、Android、iOS和路由器（OpenWrt）都支持）</p>
</li>
<li><p>稳定、速度快</p>
</li>
<li><p>开源、易于维护<br>听完上面的介绍，你心动了吗？心动不如行动，让我们马上开始！</p>
</li>
</ul>
<h2 id="安装shadowsocks">安装shadowsocks</h2><p>首先注册AWS，创建EC2服务器（自己谷歌相关教程吧，或者以后博主再写相关文章），并开放相关TCP端口，详细设置请见EC2<a href="http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/concepts.html" target="_blank" rel="external">用户指南</a>，官方文档非常详细还是中文版的！<br>我创建EC2服务器时选择的是亚马逊的自己的系统Amazon Linux AMI（其实是经过定制的Centos），请记住自己是什么系统，因为安装命令稍微不同。<br>如果忘记是什么系统，请使用命令查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">30</span>-<span class="number">45</span> ~]$ cat /etc/system-release</span><br><span class="line">Amazon Linux AMI release <span class="number">2015.09</span></span><br></pre></td></tr></table></figure></p>
<p>安装命令如下：<br>CentOS：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> python-setuptools </span><br><span class="line">easy_install pip</span><br><span class="line">pip <span class="keyword">install</span> shadowsocks</span><br></pre></td></tr></table></figure></p>
<p>Debian / Ubuntu:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get <span class="keyword">install</span> python-pip</span><br><span class="line">pip <span class="keyword">install</span> shadowsocks</span><br></pre></td></tr></table></figure></p>
<p>提示没有权限时，请在命令前面加上sudo(在这三条命令前都要加sudo)，或者切换到root用户（后面讲），如下：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/shadowsocks-2015-11-27-18.19.54.png" alt=""><br>安装完毕后，用ssserver -h命令查看是否安装成功并查看相关用法：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/shadowsocks-2015-11-27-18.26.12.png" alt=""><br>提示找不到ssserver命令时（没遇到此问题），请用which或whereis命令查看所在目录<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/shadowsocks-2015-11-27-18.24.57.png" alt=""><br>然后把/usr/local/bin加入到/etc/profile文件中即可。</p>
<h2 id="shadowsocks的使用">shadowsocks的使用</h2><ul>
<li><p>运行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -p <span class="number">8388</span> -k password -m aes-<span class="number">256</span>-cfb</span><br></pre></td></tr></table></figure>
</li>
<li><p>后台运行</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -p <span class="number">8388</span> -k password -m aes-<span class="number">256</span>-cfb --<span class="keyword">user</span> <span class="title">nobody</span> -d <span class="literal">start</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>停止</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver <span class="operator">-d</span> stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看log</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo less /<span class="built_in">var</span>/<span class="keyword">log</span>/shadowsocks<span class="built_in">.</span><span class="keyword">log</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>推荐使用以下的配置文件方式：<br>使用<code>sudu vim /etc/shadowsocks.json</code>命令创建<code>/etc/shadowsocks.json</code>文件(不是root用户请加入sudo)，比如：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">server</span>":<span class="value"><span class="string">"0.0.0.0"</span></span>,</span><br><span class="line">    "<span class="attribute">server_port</span>":<span class="value"><span class="number">8388</span></span>,</span><br><span class="line">    "<span class="attribute">local_address</span>": <span class="value"><span class="string">"127.0.0.1"</span></span>,</span><br><span class="line">    "<span class="attribute">local_port</span>":<span class="value"><span class="number">1080</span></span>,</span><br><span class="line">    "<span class="attribute">password</span>":<span class="value"><span class="string">"mypassword"</span></span>,</span><br><span class="line">    "<span class="attribute">timeout</span>":<span class="value"><span class="number">300</span></span>,</span><br><span class="line">    "<span class="attribute">method</span>":<span class="value"><span class="string">"aes-256-cfb"</span></span>,</span><br><span class="line">    "<span class="attribute">fast_open</span>": <span class="value"><span class="literal">false</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>各个字段代表的含义如下：</p>
<ul>
<li>server: 服务器监听地址</li>
<li>server_port: 服务器端口</li>
<li>local_address: 本地监听地址</li>
<li>local_port: 本地端口</li>
<li>password: 密码</li>
<li>timeout: 超时时间</li>
<li>method: 加密算法</li>
<li>fast_open: 使用TCP_FASTOPEN，true/false</li>
<li>workers: 工作线程数，Unix/Linux可用</li>
</ul>
<p>配置文件写好之后就可以运行shadowsocks了：</p>
<ul>
<li><p>运行</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c <span class="regexp">/etc/</span>shadowsocks.json</span><br></pre></td></tr></table></figure>
</li>
<li><p>后台运行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运行：sudo ssserver -c /etc/shadowsocks.json -d <span class="operator"><span class="keyword">start</span></span><br><span class="line">停止：sudo ssserver -<span class="keyword">c</span> /etc/shadowsocks.<span class="keyword">json</span> -<span class="keyword">d</span> <span class="keyword">stop</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里遇到的问题是，运行命令<code>sudo ssserver -c /etc/shadowsocks.json -d start</code>提示找不到<code>ssserver</code>命令，如下图，此时可以使用ssserver命令的绝对路径或者切换到root用户。<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/shadowsocks-2015-11-27-19.15.34.png" alt=""><br>切换到root用户：<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/shadowsocks-2015-11-27-19.22.49.png" alt=""><br>输入命令<code>sudo passwd root</code>,输入两遍新密码，然后输入命令<code>su root</code>，输入刚才设置的密码即切换为root用户，<br>然后重新执行命令<code>ssserver -c /etc/shadowsocks.json -d start</code>即可。</p>
<p>现在shadowsocks服务器已经成功运行，我们使用shadowsocks客户端连接刚刚搭建的服务器就可以科学上网啦。<br>shadowsocks客户端下载地址<a href="https://github.com/shadowsocks/shadowsocks-windows/releases/download/2.5.8/Shadowsocks-2.5.8.zip" target="_blank" rel="external">Windows</a>、<a href="https://github.com/shadowsocks/shadowsocks-iOS/releases/download/2.6.3/ShadowsocksX-2.6.3.dmg" target="_blank" rel="external">Mac</a>。客户端配置要是搞不定就提问、或者自行谷歌解决。</p>
<p>本文链接：<a href="http://blog.noobsky.com/2015/11/27/利用AWS搭建Shadowsocks服务器/">http://blog.noobsky.com/2015/11/27/利用AWS搭建Shadowsocks服务器/</a></p>
<p>– EOF –</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="aws和vps">aws和vps</h2><p>aws是亚马逊网络服务系统（英语：Amazon Web Services，简称为AWS），由亚马逊公司所创建的云计算平台，提供许多远程Web服务。Amazon EC2与Amazon S3都架构在这个平台上。在2002]]>
    </summary>
    
      <category term="AWS" scheme="http://blog.noobsky.com/tags/AWS/"/>
    
      <category term="Shadowsocks" scheme="http://blog.noobsky.com/tags/Shadowsocks/"/>
    
      <category term="代理" scheme="http://blog.noobsky.com/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="Shadowsocks" scheme="http://blog.noobsky.com/categories/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学术应用使用node-http-proxy集成谷歌学术]]></title>
    <link href="http://blog.noobsky.com/2015/11/25/%E5%AD%A6%E6%9C%AF%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8node-http-proxy%E9%9B%86%E6%88%90%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF/"/>
    <id>http://blog.noobsky.com/2015/11/25/学术应用使用node-http-proxy集成谷歌学术/</id>
    <published>2015-11-25T01:00:31.000Z</published>
    <updated>2016-04-30T04:30:14.000Z</updated>
    <content type="html"><![CDATA[<p>搞科研的同学肯定离不开谷歌学术，谷歌学术搜索是文献搜索下载一大利器。之前实验室开发了一款学术应用，遗留了历史问题，就是没有解决文献搜索的功能，而这个任务最后落在我的身上。我采用的方案就是集成谷歌学术，但是国内的网络环境，你懂的，自然状态下根本就访问不了谷歌学术的，你得翻墙才能访问。你不能期望使用你开发的学术应用都能翻墙访问谷歌学术（虽然搞科研的人电脑翻墙软件肯定都准备好了！），所以呢我还要给谷歌学术搭建一个代理。不仅要集成谷歌学术一键搜索并下载，还要能导入和分享文献到自己开发的应用，获取文献的BIBTEX并导入到自己的学术应用中，就是要在代理中hack谷歌学术的原始响应，注入相关脚本。（关于BIBTEX可以去维基百科脑补一下。）<br>废话少说，放效果图过来先：（补图）<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/google-scholar-2015-11-26-15.53.32.png" alt=""><br><img src="http://7xonwi.com1.z0.glb.clouddn.com/google-scholar-2015-11-26-12.37.34.png" alt=""></p>
<h2 id="谷歌学术代理">谷歌学术代理</h2><p>谷歌学术代理默认采用的是node-http-proxy模块实现的，node-http-proxy的使用见博客<a href="http://blog.noobsky.com/2015/11/24/用node-http-proxy搭建谷歌代理/">用node-http-proxy搭建谷歌代理</a>和<a href="https://github.com/nodejitsu/node-http-proxy" target="_blank" rel="external">node-http-proxy的Github地址</a>。有人读到这已经急，Talk is cheap, Show me the code! 好好，博主这就废话少说，放码过来。新鲜热乎的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by Jaye on 15/7/11.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'./config'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">var</span> httpProxy = <span class="built_in">require</span>(<span class="string">'http-proxy'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> cookie = <span class="built_in">require</span>(<span class="string">'./cookie'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> modifyHtml = <span class="built_in">require</span>(<span class="string">'./modify_html'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> PROXY_PORT = config.proxyPort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy, server;</span><br><span class="line"><span class="keyword">var</span> cookieArr = [];</span><br><span class="line"><span class="keyword">var</span> hl = <span class="string">'zh-CN'</span>;</span><br><span class="line"><span class="keyword">var</span> injected = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建代理服务器</span></span><br><span class="line">proxy = httpProxy.createProxy();</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理error</span></span><br><span class="line">proxy.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err,req,res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">500</span>, &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end(<span class="string">'Something went wrong. And we are reporting a custom error message.'</span> + err.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//载入需要注入的内容</span></span><br><span class="line">    injected = fs.readFileSync(<span class="string">'./inject.html'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="comment">//解析语言,没有设置默认为zh-CN,重构时可以用url_auth来代替</span></span><br><span class="line">    <span class="keyword">var</span> query = querystring.parse(url.parse(req.url).query);</span><br><span class="line">    <span class="keyword">if</span>(query)&#123;</span><br><span class="line">         hl = query.hl?query.hl:<span class="string">'zh-CN'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//<span class="doctag">todo:</span>加入权限认证，调用url_auth中的urlAuth函数进行判断，如果auth为true放行，否则拦截 </span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// var finalUrl = req.url,</span></span><br><span class="line">    <span class="keyword">var</span> finalUrl = <span class="string">'https://scholar.google.com'</span>,</span><br><span class="line">        finalAgent = <span class="literal">null</span>,</span><br><span class="line">        parsedUrl = url.parse(finalUrl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedUrl.protocol === <span class="string">'https:'</span>) &#123;</span><br><span class="line">        finalAgent = https.globalAgent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finalAgent = http.globalAgent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    proxy.web(req, res, &#123;</span><br><span class="line">        target: finalUrl,</span><br><span class="line">        agent: finalAgent,</span><br><span class="line">        headers: &#123; host: parsedUrl.hostname,</span><br><span class="line">        &#125;,</span><br><span class="line">        prependPath:<span class="literal">false</span>,</span><br><span class="line">        xfwd:<span class="literal">true</span>,</span><br><span class="line">        hostRewrite:config.proxyHost+<span class="string">':'</span>+config.proxyPort,<span class="comment">//设置重定向地址,</span></span><br><span class="line">        protocolRewrite: <span class="string">'http'</span><span class="comment">//设置重定向协议</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.on(<span class="string">'proxyReq'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">proxyReq,req,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//如果不去掉这个头字段，浏览器报330错误，无法解码</span></span><br><span class="line">    <span class="keyword">if</span>(proxyReq._headers)&#123;</span><br><span class="line">       <span class="keyword">if</span>(proxyReq._headers[<span class="string">'accept-encoding'</span>])&#123;</span><br><span class="line">           proxyReq._headers[<span class="string">'accept-encoding'</span>] = <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * [在响应返回到客户端时，重写html并注入js脚本]</span><br><span class="line"> * @param  &#123;[type]&#125; proxyRes    [description]</span><br><span class="line"> * @param  &#123;[type]&#125; request     [description]</span><br><span class="line"> * @param  &#123;[type]&#125; response    [description]</span><br><span class="line"> * @return &#123;[type]&#125;             [description]</span><br><span class="line"> */</span></span><br><span class="line">proxy.on(<span class="string">'proxyRes'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">proxyRes,request,response</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(proxyRes.headers &amp;&amp; proxyRes.headers[ <span class="string">'set-cookie'</span> ])&#123;</span><br><span class="line">       cookieArr =  cookie.parseGoogleCookies(proxyRes.headers[<span class="string">'set-cookie'</span>]); </span><br><span class="line">       proxyRes.headers[<span class="string">'set-cookie'</span>]=cookieArr;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//inject js,rewrite html body</span></span><br><span class="line">    <span class="keyword">if</span>( proxyRes.headers &amp;&amp;</span><br><span class="line">        proxyRes.headers[ <span class="string">'content-type'</span> ] &amp;&amp;</span><br><span class="line">        proxyRes.headers[ <span class="string">'content-type'</span> ].match( <span class="string">'text/html'</span> ) ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> _end = response.end,</span><br><span class="line">            chunks,</span><br><span class="line">            _writeHead = response.writeHead,</span><br><span class="line">            _write = response.write;</span><br><span class="line"></span><br><span class="line">        response.writeHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( proxyRes.headers &amp;&amp; proxyRes.headers[ <span class="string">'content-length'</span> ] )&#123;</span><br><span class="line">                response.setHeader(</span><br><span class="line">                    <span class="string">'content-length'</span>,</span><br><span class="line">                    <span class="built_in">parseInt</span>( proxyRes.headers[ <span class="string">'content-length'</span> ], <span class="number">10</span> ) + injected.length</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不设置可能出现少量乱码</span></span><br><span class="line">            response.setHeader( <span class="string">'transfer-encoding'</span>, proxyRes.headers[<span class="string">'transfer-encoding'</span>] );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Disable cache for all http as well</span></span><br><span class="line">            response.setHeader( <span class="string">'cache-control'</span>, <span class="string">'no-cache'</span> );</span><br><span class="line"></span><br><span class="line">            _writeHead.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        response.write = <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( chunks ) &#123;</span><br><span class="line">                chunks += data;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chunks = data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        response.end = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( chunks &amp;&amp; chunks.toString ) &#123;</span><br><span class="line">                _end.apply( <span class="keyword">this</span>, [ modifyHtml( chunks.toString(),hl , injected) ] );</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                _end.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">           &#125;    </span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'listening on port '</span> + PROXY_PORT);</span><br><span class="line">server.listen(PROXY_PORT);</span><br></pre></td></tr></table></figure></p>
<p>代理的功能跟谷歌代理的动能类似，这里不再赘述。谷歌代理见博文<a href="http://blog.noobsky.com/2015/11/24/用node-http-proxy搭建谷歌代理/">用node-http-proxy搭建谷歌代理</a>,下面我主要讲修改cookie来启用谷歌学术的设置功能，有设置功能的谷歌学术才够高大上！谷歌学术的设置是通过cookie来做的，需要完整的功能必须解决cookie的问题。我下面的例子是设置显示导入链接。谷歌学术的默认设置是隐藏导入链接的，需要到设置里勾选显示导入[BibTex、EndNote、RefMan、RefWorks]的链接，见下图：</p>
<ul>
<li>点击右上角我的著作引用情况右边的三角图标，选择设置<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/google-scholar-2015-11-26-12.36.30.png" alt=""></li>
<li>然后选择显示导入BibTeX的链接<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/google-scholar-2015-11-26-12.36.30.png" alt=""></li>
<li>点击保存后自动跳转到搜索结果,将会显示导入BibTeX（谷歌学术的原始显示）<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/google-scholar-2015-11-26-13.20.36.png" alt=""><br>修改谷歌学术的cookie技术原理挺简单的，我们在proxyRes返回之前对set-cookie进行解析并修改相关字段即可，对应以上代码：<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(proxyRes.headers &amp;&amp; proxyRes.headers[ <span class="symbol">'set</span>-cookie' ])&#123;</span><br><span class="line">       cookieArr =  cookie.parseGoogleCookies(proxyRes.headers[<span class="symbol">'set</span>-cookie']); </span><br><span class="line">       proxyRes.headers[<span class="symbol">'set</span>-cookie']=cookieArr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们再看看parseGoogleCookies函数做了什么事情，代码如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">	* 解析google scholar返回的cookie</span><br><span class="line">	**/</span></span><br><span class="line">	parseGoogleCookies: <span class="function"><span class="keyword">function</span> <span class="params">(cookies)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// console.log(cookies);</span></span><br><span class="line">	    <span class="keyword">var</span> cookieArr = [];</span><br><span class="line">	    <span class="keyword">if</span> (cookies &amp;&amp; cookies.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">	            <span class="keyword">var</span> cookieItem = cookieUtil.parse(cookies[i]);</span><br><span class="line">	            <span class="keyword">if</span> (cookieItem.domain) &#123;</span><br><span class="line">	             <span class="comment">//   delete cookieItem.domain;</span></span><br><span class="line">	                  cookieItem.domain = proxyHost;</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="keyword">if</span> (cookieItem.path) &#123;</span><br><span class="line">	                cookieItem.path = <span class="string">'/'</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="keyword">var</span> tempArr = [];</span><br><span class="line">	            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> cookieItem) &#123;</span><br><span class="line">	            	<span class="keyword">if</span> (key === <span class="string">'expires'</span> || key === <span class="string">'path'</span>) &#123;</span><br><span class="line">		                tempArr.push(key+<span class="string">'='</span>+cookieItem[key]);</span><br><span class="line">	            	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		                tempArr.push(key+<span class="string">'='</span>+cookieItem[key]);</span><br><span class="line">	            	&#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	            cookieArr.push(tempArr.join(<span class="string">'; '</span>));</span><br><span class="line">	        &#125;;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> cookieArr;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不够熟悉http cookie，请到谷歌先脑补一下相关的知识，这里推荐一篇博客<a href="http://www.webryan.net/2011/08/wiki-of-http-cookie/" target="_blank" rel="external">全面解读HTTP Cookie</a>。这里选取有助于理解上面程序的两点。谷歌cookie的用途：Cookie也被用来记忆用户自定义的一些功能。用户在设置自定义特征的时候，仅仅是保存在用户的浏览器中，在下一次访问的时候服务器会根据用户本地的cookie来表现用户的设置。例如google将搜索设置（使用语言、每页的条数，以及打开搜索结果的方式等等）保存在一个COOKIE里。cookie的Domain and Path<br>的作用：定义Cookie的生效作用域，只有当域名和路径同时满足的时候，浏览器才会将Cookie发送给Server。如果没有设置Domain和Path的话，他们会被默认为当前请求页面对应值。下面简单讲解一下cookie的http实现：</p>
<p>以访问<a href="http://blog.noobsky.com">http://blog.noobsky.com</a>为例</p>
<ul>
<li><p>Step1.客户端发起http请求到Server</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Host: blog<span class="class">.noobsky</span><span class="class">.com</span></span><br><span class="line">(这里是省去了User-Agent,Accept等字段)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Step2. 服务器返回http response,其中可以包含Cookie设置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: name1=value1</span><br><span class="line">Set-Cookie: name2=value2; Expires=Wed, <span class="number">06</span> Jun <span class="number">2066</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">18</span> GMT</span><br><span class="line">(content of page)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Step3. 后续访问blog.noobsky.com的相关页面</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/archives</span> HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span>: <span class="string">blog.noobsky.com</span></span><br><span class="line"><span class="attribute">Cookie</span>: <span class="string">name1=value1; name2=value2</span></span><br><span class="line"><span class="attribute">Accept</span>: <span class="string">*/*</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>第一次访问服务器的适合，服务器返回的头字段里通过set-cookie设置cookie，后面再次访问服务器时，客户端会自动的带上相关的cookie字段。这里需要注意的是要想客户端自动带上相关的cookie字段，cookie的domain和path字段必须要跟你访问的server服务。比如你在第一次访问blog.noobsky.com的时候通过技术手段把服务器response中的set-cookie中的domain域（默认值为blog.noobsky.com）修改为coolshell.cn的话，你下次再访问blog.noobsky.com的相关页面时，将不会带上相关的cookie，因为cookie的domain不匹配。同理通过访问代理然后代理访问scholar.google.com时，scholar.google.com服务器返回的response的set-cookie中的domain域的值是scholar.google.com，下次再访问代理时，因为domain域不匹配，将不会自动带上相关的cookie，所以我们在proxyRes返回给客户端之前，需要hack掉相关的cookie域，我们只需把cookie的domain域修改为proxyHost（代理主机），path域设置为<code>&#39;/&#39;</code>：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cookieItem.domain) &#123;</span><br><span class="line">	cookieItem.domain = proxyHost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cookieItem.path) &#123;</span><br><span class="line">	cookieItem.path = <span class="string">'/'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下次再访问代理主机时，因为domain域匹配，就会自动带上相关的cookie，谷歌学术就能实现记忆用户自定义的功能啦，你就可以随心所欲使用谷歌学术的设置功能！</p>
<p>除了能使用设置功能我们还需要把谷歌学术的默认显示导入BibTeX更改为导入我的网站，并修改默认的点击事件。默认的点击事件是跳转另一页面显示相应地BibTeX，我需要的点击事件是获取BibTeX数据，并推送给我的学术应用，cool！方法很简单：利用cheerio库修改response的html中<code>导入BibTeX</code>，然后注入相关的js脚本，js脚本修改默认点击事件！</p>
<ul>
<li><p>通过重写response.end函数hack返回的html页面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">response.end = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( chunks &amp;&amp; chunks.toString ) &#123;</span><br><span class="line">       	_end.apply( <span class="keyword">this</span>, [ modifyHtml( chunks.toString(),hl , injected) ] );</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        _end.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;    </span><br><span class="line">            </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改html的函数如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function(<span class="built_in">str</span>,lang,inject)&#123;</span><br><span class="line">	$ = cheerio.load(<span class="built_in">str</span>);</span><br><span class="line">	var <span class="built_in">str</span> = config.zhStr;</span><br><span class="line">	<span class="keyword">if</span>(lang.toLowerCase()==<span class="string">'en'</span>)&#123;</span><br><span class="line">	    <span class="built_in">str</span> = config.enStr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//修改显示文本</span></span><br><span class="line">	$(<span class="string">".gs_nta.gs_nph"</span>).each(function(i,elem)&#123;</span><br><span class="line">	    $(<span class="keyword">this</span>).<span class="built_in">text</span>(<span class="built_in">str</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="built_in">str</span> = $.html();</span><br><span class="line">	    <span class="comment">// Add or script to the page，注入脚本</span></span><br><span class="line">	<span class="keyword">if</span>( <span class="built_in">str</span>.indexOf( <span class="string">'&lt;/body&gt;'</span> ) &gt; -<span class="number">1</span> ) &#123;</span><br><span class="line">	    <span class="built_in">str</span> = <span class="built_in">str</span>.replace( <span class="string">'&lt;/body&gt;'</span>, inject + <span class="string">'&lt;/body&gt;'</span> );</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">str</span>.indexOf( <span class="string">'&lt;/html&gt;'</span> ) &gt; -<span class="number">1</span> )&#123;</span><br><span class="line">	    <span class="built_in">str</span> = <span class="built_in">str</span>.replace( <span class="string">'&lt;/html&gt;'</span>, inject + <span class="string">'&lt;/html&gt;'</span> );</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="built_in">str</span> = <span class="built_in">str</span> + inject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">str</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注入的js脚本</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">    $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">".gs_nta.gs_nph"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="keyword">this</span>).bind(<span class="string">"click"</span>, getData);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> pdfUrl;</span><br><span class="line">            <span class="keyword">if</span> ($(<span class="keyword">this</span>).parent().parent().prev(<span class="string">".gs_ggs.gs_fl"</span>)) &#123;</span><br><span class="line">                pdfUrl = $(<span class="keyword">this</span>).parent().parent().prev(<span class="string">".gs_ggs.gs_fl"</span>).children(<span class="string">"div.gs_md_wp.gs_ttss"</span>).children(<span class="string">"a"</span>).attr(<span class="string">"href"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> path = $(<span class="keyword">this</span>).attr(<span class="string">"href"</span>);</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type: <span class="string">"get"</span>,</span><br><span class="line">                url: path,</span><br><span class="line">                <span class="keyword">async</span>: <span class="literal">false</span>,</span><br><span class="line">                success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                    alert(<span class="string">"获取BibTex成功!"</span> + data + <span class="string">"pdfUrl:"</span> + pdfUrl);</span><br><span class="line">                &#125;,</span><br><span class="line">                error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    alert(<span class="string">"获取BibTex失败!"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里需要注意的是，推送BibTeX到自己的学术应用中存在跨域问题，这里采用JSONP的方式。激动人心的时刻来了，我们来看一下最终的效果</p>
<ul>
<li>hack原始html后的显示<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/google-scholar-2015-11-26-12.37.34.png" alt=""></li>
<li>修改后的点击事件<br><img src="http://7xonwi.com1.z0.glb.clouddn.com/google-scholar-2015-11-26-12.38.07.png" alt=""><br>详细代码见Github上的<a href="https://github.com/yejijie/google-scholar-proxy" target="_blank" rel="external">google-scholar-proxy</a>。</li>
</ul>
<p>本文链接：<a href="http://blog.noobsky.com/2015/11/25/学术应用使用node-http-proxy集成谷歌学术/">http://blog.noobsky.com/2015/11/25/学术应用使用node-http-proxy集成谷歌学术/</a></p>
<p>–EOF–</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>搞科研的同学肯定离不开谷歌学术，谷歌学术搜索是文献搜索下载一大利器。之前实验室开发了一款学术应用，遗留了历史问题，就是没有解决文献搜索的功能，而这个任务最后落在我的身上。我采用的方案就是集成谷歌学术，但是国内的网络环境，你懂的，自然状态下根本就访问不了谷歌学术的，你得翻墙才]]>
    </summary>
    
      <category term="Nodejs" scheme="http://blog.noobsky.com/tags/Nodejs/"/>
    
      <category term="代理" scheme="http://blog.noobsky.com/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="谷歌学术" scheme="http://blog.noobsky.com/tags/%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF/"/>
    
      <category term="Nodejs" scheme="http://blog.noobsky.com/categories/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用node-http-proxy搭建谷歌代理]]></title>
    <link href="http://blog.noobsky.com/2015/11/24/%E7%94%A8node-http-proxy%E6%90%AD%E5%BB%BA%E8%B0%B7%E6%AD%8C%E4%BB%A3%E7%90%86/"/>
    <id>http://blog.noobsky.com/2015/11/24/用node-http-proxy搭建谷歌代理/</id>
    <published>2015-11-24T06:48:24.000Z</published>
    <updated>2015-11-29T13:21:24.000Z</updated>
    <content type="html"><![CDATA[<p>程序员三大必备网站是：Google、Github、StackOverflow。如果你还在用Baidu搜索技术文章的话，我想说的是，少年你已经被鄙视很多年了，赶紧换成谷歌吧，不要再被鄙视了！Github、StackOverflow在国内能够正常访问，但是Google由于众所周知的原因，国内无法访问，所以我们需要翻墙访问Google。个人觉得shadowsocks的是目前最好用的代理，没有之一！shadowsocks有多牛？前段时间shadowsocks的作者被约谈了，还被要求删除在Github上的源码，你说有多牛！可以自己在vps上利用shadowsocks搭建自己的专属代理，如果你懒的话，也可以直接去买个shadowsocks账号，网上卖家多的是。后面我会写相关的文章介绍如何在vps上搭建服务器，敬请关注。今天先介绍一下用node-http-proxy搭建谷歌代理，小试牛刀一下。</p>
<p>node-http-proxy是一个用于Node.js的HTTP可编程代理库,支持 websockets。它是适用于实现例如代理服务器和负载均衡这样的组件。node-http-proxy使用起来很简单，下面简单介绍一下。</p>
<h1 id="核心概念">核心概念</h1><p>通过createProxyServer函数创建代理，同时你也可选的传入options对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpProxy = <span class="built_in">require</span>(<span class="string">'http-proxy'</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = httpProxy.createProxyServer(options);</span><br></pre></td></tr></table></figure></p>
<p>createProxyServer函数返回的proxy对象包含四个方法</p>
<ul>
<li>web <code>req, res, [options]</code> 用来代理http(s)请求</li>
<li>ws <code>req, socket, head, [options]</code> 用来代理WS(S)请求</li>
<li>listen <code>port</code> 该函数把对象包装成webserver，方便使用</li>
<li>close <code>[callback]</code> 该函数关闭内部的webserver并且停止监听给定的端口</li>
</ul>
<p>然后可以如下调用函数代理请求<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">http</span><span class="class">.createServer</span>(<span class="function">function</span>(req, res) &#123;</span><br><span class="line">  <span class="tag">proxy</span><span class="class">.web</span>(req, res, &#123; <span class="attribute">target</span>: <span class="string">'http://mytarget.com:8080'</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>错误处理可以通过监听error事件<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy.<span class="keyword">on</span>(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> <span class="comment">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>或者使用回调API<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy.web(req, res, &#123; target: <span class="string">'http://mytarget.com:8080'</span> &#125;, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="Use_Cases">Use Cases</h1><p>下面的例子显示如何用你自己的http服务器代理请求，你也可以加入自己的业务逻辑处理请求<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>),</span><br><span class="line">    httpProxy = <span class="built_in">require</span>(<span class="string">'http-proxy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Create a proxy server with custom application logic</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> proxy = httpProxy.createProxyServer(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Create your custom server and just call `proxy.web()` to proxy</span></span><br><span class="line"><span class="comment">// a web request to the target passed in the options</span></span><br><span class="line"><span class="comment">// also you can use `proxy.ws()` to proxy a websockets request</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// You can define here your custom logic to handle the request</span></span><br><span class="line">  <span class="comment">// and then proxy the request.</span></span><br><span class="line">  proxy.web(req, res, &#123; target: <span class="string">'http://127.0.0.1:5060'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"listening on port 5050"</span>)</span><br><span class="line">server.listen(<span class="number">5050</span>);</span><br></pre></td></tr></table></figure></p>
<p>更多例子请查看官方文档</p>
<h1 id="Options">Options</h1><p><code>httpProxy.createProxyServer</code>支持下列options:</p>
<ul>
<li>target: url字符串</li>
<li>forward: url字符串</li>
<li>agent: 传给http(s).request的对象</li>
<li>ssl: 密钥，HTTPS使用</li>
<li>ws: true/false, 是否代理websockets</li>
<li>xfwd: true/false, 是否加上x-forward头字段</li>
<li>secure: true/false, 是否校验ssl证书</li>
<li>toProxy: 传递绝对URL作为<code>path</code></li>
<li>prependPath: true/false, 默认值为true，是否在proxy path前面加上target的path</li>
<li>ignorePath: true/false, 默认值为false，是否忽略传入的请求的proxy path</li>
<li>localAddress: 本地地址</li>
<li>changeOrigin: true/false, 默认值为false, 是否更改原始的host头字段为target URL</li>
<li>auth: 基本身份认证，比如：‘用户名：密码’来计算Authorization header</li>
<li>hostRewrite: 重写重定向（301/302/307/308）的location hostname</li>
<li>autoRewrite: 是否自动重写重定向（301/302/307/308）的location host/port，默认值为false</li>
<li>protocolRewrite: 重写重定向（301/302/307/308）的location的协议，http或者https，默认值为null</li>
</ul>
<h1 id="谷歌代理">谷歌代理</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">var</span> httpProxy = <span class="built_in">require</span>(<span class="string">'http-proxy'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> PROXY_PORT = <span class="number">8000</span>;</span><br><span class="line"><span class="keyword">var</span> proxy, server;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a proxy server with custom application logic</span></span><br><span class="line">proxy = httpProxy.createProxy(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">proxy.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ERROR'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//var finalUrl = req.url,</span></span><br><span class="line">    <span class="keyword">var</span> finalUrl = <span class="string">'https://www.google.com'</span>;</span><br><span class="line">    <span class="keyword">var</span> finalAgent = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> parsedUrl = url.parse(finalUrl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedUrl.protocol === <span class="string">'https:'</span>) &#123;</span><br><span class="line">        finalAgent = https.globalAgent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finalAgent = http.globalAgent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    proxy.web(req, res, &#123;</span><br><span class="line">        target: finalUrl,</span><br><span class="line">        agent: finalAgent,</span><br><span class="line">        headers: &#123; host: parsedUrl.hostname &#125;,</span><br><span class="line">        prependPath: <span class="literal">false</span>,</span><br><span class="line">        xfwd : <span class="literal">true</span>,</span><br><span class="line">        hostRewrite: finalUrl.host,</span><br><span class="line">        protocolRewrite: parsedUrl.protocol</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'listening on port '</span> + PROXY_PORT);</span><br><span class="line">server.listen(PROXY_PORT);</span><br></pre></td></tr></table></figure>
<p>你没看错，就是这么点代码就能代理谷歌了，前提是你要有个墙外的vps哈！首先设置浏览器的http代理为你的vps，然后再vps上运行上面的代理程序，最后在浏览器中访问www.google.com，然后就是见证奇迹的时候了。有些小伙伴可能迫不及待的拿去试了试，结果发现博主骗人，根本不能代理谷歌。别急，这是因为node-http-proxy有一个小小的bug，不能怪博主，博主也是受害者之一。博主开始也卡在这里很久，最后去阅读源代码才发现问题所在！在node-http-proxy的web-outgoing.js里有个setRedirectHostRewrite函数，该函数的功能就是重定向时重写header中location的host地址，函数代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function setRedirectHostRewrite(req, res, proxyRes, <span class="keyword">options</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">options</span>.hostRewrite || <span class="keyword">options</span>.autoRewrite || <span class="keyword">options</span>.protocolRewrite)</span><br><span class="line">        &amp;&amp; proxyRes.headers[<span class="string">'location'</span>]</span><br><span class="line">        &amp;&amp; redirectRegex.test(proxyRes.statusCode)) &#123;</span><br><span class="line">      var target = url.parse(<span class="keyword">options</span>.target);</span><br><span class="line">      var u = url.parse(proxyRes.headers[<span class="string">'location'</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// make sure the redirected host matches the target host before rewriting</span></span><br><span class="line">      <span class="keyword">if</span> (target.host != u.host) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">options</span>.hostRewrite) &#123;</span><br><span class="line">        u.host = <span class="keyword">options</span>.hostRewrite;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">options</span>.autoRewrite) &#123;</span><br><span class="line">        u.host = req.headers[<span class="string">'host'</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">options</span>.protocolRewrite) &#123;</span><br><span class="line">        u.protocol = <span class="keyword">options</span>.protocolRewrite;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      proxyRes.headers[<span class="string">'location'</span>] = u.format();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>问题出在以下代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make sure the redirected host matches the target host before rewriting</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">target</span>.host != u.host) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>作者的意图是确保重定向的host跟target的host的匹配，不匹配就直接返回。代理谷歌时就会发生不匹配的情况直接返回了。<br>比如，博主来自中国，当我<code>curl www.google.com</code>时会重定向到www.google.com.hk:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZu1fmzgm3iZ ~]# curl www.google.com</span><br><span class="line"><span class="tag">&lt;<span class="title">HTML</span>&gt;</span><span class="tag">&lt;<span class="title">HEAD</span>&gt;</span><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"content-type"</span> <span class="attribute">content</span>=<span class="value">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">TITLE</span>&gt;</span>302 Moved<span class="tag">&lt;/<span class="title">TITLE</span>&gt;</span><span class="tag">&lt;/<span class="title">HEAD</span>&gt;</span><span class="tag">&lt;<span class="title">BODY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">H1</span>&gt;</span>302 Moved<span class="tag">&lt;/<span class="title">H1</span>&gt;</span></span><br><span class="line">The document has moved</span><br><span class="line"><span class="tag">&lt;<span class="title">A</span> <span class="attribute">HREF</span>=<span class="value">"http://www.google.com.hk/url?sa=p&amp;amp;hl=zh-CN&amp;amp;pref=hkredirect&amp;amp;pval=yes&amp;amp;q=http://www.google.com.hk/%3Fgws_rd%3Dcr&amp;amp;ust=1448378903186576&amp;amp;usg=AFQjCNHtMfRNndvgHHMAzipRzC9NpycwGw"</span>&gt;</span>here<span class="tag">&lt;/<span class="title">A</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="title">BODY</span>&gt;</span><span class="tag">&lt;/<span class="title">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果你来自日本，当你<code>curl www.google.com</code>时会重定向到www.google.co.jp：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@ip-172-31-27-165 ~]$ curl www.google.com</span><br><span class="line"><span class="tag">&lt;<span class="title">HTML</span>&gt;</span><span class="tag">&lt;<span class="title">HEAD</span>&gt;</span><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"content-type"</span> <span class="attribute">content</span>=<span class="value">"text/html;charset=utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">TITLE</span>&gt;</span>302 Moved<span class="tag">&lt;/<span class="title">TITLE</span>&gt;</span><span class="tag">&lt;/<span class="title">HEAD</span>&gt;</span><span class="tag">&lt;<span class="title">BODY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">H1</span>&gt;</span>302 Moved<span class="tag">&lt;/<span class="title">H1</span>&gt;</span></span><br><span class="line">The document has moved</span><br><span class="line"><span class="tag">&lt;<span class="title">A</span> <span class="attribute">HREF</span>=<span class="value">"http://www.google.co.jp/?gfe_rd=cr&amp;amp;ei=toJUVubpIcem8wfGirqQDw"</span>&gt;</span>here<span class="tag">&lt;/<span class="title">A</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="title">BODY</span>&gt;</span><span class="tag">&lt;/<span class="title">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>因为重定向的host跟target的host不匹配，程序直接返回，hostRewrite无效，所以我们应该去掉以下代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make sure the redirected host matches the target host before rewriting</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">target</span>.host != u.host) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们注释掉以上代码，重新运行程序，发现已经可以上谷歌了，是不是很神奇！</p>
<p>本文链接：<a href="http://blog.noobsky.com/2015/11/24/用node-http-proxy搭建谷歌代理/">http://blog.noobsky.com/2015/11/24/用node-http-proxy搭建谷歌代理/</a></p>
<p>– EOF –</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>程序员三大必备网站是：Google、Github、StackOverflow。如果你还在用Baidu搜索技术文章的话，我想说的是，少年你已经被鄙视很多年了，赶紧换成谷歌吧，不要再被鄙视了！Github、StackOverflow在国内能够正常访问，但是Google由于众所周]]>
    </summary>
    
      <category term="Nodejs" scheme="http://blog.noobsky.com/tags/Nodejs/"/>
    
      <category term="node-http-proxy" scheme="http://blog.noobsky.com/tags/node-http-proxy/"/>
    
      <category term="代理" scheme="http://blog.noobsky.com/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="Nodejs" scheme="http://blog.noobsky.com/categories/Nodejs/"/>
    
  </entry>
  
</feed>
